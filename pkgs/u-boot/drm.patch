diff --git a/.gitignore b/.gitignore
index 37f71c275c..52bf8a3b87 100644
--- a/.gitignore
+++ b/.gitignore
@@ -5,6 +5,10 @@
 #
 # Normal rules (sorted alphabetically)
 #
+generated_defconfig
+drivers/video/u_boot_logo.S
+include/bmp_logo_data.h
+include/bmp_logo.h
 .*
 !.checkpatch.conf
 *.a
diff --git a/arch/arm/dts/rk3588-hinlink-h88k-u-boot.dtsi b/arch/arm/dts/rk3588-hinlink-h88k-u-boot.dtsi
new file mode 100644
index 0000000000..cf356e4c51
--- /dev/null
+++ b/arch/arm/dts/rk3588-hinlink-h88k-u-boot.dtsi
@@ -0,0 +1,11 @@
+#include "rk3588s-u-boot.dtsi"
+
+/ {
+	chosen {
+        u-boot,spl-boot-order = &sdmmc, &sdhci;
+	};
+};
+
+&display_subsystem{
+	bootph-all;
+};
\ No newline at end of file
diff --git a/arch/arm/dts/rk3588s-u-boot.dtsi b/arch/arm/dts/rk3588s-u-boot.dtsi
index e9d38d5c83..15771a876d 100644
--- a/arch/arm/dts/rk3588s-u-boot.dtsi
+++ b/arch/arm/dts/rk3588s-u-boot.dtsi
@@ -4,6 +4,7 @@
  */
 
 #include "rockchip-u-boot.dtsi"
+#include <config.h>
 
 / {
 	aliases {
@@ -110,6 +111,12 @@
 	};
 };
 
+#ifdef CONFIG_DRM_ROCKCHIP
+&display_subsystem{
+	bootph-all;
+};
+#endif
+
 #ifdef CONFIG_ROCKCHIP_SPI_IMAGE
 &binman {
 	simple-bin-spi {
diff --git a/arch/arm/include/asm/arch-rk3588/clock.h b/arch/arm/include/asm/arch-rk3588/clock.h
new file mode 100644
index 0000000000..de244677f9
--- /dev/null
+++ b/arch/arm/include/asm/arch-rk3588/clock.h
@@ -0,0 +1,11 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * (C) Copyright 2021 Rockchip Electronics Co., Ltd
+ */
+
+#ifndef __ASM_ARCH_CLOCK_H__
+#define __ASM_ARCH_CLOCK_H__
+
+#include <asm/arch-rockchip/clock.h>
+
+#endif
diff --git a/arch/arm/include/asm/arch-rk3588/cpu.h b/arch/arm/include/asm/arch-rk3588/cpu.h
new file mode 100644
index 0000000000..7d66208c49
--- /dev/null
+++ b/arch/arm/include/asm/arch-rk3588/cpu.h
@@ -0,0 +1,11 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * (C) Copyright 2021 Rockchip Electronics Co., Ltd
+ */
+
+#ifndef __ASM_ARCH_CPU_H__
+#define __ASM_ARCH_CPU_H__
+
+#include <asm/arch-rockchip/cpu.h>
+
+#endif
diff --git a/arch/arm/include/asm/arch-rockchip/cpu.h b/arch/arm/include/asm/arch-rockchip/cpu.h
new file mode 100644
index 0000000000..8057814138
--- /dev/null
+++ b/arch/arm/include/asm/arch-rockchip/cpu.h
@@ -0,0 +1,116 @@
+/* SPDX-License-Identifier: GPL-2.0+  */
+/*
+ * Rockchip Electronics Co., Ltd.
+ *
+ */
+
+#ifndef __ASM_ARCH_CPU_H
+#define __ASM_ARCH_CPU_H
+
+#include <asm/io.h>
+#include <dm/device.h>
+
+#define ROCKCHIP_CPU_MASK       0xffff0000
+#define ROCKCHIP_CPU_PX30	0x33260000
+#define ROCKCHIP_CPU_RK312X     0x31260000
+#define ROCKCHIP_CPU_RK3288     0x32880000
+#define ROCKCHIP_CPU_RK3308	0x33080000
+#define ROCKCHIP_CPU_RK3566	0x35660000
+#define ROCKCHIP_CPU_RK3568	0x35680000
+
+#define ROCKCHIP_SOC_MASK	(ROCKCHIP_CPU_MASK | 0xff)
+#define ROCKCHIP_SOC_PX30	(ROCKCHIP_CPU_PX30 | 0x00)
+#define ROCKCHIP_SOC_PX30S	(ROCKCHIP_CPU_PX30 | 0x01)
+#define ROCKCHIP_SOC_RK3126     (ROCKCHIP_CPU_RK312X | 0x00)
+#define ROCKCHIP_SOC_RK3126B    (ROCKCHIP_CPU_RK312X | 0x10)
+#define ROCKCHIP_SOC_RK3126C    (ROCKCHIP_CPU_RK312X | 0x20)
+#define ROCKCHIP_SOC_RK3128     (ROCKCHIP_CPU_RK312X | 0x01)
+#define ROCKCHIP_SOC_RK3288     (ROCKCHIP_CPU_RK3288 | 0x00)
+#define ROCKCHIP_SOC_RK3288W    (ROCKCHIP_CPU_RK3288 | 0x01)
+#define ROCKCHIP_SOC_RK3308	(ROCKCHIP_CPU_RK3308 | 0x00)
+#define ROCKCHIP_SOC_RK3308B	(ROCKCHIP_CPU_RK3308 | 0x01)
+#define ROCKCHIP_SOC_RK3308BS	(ROCKCHIP_CPU_RK3308 | 0x02)
+#define ROCKCHIP_SOC_RK3566	(ROCKCHIP_CPU_RK3566 | 0x00)
+#define ROCKCHIP_SOC_RK3568	(ROCKCHIP_CPU_RK3568 | 0x00)
+
+static inline unsigned long rockchip_get_cpu_version(void)
+{
+#if defined(CONFIG_ROCKCHIP_RK3568)
+#define PMUGRF_SOC_CON15	0xfdc20100
+	if (readl(PMUGRF_SOC_CON15) & GENMASK(15, 14))
+		return 1;
+	else
+		return 0;
+#else
+	return 0;
+#endif
+}
+
+static inline int rockchip_soc_id(void)
+{
+#if defined(CONFIG_ROCKCHIP_PX30)
+	u32 v = readl(0xFF630004);
+
+	/* The CHIP_ID is stored in DDRGRF CON1[15:14]
+	 * PX30:  0x00
+	 * PX30S: 0x03
+	 */
+	if (((v >> 14) & 0x03) == 0x03)
+		return ROCKCHIP_SOC_PX30S;
+	else
+		return ROCKCHIP_SOC_PX30;
+#elif defined(CONFIG_ROCKCHIP_RK3288)
+	/* RK3288W HDMI Revision ID is 0x1A */
+	if (readl(0xFF980004) == 0x1A)
+		return ROCKCHIP_SOC_RK3288W;
+	else
+		return ROCKCHIP_SOC_RK3288;
+#elif defined(CONFIG_ROCKCHIP_RK3308)
+	/*
+	 * The CHIP_ID is stored in GRF_CHIP_ID:
+	 * RK3308:  0xcea (3306 in decimal)
+	 * RK3308B: 0x3308
+	 * RK3308BS: 0x3308c
+	 */
+	u32 v = readl(0xFF000800);
+
+	if (v == 3306)
+		return ROCKCHIP_SOC_RK3308;
+	else if (v == 0x3308c)
+		return ROCKCHIP_SOC_RK3308BS;
+	else
+		return ROCKCHIP_SOC_RK3308B;
+#elif defined(CONFIG_ROCKCHIP_RK3568)
+	if (of_machine_is_compatible("rockchip,rk3566"))
+		return ROCKCHIP_SOC_RK3566;
+	else
+		return ROCKCHIP_SOC_RK3568;
+#else
+	return 0;
+#endif
+}
+
+#define ROCKCHIP_SOC(id, ID) \
+static inline bool soc_is_##id(void) \
+{ \
+	int soc_id = rockchip_soc_id(); \
+	if (soc_id) \
+		return ((soc_id & ROCKCHIP_SOC_MASK) == ROCKCHIP_SOC_ ##ID); \
+	return false; \
+}
+
+ROCKCHIP_SOC(px30, PX30)
+ROCKCHIP_SOC(px30s, PX30S)
+ROCKCHIP_SOC(rk3126, RK3126)
+ROCKCHIP_SOC(rk3126b, RK3126B)
+ROCKCHIP_SOC(rk3126c, RK3126C)
+ROCKCHIP_SOC(rk3128, RK3128)
+ROCKCHIP_SOC(rk3288, RK3288)
+ROCKCHIP_SOC(rk3288w, RK3288W)
+ROCKCHIP_SOC(rk3308, RK3308)
+ROCKCHIP_SOC(rk3308b, RK3308B)
+ROCKCHIP_SOC(rk3308bs, RK3308BS)
+ROCKCHIP_SOC(rk3566, RK3566)
+ROCKCHIP_SOC(rk3568, RK3568)
+
+#endif
diff --git a/arch/arm/include/asm/arch-rockchip/vendor.h b/arch/arm/include/asm/arch-rockchip/vendor.h
new file mode 100644
index 0000000000..85570ca655
--- /dev/null
+++ b/arch/arm/include/asm/arch-rockchip/vendor.h
@@ -0,0 +1,52 @@
+/*
+ * (C) Copyright 2008-2017 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#ifndef __ROCKCHIP_VENDOR_
+#define __ROCKCHIP_VENDOR_
+
+#define RSV_ID				0
+#define SN_ID				1
+#define WIFI_MAC_ID			2
+#define LAN_MAC_ID			3
+#define BT_MAC_ID			4
+#define HDCP_14_HDMI_ID			5
+#define HDCP_14_DP_ID			6
+#define HDCP_2X_ID			7
+#define DRM_KEY_ID			8
+#define PLAYREADY_CERT_ID		9
+#define ATTENTION_KEY_ID		10
+#define PLAYREADY_ROOT_KEY_0_ID		11
+#define PLAYREADY_ROOT_KEY_1_ID		12
+#define HDCP_14_HDMIRX_ID		13
+#define SENSOR_CALIBRATION_ID		14
+#define IMEI_ID				15
+#define LAN_RGMII_DL_ID			16
+#define EINK_VCOM_ID			17
+#define FIRMWARE_VER_ID			18
+
+struct vendor_item {
+	u16  id;
+	u16  offset;
+	u16  size;
+	u16  flag;
+};
+
+int vendor_storage_test(void);
+int vendor_storage_read(u16 id, void *pbuf, u16 size);
+int vendor_storage_write(u16 id, void *pbuf, u16 size);
+int flash_vendor_dev_ops_register(int (*read)(struct blk_desc *dev_desc,
+					      u32 sec,
+					      u32 n_sec,
+					      void *p_data),
+				  int (*write)(struct blk_desc *dev_desc,
+					       u32 sec,
+					       u32 n_sec,
+					       void *p_data));
+
+int vendor_handle_hdcp(struct vendor_item *vhead);
+
+void vendor_storage_fixup(void *blob);
+
+#endif /* _ROCKCHIP_VENDOR_ */
diff --git a/common/edid.c b/common/edid.c
index 556c4e3434..f8fb974ea2 100644
--- a/common/edid.c
+++ b/common/edid.c
@@ -1,22 +1,1708 @@
-// SPDX-License-Identifier: GPL-2.0+
 /*
  * Copyright (c) 2012 The Chromium OS Authors.
  *
  * (C) Copyright 2010
  * Petr Stetiar <ynezz@true.cz>
  *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
  * Contains stolen code from ddcprobe project which is:
  * Copyright (C) Nalin Dahyabhai <bigfun@pobox.com>
+ * (C) Copyright 2008-2017 Fuzhou Rockchip Electronics Co., Ltd
  */
 
 #include <common.h>
+#include <compiler.h>
+#include <div64.h>
+#include <drm_modes.h>
 #include <edid.h>
 #include <errno.h>
 #include <fdtdec.h>
-#include <log.h>
+#include <hexdump.h>
+#include <malloc.h>
+#include <linux/compat.h>
 #include <linux/ctype.h>
+#include <linux/fb.h>
+#include <linux/hdmi.h>
 #include <linux/string.h>
 
+#define EDID_EST_TIMINGS 16
+#define EDID_STD_TIMINGS 8
+#define EDID_DETAILED_TIMINGS 4
+#define BIT_WORD(nr)             ((nr) / BITS_PER_LONG)
+#define BITMAP_FIRST_WORD_MASK(start) (~0UL << ((start) & (BITS_PER_LONG - 1)))
+#define BITMAP_LAST_WORD_MASK(nbits) (~0UL >> (-(nbits) & (BITS_PER_LONG - 1)))
+#define EDID_PRODUCT_ID(e) ((e)->prod_code[0] | ((e)->prod_code[1] << 8))
+#define version_greater(edid, maj, min) \
+	(((edid)->version > (maj)) || \
+	 ((edid)->version == (maj) && (edid)->revision > (min)))
+
+/*
+ * EDID blocks out in the wild have a variety of bugs, try to collect
+ * them here (note that userspace may work around broken monitors first,
+ * but fixes should make their way here so that the kernel "just works"
+ * on as many displays as possible).
+ */
+
+/* First detailed mode wrong, use largest 60Hz mode */
+#define EDID_QUIRK_PREFER_LARGE_60		BIT(0)
+/* Reported 135MHz pixel clock is too high, needs adjustment */
+#define EDID_QUIRK_135_CLOCK_TOO_HIGH		BIT(1)
+/* Prefer the largest mode at 75 Hz */
+#define EDID_QUIRK_PREFER_LARGE_75		BIT(2)
+/* Detail timing is in cm not mm */
+#define EDID_QUIRK_DETAILED_IN_CM		BIT(3)
+/* Detailed timing descriptors have bogus size values, so just take the
+ * maximum size and use that.
+ */
+#define EDID_QUIRK_DETAILED_USE_MAXIMUM_SIZE	BIT(4)
+/* Monitor forgot to set the first detailed is preferred bit. */
+#define EDID_QUIRK_FIRST_DETAILED_PREFERRED	BIT(5)
+/* use +hsync +vsync for detailed mode */
+#define EDID_QUIRK_DETAILED_SYNC_PP		BIT(6)
+/* Force reduced-blanking timings for detailed modes */
+#define EDID_QUIRK_FORCE_REDUCED_BLANKING	BIT(7)
+/* Force 8bpc */
+#define EDID_QUIRK_FORCE_8BPC			BIT(8)
+/* Force 12bpc */
+#define EDID_QUIRK_FORCE_12BPC			BIT(9)
+/* Force 6bpc */
+#define EDID_QUIRK_FORCE_6BPC			BIT(10)
+/* Force 10bpc */
+#define EDID_QUIRK_FORCE_10BPC			BIT(11)
+
+struct detailed_mode_closure {
+	struct edid *edid;
+	struct hdmi_edid_data *data;
+	bool preferred;
+	u32 quirks;
+	int modes;
+};
+
+#define LEVEL_DMT	0
+#define LEVEL_GTF	1
+#define LEVEL_GTF2	2
+#define LEVEL_CVT	3
+
+static struct edid_quirk {
+	char vendor[4];
+	int product_id;
+	u32 quirks;
+} edid_quirk_list[] = {
+	/* Acer AL1706 */
+	{ "ACR", 44358, EDID_QUIRK_PREFER_LARGE_60 },
+	/* Acer F51 */
+	{ "API", 0x7602, EDID_QUIRK_PREFER_LARGE_60 },
+	/* Unknown Acer */
+	{ "ACR", 2423, EDID_QUIRK_FIRST_DETAILED_PREFERRED },
+
+	/* AEO model 0 reports 8 bpc, but is a 6 bpc panel */
+	{ "AEO", 0, EDID_QUIRK_FORCE_6BPC },
+
+	/* Belinea 10 15 55 */
+	{ "MAX", 1516, EDID_QUIRK_PREFER_LARGE_60 },
+	{ "MAX", 0x77e, EDID_QUIRK_PREFER_LARGE_60 },
+
+	/* Envision Peripherals, Inc. EN-7100e */
+	{ "EPI", 59264, EDID_QUIRK_135_CLOCK_TOO_HIGH },
+	/* Envision EN2028 */
+	{ "EPI", 8232, EDID_QUIRK_PREFER_LARGE_60 },
+
+	/* Funai Electronics PM36B */
+	{ "FCM", 13600, EDID_QUIRK_PREFER_LARGE_75 |
+	  EDID_QUIRK_DETAILED_IN_CM },
+
+	/* LGD panel of HP zBook 17 G2, eDP 10 bpc, but reports unknown bpc */
+	{ "LGD", 764, EDID_QUIRK_FORCE_10BPC },
+
+	/* LG Philips LCD LP154W01-A5 */
+	{ "LPL", 0, EDID_QUIRK_DETAILED_USE_MAXIMUM_SIZE },
+	{ "LPL", 0x2a00, EDID_QUIRK_DETAILED_USE_MAXIMUM_SIZE },
+
+	/* Philips 107p5 CRT */
+	{ "PHL", 57364, EDID_QUIRK_FIRST_DETAILED_PREFERRED },
+
+	/* Proview AY765C */
+	{ "PTS", 765, EDID_QUIRK_FIRST_DETAILED_PREFERRED },
+
+	/* Samsung SyncMaster 205BW.  Note: irony */
+	{ "SAM", 541, EDID_QUIRK_DETAILED_SYNC_PP },
+	/* Samsung SyncMaster 22[5-6]BW */
+	{ "SAM", 596, EDID_QUIRK_PREFER_LARGE_60 },
+	{ "SAM", 638, EDID_QUIRK_PREFER_LARGE_60 },
+
+	/* Sony PVM-2541A does up to 12 bpc, but only reports max 8 bpc */
+	{ "SNY", 0x2541, EDID_QUIRK_FORCE_12BPC },
+
+	/* ViewSonic VA2026w */
+	{ "VSC", 5020, EDID_QUIRK_FORCE_REDUCED_BLANKING },
+
+	/* Medion MD 30217 PG */
+	{ "MED", 0x7b8, EDID_QUIRK_PREFER_LARGE_75 },
+
+	/* Panel in Samsung NP700G7A-S01PL notebook reports 6bpc */
+	{ "SEC", 0xd033, EDID_QUIRK_FORCE_8BPC },
+
+	/* Rotel RSX-1058 forwards sink's EDID but only does HDMI 1.1*/
+	{ "ETR", 13896, EDID_QUIRK_FORCE_8BPC },
+};
+
+/*
+ * Probably taken from CEA-861 spec.
+ * This table is converted from xorg's hw/xfree86/modes/xf86EdidModes.c.
+ *
+ * Index using the VIC.
+ */
+/*
+ * From CEA/CTA-861 spec.
+ * Do not access directly, instead always use cea_mode_for_vic().
+ */
+static const struct drm_display_mode edid_cea_modes_1[] = {
+	/* 1 - 640x480@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 25175, 640, 656,
+		   752, 800, 480, 490, 492, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 2 - 720x480@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 27000, 720, 736,
+		   798, 858, 480, 489, 495, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 3 - 720x480@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 27000, 720, 736,
+		   798, 858, 480, 489, 495, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 4 - 1280x720@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 74250, 1280, 1390,
+		   1430, 1650, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 5 - 1920x1080i@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 74250, 1920, 2008,
+		   2052, 2200, 1080, 1084, 1094, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+			DRM_MODE_FLAG_INTERLACE),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 6 - 720(1440)x480i@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 13500, 720, 739,
+		   801, 858, 480, 488, 494, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+			DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 7 - 720(1440)x480i@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 13500, 720, 739,
+		   801, 858, 480, 488, 494, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+			DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 8 - 720(1440)x240@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 13500, 720, 739,
+		   801, 858, 240, 244, 247, 262, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+			DRM_MODE_FLAG_DBLCLK),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 9 - 720(1440)x240@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 13500, 720, 739,
+		   801, 858, 240, 244, 247, 262, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+			DRM_MODE_FLAG_DBLCLK),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 10 - 2880x480i@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 54000, 2880, 2956,
+		   3204, 3432, 480, 488, 494, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+			DRM_MODE_FLAG_INTERLACE),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 11 - 2880x480i@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 54000, 2880, 2956,
+		   3204, 3432, 480, 488, 494, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+			DRM_MODE_FLAG_INTERLACE),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 12 - 2880x240@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 54000, 2880, 2956,
+		   3204, 3432, 240, 244, 247, 262, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 13 - 2880x240@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 54000, 2880, 2956,
+		   3204, 3432, 240, 244, 247, 262, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 14 - 1440x480@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 54000, 1440, 1472,
+		   1596, 1716, 480, 489, 495, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 15 - 1440x480@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 54000, 1440, 1472,
+		   1596, 1716, 480, 489, 495, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 16 - 1920x1080@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 148500, 1920, 2008,
+		   2052, 2200, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 17 - 720x576@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 27000, 720, 732,
+		   796, 864, 576, 581, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 18 - 720x576@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 27000, 720, 732,
+		   796, 864, 576, 581, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 19 - 1280x720@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 74250, 1280, 1720,
+		   1760, 1980, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 20 - 1920x1080i@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 74250, 1920, 2448,
+		   2492, 2640, 1080, 1084, 1094, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+			DRM_MODE_FLAG_INTERLACE),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 21 - 720(1440)x576i@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 13500, 720, 732,
+		   795, 864, 576, 580, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+			DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 22 - 720(1440)x576i@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 13500, 720, 732,
+		   795, 864, 576, 580, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+			DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 23 - 720(1440)x288@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 13500, 720, 732,
+		   795, 864, 288, 290, 293, 312, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+			DRM_MODE_FLAG_DBLCLK),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 24 - 720(1440)x288@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 13500, 720, 732,
+		   795, 864, 288, 290, 293, 312, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+			DRM_MODE_FLAG_DBLCLK),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 25 - 2880x576i@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 54000, 2880, 2928,
+		   3180, 3456, 576, 580, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+			DRM_MODE_FLAG_INTERLACE),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 26 - 2880x576i@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 54000, 2880, 2928,
+		   3180, 3456, 576, 580, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+			DRM_MODE_FLAG_INTERLACE),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 27 - 2880x288@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 54000, 2880, 2928,
+		   3180, 3456, 288, 290, 293, 312, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 28 - 2880x288@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 54000, 2880, 2928,
+		   3180, 3456, 288, 290, 293, 312, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 29 - 1440x576@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 54000, 1440, 1464,
+		   1592, 1728, 576, 581, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 30 - 1440x576@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 54000, 1440, 1464,
+		   1592, 1728, 576, 581, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 31 - 1920x1080@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 148500, 1920, 2448,
+		   2492, 2640, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 32 - 1920x1080@24Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 74250, 1920, 2558,
+		   2602, 2750, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 24, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 33 - 1920x1080@25Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 74250, 1920, 2448,
+		   2492, 2640, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 25, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 34 - 1920x1080@30Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 74250, 1920, 2008,
+		   2052, 2200, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 30, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 35 - 2880x480@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 108000, 2880, 2944,
+		   3192, 3432, 480, 489, 495, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 36 - 2880x480@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 108000, 2880, 2944,
+		   3192, 3432, 480, 489, 495, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 37 - 2880x576@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 108000, 2880, 2928,
+		   3184, 3456, 576, 581, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 38 - 2880x576@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 108000, 2880, 2928,
+		   3184, 3456, 576, 581, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 39 - 1920x1080i@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 72000, 1920, 1952,
+		   2120, 2304, 1080, 1126, 1136, 1250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC |
+			DRM_MODE_FLAG_INTERLACE),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 40 - 1920x1080i@100Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 148500, 1920, 2448,
+		   2492, 2640, 1080, 1084, 1094, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+			DRM_MODE_FLAG_INTERLACE),
+	  .vrefresh = 100, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 41 - 1280x720@100Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 148500, 1280, 1720,
+		   1760, 1980, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 100, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 42 - 720x576@100Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 54000, 720, 732,
+		   796, 864, 576, 581, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 100, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 43 - 720x576@100Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 54000, 720, 732,
+		   796, 864, 576, 581, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 100, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 44 - 720(1440)x576i@100Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 27000, 720, 732,
+		   795, 864, 576, 580, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+			DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),
+	  .vrefresh = 100, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 45 - 720(1440)x576i@100Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 27000, 720, 732,
+		   795, 864, 576, 580, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+			DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),
+	  .vrefresh = 100, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 46 - 1920x1080i@120Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 148500, 1920, 2008,
+		   2052, 2200, 1080, 1084, 1094, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+			DRM_MODE_FLAG_INTERLACE),
+	  .vrefresh = 120, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 47 - 1280x720@120Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 148500, 1280, 1390,
+		   1430, 1650, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 120, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 48 - 720x480@120Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 54000, 720, 736,
+		   798, 858, 480, 489, 495, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 120, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 49 - 720x480@120Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 54000, 720, 736,
+		   798, 858, 480, 489, 495, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 120, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 50 - 720(1440)x480i@120Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 27000, 720, 739,
+		   801, 858, 480, 488, 494, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+			DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),
+	  .vrefresh = 120, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 51 - 720(1440)x480i@120Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 27000, 720, 739,
+		   801, 858, 480, 488, 494, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+			DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),
+	  .vrefresh = 120, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 52 - 720x576@200Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 108000, 720, 732,
+		   796, 864, 576, 581, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 200, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 53 - 720x576@200Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 108000, 720, 732,
+		   796, 864, 576, 581, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 200, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 54 - 720(1440)x576i@200Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 54000, 720, 732,
+		   795, 864, 576, 580, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+			DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),
+	  .vrefresh = 200, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 55 - 720(1440)x576i@200Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 54000, 720, 732,
+		   795, 864, 576, 580, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+			DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),
+	  .vrefresh = 200, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 56 - 720x480@240Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 108000, 720, 736,
+		   798, 858, 480, 489, 495, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 240, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 57 - 720x480@240Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 108000, 720, 736,
+		   798, 858, 480, 489, 495, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 240, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 58 - 720(1440)x480i@240 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 54000, 720, 739,
+		   801, 858, 480, 488, 494, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+			DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),
+	  .vrefresh = 240, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 59 - 720(1440)x480i@240 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 54000, 720, 739,
+		   801, 858, 480, 488, 494, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+			DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),
+	  .vrefresh = 240, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 60 - 1280x720@24Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 59400, 1280, 3040,
+		   3080, 3300, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 24, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 61 - 1280x720@25Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 74250, 1280, 3700,
+		   3740, 3960, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 25, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 62 - 1280x720@30Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 74250, 1280, 3040,
+		   3080, 3300, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 30, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 63 - 1920x1080@120Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 297000, 1920, 2008,
+		   2052, 2200, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	 .vrefresh = 120, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 64 - 1920x1080@100Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 297000, 1920, 2448,
+		   2492, 2640, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	 .vrefresh = 100, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 65 - 1280x720@24Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 59400, 1280, 3040,
+		   3080, 3300, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 24, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 66 - 1280x720@25Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 74250, 1280, 3700,
+		   3740, 3960, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 25, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 67 - 1280x720@30Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 74250, 1280, 3040,
+		   3080, 3300, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 30, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 68 - 1280x720@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 74250, 1280, 1720,
+		   1760, 1980, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 69 - 1280x720@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 74250, 1280, 1390,
+		   1430, 1650, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 70 - 1280x720@100Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 148500, 1280, 1720,
+		   1760, 1980, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 100, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 71 - 1280x720@120Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 148500, 1280, 1390,
+		   1430, 1650, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 120, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 72 - 1920x1080@24Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 74250, 1920, 2558,
+		   2602, 2750, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 24, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 73 - 1920x1080@25Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 74250, 1920, 2448,
+		   2492, 2640, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 25, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 74 - 1920x1080@30Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 74250, 1920, 2008,
+		   2052, 2200, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 30, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 75 - 1920x1080@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 148500, 1920, 2448,
+		   2492, 2640, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 76 - 1920x1080@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 148500, 1920, 2008,
+		   2052, 2200, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 77 - 1920x1080@100Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 297000, 1920, 2448,
+		   2492, 2640, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	 .vrefresh = 100, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 78 - 1920x1080@120Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 297000, 1920, 2008,
+		   2052, 2200, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	 .vrefresh = 120, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 79 - 1680x720@24Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 59400, 1680, 3040,
+		   3080, 3300, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 24, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 80 - 1680x720@25Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 59400, 1680, 2908,
+		   2948, 3168, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 25, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 81 - 1680x720@30Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 59400, 1680, 2380,
+		   2420, 2640, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 30, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 82 - 1680x720@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 82500, 1680, 1940,
+		   1980, 2200, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 83 - 1680x720@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 99000, 1680, 1940,
+		   1980, 2200, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 84 - 1680x720@100Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 165000, 1680, 1740,
+		   1780, 2000, 720, 725, 730, 825, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 100, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 85 - 1680x720@120Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 198000, 1680, 1740,
+		   1780, 2000, 720, 725, 730, 825, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 120, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 86 - 2560x1080@24Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 99000, 2560, 3558,
+		   3602, 3750, 1080, 1084, 1089, 1100, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 24, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 87 - 2560x1080@25Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 90000, 2560, 3008,
+		   3052, 3200, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 25, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 88 - 2560x1080@30Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 118800, 2560, 3328,
+		   3372, 3520, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 30, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 89 - 2560x1080@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 185625, 2560, 3108,
+		   3152, 3300, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 90 - 2560x1080@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 198000, 2560, 2808,
+		   2852, 3000, 1080, 1084, 1089, 1100, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 91 - 2560x1080@100Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 371250, 2560, 2778,
+		   2822, 2970, 1080, 1084, 1089, 1250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 100, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 92 - 2560x1080@120Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 495000, 2560, 3108,
+		   3152, 3300, 1080, 1084, 1089, 1250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 120, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 93 - 3840x2160p@24Hz 16:9 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 297000, 3840, 5116,
+		   5204, 5500, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 24, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 94 - 3840x2160p@25Hz 16:9 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 297000, 3840, 4896,
+		   4984, 5280, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 25, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 95 - 3840x2160p@30Hz 16:9 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 297000, 3840, 4016,
+		   4104, 4400, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 30, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 96 - 3840x2160p@50Hz 16:9 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 594000, 3840, 4896,
+		   4984, 5280, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 97 - 3840x2160p@60Hz 16:9 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 594000, 3840, 4016,
+		   4104, 4400, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 98 - 4096x2160p@24Hz 256:135 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 297000, 4096, 5116,
+		   5204, 5500, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 24, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_256_135, },
+	/* 99 - 4096x2160p@25Hz 256:135 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 297000, 4096, 5064,
+		   5152, 5280, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 25, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_256_135, },
+	/* 100 - 4096x2160p@30Hz 256:135 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 297000, 4096, 4184,
+		   4272, 4400, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 30, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_256_135, },
+	/* 101 - 4096x2160p@50Hz 256:135 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 594000, 4096, 5064,
+		   5152, 5280, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_256_135, },
+	/* 102 - 4096x2160p@60Hz 256:135 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 594000, 4096, 4184,
+		   4272, 4400, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_256_135, },
+	/* 103 - 3840x2160p@24Hz 64:27 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 297000, 3840, 5116,
+		   5204, 5500, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 24, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 104 - 3840x2160p@25Hz 64:27 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 297000, 3840, 4016,
+		   4104, 4400, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 25, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 105 - 3840x2160p@30Hz 64:27 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 297000, 3840, 4016,
+		   4104, 4400, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 30, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 106 - 3840x2160p@50Hz 64:27 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 594000, 3840, 4896,
+		   4984, 5280, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 107 - 3840x2160p@60Hz 64:27 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 594000, 3840, 4016,
+		   4104, 4400, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 108 - 1280x720@48Hz 16:9 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 90000, 1280, 2240,
+		   2280, 2500, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 48, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 109 - 1280x720@48Hz 64:27 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 90000, 1280, 2240,
+		   2280, 2500, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 48, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 110 - 1680x720@48Hz 64:27 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 99000, 1680, 2490,
+		   2530, 2750, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 48, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 111 - 1920x1080@48Hz 16:9 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 148500, 1920, 2558,
+		   2602, 2750, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 48, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 112 - 1920x1080@48Hz 64:27 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 148500, 1920, 2558,
+		   2602, 2750, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 48, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 113 - 2560x1080@48Hz 64:27 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 198000, 2560, 3558,
+		   3602, 3750, 1080, 1084, 1089, 1100, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 48, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 114 - 3840x2160@48Hz 16:9 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 594000, 3840, 5116,
+		   5204, 5500, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 48, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 115 - 4096x2160@48Hz 256:135 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 594000, 4096, 5116,
+		   5204, 5500, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 48, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_256_135, },
+	/* 116 - 3840x2160@48Hz 64:27 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 594000, 3840, 5116,
+		   5204, 5500, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 48, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 117 - 3840x2160@100Hz 16:9 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 1188000, 3840, 4896,
+		   4984, 5280, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 100, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 118 - 3840x2160@120Hz 16:9 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 1188000, 3840, 4016,
+		   4104, 4400, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 120, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 119 - 3840x2160@100Hz 64:27 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 1188000, 3840, 4896,
+		   4984, 5280, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 100, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 120 - 3840x2160@120Hz 64:27 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 1188000, 3840, 4016,
+		   4104, 4400, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 120, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 121 - 5120x2160@24Hz 64:27 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 396000, 5120, 7116,
+		   7204, 7500, 2160, 2168, 2178, 2200, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 24, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 122 - 5120x2160@25Hz 64:27 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 396000, 5120, 6816,
+		   6904, 7200, 2160, 2168, 2178, 2200, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 25, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 123 - 5120x2160@30Hz 64:27 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 396000, 5120, 5784,
+		   5872, 6000, 2160, 2168, 2178, 2200, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 30, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 124 - 5120x2160@48Hz 64:27 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 742500, 5120, 5866,
+		   5954, 6250, 2160, 2168, 2178, 2475, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 48, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 125 - 5120x2160@50Hz 64:27 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 742500, 5120, 6216,
+		   6304, 6600, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 126 - 5120x2160@60Hz 64:27 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 742500, 5120, 5284,
+		   5372, 5500, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 127 - 5120x2160@100Hz 64:27 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 1485000, 5120, 6216,
+		   6304, 6600, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 100, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+};
+
+static const struct drm_display_mode edid_cea_modes_193[] = {
+	/* 193 - 5120x2160@120Hz 64:27 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 1485000, 5120, 5284,
+		   5372, 5500, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 194 - 7680x4320@24Hz 16:9 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 1188000, 7680, 10232,
+		   10408, 11000, 4320, 4336, 4356, 4500, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	 .vrefresh = 24, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 195 - 7680x4320@25Hz 16:9 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 1188000, 7680, 10032,
+		   10208, 10800, 4320, 4336, 4356, 4400, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	 .vrefresh = 25, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 196 - 7680x4320@30Hz 16:9 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 1188000, 7680, 8232,
+		   8408, 9000, 4320, 4336, 4356, 4400, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	 .vrefresh = 30, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 197 - 7680x4320@48Hz 16:9 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 2376000, 7680, 10232,
+		   10408, 11000, 4320, 4336, 4356, 4500, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	 .vrefresh = 48, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 198 - 7680x4320@50Hz 16:9 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 2376000, 7680, 10032,
+		   10208, 10800, 4320, 4336, 4356, 4400, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	 .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 199 - 7680x4320@60Hz 16:9 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 2376000, 7680, 8232,
+		   8408, 9000, 4320, 4336, 4356, 4400, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	 .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 200 - 7680x4320@100Hz 16:9 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 4752000, 7680, 9792,
+		   9968, 10560, 4320, 4336, 4356, 4500, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	 .vrefresh = 100, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 201 - 7680x4320@120Hz 16:9 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 4752000, 7680, 8032,
+		   8208, 8800, 4320, 4336, 4356, 4500, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	 .vrefresh = 120, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 202 - 7680x4320@24Hz 64:27 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 1188000, 7680, 10232,
+		   10408, 11000, 4320, 4336, 4356, 4500, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 24,  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 203 - 7680x4320@25Hz 64:27 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 1188000, 7680, 10032,
+		   10208, 10800, 4320, 4336, 4356, 4400, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 25,  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 204 - 7680x4320@30Hz 64:27 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 1188000, 7680, 8232,
+		   8408, 9000, 4320, 4336, 4356, 4400, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 30, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 205 - 7680x4320@48Hz 64:27 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 2376000, 7680, 10232,
+		   10408, 11000, 4320, 4336, 4356, 4500, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 48,  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 206 - 7680x4320@50Hz 64:27 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 2376000, 7680, 10032,
+		   10208, 10800, 4320, 4336, 4356, 4400, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 50,  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 207 - 7680x4320@60Hz 64:27 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 2376000, 7680, 8232,
+		   8408, 9000, 4320, 4336, 4356, 4400, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 60,  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 208 - 7680x4320@100Hz 64:27 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 4752000, 7680, 9792,
+		   9968, 10560, 4320, 4336, 4356, 4500, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 100,  .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 209 - 7680x4320@120Hz 64:27 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 4752000, 7680, 8032,
+		   8208, 8800, 4320, 4336, 4356, 4500, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 120, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 210 - 10240x4320@24Hz 64:27 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 1485000, 10240, 11732,
+		   11908, 12500, 4320, 4336, 4356, 4950, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 24, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 211 - 10240x4320@25Hz 64:27 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 1485000, 10240, 12732,
+		   12908, 13500, 4320, 4336, 4356, 4400, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 25, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 212 - 10240x4320@30Hz 64:27 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 1485000, 10240, 10528,
+		   10704, 11000, 4320, 4336, 4356, 4500, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 30, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 213 - 10240x4320@48Hz 64:27 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 2970000, 10240, 11732,
+		   11908, 12500, 4320, 4336, 4356, 4950, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 48, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 214 - 10240x4320@50Hz 64:27 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 2970000, 10240, 12732,
+		   12908, 13500, 4320, 4336, 4356, 4400, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 215 - 10240x4320@60Hz 64:27 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 2970000, 10240, 10528,
+		   10704, 11000, 4320, 4336, 4356, 4500, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	 .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 216 - 10240x4320@100Hz 64:27 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 5940000, 10240, 12432,
+		   12608, 13200, 4320, 4336, 4356, 4500, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	 .vrefresh = 100, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 217 - 10240x4320@120Hz 64:27 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 5940000, 10240, 10528,
+		   10704, 11000, 4320, 4336, 4356, 4500, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	 .vrefresh = 120, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_64_27, },
+	/* 218 - 4096x2160@100Hz 256:135 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 1188000, 4096, 4896,
+		   4984, 5280, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	 .vrefresh = 100, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_256_135, },
+	/* 219 - 4096x2160@120Hz 256:135 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 1188000, 4096, 4184,
+		   4272, 4400, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	 .vrefresh = 120, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_256_135, },
+};
+
+/*
+ * HDMI 1.4 4k modes. Index using the VIC.
+ */
+static const struct drm_display_mode edid_4k_modes[] = {
+	/* 0 - dummy, VICs start at 1 */
+	{ },
+	/* 1 - 3840x2160@30Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 297000,
+		   3840, 4016, 4104, 4400,
+		   2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 30, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 2 - 3840x2160@25Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 297000,
+		   3840, 4896, 4984, 5280,
+		   2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 25, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 3 - 3840x2160@24Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 297000,
+		   3840, 5116, 5204, 5500,
+		   2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 24, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 4 - 4096x2160@24Hz (SMPTE) */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 297000,
+		   4096, 5116, 5204, 5500,
+		   2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 24, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_256_135, },
+};
+
+/*
+ * Autogenerated from the DMT spec.
+ * This table is copied from xfree86/modes/xf86EdidModes.c.
+ */
+static const struct drm_display_mode drm_dmt_modes[] = {
+	/* 0x01 - 640x350@85Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 31500, 640, 672,
+		   736, 832, 350, 382, 385, 445, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x02 - 640x400@85Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 31500, 640, 672,
+		   736, 832, 400, 401, 404, 445, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x03 - 720x400@85Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 35500, 720, 756,
+		   828, 936, 400, 401, 404, 446, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x04 - 640x480@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 25175, 640, 656,
+		   752, 800, 480, 490, 492, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x05 - 640x480@72Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 31500, 640, 664,
+		   704, 832, 480, 489, 492, 520, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x06 - 640x480@75Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 31500, 640, 656,
+		   720, 840, 480, 481, 484, 500, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x07 - 640x480@85Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 36000, 640, 696,
+		   752, 832, 480, 481, 484, 509, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x08 - 800x600@56Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 36000, 800, 824,
+		   896, 1024, 600, 601, 603, 625, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x09 - 800x600@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 40000, 800, 840,
+		   968, 1056, 600, 601, 605, 628, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x0a - 800x600@72Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 50000, 800, 856,
+		   976, 1040, 600, 637, 643, 666, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x0b - 800x600@75Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 49500, 800, 816,
+		   896, 1056, 600, 601, 604, 625, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x0c - 800x600@85Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 56250, 800, 832,
+		   896, 1048, 600, 601, 604, 631, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x0d - 800x600@120Hz RB */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 73250, 800, 848,
+		   880, 960, 600, 603, 607, 636, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x0e - 848x480@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 33750, 848, 864,
+		   976, 1088, 480, 486, 494, 517, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x0f - 1024x768@43Hz, interlace */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 44900, 1024, 1032,
+		   1208, 1264, 768, 768, 772, 817, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+		   DRM_MODE_FLAG_INTERLACE) },
+	/* 0x10 - 1024x768@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 65000, 1024, 1048,
+		   1184, 1344, 768, 771, 777, 806, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x11 - 1024x768@70Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 75000, 1024, 1048,
+		   1184, 1328, 768, 771, 777, 806, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x12 - 1024x768@75Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 78750, 1024, 1040,
+		   1136, 1312, 768, 769, 772, 800, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x13 - 1024x768@85Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 94500, 1024, 1072,
+		   1168, 1376, 768, 769, 772, 808, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x14 - 1024x768@120Hz RB */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 115500, 1024, 1072,
+		   1104, 1184, 768, 771, 775, 813, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x15 - 1152x864@75Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 108000, 1152, 1216,
+		   1344, 1600, 864, 865, 868, 900, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x55 - 1280x720@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 74250, 1280, 1390,
+		   1430, 1650, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x16 - 1280x768@60Hz RB */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 68250, 1280, 1328,
+		   1360, 1440, 768, 771, 778, 790, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x17 - 1280x768@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 79500, 1280, 1344,
+		   1472, 1664, 768, 771, 778, 798, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x18 - 1280x768@75Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 102250, 1280, 1360,
+		   1488, 1696, 768, 771, 778, 805, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x19 - 1280x768@85Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 117500, 1280, 1360,
+		   1496, 1712, 768, 771, 778, 809, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x1a - 1280x768@120Hz RB */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 140250, 1280, 1328,
+		   1360, 1440, 768, 771, 778, 813, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x1b - 1280x800@60Hz RB */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 71000, 1280, 1328,
+		   1360, 1440, 800, 803, 809, 823, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x1c - 1280x800@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 83500, 1280, 1352,
+		   1480, 1680, 800, 803, 809, 831, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x1d - 1280x800@75Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 106500, 1280, 1360,
+		   1488, 1696, 800, 803, 809, 838, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x1e - 1280x800@85Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 122500, 1280, 1360,
+		   1496, 1712, 800, 803, 809, 843, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x1f - 1280x800@120Hz RB */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 146250, 1280, 1328,
+		   1360, 1440, 800, 803, 809, 847, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x20 - 1280x960@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 108000, 1280, 1376,
+		   1488, 1800, 960, 961, 964, 1000, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x21 - 1280x960@85Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 148500, 1280, 1344,
+		   1504, 1728, 960, 961, 964, 1011, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x22 - 1280x960@120Hz RB */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 175500, 1280, 1328,
+		   1360, 1440, 960, 963, 967, 1017, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x23 - 1280x1024@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 108000, 1280, 1328,
+		   1440, 1688, 1024, 1025, 1028, 1066, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x24 - 1280x1024@75Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 135000, 1280, 1296,
+		   1440, 1688, 1024, 1025, 1028, 1066, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x25 - 1280x1024@85Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 157500, 1280, 1344,
+		   1504, 1728, 1024, 1025, 1028, 1072, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x26 - 1280x1024@120Hz RB */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 187250, 1280, 1328,
+		   1360, 1440, 1024, 1027, 1034, 1084, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x27 - 1360x768@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 85500, 1360, 1424,
+		   1536, 1792, 768, 771, 777, 795, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x28 - 1360x768@120Hz RB */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 148250, 1360, 1408,
+		   1440, 1520, 768, 771, 776, 813, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x51 - 1366x768@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 85500, 1366, 1436,
+		   1579, 1792, 768, 771, 774, 798, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x56 - 1366x768@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 72000, 1366, 1380,
+		   1436, 1500, 768, 769, 772, 800, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x29 - 1400x1050@60Hz RB */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 101000, 1400, 1448,
+		   1480, 1560, 1050, 1053, 1057, 1080, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x2a - 1400x1050@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 121750, 1400, 1488,
+		   1632, 1864, 1050, 1053, 1057, 1089, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x2b - 1400x1050@75Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 156000, 1400, 1504,
+		   1648, 1896, 1050, 1053, 1057, 1099, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x2c - 1400x1050@85Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 179500, 1400, 1504,
+		   1656, 1912, 1050, 1053, 1057, 1105, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x2d - 1400x1050@120Hz RB */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 208000, 1400, 1448,
+		   1480, 1560, 1050, 1053, 1057, 1112, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x2e - 1440x900@60Hz RB */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 88750, 1440, 1488,
+		   1520, 1600, 900, 903, 909, 926, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x2f - 1440x900@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 106500, 1440, 1520,
+		   1672, 1904, 900, 903, 909, 934, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x30 - 1440x900@75Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 136750, 1440, 1536,
+		   1688, 1936, 900, 903, 909, 942, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x31 - 1440x900@85Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 157000, 1440, 1544,
+		   1696, 1952, 900, 903, 909, 948, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x32 - 1440x900@120Hz RB */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 182750, 1440, 1488,
+		   1520, 1600, 900, 903, 909, 953, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x53 - 1600x900@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 108000, 1600, 1624,
+		   1704, 1800, 900, 901, 904, 1000, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x33 - 1600x1200@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 162000, 1600, 1664,
+		   1856, 2160, 1200, 1201, 1204, 1250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x34 - 1600x1200@65Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 175500, 1600, 1664,
+		   1856, 2160, 1200, 1201, 1204, 1250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x35 - 1600x1200@70Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 189000, 1600, 1664,
+		   1856, 2160, 1200, 1201, 1204, 1250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x36 - 1600x1200@75Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 202500, 1600, 1664,
+		   1856, 2160, 1200, 1201, 1204, 1250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x37 - 1600x1200@85Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 229500, 1600, 1664,
+		   1856, 2160, 1200, 1201, 1204, 1250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x38 - 1600x1200@120Hz RB */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 268250, 1600, 1648,
+		   1680, 1760, 1200, 1203, 1207, 1271, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x39 - 1680x1050@60Hz RB */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 119000, 1680, 1728,
+		   1760, 1840, 1050, 1053, 1059, 1080, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x3a - 1680x1050@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 146250, 1680, 1784,
+		   1960, 2240, 1050, 1053, 1059, 1089, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x3b - 1680x1050@75Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 187000, 1680, 1800,
+		   1976, 2272, 1050, 1053, 1059, 1099, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x3c - 1680x1050@85Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 214750, 1680, 1808,
+		   1984, 2288, 1050, 1053, 1059, 1105, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x3d - 1680x1050@120Hz RB */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 245500, 1680, 1728,
+		   1760, 1840, 1050, 1053, 1059, 1112, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x3e - 1792x1344@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 204750, 1792, 1920,
+		   2120, 2448, 1344, 1345, 1348, 1394, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x3f - 1792x1344@75Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 261000, 1792, 1888,
+		   2104, 2456, 1344, 1345, 1348, 1417, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x40 - 1792x1344@120Hz RB */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 333250, 1792, 1840,
+		   1872, 1952, 1344, 1347, 1351, 1423, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x41 - 1856x1392@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 218250, 1856, 1952,
+		   2176, 2528, 1392, 1393, 1396, 1439, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x42 - 1856x1392@75Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 288000, 1856, 1984,
+		   2208, 2560, 1392, 1393, 1396, 1500, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x43 - 1856x1392@120Hz RB */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 356500, 1856, 1904,
+		   1936, 2016, 1392, 1395, 1399, 1474, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x52 - 1920x1080@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 148500, 1920, 2008,
+		   2052, 2200, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x44 - 1920x1200@60Hz RB */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 154000, 1920, 1968,
+		   2000, 2080, 1200, 1203, 1209, 1235, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x45 - 1920x1200@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 193250, 1920, 2056,
+		   2256, 2592, 1200, 1203, 1209, 1245, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x46 - 1920x1200@75Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 245250, 1920, 2056,
+		   2264, 2608, 1200, 1203, 1209, 1255, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x47 - 1920x1200@85Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 281250, 1920, 2064,
+		   2272, 2624, 1200, 1203, 1209, 1262, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x48 - 1920x1200@120Hz RB */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 317000, 1920, 1968,
+		   2000, 2080, 1200, 1203, 1209, 1271, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x49 - 1920x1440@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 234000, 1920, 2048,
+		   2256, 2600, 1440, 1441, 1444, 1500, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x4a - 1920x1440@75Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 297000, 1920, 2064,
+		   2288, 2640, 1440, 1441, 1444, 1500, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x4b - 1920x1440@120Hz RB */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 380500, 1920, 1968,
+		   2000, 2080, 1440, 1443, 1447, 1525, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x54 - 2048x1152@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 162000, 2048, 2074,
+		   2154, 2250, 1152, 1153, 1156, 1200, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x4c - 2560x1600@60Hz RB */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 268500, 2560, 2608,
+		   2640, 2720, 1600, 1603, 1609, 1646, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x4d - 2560x1600@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 348500, 2560, 2752,
+		   3032, 3504, 1600, 1603, 1609, 1658, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x4e - 2560x1600@75Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 443250, 2560, 2768,
+		   3048, 3536, 1600, 1603, 1609, 1672, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x4f - 2560x1600@85Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 505250, 2560, 2768,
+		   3048, 3536, 1600, 1603, 1609, 1682, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 0x50 - 2560x1600@120Hz RB */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 552750, 2560, 2608,
+		   2640, 2720, 1600, 1603, 1609, 1694, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x57 - 4096x2160@60Hz RB */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 556744, 4096, 4104,
+		   4136, 4176, 2160, 2208, 2216, 2222, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 0x58 - 4096x2160@59.94Hz RB */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 556188, 4096, 4104,
+		   4136, 4176, 2160, 2208, 2216, 2222, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+};
+
+/*
+ * These more or less come from the DMT spec.  The 720x400 modes are
+ * inferred from historical 80x25 practice.  The 640x480@67 and 832x624@75
+ * modes are old-school Mac modes.  The EDID spec says the 1152x864@75 mode
+ * should be 1152x870, again for the Mac, but instead we use the x864 DMT
+ * mode.
+ *
+ * The DMT modes have been fact-checked; the rest are mild guesses.
+ */
+static const struct drm_display_mode edid_est_modes[] = {
+	/* 800x600@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 40000, 800, 840,
+		   968, 1056, 600, 601, 605, 628, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 800x600@56Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 36000, 800, 824,
+		   896, 1024, 600, 601, 603,  625, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 640x480@75Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 31500, 640, 656,
+		   720, 840, 480, 481, 484, 500, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 640x480@72Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 31500, 640, 664,
+		   704,  832, 480, 489, 492, 520, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 640x480@67Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 30240, 640, 704,
+		   768,  864, 480, 483, 486, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 640x480@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 25175, 640, 656,
+		   752, 800, 480, 490, 492, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 720x400@88Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 35500, 720, 738,
+		   846, 900, 400, 421, 423,  449, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 720x400@70Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 28320, 720, 738,
+		   846,  900, 400, 412, 414, 449, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 1280x1024@75Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 135000, 1280, 1296,
+		   1440, 1688, 1024, 1025, 1028, 1066, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 1024x768@75Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 78750, 1024, 1040,
+		   1136, 1312,  768, 769, 772, 800, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 1024x768@70Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 75000, 1024, 1048,
+		   1184, 1328, 768, 771, 777, 806, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 1024x768@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 65000, 1024, 1048,
+		   1184, 1344, 768, 771, 777, 806, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 1024x768@43Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 44900, 1024, 1032,
+		   1208, 1264, 768, 768, 776, 817, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+		   DRM_MODE_FLAG_INTERLACE) },
+	/* 832x624@75Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 57284, 832, 864,
+		   928, 1152, 624, 625, 628, 667, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 800x600@75Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 49500, 800, 816,
+		   896, 1056, 600, 601, 604,  625, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 800x600@72Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 50000, 800, 856,
+		   976, 1040, 600, 637, 643, 666, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 1152x864@75Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 108000, 1152, 1216,
+		   1344, 1600, 864, 865, 868, 900, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+};
+
+static const struct drm_display_mode resolution_white[] = {
+	/* 0. vic:2 - 720x480@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 27000, 720, 736,
+		   798, 858, 480, 489, 495, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 1. vic:3 - 720x480@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 27000, 720, 736,
+		   798, 858, 480, 489, 495, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 1024x768@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 65000, 1024, 1048,
+		   1184, 1344, 768, 771, 777, 806, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 2. vic:4 - 1280x720@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 74250, 1280, 1390,
+		   1430, 1650, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 3. vic:5 - 1920x1080i@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 74250, 1920, 2008,
+		   2052, 2200, 1080, 1084, 1094, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+		   DRM_MODE_FLAG_INTERLACE),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 4. vic:6 - 720(1440)x480i@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 13500, 720, 739,
+		   801, 858, 480, 488, 494, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 5. vic:16 - 1920x1080@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 148500, 1920, 2008,
+		   2052, 2200, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 6. vic:17 - 720x576@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 27000, 720, 732,
+		   796, 864, 576, 581, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 7. vic:18 - 720x576@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 27000, 720, 732,
+		   796, 864, 576, 581, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 8. vic:19 - 1280x720@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 74250, 1280, 1720,
+		   1760, 1980, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 9. vic:20 - 1920x1080i@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 74250, 1920, 2448,
+		   2492, 2640, 1080, 1084, 1094, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+		   DRM_MODE_FLAG_INTERLACE),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 10. vic:21 - 720(1440)x576i@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 13500, 720, 732,
+		   795, 864, 576, 580, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
+	/* 11. vic:31 - 1920x1080@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 148500, 1920, 2448,
+		   2492, 2640, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 12. vic:32 - 1920x1080@24Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 74250, 1920, 2558,
+		   2602, 2750, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 24, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 13. vic:33 - 1920x1080@25Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 74250, 1920, 2448,
+		   2492, 2640, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 25, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 14. vic:34 - 1920x1080@30Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 74250, 1920, 2008,
+		   2052, 2200, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 30, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 15. vic:39 - 1920x1080i@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 72000, 1920, 1952,
+		   2120, 2304, 1080, 1126, 1136, 1250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC |
+		   DRM_MODE_FLAG_INTERLACE),
+	  .vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 16. vic:60 - 1280x720@24Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 59400, 1280, 3040,
+		   3080, 3300, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 24, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 17. vic:61 - 1280x720@25Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 74250, 1280, 3700,
+		   3740, 3960, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 25, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 18. vic:62 - 1280x720@30Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 74250, 1280, 3040,
+		   3080, 3300, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	  .vrefresh = 30, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 19. vic:93 - 3840x2160p@24Hz 16:9 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 297000, 3840, 5116,
+		   5204, 5500, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 24, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 20. vic:94 - 3840x2160p@25Hz 16:9 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 297000, 3840, 4896,
+		   4984, 5280, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 25, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 21. vic:95 - 3840x2160p@30Hz 16:9 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 297000, 3840, 4016,
+		   4104, 4400, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 30, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 22. vic:96 - 3840x2160p@50Hz 16:9 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 594000, 3840, 4896,
+		   4984, 5280, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 23. vic:97 - 3840x2160p@60Hz 16:9 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 594000, 3840, 4016,
+		   4104, 4400, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 24. vic:98 - 4096x2160p@24Hz 256:135 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 297000, 4096, 5116,
+		   5204, 5500, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 24, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_256_135, },
+	/* 25. vic:99 - 4096x2160p@25Hz 256:135 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 297000, 4096, 5064,
+		   5152, 5280, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 25, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_256_135, },
+	/* 26. vic:100 - 4096x2160p@30Hz 256:135 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 297000, 4096, 4184,
+		   4272, 4400, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 30, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_256_135, },
+	/* 27. vic:101 - 4096x2160p@50Hz 256:135 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 594000, 4096, 5064,
+		   5152, 5280, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_256_135, },
+	/* 28. vic:102 - 4096x2160p@60Hz 256:135 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 594000, 4096, 4184,
+		   4272, 4400, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_256_135, },
+	/* 29. vic:118 - 3840x2160@120Hz 16:9 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 1188000, 3840, 4016,
+		   4104, 4400, 2160, 2168, 2178, 2250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 120, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 30. vic:196 - 7680x4320@30Hz 16:9 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 1188000, 7680, 8232,
+		   8408, 9000, 4320, 4336, 4356, 4400, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 30, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 31. vic:198 - 7680x4320@50Hz 16:9 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 2376000, 7680, 10032,
+		   10208, 10800, 4320, 4336, 4356, 4400, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 50, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+	/* 32. vic:199 - 7680x4320@60Hz 16:9 */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 2376000, 7680, 8232,
+		   8408, 9000, 4320, 4336, 4356, 4400, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
+};
+
+struct minimode {
+	short w;
+	short h;
+	short r;
+	short rb;
+};
+
+static const struct minimode est3_modes[] = {
+	/* byte 6 */
+	{ 640, 350, 85, 0 },
+	{ 640, 400, 85, 0 },
+	{ 720, 400, 85, 0 },
+	{ 640, 480, 85, 0 },
+	{ 848, 480, 60, 0 },
+	{ 800, 600, 85, 0 },
+	{ 1024, 768, 85, 0 },
+	{ 1152, 864, 75, 0 },
+	/* byte 7 */
+	{ 1280, 768, 60, 1 },
+	{ 1280, 768, 60, 0 },
+	{ 1280, 768, 75, 0 },
+	{ 1280, 768, 85, 0 },
+	{ 1280, 960, 60, 0 },
+	{ 1280, 960, 85, 0 },
+	{ 1280, 1024, 60, 0 },
+	{ 1280, 1024, 85, 0 },
+	/* byte 8 */
+	{ 1360, 768, 60, 0 },
+	{ 1440, 900, 60, 1 },
+	{ 1440, 900, 60, 0 },
+	{ 1440, 900, 75, 0 },
+	{ 1440, 900, 85, 0 },
+	{ 1400, 1050, 60, 1 },
+	{ 1400, 1050, 60, 0 },
+	{ 1400, 1050, 75, 0 },
+	/* byte 9 */
+	{ 1400, 1050, 85, 0 },
+	{ 1680, 1050, 60, 1 },
+	{ 1680, 1050, 60, 0 },
+	{ 1680, 1050, 75, 0 },
+	{ 1680, 1050, 85, 0 },
+	{ 1600, 1200, 60, 0 },
+	{ 1600, 1200, 65, 0 },
+	{ 1600, 1200, 70, 0 },
+	/* byte 10 */
+	{ 1600, 1200, 75, 0 },
+	{ 1600, 1200, 85, 0 },
+	{ 1792, 1344, 60, 0 },
+	{ 1792, 1344, 75, 0 },
+	{ 1856, 1392, 60, 0 },
+	{ 1856, 1392, 75, 0 },
+	{ 1920, 1200, 60, 1 },
+	{ 1920, 1200, 60, 0 },
+	/* byte 11 */
+	{ 1920, 1200, 75, 0 },
+	{ 1920, 1200, 85, 0 },
+	{ 1920, 1440, 60, 0 },
+	{ 1920, 1440, 75, 0 },
+};
+
+static const struct minimode extra_modes[] = {
+	{ 1024, 576,  60, 0 },
+	{ 1366, 768,  60, 0 },
+	{ 1600, 900,  60, 0 },
+	{ 1680, 945,  60, 0 },
+	{ 1920, 1080, 60, 0 },
+	{ 2048, 1152, 60, 0 },
+	{ 2048, 1536, 60, 0 },
+};
+
+static const struct drm_display_mode *cea_mode_for_vic(u8 vic)
+{
+	if (!vic)
+		return NULL;
+	else if (vic >= 1 && vic < 1 + ARRAY_SIZE(edid_cea_modes_1))
+		return &edid_cea_modes_1[vic - 1];
+	else if (vic >= 193 && vic < 193 + ARRAY_SIZE(edid_cea_modes_193))
+		return &edid_cea_modes_193[vic - 193];
+
+	return NULL;
+}
+
+static u8 cea_num_vics(void)
+{
+	return 193 + ARRAY_SIZE(edid_cea_modes_193);
+}
+
+static u8 cea_next_vic(u8 vic)
+{
+	if (++vic == 1 + ARRAY_SIZE(edid_cea_modes_1))
+		vic = 193;
+
+	return vic;
+}
+
 int edid_check_info(struct edid1_info *edid_info)
 {
 	if ((edid_info == NULL) || (edid_info->version == 0))
@@ -136,10 +1822,85 @@ static void decode_timing(u8 *buf, struct display_timing *timing)
 	      va + vbl, vborder);
 }
 
+/**
+ * decode_mode() - Decoding an 18-byte detailed timing record
+ *
+ * @buf:	Pointer to EDID detailed timing record
+ * @timing:	Place to put timing
+ */
+static void decode_mode(u8 *buf, struct drm_display_mode *mode)
+{
+	uint x_mm, y_mm;
+	unsigned int ha, hbl, hso, hspw, hborder;
+	unsigned int va, vbl, vso, vspw, vborder;
+	struct edid_detailed_timing *t = (struct edid_detailed_timing *)buf;
+
+	x_mm = (buf[12] + ((buf[14] & 0xf0) << 4));
+	y_mm = (buf[13] + ((buf[14] & 0x0f) << 8));
+	ha = (buf[2] + ((buf[4] & 0xf0) << 4));
+	hbl = (buf[3] + ((buf[4] & 0x0f) << 8));
+	hso = (buf[8] + ((buf[11] & 0xc0) << 2));
+	hspw = (buf[9] + ((buf[11] & 0x30) << 4));
+	hborder = buf[15];
+	va = (buf[5] + ((buf[7] & 0xf0) << 4));
+	vbl = (buf[6] + ((buf[7] & 0x0f) << 8));
+	vso = ((buf[10] >> 4) + ((buf[11] & 0x0c) << 2));
+	vspw = ((buf[10] & 0x0f) + ((buf[11] & 0x03) << 4));
+	vborder = buf[16];
+
+	/* Edid contains pixel clock in terms of 10KHz */
+	mode->clock = (buf[0] + (buf[1] << 8)) * 10;
+	mode->hdisplay = ha;
+	mode->hsync_start = ha + hso;
+	mode->hsync_end = ha + hso + hspw;
+	mode->htotal = ha + hbl;
+	mode->vdisplay = va;
+	mode->vsync_start = va + vso;
+	mode->vsync_end = va + vso + vspw;
+	mode->vtotal = va + vbl;
+
+	mode->flags = EDID_DETAILED_TIMING_FLAG_HSYNC_POLARITY(*t) ?
+		DRM_MODE_FLAG_PHSYNC : DRM_MODE_FLAG_NHSYNC;
+	mode->flags |= EDID_DETAILED_TIMING_FLAG_VSYNC_POLARITY(*t) ?
+		DRM_MODE_FLAG_PVSYNC : DRM_MODE_FLAG_NVSYNC;
+
+	if (EDID_DETAILED_TIMING_FLAG_INTERLACED(*t))
+		mode->flags |= DRM_MODE_FLAG_INTERLACE;
+
+	debug("Detailed mode clock %u kHz, %d mm x %d mm, flags[%x]\n"
+	      "     %04d %04d %04d %04d hborder %d\n"
+	      "     %04d %04d %04d %04d vborder %d\n",
+	      mode->clock,
+	      x_mm, y_mm, mode->flags,
+	      mode->hdisplay, mode->hsync_start, mode->hsync_end,
+	      mode->htotal, hborder,
+	      mode->vdisplay, mode->vsync_start, mode->vsync_end,
+	      mode->vtotal, vborder);
+}
+
+/**
+ * edid_vendor - match a string against EDID's obfuscated vendor field
+ * @edid: EDID to match
+ * @vendor: vendor string
+ *
+ * Returns true if @vendor is in @edid, false otherwise
+ */
+static bool edid_vendor(struct edid *edid, char *vendor)
+{
+	char edid_vendor[3];
+
+	edid_vendor[0] = ((edid->mfg_id[0] & 0x7c) >> 2) + '@';
+	edid_vendor[1] = (((edid->mfg_id[0] & 0x3) << 3) |
+			  ((edid->mfg_id[1] & 0xe0) >> 5)) + '@';
+	edid_vendor[2] = (edid->mfg_id[1] & 0x1f) + '@';
+
+	return !strncmp(edid_vendor, vendor, 3);
+}
+
 /**
  * Check if HDMI vendor specific data block is present in CEA block
  * @param info	CEA extension block
- * Return: true if block is found
+ * @return true if block is found
  */
 static bool cea_is_hdmi_vsdb_present(struct edid_cea861_info *info)
 {
@@ -169,6 +1930,80 @@ static bool cea_is_hdmi_vsdb_present(struct edid_cea861_info *info)
 	return false;
 }
 
+static int drm_get_vrefresh(const struct drm_display_mode *mode)
+{
+	int refresh = 0;
+	unsigned int calc_val;
+
+	if (mode->vrefresh > 0) {
+		refresh = mode->vrefresh;
+	} else if (mode->htotal > 0 && mode->vtotal > 0) {
+		int vtotal;
+
+		vtotal = mode->vtotal;
+		/* work out vrefresh the value will be x1000 */
+		calc_val = (mode->clock * 1000);
+		calc_val /= mode->htotal;
+		refresh = (calc_val + vtotal / 2) / vtotal;
+
+		if (mode->flags & DRM_MODE_FLAG_INTERLACE)
+			refresh *= 2;
+		if (mode->flags & DRM_MODE_FLAG_DBLSCAN)
+			refresh /= 2;
+		if (mode->vscan > 1)
+			refresh /= mode->vscan;
+	}
+	return refresh;
+}
+
+int edid_get_drm_mode(u8 *buf, int buf_size, struct drm_display_mode *mode,
+		      int *panel_bits_per_colourp)
+{
+	struct edid1_info *edid = (struct edid1_info *)buf;
+	bool timing_done;
+	int i;
+
+	if (buf_size < sizeof(*edid) || edid_check_info(edid)) {
+		debug("%s: Invalid buffer\n", __func__);
+		return -EINVAL;
+	}
+
+	if (!EDID1_INFO_FEATURE_PREFERRED_TIMING_MODE(*edid)) {
+		debug("%s: No preferred timing\n", __func__);
+		return -ENOENT;
+	}
+
+	/* Look for detailed timing */
+	timing_done = false;
+	for (i = 0; i < 4; i++) {
+		struct edid_monitor_descriptor *desc;
+
+		desc = &edid->monitor_details.descriptor[i];
+		if (desc->zero_flag_1 != 0) {
+			decode_mode((u8 *)desc, mode);
+			timing_done = true;
+			break;
+		}
+	}
+	if (!timing_done)
+		return -EINVAL;
+
+	if (!EDID1_INFO_VIDEO_INPUT_DIGITAL(*edid)) {
+		debug("%s: Not a digital display\n", __func__);
+		return -ENOSYS;
+	}
+	if (edid->version != 1 || edid->revision < 4) {
+		debug("%s: EDID version %d.%d does not have required info\n",
+		      __func__, edid->version, edid->revision);
+		*panel_bits_per_colourp = -1;
+	} else  {
+		*panel_bits_per_colourp =
+			((edid->video_input_definition & 0x70) >> 3) + 4;
+	}
+
+	return 0;
+}
+
 static bool edid_find_valid_timing(void *buf, int count,
 				   struct display_timing *timing,
 				   bool (*mode_valid)(void *priv,
@@ -269,12 +2104,11 @@ int edid_get_timing(u8 *buf, int buf_size, struct display_timing *timing,
 					panel_bits_per_colourp, NULL, NULL);
 }
 
-
 /**
  * Snip the tailing whitespace/return of a string.
  *
  * @param string	The string to be snipped
- * Return: the snipped string
+ * @return the snipped string
  */
 static char *snip(char *string)
 {
@@ -288,7 +2122,7 @@ static char *snip(char *string)
 	s = &string[strlen(string) - 1];
 
 	while (s >= string && (isspace(*s) || *s == '\n' || *s == '\r' ||
-			*s == '\0'))
+	       *s == '\0'))
 		*(s--) = '\0';
 
 	return string;
@@ -328,8 +2162,8 @@ static void edid_print_dtd(struct edid_monitor_descriptor *monitor,
 			       monitor->data.range_data.vertical_max,
 			       monitor->data.range_data.pixel_clock_max * 10);
 	} else {
-		uint32_t pixclock, h_active, h_blanking, v_active, v_blanking;
-		uint32_t h_total, v_total, vfreq;
+		u32 pixclock, h_active, h_blanking, v_active, v_blanking;
+		u32 h_total, v_total, vfreq;
 
 		pixclock = EDID_DETAILED_TIMING_PIXEL_CLOCK(*timing);
 		h_active = EDID_DETAILED_TIMING_HORIZONTAL_ACTIVE(*timing);
@@ -368,7 +2202,7 @@ void edid_print_info(struct edid1_info *edid_info)
 	int i;
 	char manufacturer[4];
 	unsigned int have_timing = 0;
-	uint32_t serial_number;
+	u32 serial_number;
 
 	if (edid_check_info(edid_info)) {
 		printf("Not a valid EDID\n");
@@ -473,7 +2307,7 @@ void edid_print_info(struct edid1_info *edid_info)
 		    ((xres != 0) && (xres != 1)) ||
 		    ((vfreq != 0) && (vfreq != 1))) {
 			switch (EDID1_INFO_STANDARD_TIMING_ASPECT(*edid_info,
-					i)) {
+				i)) {
 			case ASPECT_625:
 				aspect = 6250;
 				break;
@@ -505,3 +2339,4722 @@ void edid_print_info(struct edid1_info *edid_info)
 	if (!have_timing)
 		printf("\tNone\n");
 }
+
+/**
+ * drm_cvt_mode -create a modeline based on the CVT algorithm
+ * @hdisplay: hdisplay size
+ * @vdisplay: vdisplay size
+ * @vrefresh: vrefresh rate
+ * @reduced: whether to use reduced blanking
+ * @interlaced: whether to compute an interlaced mode
+ * @margins: whether to add margins (borders)
+ *
+ * This function is called to generate the modeline based on CVT algorithm
+ * according to the hdisplay, vdisplay, vrefresh.
+ * It is based from the VESA(TM) Coordinated Video Timing Generator by
+ * Graham Loveridge April 9, 2003 available at
+ * http://www.elo.utfsm.cl/~elo212/docs/CVTd6r1.xls
+ *
+ * And it is copied from xf86CVTmode in xserver/hw/xfree86/modes/xf86cvt.c.
+ * What I have done is to translate it by using integer calculation.
+ *
+ * Returns:
+ * The modeline based on the CVT algorithm stored in a drm_display_mode object.
+ * The display mode object is allocated with drm_mode_create(). Returns NULL
+ * when no mode could be allocated.
+ */
+static
+struct drm_display_mode *drm_cvt_mode(int hdisplay, int vdisplay, int vrefresh,
+				      bool reduced, bool interlaced,
+				      bool margins)
+{
+#define HV_FACTOR			1000
+	/* 1) top/bottom margin size (% of height) - default: 1.8, */
+#define	CVT_MARGIN_PERCENTAGE		18
+	/* 2) character cell horizontal granularity (pixels) - default 8 */
+#define	CVT_H_GRANULARITY		8
+	/* 3) Minimum vertical porch (lines) - default 3 */
+#define	CVT_MIN_V_PORCH			3
+	/* 4) Minimum number of vertical back porch lines - default 6 */
+#define	CVT_MIN_V_BPORCH		6
+	/* Pixel Clock step (kHz) */
+#define CVT_CLOCK_STEP			250
+	struct drm_display_mode *drm_mode;
+	unsigned int vfieldrate, hperiod;
+	int hdisplay_rnd, hmargin, vdisplay_rnd, vmargin, vsync;
+	int interlace;
+
+	/* allocate the drm_display_mode structure. If failure, we will
+	 * return directly
+	 */
+	drm_mode = drm_mode_create();
+	if (!drm_mode)
+		return NULL;
+
+	/* the CVT default refresh rate is 60Hz */
+	if (!vrefresh)
+		vrefresh = 60;
+
+	/* the required field fresh rate */
+	if (interlaced)
+		vfieldrate = vrefresh * 2;
+	else
+		vfieldrate = vrefresh;
+
+	/* horizontal pixels */
+	hdisplay_rnd = hdisplay - (hdisplay % CVT_H_GRANULARITY);
+
+	/* determine the left&right borders */
+	hmargin = 0;
+	if (margins) {
+		hmargin = hdisplay_rnd * CVT_MARGIN_PERCENTAGE / 1000;
+		hmargin -= hmargin % CVT_H_GRANULARITY;
+	}
+	/* find the total active pixels */
+	drm_mode->hdisplay = hdisplay_rnd + 2 * hmargin;
+
+	/* find the number of lines per field */
+	if (interlaced)
+		vdisplay_rnd = vdisplay / 2;
+	else
+		vdisplay_rnd = vdisplay;
+
+	/* find the top & bottom borders */
+	vmargin = 0;
+	if (margins)
+		vmargin = vdisplay_rnd * CVT_MARGIN_PERCENTAGE / 1000;
+
+	drm_mode->vdisplay = vdisplay + 2 * vmargin;
+
+	/* Interlaced */
+	if (interlaced)
+		interlace = 1;
+	else
+		interlace = 0;
+
+	/* Determine VSync Width from aspect ratio */
+	if (!(vdisplay % 3) && ((vdisplay * 4 / 3) == hdisplay))
+		vsync = 4;
+	else if (!(vdisplay % 9) && ((vdisplay * 16 / 9) == hdisplay))
+		vsync = 5;
+	else if (!(vdisplay % 10) && ((vdisplay * 16 / 10) == hdisplay))
+		vsync = 6;
+	else if (!(vdisplay % 4) && ((vdisplay * 5 / 4) == hdisplay))
+		vsync = 7;
+	else if (!(vdisplay % 9) && ((vdisplay * 15 / 9) == hdisplay))
+		vsync = 7;
+	else /* custom */
+		vsync = 10;
+
+	if (!reduced) {
+		/* simplify the GTF calculation */
+		/* 4) Minimum time of vertical sync + back porch interval
+		 * default 550.0
+		 */
+		int tmp1, tmp2;
+#define CVT_MIN_VSYNC_BP	550
+		/* 3) Nominal HSync width (% of line period) - default 8 */
+#define CVT_HSYNC_PERCENTAGE	8
+		unsigned int hblank_percentage;
+		int vsyncandback_porch, hblank;
+
+		/* estimated the horizontal period */
+		tmp1 = HV_FACTOR * 1000000  -
+				CVT_MIN_VSYNC_BP * HV_FACTOR * vfieldrate;
+		tmp2 = (vdisplay_rnd + 2 * vmargin + CVT_MIN_V_PORCH) * 2 +
+				interlace;
+		hperiod = tmp1 * 2 / (tmp2 * vfieldrate);
+
+		tmp1 = CVT_MIN_VSYNC_BP * HV_FACTOR / hperiod + 1;
+		/* 9. Find number of lines in sync + backporch */
+		if (tmp1 < (vsync + CVT_MIN_V_PORCH))
+			vsyncandback_porch = vsync + CVT_MIN_V_PORCH;
+		else
+			vsyncandback_porch = tmp1;
+		/* 10. Find number of lines in back porch
+		 *		vback_porch = vsyncandback_porch - vsync;
+		 */
+		drm_mode->vtotal = vdisplay_rnd + 2 * vmargin +
+				vsyncandback_porch + CVT_MIN_V_PORCH;
+		/* 5) Definition of Horizontal blanking time limitation */
+		/* Gradient (%/kHz) - default 600 */
+#define CVT_M_FACTOR	600
+		/* Offset (%) - default 40 */
+#define CVT_C_FACTOR	40
+		/* Blanking time scaling factor - default 128 */
+#define CVT_K_FACTOR	128
+		/* Scaling factor weighting - default 20 */
+#define CVT_J_FACTOR	20
+#define CVT_M_PRIME	(CVT_M_FACTOR * CVT_K_FACTOR / 256)
+#define CVT_C_PRIME	((CVT_C_FACTOR - CVT_J_FACTOR) * CVT_K_FACTOR / 256 + \
+			 CVT_J_FACTOR)
+		/* 12. Find ideal blanking duty cycle from formula */
+		hblank_percentage = CVT_C_PRIME * HV_FACTOR - CVT_M_PRIME *
+					hperiod / 1000;
+		/* 13. Blanking time */
+		if (hblank_percentage < 20 * HV_FACTOR)
+			hblank_percentage = 20 * HV_FACTOR;
+		hblank = drm_mode->hdisplay * hblank_percentage /
+			 (100 * HV_FACTOR - hblank_percentage);
+		hblank -= hblank % (2 * CVT_H_GRANULARITY);
+		/* 14. find the total pixels per line */
+		drm_mode->htotal = drm_mode->hdisplay + hblank;
+		drm_mode->hsync_end = drm_mode->hdisplay + hblank / 2;
+		drm_mode->hsync_start = drm_mode->hsync_end -
+			(drm_mode->htotal * CVT_HSYNC_PERCENTAGE) / 100;
+		drm_mode->hsync_start += CVT_H_GRANULARITY -
+			drm_mode->hsync_start % CVT_H_GRANULARITY;
+		/* fill the Vsync values */
+		drm_mode->vsync_start = drm_mode->vdisplay + CVT_MIN_V_PORCH;
+		drm_mode->vsync_end = drm_mode->vsync_start + vsync;
+	} else {
+		/* Reduced blanking */
+		/* Minimum vertical blanking interval time - default 460 */
+#define CVT_RB_MIN_VBLANK	460
+		/* Fixed number of clocks for horizontal sync */
+#define CVT_RB_H_SYNC		32
+		/* Fixed number of clocks for horizontal blanking */
+#define CVT_RB_H_BLANK		160
+		/* Fixed number of lines for vertical front porch - default 3*/
+#define CVT_RB_VFPORCH		3
+		int vbilines;
+		int tmp1, tmp2;
+		/* 8. Estimate Horizontal period. */
+		tmp1 = HV_FACTOR * 1000000 -
+			CVT_RB_MIN_VBLANK * HV_FACTOR * vfieldrate;
+		tmp2 = vdisplay_rnd + 2 * vmargin;
+		hperiod = tmp1 / (tmp2 * vfieldrate);
+		/* 9. Find number of lines in vertical blanking */
+		vbilines = CVT_RB_MIN_VBLANK * HV_FACTOR / hperiod + 1;
+		/* 10. Check if vertical blanking is sufficient */
+		if (vbilines < (CVT_RB_VFPORCH + vsync + CVT_MIN_V_BPORCH))
+			vbilines = CVT_RB_VFPORCH + vsync + CVT_MIN_V_BPORCH;
+		/* 11. Find total number of lines in vertical field */
+		drm_mode->vtotal = vdisplay_rnd + 2 * vmargin + vbilines;
+		/* 12. Find total number of pixels in a line */
+		drm_mode->htotal = drm_mode->hdisplay + CVT_RB_H_BLANK;
+		/* Fill in HSync values */
+		drm_mode->hsync_end = drm_mode->hdisplay + CVT_RB_H_BLANK / 2;
+		drm_mode->hsync_start = drm_mode->hsync_end - CVT_RB_H_SYNC;
+		/* Fill in VSync values */
+		drm_mode->vsync_start = drm_mode->vdisplay + CVT_RB_VFPORCH;
+		drm_mode->vsync_end = drm_mode->vsync_start + vsync;
+	}
+	/* 15/13. Find pixel clock frequency (kHz for xf86) */
+	drm_mode->clock = drm_mode->htotal * HV_FACTOR * 1000 / hperiod;
+	drm_mode->clock -= drm_mode->clock % CVT_CLOCK_STEP;
+	/* 18/16. Find actual vertical frame frequency */
+	/* ignore - just set the mode flag for interlaced */
+	if (interlaced) {
+		drm_mode->vtotal *= 2;
+		drm_mode->flags |= DRM_MODE_FLAG_INTERLACE;
+	}
+
+	if (reduced)
+		drm_mode->flags |= (DRM_MODE_FLAG_PHSYNC |
+					DRM_MODE_FLAG_NVSYNC);
+	else
+		drm_mode->flags |= (DRM_MODE_FLAG_PVSYNC |
+					DRM_MODE_FLAG_NHSYNC);
+
+	return drm_mode;
+}
+
+static int
+cea_db_payload_len(const u8 *db)
+{
+	return db[0] & 0x1f;
+}
+
+static int
+cea_db_extended_tag(const u8 *db)
+{
+	return db[1];
+}
+
+static int
+cea_db_tag(const u8 *db)
+{
+	return db[0] >> 5;
+}
+
+#define for_each_cea_db(cea, i, start, end) \
+	for ((i) = (start); (i) < (end) && (i) + \
+	cea_db_payload_len(&(cea)[(i)]) < \
+	(end); (i) += cea_db_payload_len(&(cea)[(i)]) + 1)
+
+static int
+cea_revision(const u8 *cea)
+{
+	return cea[1];
+}
+
+static int
+cea_db_offsets(const u8 *cea, int *start, int *end)
+{
+	/* Data block offset in CEA extension block */
+	*start = 4;
+	*end = cea[2];
+	if (*end == 0)
+		*end = 127;
+	if (*end < 4 || *end > 127)
+		return -ERANGE;
+
+	/*
+	 * XXX: cea[2] is equal to the real value minus one in some sink edid.
+	 */
+	if (*end != 4) {
+		int i;
+
+		i = *start;
+		while (i < (*end) &&
+		       i + cea_db_payload_len(&(cea)[i]) < (*end))
+			i += cea_db_payload_len(&(cea)[i]) + 1;
+
+		if (cea_db_payload_len(&(cea)[i]) &&
+		    i + cea_db_payload_len(&(cea)[i]) == (*end))
+			(*end)++;
+	}
+
+	return 0;
+}
+
+static bool cea_db_is_hdmi_vsdb(const u8 *db)
+{
+	int hdmi_id;
+
+	if (cea_db_tag(db) != EDID_CEA861_DB_VENDOR)
+		return false;
+
+	if (cea_db_payload_len(db) < 5)
+		return false;
+
+	hdmi_id = db[1] | (db[2] << 8) | (db[3] << 16);
+
+	return hdmi_id == HDMI_IEEE_OUI;
+}
+
+static bool cea_db_is_hdmi_forum_vsdb(const u8 *db)
+{
+	unsigned int oui;
+
+	if (cea_db_tag(db) != EDID_CEA861_DB_VENDOR)
+		return false;
+
+	if (cea_db_payload_len(db) < 7)
+		return false;
+
+	oui = db[3] << 16 | db[2] << 8 | db[1];
+
+	return oui == HDMI_FORUM_IEEE_OUI;
+}
+
+static bool cea_db_is_y420cmdb(const u8 *db)
+{
+	if (cea_db_tag(db) != EDID_CEA861_DB_USE_EXTENDED)
+		return false;
+
+	if (!cea_db_payload_len(db))
+		return false;
+
+	if (cea_db_extended_tag(db) != EXT_VIDEO_CAP_BLOCK_Y420CMDB)
+		return false;
+
+	return true;
+}
+
+static bool cea_db_is_y420vdb(const u8 *db)
+{
+	if (cea_db_tag(db) != EDID_CEA861_DB_USE_EXTENDED)
+		return false;
+
+	if (!cea_db_payload_len(db))
+		return false;
+
+	if (cea_db_extended_tag(db) != EXT_VIDEO_DATA_BLOCK_420)
+		return false;
+
+	return true;
+}
+
+static bool drm_valid_hdmi_vic(u8 vic)
+{
+	return vic > 0 && vic < ARRAY_SIZE(edid_4k_modes);
+}
+
+void drm_add_hdmi_modes(struct hdmi_edid_data *data,
+			const struct drm_display_mode *mode)
+{
+	struct drm_display_mode *mode_buf = data->mode_buf;
+
+	if (data->modes >= MODE_LEN)
+		return;
+	mode_buf[(data->modes)++] = *mode;
+}
+
+static bool drm_valid_cea_vic(u8 vic)
+{
+	return cea_mode_for_vic(vic) ? true : false;
+}
+
+static u8 svd_to_vic(u8 svd)
+{
+	/* 0-6 bit vic, 7th bit native mode indicator */
+	if ((svd >= 1 &&  svd <= 64) || (svd >= 129 && svd <= 192))
+		return svd & 127;
+
+	return svd;
+}
+
+static struct drm_display_mode *
+drm_display_mode_from_vic_index(const u8 *video_db, u8 video_len,
+				u8 video_index)
+{
+	struct drm_display_mode *newmode;
+	u8 vic;
+
+	if (!video_db || video_index >= video_len)
+		return NULL;
+
+	/* CEA modes are numbered 1..127 */
+	vic = svd_to_vic(video_db[video_index]);
+	if (!drm_valid_cea_vic(vic))
+		return NULL;
+
+	newmode = drm_mode_create();
+	if (!newmode)
+		return NULL;
+
+	*newmode = *cea_mode_for_vic(vic);
+	newmode->vrefresh = 0;
+
+	return newmode;
+}
+
+static void bitmap_set(unsigned long *map, unsigned int start, int len)
+{
+	unsigned long *p = map + BIT_WORD(start);
+	const unsigned int size = start + len;
+	int bits_to_set = BITS_PER_LONG - (start % BITS_PER_LONG);
+	unsigned long mask_to_set = BITMAP_FIRST_WORD_MASK(start);
+
+	while (len - bits_to_set >= 0) {
+		*p |= mask_to_set;
+		len -= bits_to_set;
+		bits_to_set = BITS_PER_LONG;
+		mask_to_set = ~0UL;
+		p++;
+	}
+	if (len) {
+		mask_to_set &= BITMAP_LAST_WORD_MASK(size);
+		*p |= mask_to_set;
+	}
+}
+
+static void
+drm_add_cmdb_modes(u8 svd, struct drm_hdmi_info *hdmi)
+{
+	u8 vic = svd_to_vic(svd);
+
+	if (!drm_valid_cea_vic(vic))
+		return;
+
+	bitmap_set(hdmi->y420_cmdb_modes, vic, 1);
+}
+
+int do_cea_modes(struct hdmi_edid_data *data, const u8 *db, u8 len)
+{
+	int i, modes = 0;
+	struct drm_hdmi_info *hdmi = &data->display_info.hdmi;
+
+	for (i = 0; i < len; i++) {
+		struct drm_display_mode *mode;
+
+		mode = drm_display_mode_from_vic_index(db, len, i);
+		if (mode) {
+			/*
+			 * YCBCR420 capability block contains a bitmap which
+			 * gives the index of CEA modes from CEA VDB, which
+			 * can support YCBCR 420 sampling output also (apart
+			 * from RGB/YCBCR444 etc).
+			 * For example, if the bit 0 in bitmap is set,
+			 * first mode in VDB can support YCBCR420 output too.
+			 * Add YCBCR420 modes only if sink is HDMI 2.0 capable.
+			 */
+			if (i < 64 && hdmi->y420_cmdb_map & (1ULL << i))
+				drm_add_cmdb_modes(db[i], hdmi);
+			drm_add_hdmi_modes(data, mode);
+			drm_mode_destroy(mode);
+			modes++;
+		}
+	}
+
+	return modes;
+}
+
+/*
+ * do_y420vdb_modes - Parse YCBCR 420 only modes
+ * @data: the structure that save parsed hdmi edid data
+ * @svds: start of the data block of CEA YCBCR 420 VDB
+ * @svds_len: length of the CEA YCBCR 420 VDB
+ * @hdmi: runtime information about the connected HDMI sink
+ *
+ * Parse the CEA-861-F YCBCR 420 Video Data Block (Y420VDB)
+ * which contains modes which can be supported in YCBCR 420
+ * output format only.
+ */
+static int
+do_y420vdb_modes(struct hdmi_edid_data *data, const u8 *svds, u8 svds_len)
+{
+	int modes = 0, i;
+	struct drm_hdmi_info *hdmi = &data->display_info.hdmi;
+
+	for (i = 0; i < svds_len; i++) {
+		u8 vic = svd_to_vic(svds[i]);
+
+		if (!drm_valid_cea_vic(vic))
+			continue;
+
+		bitmap_set(hdmi->y420_vdb_modes, vic, 1);
+		drm_add_hdmi_modes(data, cea_mode_for_vic(vic));
+		modes++;
+	}
+
+	return modes;
+}
+
+struct stereo_mandatory_mode {
+	int width, height, vrefresh;
+	unsigned int flags;
+};
+
+static const struct stereo_mandatory_mode stereo_mandatory_modes[] = {
+	{ 1920, 1080, 24, DRM_MODE_FLAG_3D_TOP_AND_BOTTOM },
+	{ 1920, 1080, 24, DRM_MODE_FLAG_3D_FRAME_PACKING },
+	{ 1920, 1080, 50,
+	  DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF },
+	{ 1920, 1080, 60,
+	  DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF },
+	{ 1280, 720,  50, DRM_MODE_FLAG_3D_TOP_AND_BOTTOM },
+	{ 1280, 720,  50, DRM_MODE_FLAG_3D_FRAME_PACKING },
+	{ 1280, 720,  60, DRM_MODE_FLAG_3D_TOP_AND_BOTTOM },
+	{ 1280, 720,  60, DRM_MODE_FLAG_3D_FRAME_PACKING }
+};
+
+static bool
+stereo_match_mandatory(const struct drm_display_mode *mode,
+		       const struct stereo_mandatory_mode *stereo_mode)
+{
+	unsigned int interlaced = mode->flags & DRM_MODE_FLAG_INTERLACE;
+
+	return mode->hdisplay == stereo_mode->width &&
+	       mode->vdisplay == stereo_mode->height &&
+	       interlaced == (stereo_mode->flags & DRM_MODE_FLAG_INTERLACE) &&
+	       drm_get_vrefresh(mode) == stereo_mode->vrefresh;
+}
+
+static int add_hdmi_mandatory_stereo_modes(struct hdmi_edid_data *data)
+{
+	const struct drm_display_mode *mode;
+	int num = data->modes, modes = 0, i, k;
+
+	for (k = 0; k < num; k++) {
+		mode = &data->mode_buf[k];
+		for (i = 0; i < ARRAY_SIZE(stereo_mandatory_modes); i++) {
+			const struct stereo_mandatory_mode *mandatory;
+			struct drm_display_mode *new_mode;
+
+			if (!stereo_match_mandatory(mode,
+						    &stereo_mandatory_modes[i]))
+				continue;
+
+			mandatory = &stereo_mandatory_modes[i];
+			new_mode = drm_mode_create();
+			if (!new_mode)
+				continue;
+
+			*new_mode = *mode;
+			new_mode->flags |= mandatory->flags;
+			drm_add_hdmi_modes(data, new_mode);
+			drm_mode_destroy(new_mode);
+			modes++;
+		}
+	}
+
+	return modes;
+}
+
+static int add_3d_struct_modes(struct hdmi_edid_data *data, u16 structure,
+			       const u8 *video_db, u8 video_len, u8 video_index)
+{
+	struct drm_display_mode *newmode;
+	int modes = 0;
+
+	if (structure & (1 << 0)) {
+		newmode = drm_display_mode_from_vic_index(video_db,
+							  video_len,
+							  video_index);
+		if (newmode) {
+			newmode->flags |= DRM_MODE_FLAG_3D_FRAME_PACKING;
+			drm_add_hdmi_modes(data, newmode);
+			modes++;
+			drm_mode_destroy(newmode);
+		}
+	}
+	if (structure & (1 << 6)) {
+		newmode = drm_display_mode_from_vic_index(video_db,
+							  video_len,
+							  video_index);
+		if (newmode) {
+			newmode->flags |= DRM_MODE_FLAG_3D_TOP_AND_BOTTOM;
+			drm_add_hdmi_modes(data, newmode);
+			modes++;
+			drm_mode_destroy(newmode);
+		}
+	}
+	if (structure & (1 << 8)) {
+		newmode = drm_display_mode_from_vic_index(video_db,
+							  video_len,
+							  video_index);
+		if (newmode) {
+			newmode->flags |= DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF;
+			drm_add_hdmi_modes(data, newmode);
+			modes++;
+			drm_mode_destroy(newmode);
+		}
+	}
+
+	return modes;
+}
+
+static int add_hdmi_mode(struct hdmi_edid_data *data, u8 vic)
+{
+	if (!drm_valid_hdmi_vic(vic)) {
+		debug("Unknown HDMI VIC: %d\n", vic);
+		return 0;
+	}
+
+	drm_add_hdmi_modes(data, &edid_4k_modes[vic]);
+
+	return 1;
+}
+
+/*
+ * do_hdmi_vsdb_modes - Parse the HDMI Vendor Specific data block
+ * @db: start of the CEA vendor specific block
+ * @len: length of the CEA block payload, ie. one can access up to db[len]
+ *
+ * Parses the HDMI VSDB looking for modes to add to @data. This function
+ * also adds the stereo 3d modes when applicable.
+ */
+static int
+do_hdmi_vsdb_modes(const u8 *db, u8 len, const u8 *video_db, u8 video_len,
+		   struct hdmi_edid_data *data)
+{
+	int modes = 0, offset = 0, i, multi_present = 0, multi_len;
+	u8 vic_len, hdmi_3d_len = 0;
+	u16 mask;
+	u16 structure_all;
+
+	if (len < 8)
+		goto out;
+
+	/* no HDMI_Video_Present */
+	if (!(db[8] & (1 << 5)))
+		goto out;
+
+	/* Latency_Fields_Present */
+	if (db[8] & (1 << 7))
+		offset += 2;
+
+	/* I_Latency_Fields_Present */
+	if (db[8] & (1 << 6))
+		offset += 2;
+
+	/* the declared length is not long enough for the 2 first bytes
+	 * of additional video format capabilities
+	 */
+	if (len < (8 + offset + 2))
+		goto out;
+
+	/* 3D_Present */
+	offset++;
+	if (db[8 + offset] & (1 << 7)) {
+		modes += add_hdmi_mandatory_stereo_modes(data);
+
+		/* 3D_Multi_present */
+		multi_present = (db[8 + offset] & 0x60) >> 5;
+	}
+
+	offset++;
+	vic_len = db[8 + offset] >> 5;
+	hdmi_3d_len = db[8 + offset] & 0x1f;
+
+	for (i = 0; i < vic_len && len >= (9 + offset + i); i++) {
+		u8 vic;
+
+		vic = db[9 + offset + i];
+		modes += add_hdmi_mode(data, vic);
+	}
+
+	offset += 1 + vic_len;
+
+	if (multi_present == 1)
+		multi_len = 2;
+	else if (multi_present == 2)
+		multi_len = 4;
+	else
+		multi_len = 0;
+
+	if (len < (8 + offset + hdmi_3d_len - 1))
+		goto out;
+
+	if (hdmi_3d_len < multi_len)
+		goto out;
+
+	if (multi_present == 1 || multi_present == 2) {
+		/* 3D_Structure_ALL */
+		structure_all = (db[8 + offset] << 8) | db[9 + offset];
+
+		/* check if 3D_MASK is present */
+		if (multi_present == 2)
+			mask = (db[10 + offset] << 8) | db[11 + offset];
+		else
+			mask = 0xffff;
+
+		for (i = 0; i < 16; i++) {
+			if (mask & (1 << i))
+				modes += add_3d_struct_modes(data,
+						structure_all,
+						video_db,
+						video_len, i);
+		}
+	}
+
+	offset += multi_len;
+
+	for (i = 0; i < (hdmi_3d_len - multi_len); i++) {
+		int vic_index;
+		struct drm_display_mode *newmode = NULL;
+		unsigned int newflag = 0;
+		bool detail_present;
+
+		detail_present = ((db[8 + offset + i] & 0x0f) > 7);
+
+		if (detail_present && (i + 1 == hdmi_3d_len - multi_len))
+			break;
+
+		/* 2D_VIC_order_X */
+		vic_index = db[8 + offset + i] >> 4;
+
+		/* 3D_Structure_X */
+		switch (db[8 + offset + i] & 0x0f) {
+		case 0:
+			newflag = DRM_MODE_FLAG_3D_FRAME_PACKING;
+			break;
+		case 6:
+			newflag = DRM_MODE_FLAG_3D_TOP_AND_BOTTOM;
+			break;
+		case 8:
+			/* 3D_Detail_X */
+			if ((db[9 + offset + i] >> 4) == 1)
+				newflag = DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF;
+			break;
+		}
+
+		if (newflag != 0) {
+			newmode = drm_display_mode_from_vic_index(
+								  video_db,
+								  video_len,
+								  vic_index);
+
+			if (newmode) {
+				newmode->flags |= newflag;
+				drm_add_hdmi_modes(data, newmode);
+				modes++;
+				drm_mode_destroy(newmode);
+			}
+		}
+
+		if (detail_present)
+			i++;
+	}
+
+out:
+	return modes;
+}
+
+/**
+ * edid_get_quirks - return quirk flags for a given EDID
+ * @edid: EDID to process
+ *
+ * This tells subsequent routines what fixes they need to apply.
+ */
+static u32 edid_get_quirks(struct edid *edid)
+{
+	struct edid_quirk *quirk;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(edid_quirk_list); i++) {
+		quirk = &edid_quirk_list[i];
+
+		if (edid_vendor(edid, quirk->vendor) &&
+		    (EDID_PRODUCT_ID(edid) == quirk->product_id))
+			return quirk->quirks;
+	}
+
+	return 0;
+}
+
+static void drm_parse_y420cmdb_bitmap(struct hdmi_edid_data *data,
+				      const u8 *db)
+{
+	struct drm_display_info *info = &data->display_info;
+	struct drm_hdmi_info *hdmi = &info->hdmi;
+	u8 map_len = cea_db_payload_len(db) - 1;
+	u8 count;
+	u64 map = 0;
+
+	if (map_len == 0) {
+		/* All CEA modes support ycbcr420 sampling also.*/
+		hdmi->y420_cmdb_map = U64_MAX;
+		info->color_formats |= DRM_COLOR_FORMAT_YCRCB420;
+		return;
+	}
+
+	/*
+	 * This map indicates which of the existing CEA block modes
+	 * from VDB can support YCBCR420 output too. So if bit=0 is
+	 * set, first mode from VDB can support YCBCR420 output too.
+	 * We will parse and keep this map, before parsing VDB itself
+	 * to avoid going through the same block again and again.
+	 *
+	 * Spec is not clear about max possible size of this block.
+	 * Clamping max bitmap block size at 8 bytes. Every byte can
+	 * address 8 CEA modes, in this way this map can address
+	 * 8*8 = first 64 SVDs.
+	 */
+	if (map_len > 8)
+		map_len = 8;
+
+	for (count = 0; count < map_len; count++)
+		map |= (u64)db[2 + count] << (8 * count);
+
+	if (map)
+		info->color_formats |= DRM_COLOR_FORMAT_YCRCB420;
+
+	hdmi->y420_cmdb_map = map;
+}
+
+static
+void drm_get_max_frl_rate(int max_frl_rate, u8 *max_lanes, u8 *max_rate_per_lane)
+{
+	switch (max_frl_rate) {
+	case 1:
+		*max_lanes = 3;
+		*max_rate_per_lane = 3;
+		break;
+	case 2:
+		*max_lanes = 3;
+		*max_rate_per_lane = 6;
+		break;
+	case 3:
+		*max_lanes = 4;
+		*max_rate_per_lane = 6;
+		break;
+	case 4:
+		*max_lanes = 4;
+		*max_rate_per_lane = 8;
+		break;
+	case 5:
+		*max_lanes = 4;
+		*max_rate_per_lane = 10;
+		break;
+	case 6:
+		*max_lanes = 4;
+		*max_rate_per_lane = 12;
+		break;
+	case 0:
+	default:
+		*max_lanes = 0;
+		*max_rate_per_lane = 0;
+	}
+}
+
+static void drm_parse_ycbcr420_deep_color_info(struct hdmi_edid_data *data,
+					       const u8 *db)
+{
+	u8 dc_mask;
+	struct drm_hdmi_info *hdmi = &data->display_info.hdmi;
+
+	dc_mask = db[7] & DRM_EDID_YCBCR420_DC_MASK;
+	hdmi->y420_dc_modes |= dc_mask;
+}
+
+static void drm_parse_hdmi_forum_vsdb(struct hdmi_edid_data *data,
+				      const u8 *hf_vsdb)
+{
+	struct drm_display_info *display = &data->display_info;
+	struct drm_hdmi_info *hdmi = &display->hdmi;
+
+	if (hf_vsdb[6] & 0x80) {
+		hdmi->scdc.supported = true;
+		if (hf_vsdb[6] & 0x40)
+			hdmi->scdc.read_request = true;
+	}
+
+	/*
+	 * All HDMI 2.0 monitors must support scrambling at rates > 340 MHz.
+	 * And as per the spec, three factors confirm this:
+	 * * Availability of a HF-VSDB block in EDID (check)
+	 * * Non zero Max_TMDS_Char_Rate filed in HF-VSDB (let's check)
+	 * * SCDC support available (let's check)
+	 * Lets check it out.
+	 */
+
+	if (hf_vsdb[5]) {
+		/* max clock is 5000 KHz times block value */
+		u32 max_tmds_clock = hf_vsdb[5] * 5000;
+		struct drm_scdc *scdc = &hdmi->scdc;
+
+		if (max_tmds_clock > 340000) {
+			display->max_tmds_clock = max_tmds_clock;
+			debug("HF-VSDB: max TMDS clock %d kHz\n",
+			      display->max_tmds_clock);
+		}
+
+		if (scdc->supported) {
+			scdc->scrambling.supported = true;
+
+			/* Few sinks support scrambling for cloks < 340M */
+			if ((hf_vsdb[6] & 0x8))
+				scdc->scrambling.low_rates = true;
+		}
+	}
+
+	if (hf_vsdb[7]) {
+		u8 max_frl_rate;
+		u8 dsc_max_frl_rate;
+		u8 dsc_max_slices;
+		struct drm_hdmi_dsc_cap *hdmi_dsc = &hdmi->dsc_cap;
+
+		debug("hdmi_21 sink detected. parsing edid\n");
+		max_frl_rate = (hf_vsdb[7] & DRM_EDID_MAX_FRL_RATE_MASK) >> 4;
+		drm_get_max_frl_rate(max_frl_rate, &hdmi->max_lanes,
+				     &hdmi->max_frl_rate_per_lane);
+		hdmi->add_func = hf_vsdb[8];
+		hdmi_dsc->v_1p2 = hf_vsdb[11] & DRM_EDID_DSC_1P2;
+
+		if (hdmi_dsc->v_1p2) {
+			hdmi_dsc->native_420 = hf_vsdb[11] & DRM_EDID_DSC_NATIVE_420;
+			hdmi_dsc->all_bpp = hf_vsdb[11] & DRM_EDID_DSC_ALL_BPP;
+
+			if (hf_vsdb[11] & DRM_EDID_DSC_16BPC)
+				hdmi_dsc->bpc_supported = 16;
+			else if (hf_vsdb[11] & DRM_EDID_DSC_12BPC)
+				hdmi_dsc->bpc_supported = 12;
+			else if (hf_vsdb[11] & DRM_EDID_DSC_10BPC)
+				hdmi_dsc->bpc_supported = 10;
+			else
+				hdmi_dsc->bpc_supported = 0;
+
+			dsc_max_frl_rate = (hf_vsdb[12] & DRM_EDID_DSC_MAX_FRL_RATE_MASK) >> 4;
+			drm_get_max_frl_rate(dsc_max_frl_rate, &hdmi_dsc->max_lanes,
+					     &hdmi_dsc->max_frl_rate_per_lane);
+			hdmi_dsc->total_chunk_kbytes =
+				hf_vsdb[13] & DRM_EDID_DSC_TOTAL_CHUNK_KBYTES;
+
+			dsc_max_slices = hf_vsdb[12] & DRM_EDID_DSC_MAX_SLICES;
+			switch (dsc_max_slices) {
+			case 1:
+				hdmi_dsc->max_slices = 1;
+				hdmi_dsc->clk_per_slice = 340;
+				break;
+			case 2:
+				hdmi_dsc->max_slices = 2;
+				hdmi_dsc->clk_per_slice = 340;
+				break;
+			case 3:
+				hdmi_dsc->max_slices = 4;
+				hdmi_dsc->clk_per_slice = 340;
+				break;
+			case 4:
+				hdmi_dsc->max_slices = 8;
+				hdmi_dsc->clk_per_slice = 340;
+				break;
+			case 5:
+				hdmi_dsc->max_slices = 8;
+				hdmi_dsc->clk_per_slice = 400;
+				break;
+			case 6:
+				hdmi_dsc->max_slices = 12;
+				hdmi_dsc->clk_per_slice = 400;
+				break;
+			case 7:
+				hdmi_dsc->max_slices = 16;
+				hdmi_dsc->clk_per_slice = 400;
+				break;
+			case 0:
+			default:
+				hdmi_dsc->max_slices = 0;
+				hdmi_dsc->clk_per_slice = 0;
+			}
+		}
+	}
+
+	drm_parse_ycbcr420_deep_color_info(data, hf_vsdb);
+}
+
+/**
+ * drm_default_rgb_quant_range - default RGB quantization range
+ * @mode: display mode
+ *
+ * Determine the default RGB quantization range for the mode,
+ * as specified in CEA-861.
+ *
+ * Return: The default RGB quantization range for the mode
+ */
+enum hdmi_quantization_range
+drm_default_rgb_quant_range(struct drm_display_mode *mode)
+{
+	/* All CEA modes other than VIC 1 use limited quantization range. */
+	return drm_match_cea_mode(mode) > 1 ?
+		HDMI_QUANTIZATION_RANGE_LIMITED :
+		HDMI_QUANTIZATION_RANGE_FULL;
+}
+
+static void drm_parse_hdmi_deep_color_info(struct hdmi_edid_data *data,
+					   const u8 *hdmi)
+{
+	struct drm_display_info *info = &data->display_info;
+	unsigned int dc_bpc = 0;
+
+	/* HDMI supports at least 8 bpc */
+	info->bpc = 8;
+
+	if (cea_db_payload_len(hdmi) < 6)
+		return;
+
+	if (hdmi[6] & DRM_EDID_HDMI_DC_30) {
+		dc_bpc = 10;
+		info->edid_hdmi_dc_modes |= DRM_EDID_HDMI_DC_30;
+		debug("HDMI sink does deep color 30.\n");
+	}
+
+	if (hdmi[6] & DRM_EDID_HDMI_DC_36) {
+		dc_bpc = 12;
+		info->edid_hdmi_dc_modes |= DRM_EDID_HDMI_DC_36;
+		debug("HDMI sink does deep color 36.\n");
+	}
+
+	if (hdmi[6] & DRM_EDID_HDMI_DC_48) {
+		dc_bpc = 16;
+		info->edid_hdmi_dc_modes |= DRM_EDID_HDMI_DC_48;
+		debug("HDMI sink does deep color 48.\n");
+	}
+
+	if (dc_bpc == 0) {
+		debug("No deep color support on this HDMI sink.\n");
+		return;
+	}
+
+	debug("Assigning HDMI sink color depth as %d bpc.\n", dc_bpc);
+	info->bpc = dc_bpc;
+
+	/* YCRCB444 is optional according to spec. */
+	if (hdmi[6] & DRM_EDID_HDMI_DC_Y444) {
+		info->edid_hdmi_dc_modes |= DRM_EDID_HDMI_DC_Y444;
+		debug("HDMI sink does YCRCB444 in deep color.\n");
+	}
+
+	/*
+	 * Spec says that if any deep color mode is supported at all,
+	 * then deep color 36 bit must be supported.
+	 */
+	if (!(hdmi[6] & DRM_EDID_HDMI_DC_36))
+		debug("HDMI sink should do DC_36, but does not!\n");
+}
+
+/*
+ * Search EDID for CEA extension block.
+ */
+static u8 *drm_find_edid_extension(struct edid *edid, int ext_id)
+{
+	u8 *edid_ext = NULL;
+	int i;
+
+	/* No EDID or EDID extensions */
+	if (!edid || !edid->extensions)
+		return NULL;
+
+	/* Find CEA extension */
+	for (i = 0; i < edid->extensions; i++) {
+		edid_ext = (u8 *)edid + EDID_SIZE * (i + 1);
+		if (edid_ext[0] == ext_id)
+			break;
+	}
+
+	if (i == edid->extensions)
+		return NULL;
+
+	return edid_ext;
+}
+
+static u8 *drm_find_cea_extension(struct edid *edid)
+{
+	return drm_find_edid_extension(edid, 0x02);
+}
+
+#define AUDIO_BLOCK	0x01
+#define VIDEO_BLOCK     0x02
+#define VENDOR_BLOCK    0x03
+#define SPEAKER_BLOCK	0x04
+#define EDID_BASIC_AUDIO BIT(6)
+
+/**
+ * drm_detect_hdmi_monitor - detect whether monitor is HDMI
+ * @edid: monitor EDID information
+ *
+ * Parse the CEA extension according to CEA-861-B.
+ *
+ * Return: True if the monitor is HDMI, false if not or unknown.
+ */
+bool drm_detect_hdmi_monitor(struct edid *edid)
+{
+	u8 *edid_ext;
+	int i;
+	int start_offset, end_offset;
+
+	edid_ext = drm_find_cea_extension(edid);
+	if (!edid_ext)
+		return false;
+
+	if (cea_db_offsets(edid_ext, &start_offset, &end_offset))
+		return false;
+
+	/*
+	 * Because HDMI identifier is in Vendor Specific Block,
+	 * search it from all data blocks of CEA extension.
+	 */
+	for_each_cea_db(edid_ext, i, start_offset, end_offset) {
+		if (cea_db_is_hdmi_vsdb(&edid_ext[i]))
+			return true;
+	}
+
+	return false;
+}
+
+/**
+ * drm_detect_monitor_audio - check monitor audio capability
+ * @edid: EDID block to scan
+ *
+ * Monitor should have CEA extension block.
+ * If monitor has 'basic audio', but no CEA audio blocks, it's 'basic
+ * audio' only. If there is any audio extension block and supported
+ * audio format, assume at least 'basic audio' support, even if 'basic
+ * audio' is not defined in EDID.
+ *
+ * Return: True if the monitor supports audio, false otherwise.
+ */
+bool drm_detect_monitor_audio(struct edid *edid)
+{
+	u8 *edid_ext;
+	int i, j;
+	bool has_audio = false;
+	int start_offset, end_offset;
+
+	edid_ext = drm_find_cea_extension(edid);
+	if (!edid_ext)
+		goto end;
+
+	has_audio = ((edid_ext[3] & EDID_BASIC_AUDIO) != 0);
+
+	if (has_audio) {
+		printf("Monitor has basic audio support\n");
+		goto end;
+	}
+
+	if (cea_db_offsets(edid_ext, &start_offset, &end_offset))
+		goto end;
+
+	for_each_cea_db(edid_ext, i, start_offset, end_offset) {
+		if (cea_db_tag(&edid_ext[i]) == AUDIO_BLOCK) {
+			has_audio = true;
+			for (j = 1; j < cea_db_payload_len(&edid_ext[i]) + 1;
+			     j += 3)
+				debug("CEA audio format %d\n",
+				      (edid_ext[i + j] >> 3) & 0xf);
+			goto end;
+		}
+	}
+end:
+	return has_audio;
+}
+
+static void
+drm_parse_hdmi_vsdb_video(struct hdmi_edid_data *data, const u8 *db)
+{
+	struct drm_display_info *info = &data->display_info;
+	u8 len = cea_db_payload_len(db);
+
+	if (len >= 6)
+		info->dvi_dual = db[6] & 1;
+	if (len >= 7)
+		info->max_tmds_clock = db[7] * 5000;
+
+	drm_parse_hdmi_deep_color_info(data, db);
+}
+
+static void drm_parse_cea_ext(struct hdmi_edid_data *data,
+			      struct edid *edid)
+{
+	struct drm_display_info *info = &data->display_info;
+	const u8 *edid_ext;
+	int i, start, end;
+
+	edid_ext = drm_find_cea_extension(edid);
+	if (!edid_ext)
+		return;
+
+	info->cea_rev = edid_ext[1];
+
+	/* The existence of a CEA block should imply RGB support */
+	info->color_formats = DRM_COLOR_FORMAT_RGB444;
+	if (edid_ext[3] & EDID_CEA_YCRCB444)
+		info->color_formats |= DRM_COLOR_FORMAT_YCRCB444;
+	if (edid_ext[3] & EDID_CEA_YCRCB422)
+		info->color_formats |= DRM_COLOR_FORMAT_YCRCB422;
+
+	if (cea_db_offsets(edid_ext, &start, &end))
+		return;
+
+	for_each_cea_db(edid_ext, i, start, end) {
+		const u8 *db = &edid_ext[i];
+
+		if (cea_db_is_hdmi_vsdb(db))
+			drm_parse_hdmi_vsdb_video(data, db);
+		if (cea_db_is_hdmi_forum_vsdb(db))
+			drm_parse_hdmi_forum_vsdb(data, db);
+		if (cea_db_is_y420cmdb(db))
+			drm_parse_y420cmdb_bitmap(data, db);
+	}
+}
+
+static void drm_add_display_info(struct hdmi_edid_data *data, struct edid *edid)
+{
+	struct drm_display_info *info = &data->display_info;
+
+	info->width_mm = edid->width_cm * 10;
+	info->height_mm = edid->height_cm * 10;
+
+	/* driver figures it out in this case */
+	info->bpc = 0;
+	info->color_formats = 0;
+	info->cea_rev = 0;
+	info->max_tmds_clock = 0;
+	info->dvi_dual = false;
+	info->edid_hdmi_dc_modes = 0;
+
+	memset(&info->hdmi, 0, sizeof(info->hdmi));
+
+	if (edid->revision < 3)
+		return;
+
+	if (!(edid->input & DRM_EDID_INPUT_DIGITAL))
+		return;
+
+	drm_parse_cea_ext(data, edid);
+
+	/*
+	 * Digital sink with "DFP 1.x compliant TMDS" according to EDID 1.3?
+	 *
+	 * For such displays, the DFP spec 1.0, section 3.10 "EDID support"
+	 * tells us to assume 8 bpc color depth if the EDID doesn't have
+	 * extensions which tell otherwise.
+	 */
+	if ((info->bpc == 0) && (edid->revision < 4) &&
+	    (edid->input & DRM_EDID_DIGITAL_TYPE_DVI)) {
+		info->bpc = 8;
+		debug("Assigning DFP sink color depth as %d bpc.\n", info->bpc);
+	}
+
+	/* Only defined for 1.4 with digital displays */
+	if (edid->revision < 4)
+		return;
+
+	switch (edid->input & DRM_EDID_DIGITAL_DEPTH_MASK) {
+	case DRM_EDID_DIGITAL_DEPTH_6:
+		info->bpc = 6;
+		break;
+	case DRM_EDID_DIGITAL_DEPTH_8:
+		info->bpc = 8;
+		break;
+	case DRM_EDID_DIGITAL_DEPTH_10:
+		info->bpc = 10;
+		break;
+	case DRM_EDID_DIGITAL_DEPTH_12:
+		info->bpc = 12;
+		break;
+	case DRM_EDID_DIGITAL_DEPTH_14:
+		info->bpc = 14;
+		break;
+	case DRM_EDID_DIGITAL_DEPTH_16:
+		info->bpc = 16;
+		break;
+	case DRM_EDID_DIGITAL_DEPTH_UNDEF:
+	default:
+		info->bpc = 0;
+		break;
+	}
+
+	debug("Assigning EDID-1.4 digital sink color depth as %d bpc.\n",
+	      info->bpc);
+
+	info->color_formats |= DRM_COLOR_FORMAT_RGB444;
+	if (edid->features & DRM_EDID_FEATURE_RGB_YCRCB444)
+		info->color_formats |= DRM_COLOR_FORMAT_YCRCB444;
+	if (edid->features & DRM_EDID_FEATURE_RGB_YCRCB422)
+		info->color_formats |= DRM_COLOR_FORMAT_YCRCB422;
+}
+
+static
+int add_cea_modes(struct hdmi_edid_data *data, struct edid *edid)
+{
+	const u8 *cea = drm_find_cea_extension(edid);
+	const u8 *db, *hdmi = NULL, *video = NULL;
+	u8 dbl, hdmi_len = 0, video_len = 0;
+	int modes = 0;
+
+	if (cea && cea_revision(cea) >= 3) {
+		int i, start, end;
+
+		if (cea_db_offsets(cea, &start, &end))
+			return 0;
+
+		for_each_cea_db(cea, i, start, end) {
+			db = &cea[i];
+			dbl = cea_db_payload_len(db);
+
+			if (cea_db_tag(db) == EDID_CEA861_DB_VIDEO) {
+				video = db + 1;
+				video_len = dbl;
+				modes += do_cea_modes(data, video, dbl);
+			} else if (cea_db_is_hdmi_vsdb(db)) {
+				hdmi = db;
+				hdmi_len = dbl;
+			} else if (cea_db_is_y420vdb(db)) {
+				const u8 *vdb420 = &db[2];
+
+				/* Add 4:2:0(only) modes present in EDID */
+				modes += do_y420vdb_modes(data, vdb420,
+							  dbl - 1);
+			}
+		}
+	}
+
+	/*
+	 * We parse the HDMI VSDB after having added the cea modes as we will
+	 * be patching their flags when the sink supports stereo 3D.
+	 */
+	if (hdmi)
+		modes += do_hdmi_vsdb_modes(hdmi, hdmi_len, video,
+					    video_len, data);
+
+	return modes;
+}
+
+typedef void detailed_cb(struct detailed_timing *timing, void *closure);
+
+static void
+cea_for_each_detailed_block(u8 *ext, detailed_cb *cb, void *closure)
+{
+	int i, n = 0;
+	u8 d = ext[0x02];
+	u8 *det_base = ext + d;
+
+	if (d < 4 || d > 127)
+		return;
+
+	n = (127 - d) / 18;
+	for (i = 0; i < n; i++)
+		cb((struct detailed_timing *)(det_base + 18 * i), closure);
+}
+
+static void
+vtb_for_each_detailed_block(u8 *ext, detailed_cb *cb, void *closure)
+{
+	unsigned int i, n = min((int)ext[0x02], 6);
+	u8 *det_base = ext + 5;
+
+	if (ext[0x01] != 1)
+		return; /* unknown version */
+
+	for (i = 0; i < n; i++)
+		cb((struct detailed_timing *)(det_base + 18 * i), closure);
+}
+
+static void
+drm_for_each_detailed_block(u8 *raw_edid, detailed_cb *cb, void *closure)
+{
+	int i;
+	struct edid *edid = (struct edid *)raw_edid;
+
+	if (!edid)
+		return;
+
+	for (i = 0; i < EDID_DETAILED_TIMINGS; i++)
+		cb(&edid->detailed_timings[i], closure);
+
+	for (i = 1; i <= raw_edid[0x7e]; i++) {
+		u8 *ext = raw_edid + (i * EDID_SIZE);
+
+		switch (*ext) {
+		case CEA_EXT:
+			cea_for_each_detailed_block(ext, cb, closure);
+			break;
+		case VTB_EXT:
+			vtb_for_each_detailed_block(ext, cb, closure);
+			break;
+		default:
+			break;
+		}
+	}
+}
+
+/*
+ * EDID is delightfully ambiguous about how interlaced modes are to be
+ * encoded.  Our internal representation is of frame height, but some
+ * HDTV detailed timings are encoded as field height.
+ *
+ * The format list here is from CEA, in frame size.  Technically we
+ * should be checking refresh rate too.  Whatever.
+ */
+static void
+drm_mode_do_interlace_quirk(struct drm_display_mode *mode,
+			    struct detailed_pixel_timing *pt)
+{
+	int i;
+
+	static const struct {
+		int w, h;
+	} cea_interlaced[] = {
+		{ 1920, 1080 },
+		{  720,  480 },
+		{ 1440,  480 },
+		{ 2880,  480 },
+		{  720,  576 },
+		{ 1440,  576 },
+		{ 2880,  576 },
+	};
+
+	if (!(pt->misc & DRM_EDID_PT_INTERLACED))
+		return;
+
+	for (i = 0; i < ARRAY_SIZE(cea_interlaced); i++) {
+		if ((mode->hdisplay == cea_interlaced[i].w) &&
+		    (mode->vdisplay == cea_interlaced[i].h / 2)) {
+			mode->vdisplay *= 2;
+			mode->vsync_start *= 2;
+			mode->vsync_end *= 2;
+			mode->vtotal *= 2;
+			mode->vtotal |= 1;
+		}
+	}
+
+	mode->flags |= DRM_MODE_FLAG_INTERLACE;
+}
+
+/**
+ * drm_mode_detailed - create a new mode from an EDID detailed timing section
+ * @edid: EDID block
+ * @timing: EDID detailed timing info
+ * @quirks: quirks to apply
+ *
+ * An EDID detailed timing block contains enough info for us to create and
+ * return a new struct drm_display_mode.
+ */
+static
+struct drm_display_mode *drm_mode_detailed(struct edid *edid,
+					   struct detailed_timing *timing,
+					   u32 quirks)
+{
+	struct drm_display_mode *mode;
+	struct detailed_pixel_timing *pt = &timing->data.pixel_data;
+	unsigned hactive = (pt->hactive_hblank_hi & 0xf0) << 4 | pt->hactive_lo;
+	unsigned vactive = (pt->vactive_vblank_hi & 0xf0) << 4 | pt->vactive_lo;
+	unsigned hblank = (pt->hactive_hblank_hi & 0xf) << 8 | pt->hblank_lo;
+	unsigned vblank = (pt->vactive_vblank_hi & 0xf) << 8 | pt->vblank_lo;
+	unsigned hsync_offset =
+		(pt->hsync_vsync_offset_pulse_width_hi & 0xc0) << 2 |
+		pt->hsync_offset_lo;
+	unsigned hsync_pulse_width =
+		(pt->hsync_vsync_offset_pulse_width_hi & 0x30) << 4 |
+		pt->hsync_pulse_width_lo;
+	unsigned vsync_offset = (pt->hsync_vsync_offset_pulse_width_hi & 0xc) <<
+		2 | pt->vsync_offset_pulse_width_lo >> 4;
+	unsigned vsync_pulse_width =
+		(pt->hsync_vsync_offset_pulse_width_hi & 0x3) << 4 |
+		(pt->vsync_offset_pulse_width_lo & 0xf);
+
+	/* ignore tiny modes */
+	if (hactive < 64 || vactive < 64)
+		return NULL;
+
+	if (pt->misc & DRM_EDID_PT_STEREO) {
+		debug("stereo mode not supported\n");
+		return NULL;
+	}
+	if (!(pt->misc & DRM_EDID_PT_SEPARATE_SYNC))
+		debug("composite sync not supported\n");
+
+	/* it is incorrect if hsync/vsync width is zero */
+	if (!hsync_pulse_width || !vsync_pulse_width) {
+		debug("Incorrect Detailed timing. ");
+		debug("Wrong Hsync/Vsync pulse width\n");
+		return NULL;
+	}
+
+	if (quirks & EDID_QUIRK_FORCE_REDUCED_BLANKING) {
+		mode = drm_cvt_mode(hactive, vactive, 60, true, false, false);
+		if (!mode)
+			return NULL;
+
+		goto set_refresh;
+	}
+
+	mode = drm_mode_create();
+	if (!mode)
+		return NULL;
+
+	if (quirks & EDID_QUIRK_135_CLOCK_TOO_HIGH)
+		timing->pixel_clock = cpu_to_le16(1088);
+
+	mode->clock = le16_to_cpu(timing->pixel_clock) * 10;
+
+	mode->hdisplay = hactive;
+	mode->hsync_start = mode->hdisplay + hsync_offset;
+	mode->hsync_end = mode->hsync_start + hsync_pulse_width;
+	mode->htotal = mode->hdisplay + hblank;
+
+	mode->vdisplay = vactive;
+	mode->vsync_start = mode->vdisplay + vsync_offset;
+	mode->vsync_end = mode->vsync_start + vsync_pulse_width;
+	mode->vtotal = mode->vdisplay + vblank;
+
+	/* Some EDIDs have bogus h/vtotal values */
+	if (mode->hsync_end > mode->htotal)
+		mode->htotal = mode->hsync_end + 1;
+	if (mode->vsync_end > mode->vtotal)
+		mode->vtotal = mode->vsync_end + 1;
+
+	drm_mode_do_interlace_quirk(mode, pt);
+
+	if (quirks & EDID_QUIRK_DETAILED_SYNC_PP)
+		pt->misc |= DRM_EDID_PT_HSYNC_POSITIVE |
+			DRM_EDID_PT_VSYNC_POSITIVE;
+
+	mode->flags |= (pt->misc & DRM_EDID_PT_HSYNC_POSITIVE) ?
+		DRM_MODE_FLAG_PHSYNC : DRM_MODE_FLAG_NHSYNC;
+	mode->flags |= (pt->misc & DRM_EDID_PT_VSYNC_POSITIVE) ?
+		DRM_MODE_FLAG_PVSYNC : DRM_MODE_FLAG_NVSYNC;
+
+set_refresh:
+
+	mode->type = DRM_MODE_TYPE_DRIVER;
+	mode->vrefresh = drm_get_vrefresh(mode);
+
+	return mode;
+}
+
+/*
+ * Calculate the alternate clock for the CEA mode
+ * (60Hz vs. 59.94Hz etc.)
+ */
+static unsigned int
+cea_mode_alternate_clock(const struct drm_display_mode *cea_mode)
+{
+	unsigned int clock = cea_mode->clock;
+
+	if (cea_mode->vrefresh % 6 != 0)
+		return clock;
+
+	/*
+	 * edid_cea_modes contains the 59.94Hz
+	 * variant for 240 and 480 line modes,
+	 * and the 60Hz variant otherwise.
+	 */
+	if (cea_mode->vdisplay == 240 || cea_mode->vdisplay == 480)
+		clock = DIV_ROUND_CLOSEST(clock * 1001, 1000);
+	else
+		clock = DIV_ROUND_CLOSEST(clock * 1000, 1001);
+
+	return clock;
+}
+
+/**
+ * drm_mode_equal_no_clocks_no_stereo - test modes for equality
+ * @mode1: first mode
+ * @mode2: second mode
+ *
+ * Check to see if @mode1 and @mode2 are equivalent, but
+ * don't check the pixel clocks nor the stereo layout.
+ *
+ * Returns:
+ * True if the modes are equal, false otherwise.
+ */
+
+static
+bool drm_mode_equal_no_clocks_no_stereo(const struct drm_display_mode *mode1,
+					const struct drm_display_mode *mode2)
+{
+	unsigned int flags_mask =
+		~(DRM_MODE_FLAG_3D_MASK | DRM_MODE_FLAG_420_MASK);
+
+	if (mode1->hdisplay == mode2->hdisplay &&
+	    mode1->hsync_start == mode2->hsync_start &&
+	    mode1->hsync_end == mode2->hsync_end &&
+	    mode1->htotal == mode2->htotal &&
+	    mode1->vdisplay == mode2->vdisplay &&
+	    mode1->vsync_start == mode2->vsync_start &&
+	    mode1->vsync_end == mode2->vsync_end &&
+	    mode1->vtotal == mode2->vtotal &&
+	    mode1->vscan == mode2->vscan &&
+	    (mode1->flags & flags_mask) == (mode2->flags & flags_mask))
+		return true;
+
+	return false;
+}
+
+/**
+ * drm_mode_equal_no_clocks - test modes for equality
+ * @mode1: first mode
+ * @mode2: second mode
+ *
+ * Check to see if @mode1 and @mode2 are equivalent, but
+ * don't check the pixel clocks.
+ *
+ * Returns:
+ * True if the modes are equal, false otherwise.
+ */
+static bool drm_mode_equal_no_clocks(const struct drm_display_mode *mode1,
+				     const struct drm_display_mode *mode2)
+{
+	if ((mode1->flags & DRM_MODE_FLAG_3D_MASK) !=
+	    (mode2->flags & DRM_MODE_FLAG_3D_MASK))
+		return false;
+
+	return drm_mode_equal_no_clocks_no_stereo(mode1, mode2);
+}
+
+static
+u8 drm_match_cea_mode_clock_tolerance(const struct drm_display_mode *to_match,
+				      unsigned int clock_tolerance)
+{
+	u8 vic;
+
+	if (!to_match->clock)
+		return 0;
+
+	for (vic = 1; vic < cea_num_vics(); vic = cea_next_vic(vic)) {
+		const struct drm_display_mode *cea_mode = cea_mode_for_vic(vic);
+		unsigned int clock1, clock2;
+
+		/* Check both 60Hz and 59.94Hz */
+		clock1 = cea_mode->clock;
+		clock2 = cea_mode_alternate_clock(cea_mode);
+
+		if (abs(to_match->clock - clock1) > clock_tolerance &&
+		    abs(to_match->clock - clock2) > clock_tolerance)
+			continue;
+
+		if (drm_mode_equal_no_clocks(to_match, cea_mode))
+			return vic;
+	}
+
+	return 0;
+}
+
+static unsigned int
+hdmi_mode_alternate_clock(const struct drm_display_mode *hdmi_mode)
+{
+	if (hdmi_mode->vdisplay == 4096 && hdmi_mode->hdisplay == 2160)
+		return hdmi_mode->clock;
+
+	return cea_mode_alternate_clock(hdmi_mode);
+}
+
+static
+u8 drm_match_hdmi_mode_clock_tolerance(const struct drm_display_mode *to_match,
+				       unsigned int clock_tolerance)
+{
+	u8 vic;
+
+	if (!to_match->clock)
+		return 0;
+
+	for (vic = 1; vic < ARRAY_SIZE(edid_4k_modes); vic++) {
+		const struct drm_display_mode *hdmi_mode = &edid_4k_modes[vic];
+		unsigned int clock1, clock2;
+
+		/* Make sure to also match alternate clocks */
+		clock1 = hdmi_mode->clock;
+		clock2 = hdmi_mode_alternate_clock(hdmi_mode);
+
+		if (abs(to_match->clock - clock1) > clock_tolerance &&
+		    abs(to_match->clock - clock2) > clock_tolerance)
+			continue;
+
+		if (drm_mode_equal_no_clocks(to_match, hdmi_mode))
+			return vic;
+	}
+
+	return 0;
+}
+
+static void fixup_detailed_cea_mode_clock(struct drm_display_mode *mode)
+{
+	const struct drm_display_mode *cea_mode;
+	int clock1, clock2, clock;
+	u8 vic;
+	const char *type;
+
+	/*
+	 * allow 5kHz clock difference either way to account for
+	 * the 10kHz clock resolution limit of detailed timings.
+	 */
+	vic = drm_match_cea_mode_clock_tolerance(mode, 5);
+	if (drm_valid_cea_vic(vic)) {
+		type = "CEA";
+		cea_mode = cea_mode_for_vic(vic);
+		clock1 = cea_mode->clock;
+		clock2 = cea_mode_alternate_clock(cea_mode);
+	} else {
+		vic = drm_match_hdmi_mode_clock_tolerance(mode, 5);
+		if (drm_valid_hdmi_vic(vic)) {
+			type = "HDMI";
+			cea_mode = &edid_4k_modes[vic];
+			clock1 = cea_mode->clock;
+			clock2 = hdmi_mode_alternate_clock(cea_mode);
+		} else {
+			return;
+		}
+	}
+
+	/* pick whichever is closest */
+	if (abs(mode->clock - clock1) < abs(mode->clock - clock2))
+		clock = clock1;
+	else
+		clock = clock2;
+
+	if (mode->clock == clock)
+		return;
+
+	debug("detailed mode matches %s VIC %d, adjusting clock %d -> %d\n",
+	      type, vic, mode->clock, clock);
+	mode->clock = clock;
+}
+
+static void
+do_detailed_mode(struct detailed_timing *timing, void *c)
+{
+	struct detailed_mode_closure *closure = c;
+	struct drm_display_mode *newmode;
+
+	if (timing->pixel_clock) {
+		newmode = drm_mode_detailed(
+					    closure->edid, timing,
+					    closure->quirks);
+		if (!newmode)
+			return;
+
+		if (closure->preferred)
+			newmode->type |= DRM_MODE_TYPE_PREFERRED;
+
+		/*
+		 * Detailed modes are limited to 10kHz pixel clock resolution,
+		 * so fix up anything that looks like CEA/HDMI mode,
+		 * but the clock is just slightly off.
+		 */
+		fixup_detailed_cea_mode_clock(newmode);
+		drm_add_hdmi_modes(closure->data, newmode);
+		drm_mode_destroy(newmode);
+		closure->modes++;
+		closure->preferred = 0;
+	}
+}
+
+/*
+ * add_detailed_modes - Add modes from detailed timings
+ * @data: attached data
+ * @edid: EDID block to scan
+ * @quirks: quirks to apply
+ */
+static int
+add_detailed_modes(struct hdmi_edid_data *data, struct edid *edid,
+		   u32 quirks)
+{
+	struct detailed_mode_closure closure = {
+		.data = data,
+		.edid = edid,
+		.preferred = 1,
+		.quirks = quirks,
+	};
+
+	if (closure.preferred && !version_greater(edid, 1, 3))
+		closure.preferred =
+			(edid->features & DRM_EDID_FEATURE_PREFERRED_TIMING);
+
+	drm_for_each_detailed_block((u8 *)edid, do_detailed_mode, &closure);
+
+	return closure.modes;
+}
+
+static int drm_cvt_modes(struct hdmi_edid_data *data,
+			 struct detailed_timing *timing)
+{
+	int i, j, modes = 0;
+	struct drm_display_mode *newmode;
+	struct cvt_timing *cvt;
+	const int rates[] = { 60, 85, 75, 60, 50 };
+	const u8 empty[3] = { 0, 0, 0 };
+
+	for (i = 0; i < 4; i++) {
+		int uninitialized_var(width), height;
+
+		cvt = &timing->data.other_data.data.cvt[i];
+
+		if (!memcmp(cvt->code, empty, 3))
+			continue;
+
+		height = (cvt->code[0] + ((cvt->code[1] & 0xf0) << 4) + 1) * 2;
+		switch (cvt->code[1] & 0x0c) {
+		case 0x00:
+			width = height * 4 / 3;
+			break;
+		case 0x04:
+			width = height * 16 / 9;
+			break;
+		case 0x08:
+			width = height * 16 / 10;
+			break;
+		case 0x0c:
+			width = height * 15 / 9;
+			break;
+		}
+
+		for (j = 1; j < 5; j++) {
+			if (cvt->code[2] & (1 << j)) {
+				newmode = drm_cvt_mode(width, height,
+						       rates[j], j == 0,
+						       false, false);
+				if (newmode) {
+					drm_add_hdmi_modes(data, newmode);
+					modes++;
+					drm_mode_destroy(newmode);
+				}
+			}
+		}
+	}
+
+	return modes;
+}
+
+static void
+do_cvt_mode(struct detailed_timing *timing, void *c)
+{
+	struct detailed_mode_closure *closure = c;
+	struct detailed_non_pixel *data = &timing->data.other_data;
+
+	if (data->type == EDID_DETAIL_CVT_3BYTE)
+		closure->modes += drm_cvt_modes(closure->data, timing);
+}
+
+static int
+add_cvt_modes(struct hdmi_edid_data *data, struct edid *edid)
+{
+	struct detailed_mode_closure closure = {
+		.data = data,
+		.edid = edid,
+	};
+
+	if (version_greater(edid, 1, 2))
+		drm_for_each_detailed_block((u8 *)edid, do_cvt_mode, &closure);
+
+	/* XXX should also look for CVT codes in VTB blocks */
+
+	return closure.modes;
+}
+
+static void
+find_gtf2(struct detailed_timing *t, void *data)
+{
+	u8 *r = (u8 *)t;
+
+	if (r[3] == EDID_DETAIL_MONITOR_RANGE && r[10] == 0x02)
+		*(u8 **)data = r;
+}
+
+/* Secondary GTF curve kicks in above some break frequency */
+static int
+drm_gtf2_hbreak(struct edid *edid)
+{
+	u8 *r = NULL;
+
+	drm_for_each_detailed_block((u8 *)edid, find_gtf2, &r);
+	return r ? (r[12] * 2) : 0;
+}
+
+static int
+drm_gtf2_2c(struct edid *edid)
+{
+	u8 *r = NULL;
+
+	drm_for_each_detailed_block((u8 *)edid, find_gtf2, &r);
+	return r ? r[13] : 0;
+}
+
+static int
+drm_gtf2_m(struct edid *edid)
+{
+	u8 *r = NULL;
+
+	drm_for_each_detailed_block((u8 *)edid, find_gtf2, &r);
+	return r ? (r[15] << 8) + r[14] : 0;
+}
+
+static int
+drm_gtf2_k(struct edid *edid)
+{
+	u8 *r = NULL;
+
+	drm_for_each_detailed_block((u8 *)edid, find_gtf2, &r);
+	return r ? r[16] : 0;
+}
+
+static int
+drm_gtf2_2j(struct edid *edid)
+{
+	u8 *r = NULL;
+
+	drm_for_each_detailed_block((u8 *)edid, find_gtf2, &r);
+	return r ? r[17] : 0;
+}
+
+/**
+ * standard_timing_level - get std. timing level(CVT/GTF/DMT)
+ * @edid: EDID block to scan
+ */
+static int standard_timing_level(struct edid *edid)
+{
+	if (edid->revision >= 2) {
+		if (edid->revision >= 4 &&
+		    (edid->features & DRM_EDID_FEATURE_DEFAULT_GTF))
+			return LEVEL_CVT;
+		if (drm_gtf2_hbreak(edid))
+			return LEVEL_GTF2;
+		return LEVEL_GTF;
+	}
+	return LEVEL_DMT;
+}
+
+/*
+ * 0 is reserved.  The spec says 0x01 fill for unused timings.  Some old
+ * monitors fill with ascii space (0x20) instead.
+ */
+static int
+bad_std_timing(u8 a, u8 b)
+{
+	return (a == 0x00 && b == 0x00) ||
+	       (a == 0x01 && b == 0x01) ||
+	       (a == 0x20 && b == 0x20);
+}
+
+static void
+is_rb(struct detailed_timing *t, void *data)
+{
+	u8 *r = (u8 *)t;
+
+	if (r[3] == EDID_DETAIL_MONITOR_RANGE)
+		if (r[15] & 0x10)
+			*(bool *)data = true;
+}
+
+/* EDID 1.4 defines this explicitly.  For EDID 1.3, we guess, badly. */
+static bool
+drm_monitor_supports_rb(struct edid *edid)
+{
+	if (edid->revision >= 4) {
+		bool ret = false;
+
+		drm_for_each_detailed_block((u8 *)edid, is_rb, &ret);
+		return ret;
+	}
+
+	return ((edid->input & DRM_EDID_INPUT_DIGITAL) != 0);
+}
+
+static bool
+mode_is_rb(const struct drm_display_mode *mode)
+{
+	return (mode->htotal - mode->hdisplay == 160) &&
+	       (mode->hsync_end - mode->hdisplay == 80) &&
+	       (mode->hsync_end - mode->hsync_start == 32) &&
+	       (mode->vsync_start - mode->vdisplay == 3);
+}
+
+/*
+ * drm_mode_find_dmt - Create a copy of a mode if present in DMT
+ * @hsize: Mode width
+ * @vsize: Mode height
+ * @fresh: Mode refresh rate
+ * @rb: Mode reduced-blanking-ness
+ *
+ * Walk the DMT mode list looking for a match for the given parameters.
+ *
+ * Return: A newly allocated copy of the mode, or NULL if not found.
+ */
+static struct drm_display_mode *drm_mode_find_dmt(
+					   int hsize, int vsize, int fresh,
+					   bool rb)
+{
+	int i;
+	struct drm_display_mode *newmode;
+
+	for (i = 0; i < ARRAY_SIZE(drm_dmt_modes); i++) {
+		const struct drm_display_mode *ptr = &drm_dmt_modes[i];
+
+		if (hsize != ptr->hdisplay)
+			continue;
+		if (vsize != ptr->vdisplay)
+			continue;
+		if (fresh != drm_get_vrefresh(ptr))
+			continue;
+		if (rb != mode_is_rb(ptr))
+			continue;
+
+		newmode = drm_mode_create();
+		*newmode = *ptr;
+		return newmode;
+	}
+
+	return NULL;
+}
+
+static struct drm_display_mode *
+drm_gtf_mode_complex(int hdisplay, int vdisplay,
+		     int vrefresh, bool interlaced, int margins,
+		     int GTF_M, int GTF_2C, int GTF_K, int GTF_2J)
+{	/* 1) top/bottom margin size (% of height) - default: 1.8, */
+#define	GTF_MARGIN_PERCENTAGE		18
+	/* 2) character cell horizontal granularity (pixels) - default 8 */
+#define	GTF_CELL_GRAN			8
+	/* 3) Minimum vertical porch (lines) - default 3 */
+#define	GTF_MIN_V_PORCH			1
+	/* width of vsync in lines */
+#define V_SYNC_RQD			3
+	/* width of hsync as % of total line */
+#define H_SYNC_PERCENT			8
+	/* min time of vsync + back porch (microsec) */
+#define MIN_VSYNC_PLUS_BP		550
+	/* C' and M' are part of the Blanking Duty Cycle computation */
+#define GTF_C_PRIME	((((GTF_2C - GTF_2J) * GTF_K / 256) + GTF_2J) / 2)
+#define GTF_M_PRIME	(GTF_K * GTF_M / 256)
+	struct drm_display_mode *drm_mode;
+	unsigned int hdisplay_rnd, vdisplay_rnd, vfieldrate_rqd;
+	int top_margin, bottom_margin;
+	int interlace;
+	unsigned int hfreq_est;
+	int vsync_plus_bp;
+	unsigned int vtotal_lines;
+	int left_margin, right_margin;
+	unsigned int total_active_pixels, ideal_duty_cycle;
+	unsigned int hblank, total_pixels, pixel_freq;
+	int hsync, hfront_porch, vodd_front_porch_lines;
+	unsigned int tmp1, tmp2;
+
+	drm_mode = drm_mode_create();
+	if (!drm_mode)
+		return NULL;
+
+	/* 1. In order to give correct results, the number of horizontal
+	 * pixels requested is first processed to ensure that it is divisible
+	 * by the character size, by rounding it to the nearest character
+	 * cell boundary:
+	 */
+	hdisplay_rnd = (hdisplay + GTF_CELL_GRAN / 2) / GTF_CELL_GRAN;
+	hdisplay_rnd = hdisplay_rnd * GTF_CELL_GRAN;
+
+	/* 2. If interlace is requested, the number of vertical lines assumed
+	 * by the calculation must be halved, as the computation calculates
+	 * the number of vertical lines per field.
+	 */
+	if (interlaced)
+		vdisplay_rnd = vdisplay / 2;
+	else
+		vdisplay_rnd = vdisplay;
+
+	/* 3. Find the frame rate required: */
+	if (interlaced)
+		vfieldrate_rqd = vrefresh * 2;
+	else
+		vfieldrate_rqd = vrefresh;
+
+	/* 4. Find number of lines in Top margin: */
+	top_margin = 0;
+	if (margins)
+		top_margin = (vdisplay_rnd * GTF_MARGIN_PERCENTAGE + 500) /
+				1000;
+	/* 5. Find number of lines in bottom margin: */
+	bottom_margin = top_margin;
+
+	/* 6. If interlace is required, then set variable interlace: */
+	if (interlaced)
+		interlace = 1;
+	else
+		interlace = 0;
+
+	/* 7. Estimate the Horizontal frequency */
+	{
+		tmp1 = (1000000  - MIN_VSYNC_PLUS_BP * vfieldrate_rqd) / 500;
+		tmp2 = (vdisplay_rnd + 2 * top_margin + GTF_MIN_V_PORCH) *
+				2 + interlace;
+		hfreq_est = (tmp2 * 1000 * vfieldrate_rqd) / tmp1;
+	}
+
+	/* 8. Find the number of lines in V sync + back porch */
+	/* [V SYNC+BP] = RINT(([MIN VSYNC+BP] * hfreq_est / 1000000)) */
+	vsync_plus_bp = MIN_VSYNC_PLUS_BP * hfreq_est / 1000;
+	vsync_plus_bp = (vsync_plus_bp + 500) / 1000;
+	/*  9. Find the number of lines in V back porch alone:
+	 *	vback_porch = vsync_plus_bp - V_SYNC_RQD;
+	 */
+	/*  10. Find the total number of lines in Vertical field period: */
+	vtotal_lines = vdisplay_rnd + top_margin + bottom_margin +
+			vsync_plus_bp + GTF_MIN_V_PORCH;
+	/*  11. Estimate the Vertical field frequency:
+	 *  vfieldrate_est = hfreq_est / vtotal_lines;
+	 */
+
+	/*  12. Find the actual horizontal period:
+	 *	hperiod = 1000000 / (vfieldrate_rqd * vtotal_lines);
+	 */
+	/*  13. Find the actual Vertical field frequency:
+	 *	vfield_rate = hfreq_est / vtotal_lines;
+	 */
+	/*  14. Find the Vertical frame frequency:
+	 *	if (interlaced)
+	 *		vframe_rate = vfield_rate / 2;
+	 *	else
+	 *		vframe_rate = vfield_rate;
+	 */
+	/*  15. Find number of pixels in left margin: */
+	if (margins)
+		left_margin = (hdisplay_rnd * GTF_MARGIN_PERCENTAGE + 500) /
+				1000;
+	else
+		left_margin = 0;
+
+	/* 16.Find number of pixels in right margin: */
+	right_margin = left_margin;
+	/* 17.Find total number of active pixels in image and left and right */
+	total_active_pixels = hdisplay_rnd + left_margin + right_margin;
+	/* 18.Find the ideal blanking duty cycle from blanking duty cycle */
+	ideal_duty_cycle = GTF_C_PRIME * 1000 -
+				(GTF_M_PRIME * 1000000 / hfreq_est);
+	/* 19.Find the number of pixels in the blanking time to the nearest
+	 * double character cell:
+	 */
+	hblank = total_active_pixels * ideal_duty_cycle /
+			(100000 - ideal_duty_cycle);
+	hblank = (hblank + GTF_CELL_GRAN) / (2 * GTF_CELL_GRAN);
+	hblank = hblank * 2 * GTF_CELL_GRAN;
+	/* 20.Find total number of pixels: */
+	total_pixels = total_active_pixels + hblank;
+	/* 21.Find pixel clock frequency: */
+	pixel_freq = total_pixels * hfreq_est / 1000;
+	/* Stage 1 computations are now complete; I should really pass
+	 * the results to another function and do the Stage 2 computations,
+	 * but I only need a few more values so I'll just append the
+	 * computations here for now
+	 */
+
+	/* 17. Find the number of pixels in the horizontal sync period: */
+	hsync = H_SYNC_PERCENT * total_pixels / 100;
+	hsync = (hsync + GTF_CELL_GRAN / 2) / GTF_CELL_GRAN;
+	hsync = hsync * GTF_CELL_GRAN;
+	/* 18. Find the number of pixels in horizontal front porch period */
+	hfront_porch = hblank / 2 - hsync;
+	/*  36. Find the number of lines in the odd front porch period: */
+	vodd_front_porch_lines = GTF_MIN_V_PORCH;
+
+	/* finally, pack the results in the mode struct */
+	drm_mode->hdisplay = hdisplay_rnd;
+	drm_mode->hsync_start = hdisplay_rnd + hfront_porch;
+	drm_mode->hsync_end = drm_mode->hsync_start + hsync;
+	drm_mode->htotal = total_pixels;
+	drm_mode->vdisplay = vdisplay_rnd;
+	drm_mode->vsync_start = vdisplay_rnd + vodd_front_porch_lines;
+	drm_mode->vsync_end = drm_mode->vsync_start + V_SYNC_RQD;
+	drm_mode->vtotal = vtotal_lines;
+
+	drm_mode->clock = pixel_freq;
+
+	if (interlaced) {
+		drm_mode->vtotal *= 2;
+		drm_mode->flags |= DRM_MODE_FLAG_INTERLACE;
+	}
+
+	if (GTF_M == 600 && GTF_2C == 80 && GTF_K == 128 && GTF_2J == 40)
+		drm_mode->flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC;
+	else
+		drm_mode->flags = DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC;
+
+	return drm_mode;
+}
+
+/**
+ * drm_gtf_mode - create the mode based on the GTF algorithm
+ * @hdisplay: hdisplay size
+ * @vdisplay: vdisplay size
+ * @vrefresh: vrefresh rate.
+ * @interlaced: whether to compute an interlaced mode
+ * @margins: desired margin (borders) size
+ *
+ * return the mode based on GTF algorithm
+ *
+ * This function is to create the mode based on the GTF algorithm.
+ * Generalized Timing Formula is derived from:
+ *	GTF Spreadsheet by Andy Morrish (1/5/97)
+ *	available at http://www.vesa.org
+ *
+ * And it is copied from the file of xserver/hw/xfree86/modes/xf86gtf.c.
+ * What I have done is to translate it by using integer calculation.
+ * I also refer to the function of fb_get_mode in the file of
+ * drivers/video/fbmon.c
+ *
+ * Standard GTF parameters:
+ * M = 600
+ * C = 40
+ * K = 128
+ * J = 20
+ *
+ * Returns:
+ * The modeline based on the GTF algorithm stored in a drm_display_mode object.
+ * The display mode object is allocated with drm_mode_create(). Returns NULL
+ * when no mode could be allocated.
+ */
+static struct drm_display_mode *
+drm_gtf_mode(int hdisplay, int vdisplay, int vrefresh,
+	     bool interlaced, int margins)
+{
+	return drm_gtf_mode_complex(hdisplay, vdisplay, vrefresh,
+				    interlaced, margins,
+				    600, 40 * 2, 128, 20 * 2);
+}
+
+/** drm_mode_hsync - get the hsync of a mode
+ * @mode: mode
+ *
+ * Returns:
+ * @modes's hsync rate in kHz, rounded to the nearest integer. Calculates the
+ * value first if it is not yet set.
+ */
+static int drm_mode_hsync(const struct drm_display_mode *mode)
+{
+	unsigned int calc_val;
+
+	if (mode->htotal < 0)
+		return 0;
+
+	calc_val = (mode->clock * 1000) / mode->htotal; /* hsync in Hz */
+	calc_val += 500;				/* round to 1000Hz */
+	calc_val /= 1000;				/* truncate to kHz */
+
+	return calc_val;
+}
+
+/**
+ * drm_mode_std - convert standard mode info (width, height, refresh) into mode
+ * @data: the structure that save parsed hdmi edid data
+ * @edid: EDID block to scan
+ * @t: standard timing params
+ *
+ * Take the standard timing params (in this case width, aspect, and refresh)
+ * and convert them into a real mode using CVT/GTF/DMT.
+ */
+static struct drm_display_mode *
+drm_mode_std(struct hdmi_edid_data *data, struct edid *edid,
+	     struct std_timing *t)
+{
+	struct drm_display_mode *mode = NULL;
+	int i, hsize, vsize;
+	int vrefresh_rate;
+	int num = data->modes;
+	unsigned aspect_ratio = (t->vfreq_aspect & EDID_TIMING_ASPECT_MASK)
+		>> EDID_TIMING_ASPECT_SHIFT;
+	unsigned vfreq = (t->vfreq_aspect & EDID_TIMING_VFREQ_MASK)
+		>> EDID_TIMING_VFREQ_SHIFT;
+	int timing_level = standard_timing_level(edid);
+
+	if (bad_std_timing(t->hsize, t->vfreq_aspect))
+		return NULL;
+
+	/* According to the EDID spec, the hdisplay = hsize * 8 + 248 */
+	hsize = t->hsize * 8 + 248;
+	/* vrefresh_rate = vfreq + 60 */
+	vrefresh_rate = vfreq + 60;
+	/* the vdisplay is calculated based on the aspect ratio */
+	if (aspect_ratio == 0) {
+		if (edid->revision < 3)
+			vsize = hsize;
+		else
+			vsize = (hsize * 10) / 16;
+	} else if (aspect_ratio == 1) {
+		vsize = (hsize * 3) / 4;
+	} else if (aspect_ratio == 2) {
+		vsize = (hsize * 4) / 5;
+	} else {
+		vsize = (hsize * 9) / 16;
+	}
+
+	/* HDTV hack, part 1 */
+	if (vrefresh_rate == 60 &&
+	    ((hsize == 1360 && vsize == 765) ||
+	     (hsize == 1368 && vsize == 769))) {
+		hsize = 1366;
+		vsize = 768;
+	}
+
+	/*
+	 * If we already has a mode for this size and refresh
+	 * rate (because it came from detailed or CVT info), use that
+	 * instead.  This way we don't have to guess at interlace or
+	 * reduced blanking.
+	 */
+	for (i = 0; i < num; i++)
+		if (data->mode_buf[i].hdisplay == hsize &&
+		    data->mode_buf[i].vdisplay == vsize &&
+		    drm_get_vrefresh(&data->mode_buf[i]) == vrefresh_rate)
+			return NULL;
+
+	/* HDTV hack, part 2 */
+	if (hsize == 1366 && vsize == 768 && vrefresh_rate == 60) {
+		mode = drm_cvt_mode(1366, 768, vrefresh_rate, 0, 0,
+				    false);
+		mode->hdisplay = 1366;
+		mode->hsync_start = mode->hsync_start - 1;
+		mode->hsync_end = mode->hsync_end - 1;
+		return mode;
+	}
+
+	/* check whether it can be found in default mode table */
+	if (drm_monitor_supports_rb(edid)) {
+		mode = drm_mode_find_dmt(hsize, vsize, vrefresh_rate,
+					 true);
+		if (mode)
+			return mode;
+	}
+
+	mode = drm_mode_find_dmt(hsize, vsize, vrefresh_rate, false);
+	if (mode)
+		return mode;
+
+	/* okay, generate it */
+	switch (timing_level) {
+	case LEVEL_DMT:
+		break;
+	case LEVEL_GTF:
+		mode = drm_gtf_mode(hsize, vsize, vrefresh_rate, 0, 0);
+		break;
+	case LEVEL_GTF2:
+		/*
+		 * This is potentially wrong if there's ever a monitor with
+		 * more than one ranges section, each claiming a different
+		 * secondary GTF curve.  Please don't do that.
+		 */
+		mode = drm_gtf_mode(hsize, vsize, vrefresh_rate, 0, 0);
+		if (!mode)
+			return NULL;
+		if (drm_mode_hsync(mode) > drm_gtf2_hbreak(edid)) {
+			drm_mode_destroy(mode);
+			mode = drm_gtf_mode_complex(hsize, vsize,
+						    vrefresh_rate, 0, 0,
+						    drm_gtf2_m(edid),
+						    drm_gtf2_2c(edid),
+						    drm_gtf2_k(edid),
+						    drm_gtf2_2j(edid));
+		}
+		break;
+	case LEVEL_CVT:
+		mode = drm_cvt_mode(hsize, vsize, vrefresh_rate, 0, 0,
+				    false);
+		break;
+	}
+
+	return mode;
+}
+
+static void
+do_standard_modes(struct detailed_timing *timing, void *c)
+{
+	struct detailed_mode_closure *closure = c;
+	struct detailed_non_pixel *data = &timing->data.other_data;
+	struct edid *edid = closure->edid;
+
+	if (data->type == EDID_DETAIL_STD_MODES) {
+		int i;
+
+		for (i = 0; i < 6; i++) {
+			struct std_timing *std;
+			struct drm_display_mode *newmode;
+
+			std = &data->data.timings[i];
+			newmode = drm_mode_std(closure->data, edid, std);
+			if (newmode) {
+				drm_add_hdmi_modes(closure->data, newmode);
+				closure->modes++;
+				drm_mode_destroy(newmode);
+			}
+		}
+	}
+}
+
+/**
+ * add_standard_modes - get std. modes from EDID and add them
+ * @data: data to add mode(s) to
+ * @edid: EDID block to scan
+ *
+ * Standard modes can be calculated using the appropriate standard (DMT,
+ * GTF or CVT. Grab them from @edid and add them to the list.
+ */
+static int
+add_standard_modes(struct hdmi_edid_data *data, struct edid *edid)
+{
+	int i, modes = 0;
+	struct detailed_mode_closure closure = {
+		.data = data,
+		.edid = edid,
+	};
+
+	for (i = 0; i < EDID_STD_TIMINGS; i++) {
+		struct drm_display_mode *newmode;
+
+		newmode = drm_mode_std(data, edid,
+				       &edid->standard_timings[i]);
+		if (newmode) {
+			drm_add_hdmi_modes(data, newmode);
+			modes++;
+			drm_mode_destroy(newmode);
+		}
+	}
+
+	if (version_greater(edid, 1, 0))
+		drm_for_each_detailed_block((u8 *)edid, do_standard_modes,
+					    &closure);
+
+	/* XXX should also look for standard codes in VTB blocks */
+
+	return modes + closure.modes;
+}
+
+static int
+drm_est3_modes(struct hdmi_edid_data *data, struct detailed_timing *timing)
+{
+	int i, j, m, modes = 0;
+	struct drm_display_mode *mode;
+	u8 *est = ((u8 *)timing) + 6;
+
+	for (i = 0; i < 6; i++) {
+		for (j = 7; j >= 0; j--) {
+			m = (i * 8) + (7 - j);
+			if (m >= ARRAY_SIZE(est3_modes))
+				break;
+			if (est[i] & (1 << j)) {
+				mode = drm_mode_find_dmt(
+							 est3_modes[m].w,
+							 est3_modes[m].h,
+							 est3_modes[m].r,
+							 est3_modes[m].rb);
+				if (mode) {
+					drm_add_hdmi_modes(data, mode);
+					modes++;
+					drm_mode_destroy(mode);
+				}
+			}
+		}
+	}
+
+	return modes;
+}
+
+static void
+do_established_modes(struct detailed_timing *timing, void *c)
+{
+	struct detailed_mode_closure *closure = c;
+	struct detailed_non_pixel *data = &timing->data.other_data;
+
+	if (data->type == EDID_DETAIL_EST_TIMINGS)
+		closure->modes += drm_est3_modes(closure->data, timing);
+}
+
+/**
+ * add_established_modes - get est. modes from EDID and add them
+ * @data: data to add mode(s) to
+ * @edid: EDID block to scan
+ *
+ * Each EDID block contains a bitmap of the supported "established modes" list
+ * (defined above).  Tease them out and add them to the modes list.
+ */
+static int
+add_established_modes(struct hdmi_edid_data *data, struct edid *edid)
+{
+	unsigned long est_bits = edid->established_timings.t1 |
+		(edid->established_timings.t2 << 8) |
+		((edid->established_timings.mfg_rsvd & 0x80) << 9);
+	int i, modes = 0;
+	struct detailed_mode_closure closure = {
+		.data = data,
+		.edid = edid,
+	};
+
+	for (i = 0; i <= EDID_EST_TIMINGS; i++) {
+		if (est_bits & (1 << i)) {
+			struct drm_display_mode *newmode = drm_mode_create();
+			*newmode = edid_est_modes[i];
+			if (newmode) {
+				drm_add_hdmi_modes(data, newmode);
+				modes++;
+				drm_mode_destroy(newmode);
+			}
+		}
+	}
+
+	if (version_greater(edid, 1, 0))
+		drm_for_each_detailed_block((u8 *)edid,
+					    do_established_modes, &closure);
+
+	return modes + closure.modes;
+}
+
+static u8 drm_match_hdmi_mode(const struct drm_display_mode *to_match)
+{
+	u8 vic;
+
+	if (!to_match->clock)
+		return 0;
+
+	for (vic = 1; vic < ARRAY_SIZE(edid_4k_modes); vic++) {
+		const struct drm_display_mode *hdmi_mode = &edid_4k_modes[vic];
+		unsigned int clock1, clock2;
+
+		/* Make sure to also match alternate clocks */
+		clock1 = hdmi_mode->clock;
+		clock2 = hdmi_mode_alternate_clock(hdmi_mode);
+
+		if ((KHZ2PICOS(to_match->clock) == KHZ2PICOS(clock1) ||
+		     KHZ2PICOS(to_match->clock) == KHZ2PICOS(clock2)) &&
+		    drm_mode_equal_no_clocks_no_stereo(to_match, hdmi_mode))
+			return vic;
+	}
+	return 0;
+}
+
+static int
+add_alternate_cea_modes(struct hdmi_edid_data *data, struct edid *edid)
+{
+	struct drm_display_mode *mode;
+	int i, num, modes = 0;
+
+	/* Don't add CEA modes if the CEA extension block is missing */
+	if (!drm_find_cea_extension(edid))
+		return 0;
+
+	/*
+	 * Go through all probed modes and create a new mode
+	 * with the alternate clock for certain CEA modes.
+	 */
+	num = data->modes;
+
+	for (i = 0; i < num; i++) {
+		const struct drm_display_mode *cea_mode = NULL;
+		struct drm_display_mode *newmode;
+		u8 vic;
+		unsigned int clock1, clock2;
+
+		mode = &data->mode_buf[i];
+		vic = drm_match_cea_mode(mode);
+
+		if (drm_valid_cea_vic(vic)) {
+			cea_mode = cea_mode_for_vic(vic);
+			clock2 = cea_mode_alternate_clock(cea_mode);
+		} else {
+			vic = drm_match_hdmi_mode(mode);
+			if (drm_valid_hdmi_vic(vic)) {
+				cea_mode = &edid_4k_modes[vic];
+				clock2 = hdmi_mode_alternate_clock(cea_mode);
+			}
+		}
+
+		if (!cea_mode)
+			continue;
+
+		clock1 = cea_mode->clock;
+
+		if (clock1 == clock2)
+			continue;
+
+		if (mode->clock != clock1 && mode->clock != clock2)
+			continue;
+
+		newmode = drm_mode_create();
+		*newmode = *cea_mode;
+		if (!newmode)
+			continue;
+
+		/* Carry over the stereo flags */
+		newmode->flags |= mode->flags & DRM_MODE_FLAG_3D_MASK;
+
+		/*
+		 * The current mode could be either variant. Make
+		 * sure to pick the "other" clock for the new mode.
+		 */
+		if (mode->clock != clock1)
+			newmode->clock = clock1;
+		else
+			newmode->clock = clock2;
+
+		drm_add_hdmi_modes(data, newmode);
+		modes++;
+		drm_mode_destroy(newmode);
+	}
+
+	return modes;
+}
+
+static u8 *drm_find_displayid_extension(struct edid *edid)
+{
+	return drm_find_edid_extension(edid, DISPLAYID_EXT);
+}
+
+static int validate_displayid(u8 *displayid, int length, int idx)
+{
+	int i;
+	u8 csum = 0;
+	struct displayid_hdr *base;
+
+	base = (struct displayid_hdr *)&displayid[idx];
+
+	debug("base revision 0x%x, length %d, %d %d\n",
+	      base->rev, base->bytes, base->prod_id, base->ext_count);
+
+	if (base->bytes + 5 > length - idx)
+		return -EINVAL;
+	for (i = idx; i <= base->bytes + 5; i++)
+		csum += displayid[i];
+	if (csum) {
+		debug("DisplayID checksum invalid, remainder is %d\n", csum);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static struct
+drm_display_mode *drm_displayid_detailed(struct displayid_detailed_timings_1
+					      *timings)
+{
+	struct drm_display_mode *mode;
+	unsigned pixel_clock = (timings->pixel_clock[0] |
+				(timings->pixel_clock[1] << 8) |
+				(timings->pixel_clock[2] << 16));
+	unsigned hactive = (timings->hactive[0] | timings->hactive[1] << 8) + 1;
+	unsigned hblank = (timings->hblank[0] | timings->hblank[1] << 8) + 1;
+	unsigned hsync = (timings->hsync[0] |
+		(timings->hsync[1] & 0x7f) << 8) + 1;
+	unsigned hsync_width = (timings->hsw[0] | timings->hsw[1] << 8) + 1;
+	unsigned vactive = (timings->vactive[0] |
+		timings->vactive[1] << 8) + 1;
+	unsigned vblank = (timings->vblank[0] | timings->vblank[1] << 8) + 1;
+	unsigned vsync = (timings->vsync[0] |
+		(timings->vsync[1] & 0x7f) << 8) + 1;
+	unsigned vsync_width = (timings->vsw[0] | timings->vsw[1] << 8) + 1;
+	bool hsync_positive = (timings->hsync[1] >> 7) & 0x1;
+	bool vsync_positive = (timings->vsync[1] >> 7) & 0x1;
+
+	mode = drm_mode_create();
+	if (!mode)
+		return NULL;
+
+	mode->clock = pixel_clock * 10;
+	mode->hdisplay = hactive;
+	mode->hsync_start = mode->hdisplay + hsync;
+	mode->hsync_end = mode->hsync_start + hsync_width;
+	mode->htotal = mode->hdisplay + hblank;
+
+	mode->vdisplay = vactive;
+	mode->vsync_start = mode->vdisplay + vsync;
+	mode->vsync_end = mode->vsync_start + vsync_width;
+	mode->vtotal = mode->vdisplay + vblank;
+
+	mode->flags = 0;
+	mode->flags |=
+		hsync_positive ? DRM_MODE_FLAG_PHSYNC : DRM_MODE_FLAG_NHSYNC;
+	mode->flags |=
+		vsync_positive ? DRM_MODE_FLAG_PVSYNC : DRM_MODE_FLAG_NVSYNC;
+	mode->type = DRM_MODE_TYPE_DRIVER;
+
+	if (timings->flags & 0x80)
+		mode->type |= DRM_MODE_TYPE_PREFERRED;
+	mode->vrefresh = drm_get_vrefresh(mode);
+
+	return mode;
+}
+
+static int add_displayid_detailed_1_modes(struct hdmi_edid_data *data,
+					  struct displayid_block *block)
+{
+	struct displayid_detailed_timing_block *det;
+	int i;
+	int num_timings;
+	struct drm_display_mode *newmode;
+	int num_modes = 0;
+
+	det = (struct displayid_detailed_timing_block *)block;
+	/* blocks must be multiple of 20 bytes length */
+	if (block->num_bytes % 20)
+		return 0;
+
+	num_timings = block->num_bytes / 20;
+	for (i = 0; i < num_timings; i++) {
+		struct displayid_detailed_timings_1 *timings =
+			&det->timings[i];
+
+		newmode = drm_displayid_detailed(timings);
+		if (!newmode)
+			continue;
+
+		drm_add_hdmi_modes(data, newmode);
+		num_modes++;
+		drm_mode_destroy(newmode);
+	}
+	return num_modes;
+}
+
+static int add_displayid_detailed_modes(struct hdmi_edid_data *data,
+					struct edid *edid)
+{
+	u8 *displayid;
+	int ret;
+	int idx = 1;
+	int length = EDID_SIZE;
+	struct displayid_block *block;
+	int num_modes = 0;
+
+	displayid = drm_find_displayid_extension(edid);
+	if (!displayid)
+		return 0;
+
+	ret = validate_displayid(displayid, length, idx);
+	if (ret)
+		return 0;
+
+	idx += sizeof(struct displayid_hdr);
+	while (block = (struct displayid_block *)&displayid[idx],
+	       idx + sizeof(struct displayid_block) <= length &&
+	       idx + sizeof(struct displayid_block) + block->num_bytes <=
+	       length && block->num_bytes > 0) {
+		idx += block->num_bytes + sizeof(struct displayid_block);
+		switch (block->tag) {
+		case DATA_BLOCK_TYPE_1_DETAILED_TIMING:
+			num_modes +=
+				add_displayid_detailed_1_modes(data, block);
+			break;
+		}
+	}
+	return num_modes;
+}
+
+static bool
+mode_in_hsync_range(const struct drm_display_mode *mode,
+		    struct edid *edid, u8 *t)
+{
+	int hsync, hmin, hmax;
+
+	hmin = t[7];
+	if (edid->revision >= 4)
+		hmin += ((t[4] & 0x04) ? 255 : 0);
+	hmax = t[8];
+	if (edid->revision >= 4)
+		hmax += ((t[4] & 0x08) ? 255 : 0);
+	hsync = drm_mode_hsync(mode);
+
+	return (hsync <= hmax && hsync >= hmin);
+}
+
+static bool
+mode_in_vsync_range(const struct drm_display_mode *mode,
+		    struct edid *edid, u8 *t)
+{
+	int vsync, vmin, vmax;
+
+	vmin = t[5];
+	if (edid->revision >= 4)
+		vmin += ((t[4] & 0x01) ? 255 : 0);
+	vmax = t[6];
+	if (edid->revision >= 4)
+		vmax += ((t[4] & 0x02) ? 255 : 0);
+	vsync = drm_get_vrefresh(mode);
+
+	return (vsync <= vmax && vsync >= vmin);
+}
+
+static u32
+range_pixel_clock(struct edid *edid, u8 *t)
+{
+	/* unspecified */
+	if (t[9] == 0 || t[9] == 255)
+		return 0;
+
+	/* 1.4 with CVT support gives us real precision, yay */
+	if (edid->revision >= 4 && t[10] == 0x04)
+		return (t[9] * 10000) - ((t[12] >> 2) * 250);
+
+	/* 1.3 is pathetic, so fuzz up a bit */
+	return t[9] * 10000 + 5001;
+}
+
+static bool
+mode_in_range(const struct drm_display_mode *mode, struct edid *edid,
+	      struct detailed_timing *timing)
+{
+	u32 max_clock;
+	u8 *t = (u8 *)timing;
+
+	if (!mode_in_hsync_range(mode, edid, t))
+		return false;
+
+	if (!mode_in_vsync_range(mode, edid, t))
+		return false;
+
+	max_clock = range_pixel_clock(edid, t);
+	if (max_clock)
+		if (mode->clock > max_clock)
+			return false;
+
+	/* 1.4 max horizontal check */
+	if (edid->revision >= 4 && t[10] == 0x04)
+		if (t[13] && mode->hdisplay > 8 *
+		    (t[13] + (256 * (t[12] & 0x3))))
+			return false;
+
+	if (mode_is_rb(mode) && !drm_monitor_supports_rb(edid))
+		return false;
+
+	return true;
+}
+
+static bool valid_inferred_mode(struct hdmi_edid_data *data,
+				const struct drm_display_mode *mode)
+{
+	const struct drm_display_mode *m;
+	bool ok = false;
+	int i;
+
+	for (i = 0; i < data->modes; i++) {
+		m = &data->mode_buf[i];
+		if (mode->hdisplay == m->hdisplay &&
+		    mode->vdisplay == m->vdisplay &&
+		    drm_get_vrefresh(mode) == drm_get_vrefresh(m))
+			return false; /* duplicated */
+		if (mode->hdisplay <= m->hdisplay &&
+		    mode->vdisplay <= m->vdisplay)
+			ok = true;
+	}
+	return ok;
+}
+
+static int
+drm_dmt_modes_for_range(struct hdmi_edid_data *data, struct edid *edid,
+			struct detailed_timing *timing)
+{
+	int i, modes = 0;
+
+	for (i = 0; i < ARRAY_SIZE(drm_dmt_modes); i++) {
+		if (mode_in_range(drm_dmt_modes + i, edid, timing) &&
+		    valid_inferred_mode(data, drm_dmt_modes + i)) {
+			drm_add_hdmi_modes(data, &drm_dmt_modes[i]);
+			modes++;
+		}
+	}
+
+	return modes;
+}
+
+/* fix up 1366x768 mode from 1368x768;
+ * GFT/CVT can't express 1366 width which isn't dividable by 8
+ */
+static void fixup_mode_1366x768(struct drm_display_mode *mode)
+{
+	if (mode->hdisplay == 1368 && mode->vdisplay == 768) {
+		mode->hdisplay = 1366;
+		mode->hsync_start--;
+		mode->hsync_end--;
+	}
+}
+
+static int
+drm_gtf_modes_for_range(struct hdmi_edid_data *data, struct edid *edid,
+			struct detailed_timing *timing)
+{
+	int i, modes = 0;
+	struct drm_display_mode *newmode;
+
+	for (i = 0; i < ARRAY_SIZE(extra_modes); i++) {
+		const struct minimode *m = &extra_modes[i];
+
+		newmode = drm_gtf_mode(m->w, m->h, m->r, 0, 0);
+		if (!newmode)
+			return modes;
+
+		fixup_mode_1366x768(newmode);
+		if (!mode_in_range(newmode, edid, timing) ||
+		    !valid_inferred_mode(data, newmode)) {
+			drm_mode_destroy(newmode);
+			continue;
+		}
+
+		drm_add_hdmi_modes(data, newmode);
+		modes++;
+		drm_mode_destroy(newmode);
+	}
+
+	return modes;
+}
+
+static int
+drm_cvt_modes_for_range(struct hdmi_edid_data *data, struct edid *edid,
+			struct detailed_timing *timing)
+{
+	int i, modes = 0;
+	struct drm_display_mode *newmode;
+	bool rb = drm_monitor_supports_rb(edid);
+
+	for (i = 0; i < ARRAY_SIZE(extra_modes); i++) {
+		const struct minimode *m = &extra_modes[i];
+
+		newmode = drm_cvt_mode(m->w, m->h, m->r, rb, 0, 0);
+		if (!newmode)
+			return modes;
+
+		fixup_mode_1366x768(newmode);
+		if (!mode_in_range(newmode, edid, timing) ||
+		    !valid_inferred_mode(data, newmode)) {
+			drm_mode_destroy(newmode);
+			continue;
+		}
+
+		drm_add_hdmi_modes(data, newmode);
+		modes++;
+		drm_mode_destroy(newmode);
+	}
+
+	return modes;
+}
+
+static void
+do_inferred_modes(struct detailed_timing *timing, void *c)
+{
+	struct detailed_mode_closure *closure = c;
+	struct detailed_non_pixel *data = &timing->data.other_data;
+	struct detailed_data_monitor_range *range = &data->data.range;
+
+	if (data->type != EDID_DETAIL_MONITOR_RANGE)
+		return;
+
+	closure->modes += drm_dmt_modes_for_range(closure->data,
+						  closure->edid,
+						  timing);
+
+	if (!version_greater(closure->edid, 1, 1))
+		return; /* GTF not defined yet */
+
+	switch (range->flags) {
+	case 0x02: /* secondary gtf, XXX could do more */
+	case 0x00: /* default gtf */
+		closure->modes += drm_gtf_modes_for_range(closure->data,
+							  closure->edid,
+							  timing);
+		break;
+	case 0x04: /* cvt, only in 1.4+ */
+		if (!version_greater(closure->edid, 1, 3))
+			break;
+
+		closure->modes += drm_cvt_modes_for_range(closure->data,
+							  closure->edid,
+							  timing);
+		break;
+	case 0x01: /* just the ranges, no formula */
+	default:
+		break;
+	}
+}
+
+static int
+add_inferred_modes(struct hdmi_edid_data *data, struct edid *edid)
+{
+	struct detailed_mode_closure closure = {
+		.data = data,
+		.edid = edid,
+	};
+
+	if (version_greater(edid, 1, 0))
+		drm_for_each_detailed_block((u8 *)edid, do_inferred_modes,
+					    &closure);
+
+	return closure.modes;
+}
+
+#define MODE_SIZE(m) ((m)->hdisplay * (m)->vdisplay)
+#define MODE_REFRESH_DIFF(c, t) (abs((c) - (t)))
+
+/**
+ * edid_fixup_preferred - set preferred modes based on quirk list
+ * @data: the structure that save parsed hdmi edid data
+ * @quirks: quirks list
+ *
+ * Walk the mode list, clearing the preferred status
+ * on existing modes and setting it anew for the right mode ala @quirks.
+ */
+static void edid_fixup_preferred(struct hdmi_edid_data *data,
+				 u32 quirks)
+{
+	struct drm_display_mode *cur_mode, *preferred_mode;
+	int i, target_refresh = 0;
+	int num = data->modes;
+	int cur_vrefresh, preferred_vrefresh;
+
+	if (!num)
+		return;
+
+	preferred_mode = data->preferred_mode;
+
+	if (quirks & EDID_QUIRK_PREFER_LARGE_60)
+		target_refresh = 60;
+	if (quirks & EDID_QUIRK_PREFER_LARGE_75)
+		target_refresh = 75;
+
+	for (i = 0; i < num; i++) {
+		cur_mode = &data->mode_buf[i];
+		cur_mode->type &= ~DRM_MODE_TYPE_PREFERRED;
+
+		if (cur_mode == preferred_mode)
+			continue;
+
+		/* Largest mode is preferred */
+		if (MODE_SIZE(cur_mode) > MODE_SIZE(preferred_mode))
+			preferred_mode = cur_mode;
+
+		cur_vrefresh = cur_mode->vrefresh ?
+		cur_mode->vrefresh : drm_get_vrefresh(cur_mode);
+		preferred_vrefresh = preferred_mode->vrefresh ?
+		preferred_mode->vrefresh : drm_get_vrefresh(preferred_mode);
+		/* At a given size, try to get closest to target refresh */
+		if ((MODE_SIZE(cur_mode) == MODE_SIZE(preferred_mode)) &&
+		    MODE_REFRESH_DIFF(cur_vrefresh, target_refresh) <
+		    MODE_REFRESH_DIFF(preferred_vrefresh, target_refresh)) {
+			preferred_mode = cur_mode;
+		}
+	}
+	preferred_mode->type |= DRM_MODE_TYPE_PREFERRED;
+	data->preferred_mode = preferred_mode;
+}
+
+static const u8 edid_header[] = {
+	0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00
+};
+
+/**
+ * drm_edid_header_is_valid - sanity check the header of the base EDID block
+ * @raw_edid: pointer to raw base EDID block
+ *
+ * Sanity check the header of the base EDID block.
+ *
+ * Return: 8 if the header is perfect, down to 0 if it's totally wrong.
+ */
+static int drm_edid_header_is_valid(const u8 *raw_edid)
+{
+	int i, score = 0;
+
+	for (i = 0; i < sizeof(edid_header); i++)
+		if (raw_edid[i] == edid_header[i])
+			score++;
+
+	return score;
+}
+
+static int drm_edid_block_checksum(const u8 *raw_edid)
+{
+	int i;
+	u8 csum = 0;
+
+	for (i = 0; i < EDID_SIZE; i++)
+		csum += raw_edid[i];
+
+	return csum;
+}
+
+static bool drm_edid_is_zero(const u8 *in_edid, int length)
+{
+	if (memchr_inv(in_edid, 0, length))
+		return false;
+
+	return true;
+}
+
+/**
+ * drm_edid_block_valid - Sanity check the EDID block (base or extension)
+ * @raw_edid: pointer to raw EDID block
+ * @block: type of block to validate (0 for base, extension otherwise)
+ * @print_bad_edid: if true, dump bad EDID blocks to the console
+ * @edid_corrupt: if true, the header or checksum is invalid
+ *
+ * Validate a base or extension EDID block and optionally dump bad blocks to
+ * the console.
+ *
+ * Return: True if the block is valid, false otherwise.
+ */
+static
+bool drm_edid_block_valid(u8 *raw_edid, int block, bool print_bad_edid,
+			  bool *edid_corrupt)
+{
+	u8 csum;
+	int edid_fixup = 6;
+	struct edid *edid = (struct edid *)raw_edid;
+
+	if ((!raw_edid))
+		return false;
+
+	if (block == 0) {
+		int score = drm_edid_header_is_valid(raw_edid);
+
+		if (score == 8) {
+			if (edid_corrupt)
+				*edid_corrupt = false;
+		} else if (score >= edid_fixup) {
+			/* Displayport Link CTS Core 1.2 rev1.1 test 4.2.2.6
+			 * The corrupt flag needs to be set here otherwise, the
+			 * fix-up code here will correct the problem, the
+			 * checksum is correct and the test fails
+			 */
+			if (edid_corrupt)
+				*edid_corrupt = true;
+			debug("Fixing header, your hardware may be failing\n");
+			memcpy(raw_edid, edid_header, sizeof(edid_header));
+		} else {
+			if (edid_corrupt)
+				*edid_corrupt = true;
+			goto bad;
+		}
+	}
+
+	csum = drm_edid_block_checksum(raw_edid);
+	if (csum) {
+		if (print_bad_edid) {
+			debug("EDID checksum is invalid, remainder is %d\n",
+			      csum);
+		}
+
+		if (edid_corrupt)
+			*edid_corrupt = true;
+
+		/* allow CEA to slide through, switches mangle this */
+		if (raw_edid[0] != 0x02)
+			goto bad;
+	}
+
+	/* per-block-type checks */
+	switch (raw_edid[0]) {
+	case 0: /* base */
+		if (edid->version != 1) {
+			debug("EDID has major version %d, instead of 1\n",
+			      edid->version);
+			goto bad;
+		}
+
+		if (edid->revision > 4)
+			debug("minor > 4, assuming backward compatibility\n");
+		break;
+
+	default:
+		break;
+	}
+
+	return true;
+
+bad:
+	if (print_bad_edid) {
+		if (drm_edid_is_zero(raw_edid, EDID_SIZE)) {
+			debug("EDID block is all zeroes\n");
+		} else {
+			debug("Raw EDID:\n");
+			print_hex_dump("", DUMP_PREFIX_NONE, 16, 1,
+				       raw_edid, EDID_SIZE, false);
+		}
+	}
+	return false;
+}
+
+/**
+ * drm_edid_is_valid - sanity check EDID data
+ * @edid: EDID data
+ *
+ * Sanity-check an entire EDID record (including extensions)
+ *
+ * Return: True if the EDID data is valid, false otherwise.
+ */
+static bool drm_edid_is_valid(struct edid *edid)
+{
+	int i;
+	u8 *raw = (u8 *)edid;
+
+	if (!edid)
+		return false;
+
+	for (i = 0; i <= edid->extensions; i++)
+		if (!drm_edid_block_valid(raw + i * EDID_SIZE, i, true, NULL))
+			return false;
+
+	return true;
+}
+
+/**
+ * drm_add_edid_modes - add modes from EDID data, if available
+ * @data: data we're probing
+ * @edid: EDID data
+ *
+ * Add the specified modes to the data's mode list.
+ *
+ * Return: The number of modes added or 0 if we couldn't find any.
+ */
+int drm_add_edid_modes(struct hdmi_edid_data *data, u8 *raw_edid)
+{
+	int num_modes = 0;
+	u32 quirks;
+	struct edid *edid = (struct edid *)raw_edid;
+
+	if (!edid) {
+		debug("no edid\n");
+		return 0;
+	}
+
+	if (!drm_edid_is_valid(edid)) {
+		debug("EDID invalid\n");
+		return 0;
+	}
+
+	if (!data->mode_buf) {
+		debug("mode buff is null\n");
+		return 0;
+	}
+
+	quirks = edid_get_quirks(edid);
+	/*
+	 * CEA-861-F adds ycbcr capability map block, for HDMI 2.0 sinks.
+	 * To avoid multiple parsing of same block, lets parse that map
+	 * from sink info, before parsing CEA modes.
+	 */
+	drm_add_display_info(data, edid);
+
+	/*
+	 * EDID spec says modes should be preferred in this order:
+	 * - preferred detailed mode
+	 * - other detailed modes from base block
+	 * - detailed modes from extension blocks
+	 * - CVT 3-byte code modes
+	 * - standard timing codes
+	 * - established timing codes
+	 * - modes inferred from GTF or CVT range information
+	 *
+	 * We get this pretty much right.
+	 *
+	 * XXX order for additional mode types in extension blocks?
+	 */
+	num_modes += add_detailed_modes(data, edid, quirks);
+	num_modes += add_cvt_modes(data, edid);
+	num_modes += add_standard_modes(data, edid);
+	num_modes += add_established_modes(data, edid);
+	num_modes += add_cea_modes(data, edid);
+	num_modes += add_alternate_cea_modes(data, edid);
+	num_modes += add_displayid_detailed_modes(data, edid);
+
+	if (edid->features & DRM_EDID_FEATURE_DEFAULT_GTF)
+		num_modes += add_inferred_modes(data, edid);
+
+	if (num_modes > 0)
+		data->preferred_mode = &data->mode_buf[0];
+
+	if (quirks & (EDID_QUIRK_PREFER_LARGE_60 | EDID_QUIRK_PREFER_LARGE_75))
+		edid_fixup_preferred(data, quirks);
+
+	if (quirks & EDID_QUIRK_FORCE_6BPC)
+		data->display_info.bpc = 6;
+
+	if (quirks & EDID_QUIRK_FORCE_8BPC)
+		data->display_info.bpc = 8;
+
+	if (quirks & EDID_QUIRK_FORCE_10BPC)
+		data->display_info.bpc = 10;
+
+	if (quirks & EDID_QUIRK_FORCE_12BPC)
+		data->display_info.bpc = 12;
+
+	return num_modes;
+}
+
+u8 drm_match_cea_mode(struct drm_display_mode *to_match)
+{
+	u8 vic;
+
+	if (!to_match->clock) {
+		printf("can't find to match\n");
+		return 0;
+	}
+
+	for (vic = 1; vic < cea_num_vics(); vic = cea_next_vic(vic)) {
+		const struct drm_display_mode *cea_mode = cea_mode_for_vic(vic);
+		unsigned int clock1, clock2;
+
+		/* Check both 60Hz and 59.94Hz */
+		clock1 = cea_mode->clock;
+		clock2 = cea_mode_alternate_clock(cea_mode);
+		if ((KHZ2PICOS(to_match->clock) == KHZ2PICOS(clock1) ||
+		     KHZ2PICOS(to_match->clock) == KHZ2PICOS(clock2)) &&
+		    drm_mode_equal_no_clocks_no_stereo(to_match, cea_mode))
+			return vic;
+	}
+
+	return 0;
+}
+
+static enum hdmi_picture_aspect drm_get_cea_aspect_ratio(const u8 video_code)
+{
+	const struct drm_display_mode *mode = cea_mode_for_vic(video_code);
+
+	if (mode)
+		return mode->picture_aspect_ratio;
+
+	return HDMI_PICTURE_ASPECT_NONE;
+}
+
+int
+drm_hdmi_avi_infoframe_from_display_mode(struct hdmi_avi_infoframe *frame,
+					 struct drm_display_mode *mode,
+					 bool is_hdmi2_sink)
+{
+	int err;
+
+	if (!frame || !mode)
+		return -EINVAL;
+
+	err = hdmi_avi_infoframe_init(frame);
+	if (err < 0)
+		return err;
+
+	if (mode->flags & DRM_MODE_FLAG_DBLCLK)
+		frame->pixel_repeat = 1;
+
+	frame->video_code = drm_match_cea_mode(mode);
+
+	/*
+	 * HDMI 1.4 VIC range: 1 <= VIC <= 64 (CEA-861-D) but
+	 * HDMI 2.0 VIC range: 1 <= VIC <= 107 (CEA-861-F). So we
+	 * have to make sure we dont break HDMI 1.4 sinks.
+	 */
+	if (!is_hdmi2_sink && frame->video_code > 64)
+		frame->video_code = 0;
+
+	/*
+	 * HDMI spec says if a mode is found in HDMI 1.4b 4K modes
+	 * we should send its VIC in vendor infoframes, else send the
+	 * VIC in AVI infoframes. Lets check if this mode is present in
+	 * HDMI 1.4b 4K modes
+	 */
+	if (frame->video_code) {
+		u8 vendor_if_vic = drm_match_hdmi_mode(mode);
+		bool is_s3d = mode->flags & DRM_MODE_FLAG_3D_MASK;
+
+		if (drm_valid_hdmi_vic(vendor_if_vic) && !is_s3d)
+			frame->video_code = 0;
+	}
+
+	frame->picture_aspect = HDMI_PICTURE_ASPECT_NONE;
+
+	/*
+	 * Populate picture aspect ratio from either
+	 * user input (if specified) or from the CEA mode list.
+	 */
+	if (mode->picture_aspect_ratio == HDMI_PICTURE_ASPECT_4_3 ||
+	    mode->picture_aspect_ratio == HDMI_PICTURE_ASPECT_16_9)
+		frame->picture_aspect = mode->picture_aspect_ratio;
+	else if (frame->video_code > 0)
+		frame->picture_aspect = drm_get_cea_aspect_ratio(
+						frame->video_code);
+
+	if (frame->picture_aspect > HDMI_PICTURE_ASPECT_16_9)
+		frame->picture_aspect = HDMI_PICTURE_ASPECT_NONE;
+	frame->active_aspect = HDMI_ACTIVE_ASPECT_PICTURE;
+	frame->scan_mode = HDMI_SCAN_MODE_UNDERSCAN;
+
+	return 0;
+}
+
+/**
+ * hdmi_vendor_infoframe_init() - initialize an HDMI vendor infoframe
+ * @frame: HDMI vendor infoframe
+ *
+ * Returns 0 on success or a negative error code on failure.
+ */
+int hdmi_vendor_infoframe_init(struct hdmi_vendor_infoframe *frame)
+{
+	memset(frame, 0, sizeof(*frame));
+
+	frame->type = HDMI_INFOFRAME_TYPE_VENDOR;
+	frame->version = 1;
+
+	frame->oui = HDMI_IEEE_OUI;
+
+	/*
+	 * 0 is a valid value for s3d_struct, so we use a special "not set"
+	 * value
+	 */
+	frame->s3d_struct = HDMI_3D_STRUCTURE_INVALID;
+
+	return 0;
+}
+
+/**
+ * drm_hdmi_avi_infoframe_quant_range() - fill the HDMI AVI infoframe
+ *                                        quantization range information
+ * @frame: HDMI AVI infoframe
+ * @rgb_quant_range: RGB quantization range (Q)
+ * @rgb_quant_range_selectable: Sink support selectable RGB quantization range (QS)
+ */
+void
+drm_hdmi_avi_infoframe_quant_range(struct hdmi_avi_infoframe *frame,
+				   struct drm_display_mode *mode,
+				   enum hdmi_quantization_range rgb_quant_range,
+				   bool rgb_quant_range_selectable)
+{
+	/*
+	 * CEA-861:
+	 * "A Source shall not send a non-zero Q value that does not correspond
+	 *  to the default RGB Quantization Range for the transmitted Picture
+	 *  unless the Sink indicates support for the Q bit in a Video
+	 *  Capabilities Data Block."
+	 *
+	 * HDMI 2.0 recommends sending non-zero Q when it does match the
+	 * default RGB quantization range for the mode, even when QS=0.
+	 */
+	if (rgb_quant_range_selectable ||
+	    rgb_quant_range == drm_default_rgb_quant_range(mode))
+		frame->quantization_range = rgb_quant_range;
+	else
+		frame->quantization_range = HDMI_QUANTIZATION_RANGE_DEFAULT;
+
+	/*
+	 * CEA-861-F:
+	 * "When transmitting any RGB colorimetry, the Source should set the
+	 *  YQ-field to match the RGB Quantization Range being transmitted
+	 *  (e.g., when Limited Range RGB, set YQ=0 or when Full Range RGB,
+	 *  set YQ=1) and the Sink shall ignore the YQ-field."
+	 */
+	if (rgb_quant_range == HDMI_QUANTIZATION_RANGE_LIMITED)
+		frame->ycc_quantization_range =
+			HDMI_YCC_QUANTIZATION_RANGE_LIMITED;
+	else
+		frame->ycc_quantization_range =
+			HDMI_YCC_QUANTIZATION_RANGE_FULL;
+}
+
+static enum hdmi_3d_structure
+s3d_structure_from_display_mode(const struct drm_display_mode *mode)
+{
+	u32 layout = mode->flags & DRM_MODE_FLAG_3D_MASK;
+
+	switch (layout) {
+	case DRM_MODE_FLAG_3D_FRAME_PACKING:
+		return HDMI_3D_STRUCTURE_FRAME_PACKING;
+	case DRM_MODE_FLAG_3D_FIELD_ALTERNATIVE:
+		return HDMI_3D_STRUCTURE_FIELD_ALTERNATIVE;
+	case DRM_MODE_FLAG_3D_LINE_ALTERNATIVE:
+		return HDMI_3D_STRUCTURE_LINE_ALTERNATIVE;
+	case DRM_MODE_FLAG_3D_SIDE_BY_SIDE_FULL:
+		return HDMI_3D_STRUCTURE_SIDE_BY_SIDE_FULL;
+	case DRM_MODE_FLAG_3D_L_DEPTH:
+		return HDMI_3D_STRUCTURE_L_DEPTH;
+	case DRM_MODE_FLAG_3D_L_DEPTH_GFX_GFX_DEPTH:
+		return HDMI_3D_STRUCTURE_L_DEPTH_GFX_GFX_DEPTH;
+	case DRM_MODE_FLAG_3D_TOP_AND_BOTTOM:
+		return HDMI_3D_STRUCTURE_TOP_AND_BOTTOM;
+	case DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF:
+		return HDMI_3D_STRUCTURE_SIDE_BY_SIDE_HALF;
+	default:
+		return HDMI_3D_STRUCTURE_INVALID;
+	}
+}
+
+int
+drm_hdmi_vendor_infoframe_from_display_mode(struct hdmi_vendor_infoframe *frame,
+					    struct drm_display_mode *mode)
+{
+	int err;
+	u32 s3d_flags;
+	u8 vic;
+
+	if (!frame || !mode)
+		return -EINVAL;
+
+	vic = drm_match_hdmi_mode(mode);
+
+	s3d_flags = mode->flags & DRM_MODE_FLAG_3D_MASK;
+
+	if (!vic && !s3d_flags)
+		return -EINVAL;
+
+	if (vic && s3d_flags)
+		return -EINVAL;
+
+	err = hdmi_vendor_infoframe_init(frame);
+	if (err < 0)
+		return err;
+
+	if (vic)
+		frame->vic = vic;
+	else
+		frame->s3d_struct = s3d_structure_from_display_mode(mode);
+
+	return 0;
+}
+
+static u8 hdmi_infoframe_checksum(u8 *ptr, size_t size)
+{
+	u8 csum = 0;
+	size_t i;
+
+	/* compute checksum */
+	for (i = 0; i < size; i++)
+		csum += ptr[i];
+
+	return 256 - csum;
+}
+
+static void hdmi_infoframe_set_checksum(void *buffer, size_t size)
+{
+	u8 *ptr = buffer;
+
+	ptr[3] = hdmi_infoframe_checksum(buffer, size);
+}
+
+/**
+ * hdmi_avi_infoframe_init() - initialize an HDMI AVI infoframe
+ * @frame: HDMI AVI infoframe
+ *
+ * Returns 0 on success or a negative error code on failure.
+ */
+int hdmi_avi_infoframe_init(struct hdmi_avi_infoframe *frame)
+{
+	memset(frame, 0, sizeof(*frame));
+
+	frame->type = HDMI_INFOFRAME_TYPE_AVI;
+	frame->version = 2;
+	frame->length = HDMI_AVI_INFOFRAME_SIZE;
+
+	return 0;
+}
+EXPORT_SYMBOL(hdmi_avi_infoframe_init);
+
+/**
+ * hdmi_avi_infoframe_pack() - write HDMI AVI infoframe to binary buffer
+ * @frame: HDMI AVI infoframe
+ * @buffer: destination buffer
+ * @size: size of buffer
+ *
+ * Packs the information contained in the @frame structure into a binary
+ * representation that can be written into the corresponding controller
+ * registers. Also computes the checksum as required by section 5.3.5 of
+ * the HDMI 1.4 specification.
+ *
+ * Returns the number of bytes packed into the binary buffer or a negative
+ * error code on failure.
+ */
+ssize_t hdmi_avi_infoframe_pack(struct hdmi_avi_infoframe *frame, void *buffer,
+				size_t size)
+{
+	u8 *ptr = buffer;
+	size_t length;
+
+	length = HDMI_INFOFRAME_HEADER_SIZE + frame->length;
+
+	if (size < length)
+		return -ENOSPC;
+
+	memset(buffer, 0, size);
+
+	ptr[0] = frame->type;
+	ptr[1] = frame->version;
+	ptr[2] = frame->length;
+	ptr[3] = 0; /* checksum */
+
+	/* start infoframe payload */
+	ptr += HDMI_INFOFRAME_HEADER_SIZE;
+
+	ptr[0] = ((frame->colorspace & 0x3) << 5) | (frame->scan_mode & 0x3);
+
+	/*
+	 * Data byte 1, bit 4 has to be set if we provide the active format
+	 * aspect ratio
+	 */
+	if (frame->active_aspect & 0xf)
+		ptr[0] |= BIT(4);
+
+	/* Bit 3 and 2 indicate if we transmit horizontal/vertical bar data */
+	if (frame->top_bar || frame->bottom_bar)
+		ptr[0] |= BIT(3);
+
+	if (frame->left_bar || frame->right_bar)
+		ptr[0] |= BIT(2);
+
+	ptr[1] = ((frame->colorimetry & 0x3) << 6) |
+		 ((frame->picture_aspect & 0x3) << 4) |
+		 (frame->active_aspect & 0xf);
+
+	ptr[2] = ((frame->extended_colorimetry & 0x7) << 4) |
+		 ((frame->quantization_range & 0x3) << 2) |
+		 (frame->nups & 0x3);
+
+	if (frame->itc)
+		ptr[2] |= BIT(7);
+
+	ptr[3] = frame->video_code & 0x7f;
+
+	ptr[4] = ((frame->ycc_quantization_range & 0x3) << 6) |
+		 ((frame->content_type & 0x3) << 4) |
+		 (frame->pixel_repeat & 0xf);
+
+	ptr[5] = frame->top_bar & 0xff;
+	ptr[6] = (frame->top_bar >> 8) & 0xff;
+	ptr[7] = frame->bottom_bar & 0xff;
+	ptr[8] = (frame->bottom_bar >> 8) & 0xff;
+	ptr[9] = frame->left_bar & 0xff;
+	ptr[10] = (frame->left_bar >> 8) & 0xff;
+	ptr[11] = frame->right_bar & 0xff;
+	ptr[12] = (frame->right_bar >> 8) & 0xff;
+
+	hdmi_infoframe_set_checksum(buffer, length);
+
+	return length;
+}
+EXPORT_SYMBOL(hdmi_avi_infoframe_pack);
+
+static int hdmi_avi_infoframe_check_only(const struct hdmi_avi_infoframe *frame)
+{
+	if (frame->type != HDMI_INFOFRAME_TYPE_AVI ||
+	    frame->version != 2 ||
+	    frame->length != HDMI_AVI_INFOFRAME_SIZE)
+		return -EINVAL;
+
+	if (frame->picture_aspect > HDMI_PICTURE_ASPECT_16_9)
+		return -EINVAL;
+
+	return 0;
+}
+
+/**
+ * hdmi_avi_infoframe_check() - check a HDMI AVI infoframe
+ * @frame: HDMI AVI infoframe
+ *
+ * Validates that the infoframe is consistent and updates derived fields
+ * (eg. length) based on other fields.
+ *
+ * Returns 0 on success or a negative error code on failure.
+ */
+int hdmi_avi_infoframe_check(struct hdmi_avi_infoframe *frame)
+{
+	return hdmi_avi_infoframe_check_only(frame);
+}
+EXPORT_SYMBOL(hdmi_avi_infoframe_check);
+
+/**
+ * hdmi_avi_infoframe_pack_only() - write HDMI AVI infoframe to binary buffer
+ * @frame: HDMI AVI infoframe
+ * @buffer: destination buffer
+ * @size: size of buffer
+ *
+ * Packs the information contained in the @frame structure into a binary
+ * representation that can be written into the corresponding controller
+ * registers. Also computes the checksum as required by section 5.3.5 of
+ * the HDMI 1.4 specification.
+ *
+ * Returns the number of bytes packed into the binary buffer or a negative
+ * error code on failure.
+ */
+ssize_t hdmi_avi_infoframe_pack_only(const struct hdmi_avi_infoframe *frame,
+				     void *buffer, size_t size)
+{
+	u8 *ptr = buffer;
+	size_t length;
+	int ret;
+
+	ret = hdmi_avi_infoframe_check_only(frame);
+	if (ret)
+		return ret;
+
+	length = HDMI_INFOFRAME_HEADER_SIZE + frame->length;
+
+	if (size < length)
+		return -ENOSPC;
+
+	memset(buffer, 0, size);
+
+	ptr[0] = frame->type;
+	ptr[1] = frame->version;
+	ptr[2] = frame->length;
+	ptr[3] = 0; /* checksum */
+
+	/* start infoframe payload */
+	ptr += HDMI_INFOFRAME_HEADER_SIZE;
+
+	ptr[0] = ((frame->colorspace & 0x3) << 5) | (frame->scan_mode & 0x3);
+
+	/*
+	 * Data byte 1, bit 4 has to be set if we provide the active format
+	 * aspect ratio
+	 */
+	if (frame->active_aspect & 0xf)
+		ptr[0] |= BIT(4);
+
+	/* Bit 3 and 2 indicate if we transmit horizontal/vertical bar data */
+	if (frame->top_bar || frame->bottom_bar)
+		ptr[0] |= BIT(3);
+
+	if (frame->left_bar || frame->right_bar)
+		ptr[0] |= BIT(2);
+
+	ptr[1] = ((frame->colorimetry & 0x3) << 6) |
+		 ((frame->picture_aspect & 0x3) << 4) |
+		 (frame->active_aspect & 0xf);
+
+	ptr[2] = ((frame->extended_colorimetry & 0x7) << 4) |
+		 ((frame->quantization_range & 0x3) << 2) |
+		 (frame->nups & 0x3);
+
+	if (frame->itc)
+		ptr[2] |= BIT(7);
+
+	ptr[3] = frame->video_code & 0xff;
+
+	ptr[4] = ((frame->ycc_quantization_range & 0x3) << 6) |
+		 ((frame->content_type & 0x3) << 4) |
+		 (frame->pixel_repeat & 0xf);
+
+	ptr[5] = frame->top_bar & 0xff;
+	ptr[6] = (frame->top_bar >> 8) & 0xff;
+	ptr[7] = frame->bottom_bar & 0xff;
+	ptr[8] = (frame->bottom_bar >> 8) & 0xff;
+	ptr[9] = frame->left_bar & 0xff;
+	ptr[10] = (frame->left_bar >> 8) & 0xff;
+	ptr[11] = frame->right_bar & 0xff;
+	ptr[12] = (frame->right_bar >> 8) & 0xff;
+
+	hdmi_infoframe_set_checksum(buffer, length);
+
+	return length;
+}
+EXPORT_SYMBOL(hdmi_avi_infoframe_pack_only);
+
+/**
+ * hdmi_spd_infoframe_init() - initialize an HDMI SPD infoframe
+ * @frame: HDMI SPD infoframe
+ * @vendor: vendor string
+ * @product: product string
+ *
+ * Returns 0 on success or a negative error code on failure.
+ */
+int hdmi_spd_infoframe_init(struct hdmi_spd_infoframe *frame,
+			    const char *vendor, const char *product)
+{
+	memset(frame, 0, sizeof(*frame));
+
+	frame->type = HDMI_INFOFRAME_TYPE_SPD;
+	frame->version = 1;
+	frame->length = HDMI_SPD_INFOFRAME_SIZE;
+
+	strncpy(frame->vendor, vendor, sizeof(frame->vendor));
+	strncpy(frame->product, product, sizeof(frame->product));
+
+	return 0;
+}
+EXPORT_SYMBOL(hdmi_spd_infoframe_init);
+
+/**
+ * hdmi_spd_infoframe_pack() - write HDMI SPD infoframe to binary buffer
+ * @frame: HDMI SPD infoframe
+ * @buffer: destination buffer
+ * @size: size of buffer
+ *
+ * Packs the information contained in the @frame structure into a binary
+ * representation that can be written into the corresponding controller
+ * registers. Also computes the checksum as required by section 5.3.5 of
+ * the HDMI 1.4 specification.
+ *
+ * Returns the number of bytes packed into the binary buffer or a negative
+ * error code on failure.
+ */
+ssize_t hdmi_spd_infoframe_pack(struct hdmi_spd_infoframe *frame, void *buffer,
+				size_t size)
+{
+	u8 *ptr = buffer;
+	size_t length;
+
+	length = HDMI_INFOFRAME_HEADER_SIZE + frame->length;
+
+	if (size < length)
+		return -ENOSPC;
+
+	memset(buffer, 0, size);
+
+	ptr[0] = frame->type;
+	ptr[1] = frame->version;
+	ptr[2] = frame->length;
+	ptr[3] = 0; /* checksum */
+
+	/* start infoframe payload */
+	ptr += HDMI_INFOFRAME_HEADER_SIZE;
+
+	memcpy(ptr, frame->vendor, sizeof(frame->vendor));
+	memcpy(ptr + 8, frame->product, sizeof(frame->product));
+
+	ptr[24] = frame->sdi;
+
+	hdmi_infoframe_set_checksum(buffer, length);
+
+	return length;
+}
+EXPORT_SYMBOL(hdmi_spd_infoframe_pack);
+
+/**
+ * hdmi_audio_infoframe_init() - initialize an HDMI audio infoframe
+ * @frame: HDMI audio infoframe
+ *
+ * Returns 0 on success or a negative error code on failure.
+ */
+int hdmi_audio_infoframe_init(struct hdmi_audio_infoframe *frame)
+{
+	memset(frame, 0, sizeof(*frame));
+
+	frame->type = HDMI_INFOFRAME_TYPE_AUDIO;
+	frame->version = 1;
+	frame->length = HDMI_AUDIO_INFOFRAME_SIZE;
+
+	return 0;
+}
+
+/**
+ * hdmi_audio_infoframe_pack() - write HDMI audio infoframe to binary buffer
+ * @frame: HDMI audio infoframe
+ * @buffer: destination buffer
+ * @size: size of buffer
+ *
+ * Packs the information contained in the @frame structure into a binary
+ * representation that can be written into the corresponding controller
+ * registers. Also computes the checksum as required by section 5.3.5 of
+ * the HDMI 1.4 specification.
+ *
+ * Returns the number of bytes packed into the binary buffer or a negative
+ * error code on failure.
+ */
+ssize_t hdmi_audio_infoframe_pack(struct hdmi_audio_infoframe *frame,
+				  void *buffer, size_t size)
+{
+	unsigned char channels;
+	char *ptr = buffer;
+	size_t length;
+
+	length = HDMI_INFOFRAME_HEADER_SIZE + frame->length;
+
+	if (size < length)
+		return -ENOSPC;
+
+	memset(buffer, 0, size);
+
+	if (frame->channels >= 2)
+		channels = frame->channels - 1;
+	else
+		channels = 0;
+
+	ptr[0] = frame->type;
+	ptr[1] = frame->version;
+	ptr[2] = frame->length;
+	ptr[3] = 0; /* checksum */
+
+	/* start infoframe payload */
+	ptr += HDMI_INFOFRAME_HEADER_SIZE;
+
+	ptr[0] = ((frame->coding_type & 0xf) << 4) | (channels & 0x7);
+	ptr[1] = ((frame->sample_frequency & 0x7) << 2) |
+		 (frame->sample_size & 0x3);
+	ptr[2] = frame->coding_type_ext & 0x1f;
+	ptr[3] = frame->channel_allocation;
+	ptr[4] = (frame->level_shift_value & 0xf) << 3;
+
+	if (frame->downmix_inhibit)
+		ptr[4] |= BIT(7);
+
+	hdmi_infoframe_set_checksum(buffer, length);
+
+	return length;
+}
+
+/**
+ * hdmi_vendor_infoframe_pack() - write a HDMI vendor infoframe to binary buffer
+ * @frame: HDMI infoframe
+ * @buffer: destination buffer
+ * @size: size of buffer
+ *
+ * Packs the information contained in the @frame structure into a binary
+ * representation that can be written into the corresponding controller
+ * registers. Also computes the checksum as required by section 5.3.5 of
+ * the HDMI 1.4 specification.
+ *
+ * Returns the number of bytes packed into the binary buffer or a negative
+ * error code on failure.
+ */
+ssize_t hdmi_vendor_infoframe_pack(struct hdmi_vendor_infoframe *frame,
+				   void *buffer, size_t size)
+{
+	char *ptr = buffer;
+	size_t length;
+
+	/* empty info frame */
+	if (frame->vic == 0 && frame->s3d_struct == HDMI_3D_STRUCTURE_INVALID)
+		return -EINVAL;
+
+	/* only one of those can be supplied */
+	if (frame->vic != 0 && frame->s3d_struct != HDMI_3D_STRUCTURE_INVALID)
+		return -EINVAL;
+
+	/* for side by side (half) we also need to provide 3D_Ext_Data */
+	if (frame->s3d_struct >= HDMI_3D_STRUCTURE_SIDE_BY_SIDE_HALF)
+		frame->length = 6;
+	else
+		frame->length = 5;
+
+	length = HDMI_INFOFRAME_HEADER_SIZE + frame->length;
+
+	if (size < length)
+		return -ENOSPC;
+
+	memset(buffer, 0, size);
+
+	ptr[0] = frame->type;
+	ptr[1] = frame->version;
+	ptr[2] = frame->length;
+	ptr[3] = 0; /* checksum */
+
+	/* HDMI OUI */
+	ptr[4] = 0x03;
+	ptr[5] = 0x0c;
+	ptr[6] = 0x00;
+
+	if (frame->vic) {
+		ptr[7] = 0x1 << 5;	/* video format */
+		ptr[8] = frame->vic;
+	} else {
+		ptr[7] = 0x2 << 5;	/* video format */
+		ptr[8] = (frame->s3d_struct & 0xf) << 4;
+		if (frame->s3d_struct >= HDMI_3D_STRUCTURE_SIDE_BY_SIDE_HALF)
+			ptr[9] = (frame->s3d_ext_data & 0xf) << 4;
+	}
+
+	hdmi_infoframe_set_checksum(buffer, length);
+
+	return length;
+}
+
+/**
+ * hdmi_drm_infoframe_init() - initialize an HDMI Dynaminc Range and
+ * mastering infoframe
+ * @frame: HDMI DRM infoframe
+ *
+ * Returns 0 on success or a negative error code on failure.
+ */
+int hdmi_drm_infoframe_init(struct hdmi_drm_infoframe *frame)
+{
+	memset(frame, 0, sizeof(*frame));
+
+	frame->type = HDMI_INFOFRAME_TYPE_DRM;
+	frame->version = 1;
+
+	return 0;
+}
+
+/**
+ * hdmi_drm_infoframe_pack() - write HDMI DRM infoframe to binary buffer
+ * @frame: HDMI DRM infoframe
+ * @buffer: destination buffer
+ * @size: size of buffer
+ *
+ * Packs the information contained in the @frame structure into a binary
+ * representation that can be written into the corresponding controller
+ * registers. Also computes the checksum as required by section 5.3.5 of
+ * the HDMI 1.4 specification.
+ *
+ * Returns the number of bytes packed into the binary buffer or a negative
+ * error code on failure.
+ */
+ssize_t hdmi_drm_infoframe_pack(struct hdmi_drm_infoframe *frame, void *buffer,
+				size_t size)
+{
+	u8 *ptr = buffer;
+	size_t length;
+
+	length = HDMI_INFOFRAME_HEADER_SIZE + frame->length;
+
+	if (size < length)
+		return -ENOSPC;
+
+	memset(buffer, 0, size);
+
+	ptr[0] = frame->type;
+	ptr[1] = frame->version;
+	ptr[2] = frame->length;
+	ptr[3] = 0; /* checksum */
+
+	/* start infoframe payload */
+	ptr += HDMI_INFOFRAME_HEADER_SIZE;
+
+	ptr[0] = frame->eotf;
+	ptr[1] = frame->metadata_type;
+
+	ptr[2] = frame->display_primaries_x[0] & 0xff;
+	ptr[3] = frame->display_primaries_x[0] >> 8;
+
+	ptr[4] = frame->display_primaries_x[1] & 0xff;
+	ptr[5] = frame->display_primaries_x[1] >> 8;
+
+	ptr[6] = frame->display_primaries_x[2] & 0xff;
+	ptr[7] = frame->display_primaries_x[2] >> 8;
+
+	ptr[9] = frame->display_primaries_y[0] & 0xff;
+	ptr[10] = frame->display_primaries_y[0] >> 8;
+
+	ptr[11] = frame->display_primaries_y[1] & 0xff;
+	ptr[12] = frame->display_primaries_y[1] >> 8;
+
+	ptr[13] = frame->display_primaries_y[2] & 0xff;
+	ptr[14] = frame->display_primaries_y[2] >> 8;
+
+	ptr[15] = frame->white_point_x & 0xff;
+	ptr[16] = frame->white_point_x >> 8;
+
+	ptr[17] = frame->white_point_y & 0xff;
+	ptr[18] = frame->white_point_y >> 8;
+
+	ptr[19] = frame->max_mastering_display_luminance & 0xff;
+	ptr[20] = frame->max_mastering_display_luminance >> 8;
+
+	ptr[21] = frame->min_mastering_display_luminance & 0xff;
+	ptr[22] = frame->min_mastering_display_luminance >> 8;
+
+	ptr[23] = frame->max_cll & 0xff;
+	ptr[24] = frame->max_cll >> 8;
+
+	ptr[25] = frame->max_fall & 0xff;
+	ptr[26] = frame->max_fall >> 8;
+
+	hdmi_infoframe_set_checksum(buffer, length);
+
+	return length;
+}
+
+/*
+ * hdmi_vendor_any_infoframe_pack() - write a vendor infoframe to binary buffer
+ */
+static ssize_t
+hdmi_vendor_any_infoframe_pack(union hdmi_vendor_any_infoframe *frame,
+			       void *buffer, size_t size)
+{
+	/* we only know about HDMI vendor infoframes */
+	if (frame->any.oui != HDMI_IEEE_OUI)
+		return -EINVAL;
+
+	return hdmi_vendor_infoframe_pack(&frame->hdmi, buffer, size);
+}
+
+/**
+ * hdmi_infoframe_pack() - write a HDMI infoframe to binary buffer
+ * @frame: HDMI infoframe
+ * @buffer: destination buffer
+ * @size: size of buffer
+ *
+ * Packs the information contained in the @frame structure into a binary
+ * representation that can be written into the corresponding controller
+ * registers. Also computes the checksum as required by section 5.3.5 of
+ * the HDMI 1.4 specification.
+ *
+ * Returns the number of bytes packed into the binary buffer or a negative
+ * error code on failure.
+ */
+ssize_t
+hdmi_infoframe_pack(union hdmi_infoframe *frame, void *buffer, size_t size)
+{
+	ssize_t length;
+
+	switch (frame->any.type) {
+	case HDMI_INFOFRAME_TYPE_AVI:
+		length = hdmi_avi_infoframe_pack(&frame->avi, buffer, size);
+		break;
+	case HDMI_INFOFRAME_TYPE_DRM:
+		length = hdmi_drm_infoframe_pack(&frame->drm, buffer, size);
+		break;
+	case HDMI_INFOFRAME_TYPE_SPD:
+		length = hdmi_spd_infoframe_pack(&frame->spd, buffer, size);
+		break;
+	case HDMI_INFOFRAME_TYPE_AUDIO:
+		length = hdmi_audio_infoframe_pack(&frame->audio, buffer, size);
+		break;
+	case HDMI_INFOFRAME_TYPE_VENDOR:
+		length = hdmi_vendor_any_infoframe_pack(&frame->vendor,
+							buffer, size);
+		break;
+	default:
+		printf("Bad infoframe type %d\n", frame->any.type);
+		length = -EINVAL;
+	}
+
+	return length;
+}
+
+/**
+ * hdmi_avi_infoframe_unpack() - unpack binary buffer to a HDMI AVI infoframe
+ * @buffer: source buffer
+ * @frame: HDMI AVI infoframe
+ *
+ * Unpacks the information contained in binary @buffer into a structured
+ * @frame of the HDMI Auxiliary Video (AVI) information frame.
+ * Also verifies the checksum as required by section 5.3.5 of the HDMI 1.4
+ * specification.
+ *
+ * Returns 0 on success or a negative error code on failure.
+ */
+static int hdmi_avi_infoframe_unpack(struct hdmi_avi_infoframe *frame,
+				     void *buffer)
+{
+	u8 *ptr = buffer;
+	int ret;
+
+	if (ptr[0] != HDMI_INFOFRAME_TYPE_AVI ||
+	    ptr[1] != 2 ||
+	    ptr[2] != HDMI_AVI_INFOFRAME_SIZE)
+		return -EINVAL;
+
+	if (hdmi_infoframe_checksum(buffer, HDMI_INFOFRAME_SIZE(AVI)) != 0)
+		return -EINVAL;
+
+	ret = hdmi_avi_infoframe_init(frame);
+	if (ret)
+		return ret;
+
+	ptr += HDMI_INFOFRAME_HEADER_SIZE;
+
+	frame->colorspace = (ptr[0] >> 5) & 0x3;
+	if (ptr[0] & 0x10)
+		frame->active_aspect = ptr[1] & 0xf;
+	if (ptr[0] & 0x8) {
+		frame->top_bar = (ptr[5] << 8) + ptr[6];
+		frame->bottom_bar = (ptr[7] << 8) + ptr[8];
+	}
+	if (ptr[0] & 0x4) {
+		frame->left_bar = (ptr[9] << 8) + ptr[10];
+		frame->right_bar = (ptr[11] << 8) + ptr[12];
+	}
+	frame->scan_mode = ptr[0] & 0x3;
+
+	frame->colorimetry = (ptr[1] >> 6) & 0x3;
+	frame->picture_aspect = (ptr[1] >> 4) & 0x3;
+	frame->active_aspect = ptr[1] & 0xf;
+
+	frame->itc = ptr[2] & 0x80 ? true : false;
+	frame->extended_colorimetry = (ptr[2] >> 4) & 0x7;
+	frame->quantization_range = (ptr[2] >> 2) & 0x3;
+	frame->nups = ptr[2] & 0x3;
+
+	frame->video_code = ptr[3] & 0x7f;
+	frame->ycc_quantization_range = (ptr[4] >> 6) & 0x3;
+	frame->content_type = (ptr[4] >> 4) & 0x3;
+
+	frame->pixel_repeat = ptr[4] & 0xf;
+
+	return 0;
+}
+
+/**
+ * hdmi_spd_infoframe_unpack() - unpack binary buffer to a HDMI SPD infoframe
+ * @buffer: source buffer
+ * @frame: HDMI SPD infoframe
+ *
+ * Unpacks the information contained in binary @buffer into a structured
+ * @frame of the HDMI Source Product Description (SPD) information frame.
+ * Also verifies the checksum as required by section 5.3.5 of the HDMI 1.4
+ * specification.
+ *
+ * Returns 0 on success or a negative error code on failure.
+ */
+static int hdmi_spd_infoframe_unpack(struct hdmi_spd_infoframe *frame,
+				     void *buffer)
+{
+	char *ptr = buffer;
+	int ret;
+
+	if (ptr[0] != HDMI_INFOFRAME_TYPE_SPD ||
+	    ptr[1] != 1 ||
+	    ptr[2] != HDMI_SPD_INFOFRAME_SIZE) {
+		return -EINVAL;
+	}
+
+	if (hdmi_infoframe_checksum(buffer, HDMI_INFOFRAME_SIZE(SPD)) != 0)
+		return -EINVAL;
+
+	ptr += HDMI_INFOFRAME_HEADER_SIZE;
+
+	ret = hdmi_spd_infoframe_init(frame, ptr, ptr + 8);
+	if (ret)
+		return ret;
+
+	frame->sdi = ptr[24];
+
+	return 0;
+}
+
+/**
+ * hdmi_audio_infoframe_unpack() - unpack binary buffer to a HDMI AUDIO infoframe
+ * @buffer: source buffer
+ * @frame: HDMI Audio infoframe
+ *
+ * Unpacks the information contained in binary @buffer into a structured
+ * @frame of the HDMI Audio information frame.
+ * Also verifies the checksum as required by section 5.3.5 of the HDMI 1.4
+ * specification.
+ *
+ * Returns 0 on success or a negative error code on failure.
+ */
+static int hdmi_audio_infoframe_unpack(struct hdmi_audio_infoframe *frame,
+				       void *buffer)
+{
+	u8 *ptr = buffer;
+	int ret;
+
+	if (ptr[0] != HDMI_INFOFRAME_TYPE_AUDIO ||
+	    ptr[1] != 1 ||
+	    ptr[2] != HDMI_AUDIO_INFOFRAME_SIZE) {
+		return -EINVAL;
+	}
+
+	if (hdmi_infoframe_checksum(buffer, HDMI_INFOFRAME_SIZE(AUDIO)) != 0)
+		return -EINVAL;
+
+	ret = hdmi_audio_infoframe_init(frame);
+	if (ret)
+		return ret;
+
+	ptr += HDMI_INFOFRAME_HEADER_SIZE;
+
+	frame->channels = ptr[0] & 0x7;
+	frame->coding_type = (ptr[0] >> 4) & 0xf;
+	frame->sample_size = ptr[1] & 0x3;
+	frame->sample_frequency = (ptr[1] >> 2) & 0x7;
+	frame->coding_type_ext = ptr[2] & 0x1f;
+	frame->channel_allocation = ptr[3];
+	frame->level_shift_value = (ptr[4] >> 3) & 0xf;
+	frame->downmix_inhibit = ptr[4] & 0x80 ? true : false;
+
+	return 0;
+}
+
+/**
+ * hdmi_vendor_infoframe_unpack() - unpack binary buffer to a HDMI vendor infoframe
+ * @buffer: source buffer
+ * @frame: HDMI Vendor infoframe
+ *
+ * Unpacks the information contained in binary @buffer into a structured
+ * @frame of the HDMI Vendor information frame.
+ * Also verifies the checksum as required by section 5.3.5 of the HDMI 1.4
+ * specification.
+ *
+ * Returns 0 on success or a negative error code on failure.
+ */
+static int
+hdmi_vendor_any_infoframe_unpack(union hdmi_vendor_any_infoframe *frame,
+				 void *buffer)
+{
+	u8 *ptr = buffer;
+	size_t length;
+	int ret;
+	u8 hdmi_video_format;
+	struct hdmi_vendor_infoframe *hvf = &frame->hdmi;
+
+	if (ptr[0] != HDMI_INFOFRAME_TYPE_VENDOR ||
+	    ptr[1] != 1 ||
+	    (ptr[2] != 4 && ptr[2] != 5 && ptr[2] != 6))
+		return -EINVAL;
+
+	length = ptr[2];
+
+	if (hdmi_infoframe_checksum(buffer,
+				    HDMI_INFOFRAME_HEADER_SIZE + length) != 0)
+		return -EINVAL;
+
+	ptr += HDMI_INFOFRAME_HEADER_SIZE;
+
+	/* HDMI OUI */
+	if (ptr[0] != 0x03 ||
+	    ptr[1] != 0x0c ||
+	    ptr[2] != 0x00)
+		return -EINVAL;
+
+	hdmi_video_format = ptr[3] >> 5;
+
+	if (hdmi_video_format > 0x2)
+		return -EINVAL;
+
+	ret = hdmi_vendor_infoframe_init(hvf);
+	if (ret)
+		return ret;
+
+	hvf->length = length;
+
+	if (hdmi_video_format == 0x2) {
+		if (length != 5 && length != 6)
+			return -EINVAL;
+		hvf->s3d_struct = ptr[4] >> 4;
+		if (hvf->s3d_struct >= HDMI_3D_STRUCTURE_SIDE_BY_SIDE_HALF) {
+			if (length != 6)
+				return -EINVAL;
+			hvf->s3d_ext_data = ptr[5] >> 4;
+		}
+	} else if (hdmi_video_format == 0x1) {
+		if (length != 5)
+			return -EINVAL;
+		hvf->vic = ptr[4];
+	} else {
+		if (length != 4)
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+/**
+ * hdmi_infoframe_unpack() - unpack binary buffer to a HDMI infoframe
+ * @buffer: source buffer
+ * @frame: HDMI infoframe
+ *
+ * Unpacks the information contained in binary buffer @buffer into a structured
+ * @frame of a HDMI infoframe.
+ * Also verifies the checksum as required by section 5.3.5 of the HDMI 1.4
+ * specification.
+ *
+ * Returns 0 on success or a negative error code on failure.
+ */
+int hdmi_infoframe_unpack(union hdmi_infoframe *frame, void *buffer)
+{
+	int ret;
+	u8 *ptr = buffer;
+
+	switch (ptr[0]) {
+	case HDMI_INFOFRAME_TYPE_AVI:
+		ret = hdmi_avi_infoframe_unpack(&frame->avi, buffer);
+		break;
+	case HDMI_INFOFRAME_TYPE_SPD:
+		ret = hdmi_spd_infoframe_unpack(&frame->spd, buffer);
+		break;
+	case HDMI_INFOFRAME_TYPE_AUDIO:
+		ret = hdmi_audio_infoframe_unpack(&frame->audio, buffer);
+		break;
+	case HDMI_INFOFRAME_TYPE_VENDOR:
+		ret = hdmi_vendor_any_infoframe_unpack(&frame->vendor, buffer);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+/**
+ * drm_mode_sort - sort mode list
+ * @edid_data: modes structures to sort
+ *
+ * Sort @edid_data by favorability, moving good modes to the head of the list.
+ */
+void drm_mode_sort(struct hdmi_edid_data *edid_data)
+{
+	struct drm_display_mode *a, *b;
+	struct drm_display_mode c;
+	int diff, i, j;
+
+	for (i = 0; i < (edid_data->modes - 1); i++) {
+		a = &edid_data->mode_buf[i];
+		for (j = i + 1; j < edid_data->modes; j++) {
+			b = &edid_data->mode_buf[j];
+			diff = ((b->type & DRM_MODE_TYPE_PREFERRED) != 0) -
+				((a->type & DRM_MODE_TYPE_PREFERRED) != 0);
+			if (diff) {
+				if (diff > 0) {
+					c = *a;
+					*a = *b;
+					*b = c;
+				}
+				continue;
+			}
+
+			diff = b->hdisplay * b->vdisplay
+				- a->hdisplay * a->vdisplay;
+			if (diff) {
+				if (diff > 0) {
+					c = *a;
+					*a = *b;
+					*b = c;
+				}
+				continue;
+			}
+
+			diff = b->vrefresh - a->vrefresh;
+			if (diff) {
+				if (diff > 0) {
+					c = *a;
+					*a = *b;
+					*b = c;
+				}
+				continue;
+			}
+
+			diff = b->clock - a->clock;
+			if (diff > 0) {
+				c = *a;
+				*a = *b;
+				*b = c;
+			}
+		}
+	}
+	edid_data->preferred_mode = &edid_data->mode_buf[0];
+}
+
+/**
+ * drm_mode_prune_invalid - remove invalid modes from mode list
+ * @edid_data: structure store mode list
+ * Returns:
+ * Number of valid modes.
+ */
+int drm_mode_prune_invalid(struct hdmi_edid_data *edid_data)
+{
+	int i, j;
+	int num = edid_data->modes;
+	int len = sizeof(struct drm_display_mode);
+	struct drm_display_mode *mode_buf = edid_data->mode_buf;
+
+	for (i = 0; i < num; i++) {
+		if (mode_buf[i].invalid) {
+			/* If mode is invalid, delete it. */
+			for (j = i; j < num - 1; j++)
+				memcpy(&mode_buf[j], &mode_buf[j + 1], len);
+
+			num--;
+			i--;
+		}
+	}
+	/* Clear redundant modes of mode_buf. */
+	memset(&mode_buf[num], 0, len * (edid_data->modes - num));
+
+	edid_data->modes = num;
+	return num;
+}
+
+/**
+ * drm_rk_filter_whitelist - mark modes out of white list from mode list
+ * @edid_data: structure store mode list
+ */
+void drm_rk_filter_whitelist(struct hdmi_edid_data *edid_data)
+{
+	int i, j, white_len;
+
+	if (sizeof(resolution_white)) {
+		white_len = sizeof(resolution_white) /
+			sizeof(resolution_white[0]);
+		for (i = 0; i < edid_data->modes; i++) {
+			for (j = 0; j < white_len; j++) {
+				if (drm_mode_match(&resolution_white[j],
+						   &edid_data->mode_buf[i],
+						   DRM_MODE_MATCH_TIMINGS |
+						   DRM_MODE_MATCH_CLOCK |
+						   DRM_MODE_MATCH_FLAGS))
+					break;
+			}
+
+			if (j == white_len)
+				edid_data->mode_buf[i].invalid = true;
+		}
+	}
+}
+
+static void drm_display_mode_convert(struct drm_display_mode *mode,
+				     struct base_drm_display_mode *base_mode)
+{
+	mode->clock = base_mode->clock;
+	mode->hdisplay = base_mode->hdisplay;
+	mode->hsync_start = base_mode->hsync_start;
+	mode->hsync_end = base_mode->hsync_end;
+	mode->htotal = base_mode->htotal;
+	mode->vdisplay = base_mode->vdisplay;
+	mode->vsync_start = base_mode->vsync_start;
+	mode->vsync_end = base_mode->vsync_end;
+	mode->vtotal = base_mode->vtotal;
+	mode->vrefresh = base_mode->vrefresh;
+	mode->vscan = base_mode->vscan;
+	mode->flags = base_mode->flags;
+	mode->picture_aspect_ratio = base_mode->picture_aspect_ratio;
+}
+
+void drm_rk_select_mode(struct hdmi_edid_data *edid_data,
+			struct base_screen_info *screen_info)
+{
+	int i;
+	struct drm_display_mode mode;
+
+	if (!screen_info) {
+		/* define init resolution here */
+	} else {
+		memset(&mode, 0, sizeof(struct drm_display_mode));
+
+		drm_display_mode_convert(&mode, &screen_info->mode);
+		for (i = 0; i < edid_data->modes; i++) {
+			if (drm_mode_match(&mode,
+					   &edid_data->mode_buf[i],
+					   DRM_MODE_MATCH_TIMINGS |
+					   DRM_MODE_MATCH_CLOCK |
+					   DRM_MODE_MATCH_FLAGS)) {
+				edid_data->preferred_mode =
+					&edid_data->mode_buf[i];
+
+				if (edid_data->mode_buf[i].picture_aspect_ratio)
+					break;
+			}
+		}
+	}
+}
+
+/**
+ * drm_do_probe_ddc_edid() - get EDID information via I2C
+ * @adap: ddc adapter
+ * @buf: EDID data buffer to be filled
+ * @block: 128 byte EDID block to start fetching from
+ * @len: EDID data buffer length to fetch
+ *
+ * Try to fetch EDID information by calling I2C driver functions.
+ *
+ * Return: 0 on success or -1 on failure.
+ */
+static int
+drm_do_probe_ddc_edid(struct ddc_adapter *adap, u8 *buf, unsigned int block,
+		      size_t len)
+{
+	unsigned char start = block * HDMI_EDID_BLOCK_SIZE;
+	unsigned char segment = block >> 1;
+	unsigned char xfers = segment ? 3 : 2;
+	int ret, retries = 5;
+
+	do {
+		struct i2c_msg msgs[] = {
+			{
+				.addr	= DDC_SEGMENT_ADDR,
+				.flags	= 0,
+				.len	= 1,
+				.buf	= &segment,
+			}, {
+				.addr	= DDC_ADDR,
+				.flags	= 0,
+				.len	= 1,
+				.buf	= &start,
+			}, {
+				.addr	= DDC_ADDR,
+				.flags	= I2C_M_RD,
+				.len	= len,
+				.buf	= buf,
+			}
+		};
+
+		if (adap->ops) {
+			ret = adap->ops->xfer(adap->i2c_bus, &msgs[3 - xfers],
+					      xfers);
+			if (!ret)
+				ret = xfers;
+		} else {
+			ret = adap->ddc_xfer(adap, &msgs[3 - xfers], xfers);
+		}
+	} while (ret != xfers && --retries);
+
+	/* All msg transfer successfully. */
+	return ret == xfers ? 0 : -1;
+}
+
+int drm_do_get_edid(struct ddc_adapter *adap, u8 *edid)
+{
+	int i, j, block_num, block = 0;
+	bool edid_corrupt;
+#ifdef DEBUG
+	u8 *buff;
+#endif
+
+	/* base block fetch */
+	for (i = 0; i < 4; i++) {
+		if (drm_do_probe_ddc_edid(adap, edid, 0, HDMI_EDID_BLOCK_SIZE))
+			goto err;
+		if (drm_edid_block_valid(edid, 0, true,
+					 &edid_corrupt))
+			break;
+		if (i == 0 && drm_edid_is_zero(edid, HDMI_EDID_BLOCK_SIZE)) {
+			printf("edid base block is 0, get edid failed\n");
+			goto err;
+		}
+	}
+
+	if (i == 4)
+		goto err;
+
+	block++;
+	/* get the number of extensions */
+	block_num = edid[0x7e];
+
+	for (j = 1; j <= block_num; j++) {
+		for (i = 0; i < 4; i++) {
+			if (drm_do_probe_ddc_edid(adap, &edid[0x80 * j], j,
+						  HDMI_EDID_BLOCK_SIZE))
+				goto err;
+			if (drm_edid_block_valid(&edid[0x80 * j], j,
+						 true, NULL))
+				break;
+		}
+
+		if (i == 4)
+			goto err;
+		block++;
+	}
+
+#ifdef DEBUG
+	printf("RAW EDID:\n");
+	for (i = 0; i < block_num + 1; i++) {
+		buff = &edid[0x80 * i];
+		for (j = 0; j < HDMI_EDID_BLOCK_SIZE; j++) {
+			if (j % 16 == 0)
+				printf("\n");
+			printf("0x%02x, ", buff[j]);
+		}
+		printf("\n");
+	}
+#endif
+
+	return 0;
+
+err:
+	printf("can't get edid block:%d\n", block);
+	/* clear all read edid block, include invalid block */
+	memset(edid, 0, HDMI_EDID_BLOCK_SIZE * (block + 1));
+	return -EFAULT;
+}
+
+static ssize_t hdmi_ddc_read(struct ddc_adapter *adap, u16 addr, u8 offset,
+			     void *buffer, size_t size)
+{
+	struct i2c_msg msgs[2] = {
+		{
+			.addr = addr,
+			.flags = 0,
+			.len = 1,
+			.buf = &offset,
+		}, {
+			.addr = addr,
+			.flags = I2C_M_RD,
+			.len = size,
+			.buf = buffer,
+		}
+	};
+
+	return adap->ddc_xfer(adap, msgs, ARRAY_SIZE(msgs));
+}
+
+static ssize_t hdmi_ddc_write(struct ddc_adapter *adap, u16 addr, u8 offset,
+			      const void *buffer, size_t size)
+{
+	struct i2c_msg msg = {
+		.addr = addr,
+		.flags = 0,
+		.len = 1 + size,
+		.buf = NULL,
+	};
+	void *data;
+	int err;
+
+	data = malloc(1 + size);
+	if (!data)
+		return -ENOMEM;
+
+	msg.buf = data;
+
+	memcpy(data, &offset, sizeof(offset));
+	memcpy(data + 1, buffer, size);
+
+	err = adap->ddc_xfer(adap, &msg, 1);
+
+	free(data);
+
+	return err;
+}
+
+/**
+ * drm_scdc_readb - read a single byte from SCDC
+ * @adap: ddc adapter
+ * @offset: offset of register to read
+ * @value: return location for the register value
+ *
+ * Reads a single byte from SCDC. This is a convenience wrapper around the
+ * drm_scdc_read() function.
+ *
+ * Returns:
+ * 0 on success or a negative error code on failure.
+ */
+u8 drm_scdc_readb(struct ddc_adapter *adap, u8 offset,
+		  u8 *value)
+{
+	return hdmi_ddc_read(adap, SCDC_I2C_SLAVE_ADDRESS, offset, value,
+			     sizeof(*value));
+}
+
+/**
+ * drm_scdc_writeb - write a single byte to SCDC
+ * @adap: ddc adapter
+ * @offset: offset of register to read
+ * @value: return location for the register value
+ *
+ * Writes a single byte to SCDC. This is a convenience wrapper around the
+ * drm_scdc_write() function.
+ *
+ * Returns:
+ * 0 on success or a negative error code on failure.
+ */
+u8 drm_scdc_writeb(struct ddc_adapter *adap, u8 offset,
+		   u8 value)
+{
+	return hdmi_ddc_write(adap, SCDC_I2C_SLAVE_ADDRESS, offset, &value,
+			      sizeof(value));
+}
+
diff --git a/configs/hinlink-h88k-rk3588_defconfig b/configs/hinlink-h88k-rk3588_defconfig
new file mode 100644
index 0000000000..d289259a83
--- /dev/null
+++ b/configs/hinlink-h88k-rk3588_defconfig
@@ -0,0 +1,135 @@
+CONFIG_ARM=y
+CONFIG_SKIP_LOWLEVEL_INIT=y
+CONFIG_SYS_HAS_NONCACHED_MEMORY=y
+CONFIG_COUNTER_FREQUENCY=24000000
+CONFIG_ARCH_ROCKCHIP=y
+CONFIG_SF_DEFAULT_SPEED=24000000
+CONFIG_SF_DEFAULT_MODE=0x2000
+CONFIG_DEFAULT_DEVICE_TREE="rockchip/rk3588-rock-5b"
+CONFIG_ROCKCHIP_RK3588=y
+CONFIG_ROCKCHIP_SPI_IMAGE=y
+CONFIG_SPL_SERIAL=y
+CONFIG_TARGET_ROCK5B_RK3588=y
+CONFIG_DEBUG_UART_BASE=0xFEB50000
+CONFIG_DEBUG_UART_CLOCK=24000000
+CONFIG_SPL_SPI_FLASH_SUPPORT=y
+CONFIG_SPL_SPI=y
+CONFIG_SYS_LOAD_ADDR=0xc00800
+CONFIG_PCI=y
+CONFIG_DEBUG_UART=y
+CONFIG_AHCI=y
+CONFIG_FIT=y
+CONFIG_FIT_VERBOSE=y
+CONFIG_SPL_FIT_SIGNATURE=y
+CONFIG_SPL_LOAD_FIT=y
+CONFIG_LEGACY_IMAGE_FORMAT=y
+CONFIG_DEFAULT_FDT_FILE="rockchip/rk3588-rock-5b.dtb"
+# CONFIG_DISPLAY_CPUINFO is not set
+CONFIG_DISPLAY_BOARDINFO_LATE=y
+CONFIG_SPL_MAX_SIZE=0x40000
+CONFIG_SPL_PAD_TO=0x7f8000
+# CONFIG_SPL_RAW_IMAGE_SUPPORT is not set
+CONFIG_SPL_SPI_LOAD=y
+CONFIG_SYS_SPI_U_BOOT_OFFS=0x60000
+CONFIG_SPL_ATF=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_GPT=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_PCI=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_ROCKUSB=y
+# CONFIG_CMD_SETEXPR is not set
+CONFIG_CMD_REGULATOR=y
+# CONFIG_SPL_DOS_PARTITION is not set
+CONFIG_SPL_OF_CONTROL=y
+CONFIG_OF_LIVE=y
+CONFIG_OF_SPL_REMOVE_PROPS="clock-names interrupt-parent assigned-clocks assigned-clock-rates assigned-clock-parents"
+CONFIG_SPL_DM_SEQ_ALIAS=y
+CONFIG_SPL_REGMAP=y
+CONFIG_SPL_SYSCON=y
+CONFIG_AHCI_PCI=y
+CONFIG_DWC_AHCI=y
+CONFIG_SPL_CLK=y
+# CONFIG_USB_FUNCTION_FASTBOOT is not set
+CONFIG_ROCKCHIP_GPIO=y
+CONFIG_SYS_I2C_ROCKCHIP=y
+CONFIG_MISC=y
+CONFIG_SUPPORT_EMMC_RPMB=y
+CONFIG_MMC_DW=y
+CONFIG_MMC_DW_ROCKCHIP=y
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_SDMA=y
+CONFIG_MMC_SDHCI_ROCKCHIP=y
+CONFIG_SF_DEFAULT_BUS=5
+CONFIG_SPI_FLASH_SFDP_SUPPORT=y
+CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_SPI_FLASH_XTX=y
+CONFIG_PHYLIB=y
+CONFIG_RTL8169=y
+CONFIG_NVME_PCI=y
+CONFIG_PCIE_DW_ROCKCHIP=y
+CONFIG_PHY_ROCKCHIP_INNO_USB2=y
+CONFIG_PHY_ROCKCHIP_NANENG_COMBOPHY=y
+CONFIG_PHY_ROCKCHIP_USBDP=y
+CONFIG_SPL_PINCTRL=y
+CONFIG_PWM_ROCKCHIP=y
+CONFIG_SPL_RAM=y
+CONFIG_SCSI=y
+CONFIG_BAUDRATE=1500000
+CONFIG_DEBUG_UART_SHIFT=2
+CONFIG_SYS_NS16550_MEM32=y
+CONFIG_ROCKCHIP_SFC=y
+CONFIG_SYSRESET=y
+CONFIG_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_GENERIC=y
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_OHCI_GENERIC=y
+CONFIG_USB_DWC3=y
+CONFIG_USB_DWC3_GENERIC=y
+CONFIG_SPL_USB_DWC3_GENERIC=y
+CONFIG_USB_HOST_ETHER=y
+CONFIG_USB_ETHER_ASIX=y
+CONFIG_USB_ETHER_ASIX88179=y
+CONFIG_USB_ETHER_LAN75XX=y
+CONFIG_USB_ETHER_LAN78XX=y
+CONFIG_USB_ETHER_MCS7830=y
+CONFIG_USB_ETHER_RTL8152=y
+CONFIG_USB_ETHER_SMSC95XX=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_USB_FUNCTION_ROCKUSB=y
+CONFIG_ERRNO_STR=y
+
+CONFIG_DEFAULT_DEVICE_TREE="rockchip/rk3588-hinlink-h88k"
+CONFIG_DEFAULT_FDT_FILE="rockchip/rk3588-hinlink-h88k.dtb"
+# CONFIG_OF_LIST="rockchip/rk3588-hinlink-h88k rockchip/rk3588-hinlink-h88k-kernel"
+# CONFIG_SPL_OF_LIST="rockchip/rk3588-hinlink-h88k"
+
+CONFIG_SYSINFO=y
+CONFIG_SYSINFO_SMBIOS=y
+CONFIG_LOG=y
+# CONFIG_LOG_DEFAULT_LEVEL=7
+# CONFIG_LOG_MAX_LEVEL=7
+CONFIG_USB_KEYBOARD=y
+CONFIG_SYS_USB_EVENT_POLL_VIA_CONTROL_EP=y
+CONFIG_CMD_BOOTMENU=y
+# CONFIG_AUTOBOOT_KEYED=y
+# CONFIG_BOOTDELAY=2
+# CONFIG_AUTOBOOT_MENU_SHOW=y
+# CONFIG_BOOTMENU_DISABLE_UBOOT_CONSOLE=y
+CONFIG_CMD_EFIDEBUG=y
+CONFIG_CMD_EFICONFIG=y
+CONFIG_USE_PREBOOT=y
+CONFIG_PREBOOT="pci enum;usb start;nvme scan; setenv bootmenu_0 UEFI Boot Manager=bootefi bootmgr; setenv bootmenu_1 UEFI Maintenance Menu=eficonfig"
+
+CONFIG_DISPLAY=y
+CONFIG_VIDEO=y
+# CONFIG_VIDEO_COPY=y
+CONFIG_DRM_ROCKCHIP_VIDEO_FRAMEBUFFER=y
+CONFIG_DRM_ROCKCHIP=y
+CONFIG_PHY_ROCKCHIP_SAMSUNG_HDPTX_HDMI=y
+CONFIG_DRM_ROCKCHIP_DW_HDMI_QP=y
+# CONFIG_DRM_ROCKCHIP_DW_DP=y
\ No newline at end of file
diff --git a/drivers/core/of_access.c b/drivers/core/of_access.c
index c8db743f52..c29e805e3a 100644
--- a/drivers/core/of_access.c
+++ b/drivers/core/of_access.c
@@ -548,6 +548,25 @@ int of_read_u32_array(const struct device_node *np, const char *propname,
 	return 0;
 }
 
+int of_write_u32_array(const struct device_node *np, const char *propname,
+		       u32 *values, size_t sz)
+{
+	__be32 *val;
+
+	debug("%s: %s: ", __func__, propname);
+	val = of_find_property_value_of_size(np, propname,
+					     sz * sizeof(*values));
+
+	if (IS_ERR(val))
+		return PTR_ERR(val);
+
+	debug("size %zd\n", sz);
+	while (sz--)
+		*val++ = cpu_to_be32p(values++);
+
+	return 0;
+}
+
 int of_read_u32_index(const struct device_node *np, const char *propname,
 		      int index, u32 *outp)
 {
@@ -930,6 +949,26 @@ int of_alias_get_highest_id(const char *stem)
 	return id;
 }
 
+struct device_node *of_alias_get_dev(const char *stem, int id)
+{
+	struct alias_prop *app;
+	struct device_node *np = NULL;
+
+	mutex_lock(&of_mutex);
+	list_for_each_entry(app, &aliases_lookup, link) {
+		if (strcmp(app->stem, stem) != 0)
+			continue;
+
+		if (id == app->id) {
+			np = app->np;
+			break;
+		}
+	}
+	mutex_unlock(&of_mutex);
+
+	return np;
+}
+
 struct device_node *of_get_stdout(void)
 {
 	return of_stdout;
diff --git a/drivers/core/ofnode.c b/drivers/core/ofnode.c
index 21a233f90f..34eaa2e352 100644
--- a/drivers/core/ofnode.c
+++ b/drivers/core/ofnode.c
@@ -621,6 +621,21 @@ int ofnode_read_u32_array(ofnode node, const char *propname,
 	}
 }
 
+int ofnode_write_u32_array(ofnode node, const char *propname,
+			   u32 *values, size_t sz)
+{
+	assert(ofnode_valid(node));
+	debug("%s: %s: ", __func__, propname);
+
+	if (ofnode_is_np(node)) {
+		return of_write_u32_array(ofnode_to_np(node), propname,
+					 values, sz);
+	} else {
+		return fdt_setprop((void *)gd->fdt_blob, ofnode_to_offset(node),
+				   propname, values, sz);
+	}
+}
+
 #if !CONFIG_IS_ENABLED(DM_INLINE_OFNODE)
 bool ofnode_is_enabled(ofnode node)
 {
diff --git a/drivers/phy/rockchip/phy-rockchip-usbdp.c b/drivers/phy/rockchip/phy-rockchip-usbdp.c
index 18e7640279..cae3567e5d 100644
--- a/drivers/phy/rockchip/phy-rockchip-usbdp.c
+++ b/drivers/phy/rockchip/phy-rockchip-usbdp.c
@@ -614,6 +614,8 @@ static int rockchip_u3phy_exit(struct phy *phy)
 {
 	struct rockchip_udphy *udphy = dev_get_priv(phy->dev);
 
+	udphy_u3_port_disable(udphy, true);
+	
 	/* DP only or high-speed */
 	if (!(udphy->mode & UDPHY_MODE_USB) || udphy->hs)
 		return 0;
diff --git a/drivers/usb/dwc3/dwc3-generic.c b/drivers/usb/dwc3/dwc3-generic.c
index 7a00529a2a..04963847a2 100644
--- a/drivers/usb/dwc3/dwc3-generic.c
+++ b/drivers/usb/dwc3/dwc3-generic.c
@@ -155,8 +155,8 @@ static int dwc3_generic_remove(struct udevice *dev,
 		dm_gpio_free(ulpi_reset->dev, ulpi_reset);
 	}
 
-	dwc3_remove(dwc3);
 	dwc3_shutdown_phy(dev, &priv->phys);
+	dwc3_remove(dwc3);
 	unmap_physmem(dwc3->regs, MAP_NOCACHE);
 
 	return 0;
diff --git a/drivers/video/Kconfig b/drivers/video/Kconfig
index 7808ae7919..d7afa0b5a4 100644
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -739,6 +739,7 @@ config VIDEO_IVYBRIDGE_IGD
 	  resolution can be selected in U-Boot.
 
 source "drivers/video/rockchip/Kconfig"
+source "drivers/video/drm/Kconfig"
 
 config VIDEO_ARM_MALIDP
 	bool "Enable Arm Mali Display Processor support"
diff --git a/drivers/video/Makefile b/drivers/video/Makefile
index f3f70cd04a..6a0170a815 100644
--- a/drivers/video/Makefile
+++ b/drivers/video/Makefile
@@ -32,6 +32,7 @@ endif
 obj-$(CONFIG_BACKLIGHT_LM3533) += lm3533_backlight.o
 obj-${CONFIG_EXYNOS_FB} += exynos/
 obj-${CONFIG_VIDEO_ROCKCHIP} += rockchip/
+obj-${CONFIG_DRM_ROCKCHIP} += drm/
 obj-${CONFIG_VIDEO_STM32} += stm32/
 obj-${CONFIG_VIDEO_TEGRA124} += tegra124/
 obj-${CONFIG_$(SPL_)VIDEO_TIDSS} += tidss/
diff --git a/drivers/video/bridge/video-bridge-uclass.c b/drivers/video/bridge/video-bridge-uclass.c
index f389bc6b14..1c79533a89 100644
--- a/drivers/video/bridge/video-bridge-uclass.c
+++ b/drivers/video/bridge/video-bridge-uclass.c
@@ -58,6 +58,15 @@ int video_bridge_read_edid(struct udevice *dev, u8 *buf, int buf_size)
 	return ops->read_edid(dev, buf, buf_size);
 }
 
+int video_bridge_get_timing(struct udevice *dev)
+{
+	struct video_bridge_ops *ops = video_bridge_get_ops(dev);
+
+	if (!ops || !ops->get_timing)
+		return -ENOSYS;
+	return ops->get_timing(dev);
+}
+
 static int video_bridge_pre_probe(struct udevice *dev)
 {
 	struct video_bridge_priv *uc_priv = dev_get_uclass_priv(dev);
diff --git a/drivers/video/drm/Kconfig b/drivers/video/drm/Kconfig
new file mode 100644
index 0000000000..d5f0e411ea
--- /dev/null
+++ b/drivers/video/drm/Kconfig
@@ -0,0 +1,235 @@
+menuconfig DRM_ROCKCHIP
+	bool "Rockchip DRM Support"
+	depends on VIDEO && OF_LIVE
+	select VIDEO_BRIDGE
+	select PHY
+	help
+	  Rockchip SoCs provide video output capabilities for High-Definition
+	  Multimedia Interface (HDMI), Low-voltage Differential Signalling
+	  (LVDS), embedded DisplayPort (eDP) and Display Serial Interface (DSI).
+
+	  This driver supports the on-chip video output device, and targets the
+	  Rockchip RK3288 and RK3399.
+
+config DRM_MEM_RESERVED_SIZE_MBYTES
+	int "Size in Mega Bytes"
+	depends on DRM_ROCKCHIP
+	default 32
+
+config DRM_DP_HELPER
+	bool
+	depends on DRM_ROCKCHIP
+
+config DRM_ROCKCHIP_VIDEO_FRAMEBUFFER
+	bool "Drm Framebuffer"
+	depends on DRM_ROCKCHIP
+
+config DRM_MAXIM_MAX96745
+	bool "Maxim max96745 GMSL2 Serializer"
+	depends on DRM_ROCKCHIP
+	select I2C_MUX_MAX96745
+	select PINCTRL_MAX96745
+	help
+	  Driver for Maxim MAX96745 GMSL2 Serializer with eDP1.4a/DP1.4 Input.
+
+config DRM_MAXIM_MAX96755F
+	bool "Maxim max96755F GMSL2 Serializer"
+	depends on DRM_ROCKCHIP
+	select I2C_MUX_MAX96755F
+	select PINCTRL_MAX96755F
+	help
+	  Driver for Maxim MAX96755F GMSL2 Serializer with MIPI-DSI Input.
+
+config DRM_PANEL_ROHM_BU18RL82
+	bool "Rohm BU18RL82-based panels"
+	depends on DRM_ROCKCHIP
+	help
+	  Say Y if you want to enable support for panels based on the
+	  Rohm BU18RL82.
+
+config DRM_PANEL_MAXIM_MAX96752F
+	bool "Maxim MAX96752F-based panels"
+	depends on DRM_ROCKCHIP
+	help
+	  Say Y if you want to enable support for panels based on the
+	  Maxim MAX96752F.
+
+config DRM_ROCKCHIP_PANEL
+	bool "Rockchip Panel Support"
+	depends on DRM_ROCKCHIP
+	select DRM_MIPI_DSI
+
+config DRM_ROHM_BU18XL82
+	bool "ROHM clockless serializer BU18TL82 and  deserializer BU18RL82"
+	depends on DRM_ROCKCHIP && I2C_MUX
+	help
+	  Driver for ROHM clockless serdes with MIPI or LVDS Input.
+
+config DRM_ROCKCHIP_DW_HDMI
+	bool "Rockchip specific extensions for Synopsys DW HDMI"
+	depends on DRM_ROCKCHIP
+	help
+	 This selects support for Rockchip SoC specific extensions
+	 for the Synopsys DesignWare HDMI driver. If you want to
+	 enable HDMI on, you should selet this option.
+
+config DRM_ROCKCHIP_DW_HDMI_QP
+	bool "Rockchip specific extensions for Synopsys DW HDMI QP"
+	depends on DRM_ROCKCHIP
+	help
+	 This selects support for Rockchip SoC specific extensions
+	 for the Synopsys DesignWare HDMI QP driver. If you want to
+	 enable HDMI on, you should select this option.
+
+config DRM_ROCKCHIP_INNO_HDMI
+	bool "Rockchip specific extensions for INNO HDMI"
+	depends on DRM_ROCKCHIP
+	help
+	 This selects support for Rockchip SoC specific extensions
+	 for the Synopsys DesignWare HDMI driver. If you want to
+	 enable HDMI on, you should selet this option.
+
+config ROCKCHIP_INNO_HDMI_PHY
+	bool "Rockchip specific extensions for INNO HDMI PHY"
+	depends on DRM_ROCKCHIP
+	help
+	 This selects support for INNO HDMI PHY. If you want to
+	 use HDMI or TVE in RK322XH or RK322X, you should selet
+	 this option.
+
+config DRM_ROCKCHIP_INNO_MIPI_PHY
+	tristate "Rockchip INNO MIPI PHY driver"
+	depends on DRM_ROCKCHIP
+	help
+	  Enable this to support the Rockchip MIPI PHY
+	  with Innosilicon IP block.
+
+config DRM_ROCKCHIP_INNO_VIDEO_PHY
+	tristate "Rockchip INNO LVDS/TTL PHY driver"
+	depends on DRM_ROCKCHIP
+	help
+	  Enable this to support the Rockchip LVDS/TTL PHY
+	  with Innosilicon IP block.
+
+config DRM_ROCKCHIP_INNO_VIDEO_COMBO_PHY
+	tristate "Rockchip INNO MIPI/LVDS/TTL PHY driver"
+	depends on DRM_ROCKCHIP
+	help
+	  Enable this to support the Rockchip MIPI/LVDS/TTL PHY
+	  with Innosilicon IP block.
+
+config DRM_MIPI_DSI
+	bool
+	depends on DRM_ROCKCHIP
+
+config DRM_DSC
+	bool
+	depends on DRM_ROCKCHIP
+
+config DRM_ROCKCHIP_DW_MIPI_DSI
+	tristate "Rockchip specific extensions for Synopsys DW MIPI DSI"
+	depends on DRM_ROCKCHIP
+	select DRM_MIPI_DSI
+	select DRM_ROCKCHIP_PANEL
+	help
+	 This selects support for Rockchip SoC specific extensions
+	 for the Synopsys DesignWare HDMI driver. If you want to
+	 enable MIPI DSI on RK3288 based SoC, you should selet this
+	 option.
+
+config DRM_ROCKCHIP_DW_MIPI_DSI2
+	tristate "Rockchip specific extensions for Synopsys DW MIPI DSI2"
+	depends on DRM_ROCKCHIP
+	select DRM_MIPI_DSI
+	select DRM_DSC
+	select DRM_ROCKCHIP_PANEL
+	help
+	 This selects support for Rockchip SoC specific extensions
+	 for the Synopsys DesignWare MIPI DSI2 driver. If you want to
+	 enable MIPI DSI2 on RK3588 based SoC, you should selet this
+	 option.
+
+config DRM_ROCKCHIP_DW_DP
+	bool "Rockchip specific extensions for Synopsys DW DP driver"
+	depends on DRM_ROCKCHIP
+	select DRM_DP_HELPER
+	help
+	  This selects support for Rockchip SoC specific extensions
+	  for the Synopsys DW DP driver. If you want to enable DP
+	  on RK3588 based SoC, you should select this option.
+
+config DRM_ROCKCHIP_ANALOGIX_DP
+	bool "Rockchip specific extensions for Analogix DP driver"
+	depends on DRM_ROCKCHIP
+	select DRM_ROCKCHIP_PANEL
+	select DRM_DP_HELPER
+	help
+	  This selects support for Rockchip SoC specific extensions
+	  for the Analogix Core DP driver. If you want to enable DP
+	  on RK3288 based SoC, you should selet this option.
+
+config DRM_ROCKCHIP_LVDS
+	bool "Rockchip LVDS Support"
+	depends on DRM_ROCKCHIP
+	select DRM_ROCKCHIP_PANEL
+	help
+	  Choose this option to enable support for Rockchip LVDS controllers.
+	  Rockchip rk3288 SoC has LVDS TX Controller can be used, and it
+	  support LVDS, rgb, dual LVDS output mode. say Y to enable its
+	  driver.
+
+config DRM_ROCKCHIP_RGB
+	bool "Rockchip RGB Support"
+	depends on DRM_ROCKCHIP
+	select DRM_ROCKCHIP_PANEL
+	help
+	  Choose this option to enable support for Rockchip RGB driver.
+	  say Y to enable its driver.
+
+config DRM_ROCKCHIP_RK618
+	bool "Rockchip RK618 display bridge driver"
+	depends on DRM_ROCKCHIP
+	select DRM_ROCKCHIP_PANEL
+	select VIDEO_BRIDGE
+	help
+	  Choose this option to enable support for Rockchip RK618 display
+	  bridge chips driver. say Y to enable its driver.
+
+config DRM_ROCKCHIP_RK1000
+	bool "Rockchip RK1000 display bridge driver"
+	depends on DRM_ROCKCHIP
+	select DRM_ROCKCHIP_PANEL
+	select VIDEO_BRIDGE
+	help
+	  Choose this option to enable support for Rockchip RK1000 display
+	  bridge chips driver. say Y to enable its driver.
+
+config DRM_ROCKCHIP_SAMSUNG_MIPI_DCPHY
+	tristate "Rockchip SAMSUNG MIPI DCPHY driver"
+	depends on DRM_ROCKCHIP
+	help
+	  Enable this to support the Rockchip MIPI DCPHY
+	  with SAMSUNG IP block.
+
+config PHY_ROCKCHIP_SAMSUNG_HDPTX_HDMI
+	bool "Rockchip Samsung HDMI/DP Combo PHY HDMI driver"
+	depends on DRM_ROCKCHIP
+	select LIB_RATIONAL
+	help
+	  Support for Rockchip HDMI/DP Combo PHY HDMI with Samsung
+	  IP block.
+
+config DRM_ROCKCHIP_TVE
+	bool "Rockchip TVE Support"
+	depends on DRM_ROCKCHIP
+	help
+	  Choose this option to enable support for Rockchip TVE.
+	  Say Y to enable TVE driver.
+
+config ROCKCHIP_CUBIC_LUT_SIZE
+	int "Rockchip cubic lut size"
+	depends on DRM_ROCKCHIP
+	default 0
+	help
+	  Used to calc cubic lut size.
+
diff --git a/drivers/video/drm/Makefile b/drivers/video/drm/Makefile
new file mode 100644
index 0000000000..4756e674b7
--- /dev/null
+++ b/drivers/video/drm/Makefile
@@ -0,0 +1,44 @@
+#
+# (C) Copyright 2008-2017 Fuzhou Rockchip Electronics Co., Ltd
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y += drm_modes.o
+
+ifndef CONFIG_SPL_BUILD
+obj-y += rockchip_display.o rockchip_display_helper.o rockchip_crtc.o rockchip_phy.o rockchip_bridge.o \
+		rockchip_vop.o rockchip_vop_reg.o rockchip_vop2.o bmp_helper.o \
+		rockchip_connector.o rockchip_post_csc.o libnsbmp.o
+
+obj-$(CONFIG_DRM_MIPI_DSI) += drm_mipi_dsi.o
+obj-$(CONFIG_DRM_DP_HELPER) += drm_dp_helper.o
+obj-$(CONFIG_DRM_DSC) += drm_dsc.o
+obj-$(CONFIG_DRM_MAXIM_MAX96745) += max96745.o
+obj-$(CONFIG_DRM_MAXIM_MAX96755F) += max96755f.o
+obj-$(CONFIG_DRM_PANEL_ROHM_BU18RL82) += panel-rohm-bu18rl82.o
+obj-$(CONFIG_DRM_PANEL_MAXIM_MAX96752F) += panel-maxim-max96752f.o
+obj-$(CONFIG_DRM_ROCKCHIP_DW_MIPI_DSI) += dw_mipi_dsi.o
+obj-$(CONFIG_DRM_ROCKCHIP_DW_MIPI_DSI2) += dw_mipi_dsi2.o
+obj-$(CONFIG_DRM_ROCKCHIP_DW_HDMI) += rockchip_dw_hdmi.o dw_hdmi.o
+obj-$(CONFIG_DRM_ROCKCHIP_DW_HDMI_QP) += rockchip_dw_hdmi_qp.o dw_hdmi_qp.o
+obj-$(CONFIG_ROCKCHIP_INNO_HDMI_PHY) += rockchip-inno-hdmi-phy.o
+obj-$(CONFIG_DRM_ROCKCHIP_INNO_HDMI) += inno_hdmi.o
+obj-$(CONFIG_DRM_ROCKCHIP_INNO_MIPI_PHY) += inno_mipi_phy.o
+obj-$(CONFIG_DRM_ROCKCHIP_INNO_VIDEO_PHY) += inno_video_phy.o
+obj-$(CONFIG_DRM_ROCKCHIP_INNO_VIDEO_COMBO_PHY) += inno_video_combo_phy.o
+obj-$(CONFIG_PHY_ROCKCHIP_SAMSUNG_HDPTX_HDMI) += phy-rockchip-samsung-hdptx-hdmi.o
+obj-$(CONFIG_DRM_ROCKCHIP_TVE) += rockchip_tve.o
+obj-$(CONFIG_DRM_ROCKCHIP_ANALOGIX_DP) += analogix_dp.o analogix_dp_reg.o
+obj-$(CONFIG_DRM_ROCKCHIP_DW_DP) += dw-dp.o
+obj-$(CONFIG_DRM_ROCKCHIP_LVDS) += rockchip_lvds.o drm_of.o
+obj-$(CONFIG_DRM_ROCKCHIP_RGB) += rockchip_rgb.o
+obj-$(CONFIG_DRM_ROCKCHIP_PANEL) += rockchip_panel.o
+obj-$(CONFIG_DRM_ROHM_BU18XL82) += rohm-bu18tl82.o rohm-bu18rl82.o
+obj-$(CONFIG_DRM_ROCKCHIP_RK618) += rk618.o rk618_lvds.o rk618_dsi.o
+obj-$(CONFIG_DRM_ROCKCHIP_RK1000) += rk1000.o rk1000_tve.o
+obj-$(CONFIG_DRM_ROCKCHIP_SAMSUNG_MIPI_DCPHY) += samsung_mipi_dcphy.o
+else
+obj-y += rockchip_spl_display.o rockchip_display_helper.o rockchip_crtc.o rockchip_connector.o rockchip_post_csc.o rockchip_vop2.o rockchip_phy.o rockchip-inno-hdmi-phy.o rockchip_dw_hdmi.o dw_hdmi.o
+endif
+
diff --git a/drivers/video/drm/analogix_dp.c b/drivers/video/drm/analogix_dp.c
new file mode 100644
index 0000000000..9384542ad6
--- /dev/null
+++ b/drivers/video/drm/analogix_dp.c
@@ -0,0 +1,1162 @@
+/*
+ * (C) Copyright 2008-2017 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <config.h>
+#include <common.h>
+#include <errno.h>
+#include <malloc.h>
+#include <asm/unaligned.h>
+#include <asm/io.h>
+#include <dm/device.h>
+#include <dm/of_access.h>
+#include <dm/read.h>
+#include <linux/bitfield.h>
+#include <linux/list.h>
+#include <syscon.h>
+#include <asm/arch-rockchip/clock.h>
+#include <asm/gpio.h>
+
+#include "rockchip_display.h"
+#include "rockchip_crtc.h"
+#include "rockchip_connector.h"
+#include "analogix_dp.h"
+
+#define RK3588_GRF_VO1_CON0	0x0000
+#define EDP_MODE		BIT(0)
+#define RK3588_GRF_VO1_CON1	0x0004
+
+/**
+ * struct rockchip_dp_chip_data - splite the grf setting of kind of chips
+ * @lcdsel_grf_reg: grf register offset of lcdc select
+ * @lcdsel_big: reg value of selecting vop big for eDP
+ * @lcdsel_lit: reg value of selecting vop little for eDP
+ * @chip_type: specific chip type
+ * @ssc: check if SSC is supported by source
+ */
+struct rockchip_dp_chip_data {
+	u32	lcdsel_grf_reg;
+	u32	lcdsel_big;
+	u32	lcdsel_lit;
+	u32	chip_type;
+	bool    ssc;
+
+	u32 max_link_rate;
+	u32 max_lane_count;
+};
+
+static void
+analogix_dp_enable_rx_to_enhanced_mode(struct analogix_dp_device *dp,
+				       bool enable)
+{
+	u8 data;
+
+	analogix_dp_read_byte_from_dpcd(dp, DP_LANE_COUNT_SET, &data);
+
+	if (enable)
+		analogix_dp_write_byte_to_dpcd(dp, DP_LANE_COUNT_SET,
+					       DP_LANE_COUNT_ENHANCED_FRAME_EN |
+					       DPCD_LANE_COUNT_SET(data));
+	else
+		analogix_dp_write_byte_to_dpcd(dp, DP_LANE_COUNT_SET,
+					       DPCD_LANE_COUNT_SET(data));
+}
+
+static int analogix_dp_is_enhanced_mode_available(struct analogix_dp_device *dp)
+{
+	u8 data;
+	int retval;
+
+	analogix_dp_read_byte_from_dpcd(dp, DP_MAX_LANE_COUNT, &data);
+	retval = DPCD_ENHANCED_FRAME_CAP(data);
+
+	return retval;
+}
+
+static void analogix_dp_set_enhanced_mode(struct analogix_dp_device *dp)
+{
+	u8 data;
+
+	data = analogix_dp_is_enhanced_mode_available(dp);
+	analogix_dp_enable_rx_to_enhanced_mode(dp, data);
+	analogix_dp_enable_enhanced_mode(dp, data);
+}
+
+static void analogix_dp_training_pattern_dis(struct analogix_dp_device *dp)
+{
+	analogix_dp_set_training_pattern(dp, DP_NONE);
+
+	analogix_dp_write_byte_to_dpcd(dp, DP_TRAINING_PATTERN_SET,
+				       DP_TRAINING_PATTERN_DISABLE);
+}
+
+static int analogix_dp_link_start(struct analogix_dp_device *dp)
+{
+	u8 buf[4];
+	int lane, lane_count, retval;
+
+	lane_count = dp->link_train.lane_count;
+
+	dp->link_train.lt_state = CLOCK_RECOVERY;
+	dp->link_train.eq_loop = 0;
+
+	for (lane = 0; lane < lane_count; lane++)
+		dp->link_train.cr_loop[lane] = 0;
+
+	/* Set link rate and count as you want to establish*/
+	analogix_dp_set_link_bandwidth(dp, dp->link_train.link_rate);
+	analogix_dp_set_lane_count(dp, dp->link_train.lane_count);
+
+	/* Setup RX configuration */
+	buf[0] = dp->link_train.link_rate;
+	buf[1] = dp->link_train.lane_count;
+	retval = analogix_dp_write_bytes_to_dpcd(dp, DP_LINK_BW_SET, 2, buf);
+	if (retval)
+		return retval;
+
+	/* Spread AMP if required, enable 8b/10b coding */
+	buf[0] = analogix_dp_ssc_supported(dp) ? DP_SPREAD_AMP_0_5 : 0;
+	buf[1] = DP_SET_ANSI_8B10B;
+	retval = analogix_dp_write_bytes_to_dpcd(dp, DP_DOWNSPREAD_CTRL,
+						 2, buf);
+	if (retval < 0)
+		return retval;
+
+	/* Set TX voltage-swing and pre-emphasis to minimum */
+	for (lane = 0; lane < lane_count; lane++)
+		dp->link_train.training_lane[lane] =
+				DP_TRAIN_VOLTAGE_SWING_LEVEL_0 |
+				DP_TRAIN_PRE_EMPH_LEVEL_0;
+	analogix_dp_set_lane_link_training(dp);
+
+	/* Set training pattern 1 */
+	analogix_dp_set_training_pattern(dp, TRAINING_PTN1);
+
+	/* Set RX training pattern */
+	retval = analogix_dp_write_byte_to_dpcd(dp,
+			DP_TRAINING_PATTERN_SET,
+			DP_LINK_SCRAMBLING_DISABLE | DP_TRAINING_PATTERN_1);
+	if (retval)
+		return retval;
+
+	for (lane = 0; lane < lane_count; lane++)
+		buf[lane] = DP_TRAIN_PRE_EMPH_LEVEL_0 |
+			    DP_TRAIN_VOLTAGE_SWING_LEVEL_0;
+
+	retval = analogix_dp_write_bytes_to_dpcd(dp, DP_TRAINING_LANE0_SET,
+						 lane_count, buf);
+
+	return retval;
+}
+
+static unsigned char analogix_dp_get_lane_status(u8 link_status[2], int lane)
+{
+	int shift = (lane & 1) * 4;
+	u8 link_value = link_status[lane >> 1];
+
+	return (link_value >> shift) & 0xf;
+}
+
+static int analogix_dp_clock_recovery_ok(u8 link_status[2], int lane_count)
+{
+	int lane;
+	u8 lane_status;
+
+	for (lane = 0; lane < lane_count; lane++) {
+		lane_status = analogix_dp_get_lane_status(link_status, lane);
+		if ((lane_status & DP_LANE_CR_DONE) == 0)
+			return -EINVAL;
+	}
+	return 0;
+}
+
+static int analogix_dp_channel_eq_ok(u8 link_status[2], u8 link_align,
+				     int lane_count)
+{
+	int lane;
+	u8 lane_status;
+
+	if ((link_align & DP_INTERLANE_ALIGN_DONE) == 0)
+		return -EINVAL;
+
+	for (lane = 0; lane < lane_count; lane++) {
+		lane_status = analogix_dp_get_lane_status(link_status, lane);
+		lane_status &= DP_CHANNEL_EQ_BITS;
+		if (lane_status != DP_CHANNEL_EQ_BITS)
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static unsigned char
+analogix_dp_get_adjust_request_voltage(u8 adjust_request[2], int lane)
+{
+	int shift = (lane & 1) * 4;
+	u8 link_value = adjust_request[lane >> 1];
+
+	return (link_value >> shift) & 0x3;
+}
+
+static unsigned char analogix_dp_get_adjust_request_pre_emphasis(
+					u8 adjust_request[2],
+					int lane)
+{
+	int shift = (lane & 1) * 4;
+	u8 link_value = adjust_request[lane >> 1];
+
+	return ((link_value >> shift) & 0xc) >> 2;
+}
+
+static void analogix_dp_reduce_link_rate(struct analogix_dp_device *dp)
+{
+	analogix_dp_training_pattern_dis(dp);
+	analogix_dp_set_enhanced_mode(dp);
+
+	dp->link_train.lt_state = FAILED;
+}
+
+static void analogix_dp_get_adjust_training_lane(struct analogix_dp_device *dp,
+						 u8 adjust_request[2])
+{
+	int lane, lane_count;
+	u8 voltage_swing, pre_emphasis, training_lane;
+
+	lane_count = dp->link_train.lane_count;
+	for (lane = 0; lane < lane_count; lane++) {
+		voltage_swing = analogix_dp_get_adjust_request_voltage(
+						adjust_request, lane);
+		pre_emphasis = analogix_dp_get_adjust_request_pre_emphasis(
+						adjust_request, lane);
+		training_lane = DPCD_VOLTAGE_SWING_SET(voltage_swing) |
+				DPCD_PRE_EMPHASIS_SET(pre_emphasis);
+
+		if (voltage_swing == VOLTAGE_LEVEL_3)
+			training_lane |= DP_TRAIN_MAX_SWING_REACHED;
+		if (pre_emphasis == PRE_EMPHASIS_LEVEL_3)
+			training_lane |= DP_TRAIN_MAX_PRE_EMPHASIS_REACHED;
+
+		dp->link_train.training_lane[lane] = training_lane;
+	}
+}
+
+static bool analogix_dp_tps3_supported(struct analogix_dp_device *dp)
+{
+	bool source_tps3_supported, sink_tps3_supported;
+	u8 dpcd = 0;
+
+	source_tps3_supported =
+		dp->video_info.max_link_rate == DP_LINK_BW_5_4;
+	analogix_dp_read_byte_from_dpcd(dp, DP_MAX_LANE_COUNT, &dpcd);
+	sink_tps3_supported = dpcd & DP_TPS3_SUPPORTED;
+
+	return source_tps3_supported && sink_tps3_supported;
+}
+
+static int analogix_dp_process_clock_recovery(struct analogix_dp_device *dp)
+{
+	int lane, lane_count, retval;
+	u8 voltage_swing, pre_emphasis, training_lane;
+	u8 link_status[2], adjust_request[2];
+	u8 training_pattern = TRAINING_PTN2;
+
+	drm_dp_link_train_clock_recovery_delay(dp->dpcd);
+
+	lane_count = dp->link_train.lane_count;
+
+	retval =  analogix_dp_read_bytes_from_dpcd(dp,
+			DP_LANE0_1_STATUS, 2, link_status);
+	if (retval)
+		return retval;
+
+	if (analogix_dp_clock_recovery_ok(link_status, lane_count) == 0) {
+		if (analogix_dp_tps3_supported(dp))
+			training_pattern = TRAINING_PTN3;
+
+		/* set training pattern for EQ */
+		analogix_dp_set_training_pattern(dp, training_pattern);
+
+		retval = analogix_dp_write_byte_to_dpcd(dp,
+				DP_TRAINING_PATTERN_SET,
+				(training_pattern == TRAINING_PTN3 ?
+				 DP_TRAINING_PATTERN_3 : DP_TRAINING_PATTERN_2));
+		if (retval)
+			return retval;
+
+		dev_info(dp->dev, "Link Training Clock Recovery success\n");
+		dp->link_train.lt_state = EQUALIZER_TRAINING;
+
+		return 0;
+	} else {
+		retval = analogix_dp_read_bytes_from_dpcd(dp,
+				DP_ADJUST_REQUEST_LANE0_1, 2, adjust_request);
+		if (retval)
+			return retval;
+
+		for (lane = 0; lane < lane_count; lane++) {
+			training_lane = analogix_dp_get_lane_link_training(
+							dp, lane);
+			voltage_swing = analogix_dp_get_adjust_request_voltage(
+							adjust_request, lane);
+			pre_emphasis = analogix_dp_get_adjust_request_pre_emphasis(
+							adjust_request, lane);
+
+			if (DPCD_VOLTAGE_SWING_GET(training_lane) ==
+					voltage_swing &&
+			    DPCD_PRE_EMPHASIS_GET(training_lane) ==
+					pre_emphasis)
+				dp->link_train.cr_loop[lane]++;
+
+			if (dp->link_train.cr_loop[lane] == MAX_CR_LOOP ||
+			    voltage_swing == VOLTAGE_LEVEL_3 ||
+			    pre_emphasis == PRE_EMPHASIS_LEVEL_3) {
+				dev_err(dp->dev, "CR Max reached (%d,%d,%d)\n",
+					dp->link_train.cr_loop[lane],
+					voltage_swing, pre_emphasis);
+				analogix_dp_reduce_link_rate(dp);
+				return -EIO;
+			}
+		}
+	}
+
+	analogix_dp_get_adjust_training_lane(dp, adjust_request);
+	analogix_dp_set_lane_link_training(dp);
+
+	retval = analogix_dp_write_bytes_to_dpcd(dp,
+			DP_TRAINING_LANE0_SET, lane_count,
+			dp->link_train.training_lane);
+	if (retval)
+		return retval;
+
+	return retval;
+}
+
+static int analogix_dp_process_equalizer_training(struct analogix_dp_device *dp)
+{
+	int lane_count, retval;
+	u32 reg;
+	u8 link_align, link_status[2], adjust_request[2];
+
+	drm_dp_link_train_channel_eq_delay(dp->dpcd);
+
+	lane_count = dp->link_train.lane_count;
+
+	retval = analogix_dp_read_bytes_from_dpcd(dp,
+			DP_LANE0_1_STATUS, 2, link_status);
+	if (retval)
+		return retval;
+
+	if (analogix_dp_clock_recovery_ok(link_status, lane_count)) {
+		analogix_dp_reduce_link_rate(dp);
+		return -EIO;
+	}
+
+	retval = analogix_dp_read_byte_from_dpcd(dp,
+			DP_LANE_ALIGN_STATUS_UPDATED, &link_align);
+	if (retval)
+		return retval;
+
+	if (!analogix_dp_channel_eq_ok(link_status, link_align, lane_count)) {
+		/* traing pattern Set to Normal */
+		analogix_dp_training_pattern_dis(dp);
+
+		printf("Link Training success!\n");
+
+		analogix_dp_get_link_bandwidth(dp, &reg);
+		dp->link_train.link_rate = reg;
+		analogix_dp_get_lane_count(dp, &reg);
+		dp->link_train.lane_count = reg;
+
+		printf("final link rate = 0x%.2x, lane count = 0x%.2x\n",
+		       dp->link_train.link_rate, dp->link_train.lane_count);
+
+		/* set enhanced mode if available */
+		analogix_dp_set_enhanced_mode(dp);
+		dp->link_train.lt_state = FINISHED;
+
+		return 0;
+	}
+
+	/* not all locked */
+	dp->link_train.eq_loop++;
+
+	if (dp->link_train.eq_loop > MAX_EQ_LOOP) {
+		dev_dbg(dp->dev, "EQ Max loop\n");
+		analogix_dp_reduce_link_rate(dp);
+		return -EIO;
+	}
+
+	retval = analogix_dp_read_bytes_from_dpcd(dp,
+			DP_ADJUST_REQUEST_LANE0_1, 2, adjust_request);
+	if (retval)
+		return retval;
+
+	analogix_dp_get_adjust_training_lane(dp, adjust_request);
+	analogix_dp_set_lane_link_training(dp);
+
+	retval = analogix_dp_write_bytes_to_dpcd(dp, DP_TRAINING_LANE0_SET,
+			lane_count, dp->link_train.training_lane);
+
+	return retval;
+}
+
+static void analogix_dp_get_max_rx_bandwidth(struct analogix_dp_device *dp,
+					     u8 *bandwidth)
+{
+	u8 data;
+
+	/*
+	 * For DP rev.1.1, Maximum link rate of Main Link lanes
+	 * 0x06 = 1.62 Gbps, 0x0a = 2.7 Gbps
+	 * For DP rev.1.2, Maximum link rate of Main Link lanes
+	 * 0x06 = 1.62 Gbps, 0x0a = 2.7 Gbps, 0x14 = 5.4Gbps
+	 */
+	analogix_dp_read_byte_from_dpcd(dp, DP_MAX_LINK_RATE, &data);
+	*bandwidth = data;
+}
+
+static void analogix_dp_get_max_rx_lane_count(struct analogix_dp_device *dp,
+					      u8 *lane_count)
+{
+	u8 data;
+
+	/*
+	 * For DP rev.1.1, Maximum number of Main Link lanes
+	 * 0x01 = 1 lane, 0x02 = 2 lanes, 0x04 = 4 lanes
+	 */
+	analogix_dp_read_byte_from_dpcd(dp, DP_MAX_LANE_COUNT, &data);
+	*lane_count = DPCD_MAX_LANE_COUNT(data);
+}
+
+static int analogix_dp_init_training(struct analogix_dp_device *dp,
+				     enum link_lane_count_type max_lane,
+				     int max_rate)
+{
+	u8 dpcd;
+
+	/*
+	 * MACRO_RST must be applied after the PLL_LOCK to avoid
+	 * the DP inter pair skew issue for at least 10 us
+	 */
+	analogix_dp_reset_macro(dp);
+
+	/* Initialize by reading RX's DPCD */
+	analogix_dp_get_max_rx_bandwidth(dp, &dp->link_train.link_rate);
+	analogix_dp_get_max_rx_lane_count(dp, &dp->link_train.lane_count);
+
+	/* Setup TX lane count & rate */
+	dp->link_train.lane_count = min_t(u8, dp->link_train.lane_count,
+					  max_lane);
+	dp->link_train.link_rate = min_t(u32, dp->link_train.link_rate,
+					 max_rate);
+
+	analogix_dp_read_byte_from_dpcd(dp, DP_MAX_DOWNSPREAD, &dpcd);
+	dp->link_train.ssc = !!(dpcd & DP_MAX_DOWNSPREAD_0_5);
+
+	/* All DP analog module power up */
+	analogix_dp_set_analog_power_down(dp, POWER_ALL, 0);
+
+	return 0;
+}
+
+static int analogix_dp_sw_link_training(struct analogix_dp_device *dp)
+{
+	int retval = 0, training_finished = 0;
+
+	dp->link_train.lt_state = START;
+
+	/* Process here */
+	while (!retval && !training_finished) {
+		switch (dp->link_train.lt_state) {
+		case START:
+			retval = analogix_dp_link_start(dp);
+			if (retval)
+				dev_err(dp->dev, "LT link start failed!\n");
+			break;
+		case CLOCK_RECOVERY:
+			retval = analogix_dp_process_clock_recovery(dp);
+			if (retval)
+				dev_err(dp->dev, "LT CR failed!\n");
+			break;
+		case EQUALIZER_TRAINING:
+			retval = analogix_dp_process_equalizer_training(dp);
+			if (retval)
+				dev_err(dp->dev, "LT EQ failed!\n");
+			break;
+		case FINISHED:
+			training_finished = 1;
+			break;
+		case FAILED:
+			return -EREMOTEIO;
+		}
+	}
+
+	return retval;
+}
+
+static int analogix_dp_set_link_train(struct analogix_dp_device *dp,
+				      u32 count, u32 bwtype)
+{
+	int i, ret;
+
+	for (i = 0; i < 5; i++) {
+		ret = analogix_dp_init_training(dp, count, bwtype);
+		if (ret < 0) {
+			dev_err(dp->dev, "failed to init training\n");
+			return ret;
+		}
+
+		ret = analogix_dp_sw_link_training(dp);
+		if (!ret)
+			break;
+	}
+
+	return ret;
+}
+
+static int analogix_dp_config_video(struct analogix_dp_device *dp)
+{
+	int timeout_loop = 0;
+	int done_count = 0;
+
+	analogix_dp_config_video_slave_mode(dp);
+
+	analogix_dp_set_video_color_format(dp);
+
+	if (analogix_dp_get_pll_lock_status(dp) == PLL_UNLOCKED) {
+		dev_err(dp->dev, "PLL is not locked yet.\n");
+		return -EINVAL;
+	}
+
+	for (;;) {
+		timeout_loop++;
+		if (analogix_dp_is_slave_video_stream_clock_on(dp) == 0)
+			break;
+		if (timeout_loop > DP_TIMEOUT_LOOP_COUNT) {
+			dev_err(dp->dev, "Timeout of video streamclk ok\n");
+			return -ETIMEDOUT;
+		}
+
+		udelay(2);
+	}
+
+	/* Set to use the register calculated M/N video */
+	analogix_dp_set_video_cr_mn(dp, CALCULATED_M, 0, 0);
+
+	/* For video bist, Video timing must be generated by register */
+	analogix_dp_set_video_timing_mode(dp, VIDEO_TIMING_FROM_REGISTER);
+
+	/* Disable video mute */
+	analogix_dp_enable_video_mute(dp, 0);
+
+	/* Configure video slave mode */
+	analogix_dp_enable_video_master(dp, 0);
+
+	/* Enable video input */
+	analogix_dp_start_video(dp);
+
+	timeout_loop = 0;
+
+	for (;;) {
+		timeout_loop++;
+		if (analogix_dp_is_video_stream_on(dp) == 0) {
+			done_count++;
+			if (done_count > 10)
+				break;
+		} else if (done_count) {
+			done_count = 0;
+		}
+		if (timeout_loop > DP_TIMEOUT_LOOP_COUNT) {
+			dev_err(dp->dev, "Timeout of video streamclk ok\n");
+			return -ETIMEDOUT;
+		}
+
+		udelay(1001);
+	}
+
+	return 0;
+}
+
+static void analogix_dp_enable_scramble(struct analogix_dp_device *dp,
+					bool enable)
+{
+	u8 data;
+
+	if (enable) {
+		analogix_dp_enable_scrambling(dp);
+
+		analogix_dp_read_byte_from_dpcd(dp, DP_TRAINING_PATTERN_SET,
+						&data);
+		analogix_dp_write_byte_to_dpcd(dp,
+			DP_TRAINING_PATTERN_SET,
+			(u8)(data & ~DP_LINK_SCRAMBLING_DISABLE));
+	} else {
+		analogix_dp_disable_scrambling(dp);
+
+		analogix_dp_read_byte_from_dpcd(dp, DP_TRAINING_PATTERN_SET,
+						&data);
+		analogix_dp_write_byte_to_dpcd(dp,
+			DP_TRAINING_PATTERN_SET,
+			(u8)(data | DP_LINK_SCRAMBLING_DISABLE));
+	}
+}
+
+static void analogix_dp_init_dp(struct analogix_dp_device *dp)
+{
+	analogix_dp_reset(dp);
+
+	analogix_dp_swreset(dp);
+
+	analogix_dp_init_analog_param(dp);
+	analogix_dp_init_interrupt(dp);
+
+	/* SW defined function Normal operation */
+	analogix_dp_enable_sw_function(dp);
+
+	analogix_dp_config_interrupt(dp);
+	analogix_dp_init_analog_func(dp);
+
+	analogix_dp_init_hpd(dp);
+	analogix_dp_init_aux(dp);
+}
+
+static unsigned char analogix_dp_calc_edid_check_sum(unsigned char *edid_data)
+{
+	int i;
+	unsigned char sum = 0;
+
+	for (i = 0; i < EDID_BLOCK_LENGTH; i++)
+		sum = sum + edid_data[i];
+
+	return sum;
+}
+
+static int analogix_dp_read_edid(struct analogix_dp_device *dp)
+{
+	unsigned char *edid = dp->edid;
+	unsigned int extend_block = 0;
+	unsigned char test_vector;
+	int retval;
+
+	/*
+	 * EDID device address is 0x50.
+	 * However, if necessary, you must have set upper address
+	 * into E-EDID in I2C device, 0x30.
+	 */
+
+	/* Read Extension Flag, Number of 128-byte EDID extension blocks */
+	retval = analogix_dp_read_byte_from_i2c(dp, I2C_EDID_DEVICE_ADDR,
+						EDID_EXTENSION_FLAG,
+						&extend_block);
+	if (retval)
+		return retval;
+
+	if (extend_block > 0) {
+		debug("EDID data includes a single extension!\n");
+
+		/* Read EDID data */
+		retval = analogix_dp_read_bytes_from_i2c(dp,
+						I2C_EDID_DEVICE_ADDR,
+						EDID_HEADER_PATTERN,
+						EDID_BLOCK_LENGTH,
+						&edid[EDID_HEADER_PATTERN]);
+		if (retval < 0)
+			return retval;
+
+		if (analogix_dp_calc_edid_check_sum(edid))
+			return -EINVAL;
+
+		/* Read additional EDID data */
+		retval = analogix_dp_read_bytes_from_i2c(dp,
+				I2C_EDID_DEVICE_ADDR,
+				EDID_BLOCK_LENGTH,
+				EDID_BLOCK_LENGTH,
+				&edid[EDID_BLOCK_LENGTH]);
+		if (retval < 0)
+			return retval;
+
+		if (analogix_dp_calc_edid_check_sum(&edid[EDID_BLOCK_LENGTH]))
+			return -EINVAL;
+
+		analogix_dp_read_byte_from_dpcd(dp, DP_TEST_REQUEST,
+						&test_vector);
+		if (test_vector & DP_TEST_LINK_EDID_READ) {
+			analogix_dp_write_byte_to_dpcd(dp,
+				DP_TEST_EDID_CHECKSUM,
+				edid[EDID_BLOCK_LENGTH + EDID_CHECKSUM]);
+			analogix_dp_write_byte_to_dpcd(dp,
+				DP_TEST_RESPONSE,
+				DP_TEST_EDID_CHECKSUM_WRITE);
+		}
+	} else {
+		dev_info(dp->dev,
+			 "EDID data does not include any extensions.\n");
+
+		/* Read EDID data */
+		retval = analogix_dp_read_bytes_from_i2c(dp,
+				I2C_EDID_DEVICE_ADDR, EDID_HEADER_PATTERN,
+				EDID_BLOCK_LENGTH, &edid[EDID_HEADER_PATTERN]);
+		if (retval < 0)
+			return retval;
+
+		if (analogix_dp_calc_edid_check_sum(edid))
+			return -EINVAL;
+
+		analogix_dp_read_byte_from_dpcd(dp, DP_TEST_REQUEST,
+						&test_vector);
+		if (test_vector & DP_TEST_LINK_EDID_READ) {
+			analogix_dp_write_byte_to_dpcd(dp,
+				DP_TEST_EDID_CHECKSUM, edid[EDID_CHECKSUM]);
+			analogix_dp_write_byte_to_dpcd(dp,
+				DP_TEST_RESPONSE, DP_TEST_EDID_CHECKSUM_WRITE);
+		}
+	}
+
+	return 0;
+}
+
+static int analogix_dp_handle_edid(struct analogix_dp_device *dp)
+{
+	u8 buf[12];
+	int i, try = 5;
+	int retval;
+
+retry:
+	/* Read DPCD DP_DPCD_REV~RECEIVE_PORT1_CAP_1 */
+	retval = analogix_dp_read_bytes_from_dpcd(dp, DP_DPCD_REV, 12, buf);
+
+	if (retval && try--) {
+		mdelay(10);
+		goto retry;
+	}
+
+	if (retval)
+		return retval;
+
+	/* Read EDID */
+	for (i = 0; i < 3; i++) {
+		retval = analogix_dp_read_edid(dp);
+		if (!retval)
+			break;
+	}
+
+	return retval;
+}
+
+static int analogix_dp_connector_init(struct rockchip_connector *conn, struct display_state *state)
+{
+	struct connector_state *conn_state = &state->conn_state;
+	struct analogix_dp_device *dp = dev_get_priv(conn->dev);
+
+	conn_state->output_if |= dp->id ? VOP_OUTPUT_IF_eDP1 : VOP_OUTPUT_IF_eDP0;
+	conn_state->output_mode = ROCKCHIP_OUT_MODE_AAAA;
+	conn_state->color_space = V4L2_COLORSPACE_DEFAULT;
+
+	reset_assert_bulk(&dp->resets);
+	udelay(1);
+	reset_deassert_bulk(&dp->resets);
+
+	conn_state->disp_info  = rockchip_get_disp_info(conn_state->type, dp->id);
+	generic_phy_set_mode(&dp->phy, PHY_MODE_DP);
+	generic_phy_power_on(&dp->phy);
+	analogix_dp_init_dp(dp);
+
+	return 0;
+}
+
+static int analogix_dp_connector_get_edid(struct rockchip_connector *conn,
+					  struct display_state *state)
+{
+	struct connector_state *conn_state = &state->conn_state;
+	struct analogix_dp_device *dp = dev_get_priv(conn->dev);
+	int ret;
+
+	ret = analogix_dp_handle_edid(dp);
+	if (ret) {
+		dev_err(dp->dev, "failed to get edid\n");
+		return ret;
+	}
+
+	memcpy(&conn_state->edid, &dp->edid, sizeof(dp->edid));
+
+	return 0;
+}
+
+static int analogix_dp_link_power_up(struct analogix_dp_device *dp)
+{
+	u8 value;
+	int ret;
+
+	if (dp->dpcd[DP_DPCD_REV] < 0x11)
+		return 0;
+
+	ret = analogix_dp_read_byte_from_dpcd(dp, DP_SET_POWER, &value);
+	if (ret < 0)
+		return ret;
+
+	value &= ~DP_SET_POWER_MASK;
+	value |= DP_SET_POWER_D0;
+
+	ret = analogix_dp_write_byte_to_dpcd(dp, DP_SET_POWER, value);
+	if (ret < 0)
+		return ret;
+
+	mdelay(1);
+
+	return 0;
+}
+
+static int analogix_dp_link_power_down(struct analogix_dp_device *dp)
+{
+	u8 value;
+	int ret;
+
+	if (dp->dpcd[DP_DPCD_REV] < 0x11)
+		return 0;
+
+	ret = analogix_dp_read_byte_from_dpcd(dp, DP_SET_POWER, &value);
+	if (ret < 0)
+		return ret;
+
+	value &= ~DP_SET_POWER_MASK;
+	value |= DP_SET_POWER_D3;
+
+	ret = analogix_dp_write_byte_to_dpcd(dp, DP_SET_POWER, value);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int analogix_dp_connector_enable(struct rockchip_connector *conn,
+					struct display_state *state)
+{
+	struct connector_state *conn_state = &state->conn_state;
+	struct crtc_state *crtc_state = &state->crtc_state;
+	const struct rockchip_dp_chip_data *pdata =
+		(const struct rockchip_dp_chip_data *)dev_get_driver_data(conn->dev);
+	struct analogix_dp_device *dp = dev_get_priv(conn->dev);
+	struct video_info *video = &dp->video_info;
+	u32 val;
+	int ret;
+
+	if (pdata->lcdsel_grf_reg) {
+		if (crtc_state->crtc_id)
+			val = pdata->lcdsel_lit;
+		else
+			val = pdata->lcdsel_big;
+
+		regmap_write(dp->grf, pdata->lcdsel_grf_reg, val);
+	}
+
+	if (pdata->chip_type == RK3588_EDP)
+		regmap_write(dp->grf, dp->id ? RK3588_GRF_VO1_CON1 : RK3588_GRF_VO1_CON0,
+			     EDP_MODE << 16 | FIELD_PREP(EDP_MODE, 1));
+
+	switch (conn_state->bpc) {
+	case 12:
+		video->color_depth = COLOR_12;
+		break;
+	case 10:
+		video->color_depth = COLOR_10;
+		break;
+	case 6:
+		video->color_depth = COLOR_6;
+		break;
+	case 8:
+	default:
+		video->color_depth = COLOR_8;
+		break;
+	}
+
+	ret = analogix_dp_read_bytes_from_dpcd(dp, DP_DPCD_REV,
+					       DP_RECEIVER_CAP_SIZE, dp->dpcd);
+	if (ret) {
+		dev_err(dp->dev, "failed to read dpcd caps: %d\n", ret);
+		return ret;
+	}
+
+	ret = analogix_dp_link_power_up(dp);
+	if (ret) {
+		dev_err(dp->dev, "failed to power up link: %d\n", ret);
+		return ret;
+	}
+
+	ret = analogix_dp_set_link_train(dp, dp->video_info.max_lane_count,
+					 dp->video_info.max_link_rate);
+	if (ret) {
+		dev_err(dp->dev, "unable to do link train\n");
+		return ret;
+	}
+
+	analogix_dp_enable_scramble(dp, 1);
+	analogix_dp_enable_rx_to_enhanced_mode(dp, 1);
+	analogix_dp_enable_enhanced_mode(dp, 1);
+
+	analogix_dp_init_video(dp);
+	analogix_dp_set_video_format(dp, &conn_state->mode);
+
+	if (dp->video_bist_enable)
+		analogix_dp_video_bist_enable(dp);
+
+	ret = analogix_dp_config_video(dp);
+	if (ret) {
+		dev_err(dp->dev, "unable to config video\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int analogix_dp_connector_disable(struct rockchip_connector *conn,
+					 struct display_state *state)
+{
+	const struct rockchip_dp_chip_data *pdata =
+		(const struct rockchip_dp_chip_data *)dev_get_driver_data(conn->dev);
+	struct analogix_dp_device *dp = dev_get_priv(conn->dev);
+
+	if (!analogix_dp_get_plug_in_status(dp))
+		analogix_dp_link_power_down(dp);
+
+	if (pdata->chip_type == RK3588_EDP)
+		regmap_write(dp->grf, dp->id ? RK3588_GRF_VO1_CON1 : RK3588_GRF_VO1_CON0,
+			     EDP_MODE << 16 | FIELD_PREP(EDP_MODE, 0));
+
+	return 0;
+}
+
+static int analogix_dp_connector_detect(struct rockchip_connector *conn,
+					struct display_state *state)
+{
+	struct analogix_dp_device *dp = dev_get_priv(conn->dev);
+
+	return analogix_dp_detect(dp);
+}
+
+static int analogix_dp_connector_mode_valid(struct rockchip_connector *conn,
+					    struct display_state *state)
+{
+	struct connector_state *conn_state = &state->conn_state;
+	struct videomode vm;
+
+	drm_display_mode_to_videomode(&conn_state->mode, &vm);
+
+	if (!vm.hfront_porch || !vm.hback_porch || !vm.vfront_porch || !vm.vback_porch) {
+		dev_err(dp->dev, "front porch or back porch can not be 0\n");
+		return MODE_BAD;
+	}
+
+	return MODE_OK;
+}
+
+static const struct rockchip_connector_funcs analogix_dp_connector_funcs = {
+	.init = analogix_dp_connector_init,
+	.get_edid = analogix_dp_connector_get_edid,
+	.enable = analogix_dp_connector_enable,
+	.disable = analogix_dp_connector_disable,
+	.detect = analogix_dp_connector_detect,
+	.mode_valid = analogix_dp_connector_mode_valid,
+};
+
+static u32 analogix_dp_parse_link_frequencies(struct analogix_dp_device *dp)
+{
+	struct udevice *dev = dp->dev;
+	const struct device_node *endpoint;
+	u64 frequency = 0;
+
+	endpoint = rockchip_of_graph_get_endpoint_by_regs(dev->node, 1, 0);
+	if (!endpoint)
+		return 0;
+
+	if (of_property_read_u64(endpoint, "link-frequencies", &frequency) < 0)
+		return 0;
+
+	if (!frequency)
+		return 0;
+
+	do_div(frequency, 10 * 1000);	/* symbol rate kbytes */
+
+	switch (frequency) {
+	case 162000:
+	case 270000:
+	case 540000:
+		break;
+	default:
+		dev_err(dev, "invalid link frequency value: %llu\n", frequency);
+		return 0;
+	}
+
+	return frequency;
+}
+
+static int analogix_dp_parse_dt(struct analogix_dp_device *dp)
+{
+	struct udevice *dev = dp->dev;
+	int len;
+	u32 num_lanes;
+	u32 max_link_rate;
+	int ret;
+
+	dp->force_hpd = dev_read_bool(dev, "force-hpd");
+	dp->video_bist_enable = dev_read_bool(dev, "analogix,video-bist-enable");
+	dp->video_info.force_stream_valid =
+		dev_read_bool(dev, "analogix,force-stream-valid");
+
+	max_link_rate = analogix_dp_parse_link_frequencies(dp);
+	if (max_link_rate && max_link_rate < drm_dp_bw_code_to_link_rate(dp->video_info.max_link_rate))
+		dp->video_info.max_link_rate = drm_dp_link_rate_to_bw_code(max_link_rate);
+
+	if (dev_read_prop(dev, "data-lanes", &len)) {
+		num_lanes = len / sizeof(u32);
+		if (num_lanes < 1 || num_lanes > 4 || num_lanes == 3) {
+			dev_err(dev, "bad number of data lanes\n");
+			return -EINVAL;
+		}
+
+		ret = dev_read_u32_array(dev, "data-lanes", dp->lane_map,
+					 num_lanes);
+		if (ret)
+			return ret;
+
+		dp->video_info.max_lane_count = num_lanes;
+	} else {
+		dp->lane_map[0] = 0;
+		dp->lane_map[1] = 1;
+		dp->lane_map[2] = 2;
+		dp->lane_map[3] = 3;
+	}
+
+	return 0;
+}
+
+static int analogix_dp_probe(struct udevice *dev)
+{
+	struct analogix_dp_device *dp = dev_get_priv(dev);
+	const struct rockchip_dp_chip_data *pdata =
+		(const struct rockchip_dp_chip_data *)dev_get_driver_data(dev);
+	struct udevice *syscon;
+	int ret;
+
+	dp->reg_base = dev_read_addr_ptr(dev);
+
+	dp->id = of_alias_get_id(ofnode_to_np(dev->node), "edp");
+	if (dp->id < 0)
+		dp->id = 0;
+
+	ret = uclass_get_device_by_phandle(UCLASS_SYSCON, dev, "rockchip,grf",
+					   &syscon);
+	if (!ret) {
+		dp->grf = syscon_get_regmap(syscon);
+		if (!dp->grf)
+			return -ENODEV;
+	}
+
+	ret = reset_get_bulk(dev, &dp->resets);
+	if (ret) {
+		dev_err(dev, "failed to get reset control: %d\n", ret);
+		return ret;
+	}
+
+	ret = gpio_request_by_name(dev, "hpd-gpios", 0, &dp->hpd_gpio,
+				   GPIOD_IS_IN);
+	if (ret && ret != -ENOENT) {
+		dev_err(dev, "failed to get hpd GPIO: %d\n", ret);
+		return ret;
+	}
+
+	generic_phy_get_by_name(dev, "dp", &dp->phy);
+
+	dp->plat_data.dev_type = ROCKCHIP_DP;
+	dp->plat_data.subdev_type = pdata->chip_type;
+	dp->plat_data.ssc = pdata->ssc;
+
+	dp->video_info.max_link_rate = pdata->max_link_rate;
+	dp->video_info.max_lane_count = pdata->max_lane_count;
+
+	dp->dev = dev;
+
+	ret = analogix_dp_parse_dt(dp);
+	if (ret) {
+		dev_err(dev, "failed to parse DT: %d\n", ret);
+		return ret;
+	}
+
+	rockchip_connector_bind(&dp->connector, dev, dp->id, &analogix_dp_connector_funcs,
+				NULL, DRM_MODE_CONNECTOR_eDP);
+
+	return 0;
+}
+
+static const struct rockchip_dp_chip_data rk3288_edp_platform_data = {
+	.lcdsel_grf_reg = 0x025c,
+	.lcdsel_big = 0 | BIT(21),
+	.lcdsel_lit = BIT(5) | BIT(21),
+	.chip_type = RK3288_DP,
+
+	.max_link_rate = DP_LINK_BW_2_7,
+	.max_lane_count = 4,
+};
+
+static const struct rockchip_dp_chip_data rk3368_edp_platform_data = {
+	.chip_type = RK3368_EDP,
+
+	.max_link_rate = DP_LINK_BW_2_7,
+	.max_lane_count = 4,
+};
+
+static const struct rockchip_dp_chip_data rk3399_edp_platform_data = {
+	.lcdsel_grf_reg = 0x6250,
+	.lcdsel_big = 0 | BIT(21),
+	.lcdsel_lit = BIT(5) | BIT(21),
+	.chip_type = RK3399_EDP,
+	.ssc = true,
+
+	.max_link_rate = DP_LINK_BW_5_4,
+	.max_lane_count = 4,
+};
+
+static const struct rockchip_dp_chip_data rk3568_edp_platform_data = {
+	.chip_type = RK3568_EDP,
+	.ssc = true,
+
+	.max_link_rate = DP_LINK_BW_2_7,
+	.max_lane_count = 4,
+};
+
+static const struct rockchip_dp_chip_data rk3588_edp_platform_data = {
+	.chip_type = RK3588_EDP,
+	.ssc = true,
+
+	.max_link_rate = DP_LINK_BW_5_4,
+	.max_lane_count = 4,
+};
+
+static const struct udevice_id analogix_dp_ids[] = {
+	{
+		.compatible = "rockchip,rk3288-dp",
+		.data = (ulong)&rk3288_edp_platform_data,
+	}, {
+		.compatible = "rockchip,rk3368-edp",
+		.data = (ulong)&rk3368_edp_platform_data,
+	}, {
+		.compatible = "rockchip,rk3399-edp",
+		.data = (ulong)&rk3399_edp_platform_data,
+	}, {
+		.compatible = "rockchip,rk3568-edp",
+		.data = (ulong)&rk3568_edp_platform_data,
+	}, {
+		.compatible = "rockchip,rk3588-edp",
+		.data = (ulong)&rk3588_edp_platform_data,
+	},
+	{}
+};
+
+U_BOOT_DRIVER(analogix_dp) = {
+	.name = "analogix_dp",
+	.id = UCLASS_DISPLAY,
+	.of_match = analogix_dp_ids,
+	.probe = analogix_dp_probe,
+	.priv_auto_alloc_size = sizeof(struct analogix_dp_device),
+};
diff --git a/drivers/video/drm/analogix_dp.h b/drivers/video/drm/analogix_dp.h
new file mode 100644
index 0000000000..dc9466cfbc
--- /dev/null
+++ b/drivers/video/drm/analogix_dp.h
@@ -0,0 +1,729 @@
+/*
+ * (C) Copyright 2008-2017 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __DRM_ANALOGIX_DP_H__
+#define __DRM_ANALOGIX_DP_H__
+
+#include <generic-phy.h>
+#include <regmap.h>
+#include <reset.h>
+
+#include <drm/drm_dp_helper.h>
+
+#include "rockchip_connector.h"
+
+#define ANALOGIX_DP_TX_SW_RESET			0x14
+#define ANALOGIX_DP_FUNC_EN_1			0x18
+#define ANALOGIX_DP_FUNC_EN_2			0x1C
+#define ANALOGIX_DP_VIDEO_CTL_1			0x20
+#define ANALOGIX_DP_VIDEO_CTL_2			0x24
+#define ANALOGIX_DP_VIDEO_CTL_3			0x28
+#define ANALOGIX_DP_VIDEO_CTL_4			0x2C
+#define ANALOGIX_DP_VIDEO_CTL_8			0x3C
+#define ANALOGIX_DP_VIDEO_CTL_10		0x44
+
+#define ANALOGIX_DP_TOTAL_LINE_CFG_L		0x48
+#define ANALOGIX_DP_TOTAL_LINE_CFG_H		0x4C
+#define ANALOGIX_DP_ACTIVE_LINE_CFG_L		0x50
+#define ANALOGIX_DP_ACTIVE_LINE_CFG_H		0x54
+#define ANALOGIX_DP_V_F_PORCH_CFG		0x58
+#define ANALOGIX_DP_V_SYNC_WIDTH_CFG		0x5C
+#define ANALOGIX_DP_V_B_PORCH_CFG		0x60
+#define ANALOGIX_DP_TOTAL_PIXEL_CFG_L		0x64
+#define ANALOGIX_DP_TOTAL_PIXEL_CFG_H		0x68
+#define ANALOGIX_DP_ACTIVE_PIXEL_CFG_L		0x6C
+#define ANALOGIX_DP_ACTIVE_PIXEL_CFG_H		0x70
+#define ANALOGIX_DP_H_F_PORCH_CFG_L		0x74
+#define ANALOGIX_DP_H_F_PORCH_CFG_H		0x78
+#define ANALOGIX_DP_H_SYNC_CFG_L		0x7C
+#define ANALOGIX_DP_H_SYNC_CFG_H		0x80
+#define ANALOGIX_DP_H_B_PORCH_CFG_L		0x84
+#define ANALOGIX_DP_H_B_PORCH_CFG_H		0x88
+
+#define ANALOGIX_DP_PLL_REG_1			0xfc
+#define ANALOGIX_DP_PLL_REG_2			0x9e4
+#define ANALOGIX_DP_PLL_REG_3			0x9e8
+#define ANALOGIX_DP_PLL_REG_4			0x9ec
+#define ANALOGIX_DP_PLL_REG_5			0xa00
+
+#define ANALOGIX_DP_BIAS			0x124
+#define ANALOGIX_DP_PD				0x12c
+
+#define ANALOGIX_DP_LANE_MAP			0x35C
+
+#define ANALOGIX_DP_ANALOG_CTL_1		0x370
+#define ANALOGIX_DP_ANALOG_CTL_2		0x374
+#define ANALOGIX_DP_ANALOG_CTL_3		0x378
+#define ANALOGIX_DP_PLL_FILTER_CTL_1		0x37C
+#define ANALOGIX_DP_TX_AMP_TUNING_CTL		0x380
+
+#define ANALOGIX_DP_AUX_HW_RETRY_CTL		0x390
+
+#define ANALOGIX_DP_COMMON_INT_STA_1		0x3C4
+#define ANALOGIX_DP_COMMON_INT_STA_2		0x3C8
+#define ANALOGIX_DP_COMMON_INT_STA_3		0x3CC
+#define ANALOGIX_DP_COMMON_INT_STA_4		0x3D0
+#define ANALOGIX_DP_INT_STA			0x3DC
+#define ANALOGIX_DP_COMMON_INT_MASK_1		0x3E0
+#define ANALOGIX_DP_COMMON_INT_MASK_2		0x3E4
+#define ANALOGIX_DP_COMMON_INT_MASK_3		0x3E8
+#define ANALOGIX_DP_COMMON_INT_MASK_4		0x3EC
+#define ANALOGIX_DP_INT_STA_MASK		0x3F8
+#define ANALOGIX_DP_INT_CTL			0x3FC
+
+#define ANALOGIX_DP_SYS_CTL_1			0x600
+#define ANALOGIX_DP_SYS_CTL_2			0x604
+#define ANALOGIX_DP_SYS_CTL_3			0x608
+#define ANALOGIX_DP_SYS_CTL_4			0x60C
+
+#define ANALOGIX_DP_PKT_SEND_CTL		0x640
+#define ANALOGIX_DP_HDCP_CTL			0x648
+
+#define ANALOGIX_DP_LINK_BW_SET			0x680
+#define ANALOGIX_DP_LANE_COUNT_SET		0x684
+#define ANALOGIX_DP_TRAINING_PTN_SET		0x688
+#define ANALOGIX_DP_LN0_LINK_TRAINING_CTL	0x68C
+#define ANALOGIX_DP_LN1_LINK_TRAINING_CTL	0x690
+#define ANALOGIX_DP_LN2_LINK_TRAINING_CTL	0x694
+#define ANALOGIX_DP_LN3_LINK_TRAINING_CTL	0x698
+
+#define ANALOGIX_DP_DEBUG_CTL			0x6C0
+#define ANALOGIX_DP_HPD_DEGLITCH_L		0x6C4
+#define ANALOGIX_DP_HPD_DEGLITCH_H		0x6C8
+#define ANALOGIX_DP_LINK_DEBUG_CTL		0x6E0
+
+#define ANALOGIX_DP_M_VID_0			0x700
+#define ANALOGIX_DP_M_VID_1			0x704
+#define ANALOGIX_DP_M_VID_2			0x708
+#define ANALOGIX_DP_N_VID_0			0x70C
+#define ANALOGIX_DP_N_VID_1			0x710
+#define ANALOGIX_DP_N_VID_2			0x714
+
+#define ANALOGIX_DP_PLL_CTL			0x71C
+#define ANALOGIX_DP_PHY_PD			0x720
+#define ANALOGIX_DP_PHY_TEST			0x724
+
+#define ANALOGIX_DP_VIDEO_FIFO_THRD		0x730
+#define ANALOGIX_DP_AUDIO_MARGIN		0x73C
+
+#define ANALOGIX_DP_M_VID_GEN_FILTER_TH		0x764
+#define ANALOGIX_DP_M_AUD_GEN_FILTER_TH		0x778
+#define ANALOGIX_DP_AUX_CH_STA			0x780
+#define ANALOGIX_DP_AUX_CH_DEFER_CTL		0x788
+#define ANALOGIX_DP_AUX_RX_COMM			0x78C
+#define ANALOGIX_DP_BUFFER_DATA_CTL		0x790
+#define ANALOGIX_DP_AUX_CH_CTL_1		0x794
+#define ANALOGIX_DP_AUX_ADDR_7_0		0x798
+#define ANALOGIX_DP_AUX_ADDR_15_8		0x79C
+#define ANALOGIX_DP_AUX_ADDR_19_16		0x7A0
+#define ANALOGIX_DP_AUX_CH_CTL_2		0x7A4
+
+#define ANALOGIX_DP_BUF_DATA_0			0x7C0
+
+#define ANALOGIX_DP_SOC_GENERAL_CTL		0x800
+
+/* ANALOGIX_DP_TX_SW_RESET */
+#define RESET_DP_TX				(0x1 << 0)
+
+/* ANALOGIX_DP_FUNC_EN_1 */
+#define MASTER_VID_FUNC_EN_N			(0x1 << 7)
+#define SLAVE_VID_FUNC_EN_N			(0x1 << 5)
+#define AUD_FIFO_FUNC_EN_N			(0x1 << 4)
+#define AUD_FUNC_EN_N				(0x1 << 3)
+#define HDCP_FUNC_EN_N				(0x1 << 2)
+#define CRC_FUNC_EN_N				(0x1 << 1)
+#define SW_FUNC_EN_N				(0x1 << 0)
+
+/* ANALOGIX_DP_FUNC_EN_2 */
+#define SSC_FUNC_EN_N				(0x1 << 7)
+#define AUX_FUNC_EN_N				(0x1 << 2)
+#define SERDES_FIFO_FUNC_EN_N			(0x1 << 1)
+#define LS_CLK_DOMAIN_FUNC_EN_N			(0x1 << 0)
+
+/* ANALOGIX_DP_VIDEO_CTL_1 */
+#define VIDEO_EN				(0x1 << 7)
+#define HDCP_VIDEO_MUTE				(0x1 << 6)
+
+/* ANALOGIX_DP_VIDEO_CTL_4 */
+#define BIST_EN					(0x1 << 3)
+#define BIST_WIDTH(x)				(((x) & 0x1) << 2)
+#define BIST_TYPE(x)				(((x) & 0x3) << 0)
+
+/* ANALOGIX_DP_VIDEO_CTL_1 */
+#define IN_D_RANGE_MASK				(0x1 << 7)
+#define IN_D_RANGE_SHIFT			(7)
+#define IN_D_RANGE_CEA				(0x1 << 7)
+#define IN_D_RANGE_VESA				(0x0 << 7)
+#define IN_BPC_MASK				(0x7 << 4)
+#define IN_BPC_SHIFT				(4)
+#define IN_BPC_12_BITS				(0x3 << 4)
+#define IN_BPC_10_BITS				(0x2 << 4)
+#define IN_BPC_8_BITS				(0x1 << 4)
+#define IN_BPC_6_BITS				(0x0 << 4)
+#define IN_COLOR_F_MASK				(0x3 << 0)
+#define IN_COLOR_F_SHIFT			(0)
+#define IN_COLOR_F_YCBCR444			(0x2 << 0)
+#define IN_COLOR_F_YCBCR422			(0x1 << 0)
+#define IN_COLOR_F_RGB				(0x0 << 0)
+
+/* ANALOGIX_DP_VIDEO_CTL_3 */
+#define IN_YC_COEFFI_MASK			(0x1 << 7)
+#define IN_YC_COEFFI_SHIFT			(7)
+#define IN_YC_COEFFI_ITU709			(0x1 << 7)
+#define IN_YC_COEFFI_ITU601			(0x0 << 7)
+#define VID_CHK_UPDATE_TYPE_MASK		(0x1 << 4)
+#define VID_CHK_UPDATE_TYPE_SHIFT		(4)
+#define VID_CHK_UPDATE_TYPE_1			(0x1 << 4)
+#define VID_CHK_UPDATE_TYPE_0			(0x0 << 4)
+
+/* ANALOGIX_DP_VIDEO_CTL_8 */
+#define VID_HRES_TH(x)				(((x) & 0xf) << 4)
+#define VID_VRES_TH(x)				(((x) & 0xf) << 0)
+
+/* ANALOGIX_DP_VIDEO_CTL_10 */
+#define FORMAT_SEL				(0x1 << 4)
+#define INTERACE_SCAN_CFG			(0x1 << 2)
+#define VSYNC_POLARITY_CFG			(0x1 << 1)
+#define HSYNC_POLARITY_CFG			(0x1 << 0)
+
+/* ANALOGIX_DP_TOTAL_LINE_CFG_L */
+#define TOTAL_LINE_CFG_L(x)			(((x) & 0xff) << 0)
+
+/* ANALOGIX_DP_TOTAL_LINE_CFG_H */
+#define TOTAL_LINE_CFG_H(x)			(((x) & 0xf) << 0)
+
+/* ANALOGIX_DP_ACTIVE_LINE_CFG_L */
+#define ACTIVE_LINE_CFG_L(x)			(((x) & 0xff) << 0)
+
+/* ANALOGIX_DP_ACTIVE_LINE_CFG_H */
+#define ACTIVE_LINE_CFG_H(x)			(((x) & 0xf) << 0)
+
+/* ANALOGIX_DP_V_F_PORCH_CFG */
+#define V_F_PORCH_CFG(x)			(((x) & 0xff) << 0)
+
+/* ANALOGIX_DP_V_SYNC_WIDTH_CFG */
+#define V_SYNC_WIDTH_CFG(x)			(((x) & 0xff) << 0)
+
+/* ANALOGIX_DP_V_B_PORCH_CFG */
+#define V_B_PORCH_CFG(x)			(((x) & 0xff) << 0)
+
+/* ANALOGIX_DP_TOTAL_PIXEL_CFG_L */
+#define TOTAL_PIXEL_CFG_L(x)			(((x) & 0xff) << 0)
+
+/* ANALOGIX_DP_TOTAL_PIXEL_CFG_H */
+#define TOTAL_PIXEL_CFG_H(x)			(((x) & 0x3f) << 0)
+
+/* ANALOGIX_DP_ACTIVE_PIXEL_CFG_L */
+#define ACTIVE_PIXEL_CFG_L(x)			(((x) & 0xff) << 0)
+
+/* ANALOGIX_DP_ACTIVE_PIXEL_CFG_H */
+#define ACTIVE_PIXEL_CFG_H(x)			(((x) & 0x3f) << 0)
+
+/* ANALOGIX_DP_H_F_PORCH_CFG_L */
+#define H_F_PORCH_CFG_L(x)			(((x) & 0xff) << 0)
+
+/* ANALOGIX_DP_H_F_PORCH_CFG_H */
+#define H_F_PORCH_CFG_H(x)			(((x) & 0xf) << 0)
+
+/* ANALOGIX_DP_H_SYNC_CFG_L */
+#define H_SYNC_CFG_L(x)				(((x) & 0xff) << 0)
+
+/* ANALOGIX_DP_H_SYNC_CFG_H */
+#define H_SYNC_CFG_H(x)				(((x) & 0xf) << 0)
+
+/* ANALOGIX_DP_H_B_PORCH_CFG_L */
+#define H_B_PORCH_CFG_L(x)			(((x) & 0xff) << 0)
+
+/* ANALOGIX_DP_H_B_PORCH_CFG_H */
+#define H_B_PORCH_CFG_H(x)			(((x) & 0xf) << 0)
+
+/* ANALOGIX_DP_PLL_REG_1 */
+#define REF_CLK_24M				(0x1 << 0)
+#define REF_CLK_27M				(0x0 << 0)
+#define REF_CLK_MASK				(0x1 << 0)
+
+/* ANALOGIX_DP_LANE_MAP */
+#define LANE3_MAP_LOGIC_LANE_0			(0x0 << 6)
+#define LANE3_MAP_LOGIC_LANE_1			(0x1 << 6)
+#define LANE3_MAP_LOGIC_LANE_2			(0x2 << 6)
+#define LANE3_MAP_LOGIC_LANE_3			(0x3 << 6)
+#define LANE2_MAP_LOGIC_LANE_0			(0x0 << 4)
+#define LANE2_MAP_LOGIC_LANE_1			(0x1 << 4)
+#define LANE2_MAP_LOGIC_LANE_2			(0x2 << 4)
+#define LANE2_MAP_LOGIC_LANE_3			(0x3 << 4)
+#define LANE1_MAP_LOGIC_LANE_0			(0x0 << 2)
+#define LANE1_MAP_LOGIC_LANE_1			(0x1 << 2)
+#define LANE1_MAP_LOGIC_LANE_2			(0x2 << 2)
+#define LANE1_MAP_LOGIC_LANE_3			(0x3 << 2)
+#define LANE0_MAP_LOGIC_LANE_0			(0x0 << 0)
+#define LANE0_MAP_LOGIC_LANE_1			(0x1 << 0)
+#define LANE0_MAP_LOGIC_LANE_2			(0x2 << 0)
+#define LANE0_MAP_LOGIC_LANE_3			(0x3 << 0)
+
+/* ANALOGIX_DP_ANALOG_CTL_1 */
+#define TX_TERMINAL_CTRL_50_OHM			(0x1 << 4)
+
+/* ANALOGIX_DP_ANALOG_CTL_2 */
+#define SEL_24M					(0x1 << 3)
+#define TX_DVDD_BIT_1_0625V			(0x4 << 0)
+
+/* ANALOGIX_DP_ANALOG_CTL_3 */
+#define DRIVE_DVDD_BIT_1_0625V			(0x4 << 5)
+#define VCO_BIT_600_MICRO			(0x5 << 0)
+
+/* ANALOGIX_DP_PLL_FILTER_CTL_1 */
+#define PD_RING_OSC				(0x1 << 6)
+#define AUX_TERMINAL_CTRL_50_OHM		(0x2 << 4)
+#define TX_CUR1_2X				(0x1 << 2)
+#define TX_CUR_16_MA				(0x3 << 0)
+
+/* ANALOGIX_DP_TX_AMP_TUNING_CTL */
+#define CH3_AMP_400_MV				(0x0 << 24)
+#define CH2_AMP_400_MV				(0x0 << 16)
+#define CH1_AMP_400_MV				(0x0 << 8)
+#define CH0_AMP_400_MV				(0x0 << 0)
+
+/* ANALOGIX_DP_AUX_HW_RETRY_CTL */
+#define AUX_BIT_PERIOD_EXPECTED_DELAY(x)	(((x) & 0x7) << 8)
+#define AUX_HW_RETRY_INTERVAL_MASK		(0x3 << 3)
+#define AUX_HW_RETRY_INTERVAL_600_MICROSECONDS	(0x0 << 3)
+#define AUX_HW_RETRY_INTERVAL_800_MICROSECONDS	(0x1 << 3)
+#define AUX_HW_RETRY_INTERVAL_1000_MICROSECONDS	(0x2 << 3)
+#define AUX_HW_RETRY_INTERVAL_1800_MICROSECONDS	(0x3 << 3)
+#define AUX_HW_RETRY_COUNT_SEL(x)		(((x) & 0x7) << 0)
+
+/* ANALOGIX_DP_COMMON_INT_STA_1 */
+#define VSYNC_DET				(0x1 << 7)
+#define PLL_LOCK_CHG				(0x1 << 6)
+#define SPDIF_ERR				(0x1 << 5)
+#define SPDIF_UNSTBL				(0x1 << 4)
+#define VID_FORMAT_CHG				(0x1 << 3)
+#define AUD_CLK_CHG				(0x1 << 2)
+#define VID_CLK_CHG				(0x1 << 1)
+#define SW_INT					(0x1 << 0)
+
+/* ANALOGIX_DP_COMMON_INT_STA_2 */
+#define ENC_EN_CHG				(0x1 << 6)
+#define HW_BKSV_RDY				(0x1 << 3)
+#define HW_SHA_DONE				(0x1 << 2)
+#define HW_AUTH_STATE_CHG			(0x1 << 1)
+#define HW_AUTH_DONE				(0x1 << 0)
+
+/* ANALOGIX_DP_COMMON_INT_STA_3 */
+#define AFIFO_UNDER				(0x1 << 7)
+#define AFIFO_OVER				(0x1 << 6)
+#define R0_CHK_FLAG				(0x1 << 5)
+
+/* ANALOGIX_DP_COMMON_INT_STA_4 */
+#define PSR_ACTIVE				(0x1 << 7)
+#define PSR_INACTIVE				(0x1 << 6)
+#define SPDIF_BI_PHASE_ERR			(0x1 << 5)
+#define HOTPLUG_CHG				(0x1 << 2)
+#define HPD_LOST				(0x1 << 1)
+#define PLUG					(0x1 << 0)
+
+/* ANALOGIX_DP_INT_STA */
+#define INT_HPD					(0x1 << 6)
+#define HW_TRAINING_FINISH			(0x1 << 5)
+#define RPLY_RECEIV				(0x1 << 1)
+#define AUX_ERR					(0x1 << 0)
+
+/* ANALOGIX_DP_INT_CTL */
+#define SOFT_INT_CTRL				(0x1 << 2)
+#define INT_POL1				(0x1 << 1)
+#define INT_POL0				(0x1 << 0)
+
+/* ANALOGIX_DP_SYS_CTL_1 */
+#define DET_STA					(0x1 << 2)
+#define FORCE_DET				(0x1 << 1)
+#define DET_CTRL				(0x1 << 0)
+
+/* ANALOGIX_DP_SYS_CTL_2 */
+#define CHA_CRI(x)				(((x) & 0xf) << 4)
+#define CHA_STA					(0x1 << 2)
+#define FORCE_CHA				(0x1 << 1)
+#define CHA_CTRL				(0x1 << 0)
+
+/* ANALOGIX_DP_SYS_CTL_3 */
+#define HPD_STATUS				(0x1 << 6)
+#define F_HPD					(0x1 << 5)
+#define HPD_CTRL				(0x1 << 4)
+#define HDCP_RDY				(0x1 << 3)
+#define STRM_VALID				(0x1 << 2)
+#define F_VALID					(0x1 << 1)
+#define VALID_CTRL				(0x1 << 0)
+
+/* ANALOGIX_DP_SYS_CTL_4 */
+#define FIX_M_AUD				(0x1 << 4)
+#define ENHANCED				(0x1 << 3)
+#define FIX_M_VID				(0x1 << 2)
+#define M_VID_UPDATE_CTRL			(0x3 << 0)
+
+/* ANALOGIX_DP_TRAINING_PTN_SET */
+#define SCRAMBLER_TYPE				(0x1 << 9)
+#define HW_LINK_TRAINING_PATTERN		(0x1 << 8)
+#define SCRAMBLING_DISABLE			(0x1 << 5)
+#define SCRAMBLING_ENABLE			(0x0 << 5)
+#define LINK_QUAL_PATTERN_SET_MASK		(0x3 << 2)
+#define LINK_QUAL_PATTERN_SET_PRBS7		(0x3 << 2)
+#define LINK_QUAL_PATTERN_SET_D10_2		(0x1 << 2)
+#define LINK_QUAL_PATTERN_SET_DISABLE		(0x0 << 2)
+#define SW_TRAINING_PATTERN_SET_MASK		(0x3 << 0)
+#define SW_TRAINING_PATTERN_SET_PTN3		(0x3 << 0)
+#define SW_TRAINING_PATTERN_SET_PTN2		(0x2 << 0)
+#define SW_TRAINING_PATTERN_SET_PTN1		(0x1 << 0)
+#define SW_TRAINING_PATTERN_SET_NORMAL		(0x0 << 0)
+
+/* ANALOGIX_DP_LN0_LINK_TRAINING_CTL */
+#define PRE_EMPHASIS_SET_MASK			(0x3 << 3)
+#define PRE_EMPHASIS_SET_SHIFT			(3)
+
+/* ANALOGIX_DP_DEBUG_CTL */
+#define PLL_LOCK				(0x1 << 4)
+#define F_PLL_LOCK				(0x1 << 3)
+#define PLL_LOCK_CTRL				(0x1 << 2)
+#define PN_INV					(0x1 << 0)
+
+/* ANALOGIX_DP_PLL_CTL */
+#define DP_PLL_PD				(0x1 << 7)
+#define DP_PLL_RESET				(0x1 << 6)
+#define DP_PLL_LOOP_BIT_DEFAULT			(0x1 << 4)
+#define DP_PLL_REF_BIT_1_1250V			(0x5 << 0)
+#define DP_PLL_REF_BIT_1_2500V			(0x7 << 0)
+
+/* ANALOGIX_DP_PHY_PD */
+#define DP_PHY_PD				(0x1 << 5)
+#define AUX_PD					(0x1 << 4)
+#define CH3_PD					(0x1 << 3)
+#define CH2_PD					(0x1 << 2)
+#define CH1_PD					(0x1 << 1)
+#define CH0_PD					(0x1 << 0)
+
+/* ANALOGIX_DP_PHY_TEST */
+#define MACRO_RST				(0x1 << 5)
+#define CH1_TEST				(0x1 << 1)
+#define CH0_TEST				(0x1 << 0)
+
+/* ANALOGIX_DP_AUX_CH_STA */
+#define AUX_BUSY				(0x1 << 4)
+#define AUX_STATUS_MASK				(0xf << 0)
+
+/* ANALOGIX_DP_AUX_CH_DEFER_CTL */
+#define DEFER_CTRL_EN				(0x1 << 7)
+#define DEFER_COUNT(x)				(((x) & 0x7f) << 0)
+
+/* ANALOGIX_DP_AUX_RX_COMM */
+#define AUX_RX_COMM_I2C_DEFER			(0x2 << 2)
+#define AUX_RX_COMM_AUX_DEFER			(0x2 << 0)
+
+/* ANALOGIX_DP_BUFFER_DATA_CTL */
+#define BUF_CLR					(0x1 << 7)
+#define BUF_DATA_COUNT(x)			(((x) & 0x1f) << 0)
+
+/* ANALOGIX_DP_AUX_CH_CTL_1 */
+#define AUX_LENGTH(x)				(((x - 1) & 0xf) << 4)
+#define AUX_TX_COMM_MASK			(0xf << 0)
+#define AUX_TX_COMM_DP_TRANSACTION		(0x1 << 3)
+#define AUX_TX_COMM_I2C_TRANSACTION		(0x0 << 3)
+#define AUX_TX_COMM_MOT				(0x1 << 2)
+#define AUX_TX_COMM_WRITE			(0x0 << 0)
+#define AUX_TX_COMM_READ			(0x1 << 0)
+
+/* ANALOGIX_DP_AUX_ADDR_7_0 */
+#define AUX_ADDR_7_0(x)				(((x) >> 0) & 0xff)
+
+/* ANALOGIX_DP_AUX_ADDR_15_8 */
+#define AUX_ADDR_15_8(x)			(((x) >> 8) & 0xff)
+
+/* ANALOGIX_DP_AUX_ADDR_19_16 */
+#define AUX_ADDR_19_16(x)			(((x) >> 16) & 0x0f)
+
+/* ANALOGIX_DP_AUX_CH_CTL_2 */
+#define ADDR_ONLY				(0x1 << 1)
+#define AUX_EN					(0x1 << 0)
+
+/* ANALOGIX_DP_SOC_GENERAL_CTL */
+#define AUDIO_MODE_SPDIF_MODE			(0x1 << 8)
+#define AUDIO_MODE_MASTER_MODE			(0x0 << 8)
+#define MASTER_VIDEO_INTERLACE_EN		(0x1 << 4)
+#define VIDEO_MASTER_CLK_SEL			(0x1 << 2)
+#define VIDEO_MASTER_MODE_EN			(0x1 << 1)
+#define VIDEO_MODE_MASK				(0x1 << 0)
+#define VIDEO_MODE_SLAVE_MODE			(0x1 << 0)
+#define VIDEO_MODE_MASTER_MODE			(0x0 << 0)
+
+#define DP_TIMEOUT_LOOP_COUNT 100
+#define MAX_CR_LOOP 5
+#define MAX_EQ_LOOP 5
+
+/* I2C EDID Chip ID, Slave Address */
+#define I2C_EDID_DEVICE_ADDR			0x50
+#define I2C_E_EDID_DEVICE_ADDR			0x30
+
+#define EDID_BLOCK_LENGTH			0x80
+#define EDID_HEADER_PATTERN			0x00
+#define EDID_EXTENSION_FLAG			0x7e
+#define EDID_CHECKSUM				0x7f
+
+/* DP_MAX_LANE_COUNT */
+#define DPCD_ENHANCED_FRAME_CAP(x)		(((x) >> 7) & 0x1)
+#define DPCD_MAX_LANE_COUNT(x)			((x) & 0x1f)
+
+/* DP_LANE_COUNT_SET */
+#define DPCD_LANE_COUNT_SET(x)			((x) & 0x1f)
+
+/* DP_TRAINING_LANE0_SET */
+#define DPCD_PRE_EMPHASIS_SET(x)		(((x) & 0x3) << 3)
+#define DPCD_PRE_EMPHASIS_GET(x)		(((x) >> 3) & 0x3)
+#define DPCD_VOLTAGE_SWING_SET(x)		(((x) & 0x3) << 0)
+#define DPCD_VOLTAGE_SWING_GET(x)		(((x) >> 0) & 0x3)
+
+enum link_lane_count_type {
+	LANE_COUNT1 = 1,
+	LANE_COUNT2 = 2,
+	LANE_COUNT4 = 4
+};
+
+enum link_training_state {
+	START,
+	CLOCK_RECOVERY,
+	EQUALIZER_TRAINING,
+	FINISHED,
+	FAILED
+};
+
+enum voltage_swing_level {
+	VOLTAGE_LEVEL_0,
+	VOLTAGE_LEVEL_1,
+	VOLTAGE_LEVEL_2,
+	VOLTAGE_LEVEL_3,
+};
+
+enum pre_emphasis_level {
+	PRE_EMPHASIS_LEVEL_0,
+	PRE_EMPHASIS_LEVEL_1,
+	PRE_EMPHASIS_LEVEL_2,
+	PRE_EMPHASIS_LEVEL_3,
+};
+
+enum pattern_set {
+	PRBS7,
+	D10_2,
+	TRAINING_PTN1,
+	TRAINING_PTN2,
+	TRAINING_PTN3,
+	DP_NONE
+};
+
+enum color_space {
+	COLOR_RGB,
+	COLOR_YCBCR422,
+	COLOR_YCBCR444
+};
+
+enum color_depth {
+	COLOR_6,
+	COLOR_8,
+	COLOR_10,
+	COLOR_12
+};
+
+enum color_coefficient {
+	COLOR_YCBCR601,
+	COLOR_YCBCR709
+};
+
+enum dynamic_range {
+	VESA,
+	CEA
+};
+
+enum pll_status {
+	PLL_UNLOCKED,
+	PLL_LOCKED
+};
+
+enum clock_recovery_m_value_type {
+	CALCULATED_M,
+	REGISTER_M
+};
+
+enum video_timing_recognition_type {
+	VIDEO_TIMING_FROM_CAPTURE,
+	VIDEO_TIMING_FROM_REGISTER
+};
+
+enum analog_power_block {
+	AUX_BLOCK,
+	CH0_BLOCK,
+	CH1_BLOCK,
+	CH2_BLOCK,
+	CH3_BLOCK,
+	ANALOG_TOTAL,
+	POWER_ALL
+};
+
+enum dp_irq_type {
+	DP_IRQ_TYPE_HP_CABLE_IN  = BIT(0),
+	DP_IRQ_TYPE_HP_CABLE_OUT = BIT(1),
+	DP_IRQ_TYPE_HP_CHANGE    = BIT(2),
+	DP_IRQ_TYPE_UNKNOWN      = BIT(3),
+};
+
+struct video_info {
+	char *name;
+
+	bool h_sync_polarity;
+	bool v_sync_polarity;
+	bool interlaced;
+
+	enum color_space color_space;
+	enum dynamic_range dynamic_range;
+	enum color_coefficient ycbcr_coeff;
+	enum color_depth color_depth;
+
+	int max_link_rate;
+	enum link_lane_count_type max_lane_count;
+
+	bool force_stream_valid;
+};
+
+struct link_train {
+	int eq_loop;
+	int cr_loop[4];
+
+	u8 link_rate;
+	u8 lane_count;
+	u8 training_lane[4];
+	bool ssc;
+
+	enum link_training_state lt_state;
+};
+
+enum analogix_dp_devtype {
+	EXYNOS_DP,
+	ROCKCHIP_DP,
+};
+
+enum analogix_dp_sub_devtype {
+	RK3288_DP,
+	RK3368_EDP,
+	RK3399_EDP,
+	RK3568_EDP,
+	RK3588_EDP
+};
+
+struct analogix_dp_plat_data {
+	enum analogix_dp_devtype dev_type;
+	enum analogix_dp_sub_devtype subdev_type;
+	bool ssc;
+};
+
+struct analogix_dp_device {
+	struct rockchip_connector connector;
+	int id;
+	struct udevice *dev;
+	void *reg_base;
+	struct regmap *grf;
+	struct phy phy;
+	struct reset_ctl_bulk resets;
+	struct gpio_desc hpd_gpio;
+	bool force_hpd;
+	struct video_info	video_info;
+	struct link_train	link_train;
+	struct drm_display_mode *mode;
+	struct analogix_dp_plat_data plat_data;
+	unsigned char edid[EDID_BLOCK_LENGTH * 2];
+	u8 dpcd[DP_RECEIVER_CAP_SIZE];
+	bool video_bist_enable;
+	u32 lane_map[4];
+};
+
+/* analogix_dp_reg.c */
+void analogix_dp_enable_video_mute(struct analogix_dp_device *dp, bool enable);
+void analogix_dp_stop_video(struct analogix_dp_device *dp);
+void analogix_dp_init_analog_param(struct analogix_dp_device *dp);
+void analogix_dp_init_interrupt(struct analogix_dp_device *dp);
+void analogix_dp_reset(struct analogix_dp_device *dp);
+void analogix_dp_swreset(struct analogix_dp_device *dp);
+void analogix_dp_config_interrupt(struct analogix_dp_device *dp);
+void analogix_dp_mute_hpd_interrupt(struct analogix_dp_device *dp);
+void analogix_dp_unmute_hpd_interrupt(struct analogix_dp_device *dp);
+enum pll_status analogix_dp_get_pll_lock_status(struct analogix_dp_device *dp);
+void analogix_dp_set_pll_power_down(struct analogix_dp_device *dp, bool enable);
+void analogix_dp_set_analog_power_down(struct analogix_dp_device *dp,
+				       enum analog_power_block block,
+				       bool enable);
+void analogix_dp_init_analog_func(struct analogix_dp_device *dp);
+void analogix_dp_init_hpd(struct analogix_dp_device *dp);
+void analogix_dp_force_hpd(struct analogix_dp_device *dp);
+enum dp_irq_type analogix_dp_get_irq_type(struct analogix_dp_device *dp);
+void analogix_dp_clear_hotplug_interrupts(struct analogix_dp_device *dp);
+void analogix_dp_reset_aux(struct analogix_dp_device *dp);
+void analogix_dp_init_aux(struct analogix_dp_device *dp);
+int analogix_dp_get_plug_in_status(struct analogix_dp_device *dp);
+int analogix_dp_detect(struct analogix_dp_device *dp);
+void analogix_dp_enable_sw_function(struct analogix_dp_device *dp);
+int analogix_dp_start_aux_transaction(struct analogix_dp_device *dp);
+int analogix_dp_write_byte_to_dpcd(struct analogix_dp_device *dp,
+				   unsigned int reg_addr,
+				   unsigned char data);
+int analogix_dp_read_byte_from_dpcd(struct analogix_dp_device *dp,
+				    unsigned int reg_addr,
+				    unsigned char *data);
+int analogix_dp_write_bytes_to_dpcd(struct analogix_dp_device *dp,
+				    unsigned int reg_addr,
+				    unsigned int count,
+				    unsigned char data[]);
+int analogix_dp_read_bytes_from_dpcd(struct analogix_dp_device *dp,
+				     unsigned int reg_addr,
+				     unsigned int count,
+				     unsigned char data[]);
+int analogix_dp_select_i2c_device(struct analogix_dp_device *dp,
+				  unsigned int device_addr,
+				  unsigned int reg_addr);
+int analogix_dp_read_byte_from_i2c(struct analogix_dp_device *dp,
+				   unsigned int device_addr,
+				   unsigned int reg_addr,
+				   unsigned int *data);
+int analogix_dp_read_bytes_from_i2c(struct analogix_dp_device *dp,
+				    unsigned int device_addr,
+				    unsigned int reg_addr,
+				    unsigned int count,
+				    unsigned char edid[]);
+void analogix_dp_set_link_bandwidth(struct analogix_dp_device *dp, u32 bwtype);
+void analogix_dp_get_link_bandwidth(struct analogix_dp_device *dp, u32 *bwtype);
+void analogix_dp_set_lane_count(struct analogix_dp_device *dp, u32 count);
+void analogix_dp_get_lane_count(struct analogix_dp_device *dp, u32 *count);
+void analogix_dp_enable_enhanced_mode(struct analogix_dp_device *dp,
+				      bool enable);
+void analogix_dp_set_training_pattern(struct analogix_dp_device *dp,
+				      enum pattern_set pattern);
+void analogix_dp_set_lane_link_training(struct analogix_dp_device *dp);
+u32 analogix_dp_get_lane_link_training(struct analogix_dp_device *dp, u8 lane);
+void analogix_dp_reset_macro(struct analogix_dp_device *dp);
+void analogix_dp_init_video(struct analogix_dp_device *dp);
+
+void analogix_dp_set_video_color_format(struct analogix_dp_device *dp);
+int analogix_dp_is_slave_video_stream_clock_on(struct analogix_dp_device *dp);
+void analogix_dp_set_video_cr_mn(struct analogix_dp_device *dp,
+				 enum clock_recovery_m_value_type type,
+				 u32 m_value,
+				 u32 n_value);
+void analogix_dp_set_video_timing_mode(struct analogix_dp_device *dp, u32 type);
+void analogix_dp_enable_video_master(struct analogix_dp_device *dp,
+				     bool enable);
+void analogix_dp_start_video(struct analogix_dp_device *dp);
+int analogix_dp_is_video_stream_on(struct analogix_dp_device *dp);
+void analogix_dp_config_video_slave_mode(struct analogix_dp_device *dp);
+void analogix_dp_enable_scrambling(struct analogix_dp_device *dp);
+void analogix_dp_disable_scrambling(struct analogix_dp_device *dp);
+bool analogix_dp_ssc_supported(struct analogix_dp_device *dp);
+void analogix_dp_set_video_format(struct analogix_dp_device *dp,
+				  const struct drm_display_mode *mode);
+void analogix_dp_video_bist_enable(struct analogix_dp_device *dp);
+
+#endif /* __DRM_ANALOGIX_DP__ */
diff --git a/drivers/video/drm/analogix_dp_reg.c b/drivers/video/drm/analogix_dp_reg.c
new file mode 100644
index 0000000000..3bd1cd55a0
--- /dev/null
+++ b/drivers/video/drm/analogix_dp_reg.c
@@ -0,0 +1,1375 @@
+/*
+ * Analogix DP (Display port) core register interface driver.
+ *
+ * Copyright (C) 2008-2017 Fuzhou Rockchip Electronics Co., Ltd
+ * Copyright (C) 2012 Samsung Electronics Co., Ltd.
+ * Author: Jingoo Han <jg1.han@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ */
+
+#include <config.h>
+#include <common.h>
+#include <errno.h>
+#include <malloc.h>
+#include <asm/unaligned.h>
+#include <linux/list.h>
+#include <dm/device.h>
+#include <syscon.h>
+#include <asm/io.h>
+#include <asm/gpio.h>
+#include <linux/iopoll.h>
+
+#include "rockchip_display.h"
+#include "rockchip_crtc.h"
+#include "rockchip_connector.h"
+#include "analogix_dp.h"
+
+#define COMMON_INT_MASK_1	0
+#define COMMON_INT_MASK_2	0
+#define COMMON_INT_MASK_3	0
+#define COMMON_INT_MASK_4	(HOTPLUG_CHG | HPD_LOST | PLUG)
+#define INT_STA_MASK		INT_HPD
+
+static void analogix_dp_write(struct analogix_dp_device *dp, u32 reg, u32 val)
+{
+	readl(dp->reg_base);
+	writel(val, dp->reg_base + reg);
+	writel(val, dp->reg_base + reg);
+}
+
+static u32 analogix_dp_read(struct analogix_dp_device *dp, u32 reg)
+{
+	readl(dp->reg_base + reg);
+
+	return readl(dp->reg_base + reg);
+}
+
+void analogix_dp_enable_video_mute(struct analogix_dp_device *dp, bool enable)
+{
+	u32 reg;
+
+	if (enable) {
+		reg = analogix_dp_read(dp, ANALOGIX_DP_VIDEO_CTL_1);
+		reg |= HDCP_VIDEO_MUTE;
+		analogix_dp_write(dp, ANALOGIX_DP_VIDEO_CTL_1, reg);
+	} else {
+		reg = analogix_dp_read(dp, ANALOGIX_DP_VIDEO_CTL_1);
+		reg &= ~HDCP_VIDEO_MUTE;
+		analogix_dp_write(dp, ANALOGIX_DP_VIDEO_CTL_1, reg);
+	}
+}
+
+void analogix_dp_stop_video(struct analogix_dp_device *dp)
+{
+	u32 reg;
+
+	reg = analogix_dp_read(dp, ANALOGIX_DP_VIDEO_CTL_1);
+	reg &= ~VIDEO_EN;
+	analogix_dp_write(dp, ANALOGIX_DP_VIDEO_CTL_1, reg);
+}
+
+static void analogix_dp_set_lane_map(struct analogix_dp_device *dp)
+{
+	u32 i, reg = 0;
+
+	for (i = 0; i < dp->video_info.max_lane_count; i++)
+		reg |= dp->lane_map[i] << (2 * i);
+
+	analogix_dp_write(dp, ANALOGIX_DP_LANE_MAP, reg);
+}
+
+void analogix_dp_init_analog_param(struct analogix_dp_device *dp)
+{
+	u32 reg;
+
+	reg = TX_TERMINAL_CTRL_50_OHM;
+	analogix_dp_write(dp, ANALOGIX_DP_ANALOG_CTL_1, reg);
+
+	reg = SEL_24M | TX_DVDD_BIT_1_0625V;
+	analogix_dp_write(dp, ANALOGIX_DP_ANALOG_CTL_2, reg);
+
+	if (dp->plat_data.dev_type == ROCKCHIP_DP) {
+		reg = REF_CLK_24M;
+		if (dp->plat_data.subdev_type == RK3288_DP ||
+		    dp->plat_data.subdev_type == RK3368_EDP)
+			reg ^= REF_CLK_MASK;
+
+		analogix_dp_write(dp, ANALOGIX_DP_PLL_REG_1, reg);
+		analogix_dp_write(dp, ANALOGIX_DP_PLL_REG_2, 0x99);
+		analogix_dp_write(dp, ANALOGIX_DP_PLL_REG_3, 0x40);
+		analogix_dp_write(dp, ANALOGIX_DP_PLL_REG_4, 0x58);
+		analogix_dp_write(dp, ANALOGIX_DP_PLL_REG_5, 0x22);
+		analogix_dp_write(dp, ANALOGIX_DP_BIAS, 0x44);
+	}
+
+	reg = DRIVE_DVDD_BIT_1_0625V | VCO_BIT_600_MICRO;
+	analogix_dp_write(dp, ANALOGIX_DP_ANALOG_CTL_3, reg);
+
+	reg = PD_RING_OSC | AUX_TERMINAL_CTRL_50_OHM |
+		TX_CUR1_2X | TX_CUR_16_MA;
+	analogix_dp_write(dp, ANALOGIX_DP_PLL_FILTER_CTL_1, reg);
+
+	reg = CH3_AMP_400_MV | CH2_AMP_400_MV |
+		CH1_AMP_400_MV | CH0_AMP_400_MV;
+	analogix_dp_write(dp, ANALOGIX_DP_TX_AMP_TUNING_CTL, reg);
+}
+
+void analogix_dp_init_interrupt(struct analogix_dp_device *dp)
+{
+	/* Set interrupt pin assertion polarity as high */
+	analogix_dp_write(dp, ANALOGIX_DP_INT_CTL, INT_POL1 | INT_POL0);
+
+	/* Clear pending regisers */
+	analogix_dp_write(dp, ANALOGIX_DP_COMMON_INT_STA_1, 0xff);
+	analogix_dp_write(dp, ANALOGIX_DP_COMMON_INT_STA_2, 0x4f);
+	analogix_dp_write(dp, ANALOGIX_DP_COMMON_INT_STA_3, 0xe0);
+	analogix_dp_write(dp, ANALOGIX_DP_COMMON_INT_STA_4, 0xe7);
+	analogix_dp_write(dp, ANALOGIX_DP_INT_STA, 0x63);
+
+	/* 0:mask,1: unmask */
+	analogix_dp_write(dp, ANALOGIX_DP_COMMON_INT_MASK_1, 0x00);
+	analogix_dp_write(dp, ANALOGIX_DP_COMMON_INT_MASK_2, 0x00);
+	analogix_dp_write(dp, ANALOGIX_DP_COMMON_INT_MASK_3, 0x00);
+	analogix_dp_write(dp, ANALOGIX_DP_COMMON_INT_MASK_4, 0x00);
+	analogix_dp_write(dp, ANALOGIX_DP_INT_STA_MASK, 0x00);
+}
+
+void analogix_dp_reset(struct analogix_dp_device *dp)
+{
+	u32 reg;
+
+	analogix_dp_stop_video(dp);
+	analogix_dp_enable_video_mute(dp, 0);
+
+	reg = MASTER_VID_FUNC_EN_N | SLAVE_VID_FUNC_EN_N |
+		AUD_FIFO_FUNC_EN_N | AUD_FUNC_EN_N |
+		HDCP_FUNC_EN_N | SW_FUNC_EN_N;
+	analogix_dp_write(dp, ANALOGIX_DP_FUNC_EN_1, reg);
+
+	reg = SSC_FUNC_EN_N | AUX_FUNC_EN_N |
+		SERDES_FIFO_FUNC_EN_N |
+		LS_CLK_DOMAIN_FUNC_EN_N;
+	analogix_dp_write(dp, ANALOGIX_DP_FUNC_EN_2, reg);
+
+	udelay(30);
+
+	analogix_dp_set_lane_map(dp);
+
+	analogix_dp_write(dp, ANALOGIX_DP_SYS_CTL_1, 0x0);
+	analogix_dp_write(dp, ANALOGIX_DP_SYS_CTL_2, 0x40);
+	analogix_dp_write(dp, ANALOGIX_DP_SYS_CTL_3, 0x0);
+	analogix_dp_write(dp, ANALOGIX_DP_SYS_CTL_4, 0x0);
+
+	analogix_dp_write(dp, ANALOGIX_DP_PKT_SEND_CTL, 0x0);
+	analogix_dp_write(dp, ANALOGIX_DP_HDCP_CTL, 0x0);
+
+	analogix_dp_write(dp, ANALOGIX_DP_HPD_DEGLITCH_L, 0x5e);
+	analogix_dp_write(dp, ANALOGIX_DP_HPD_DEGLITCH_H, 0x1a);
+
+	analogix_dp_write(dp, ANALOGIX_DP_LINK_DEBUG_CTL, 0x10);
+
+	analogix_dp_write(dp, ANALOGIX_DP_PHY_TEST, 0x0);
+
+	analogix_dp_write(dp, ANALOGIX_DP_VIDEO_FIFO_THRD, 0x0);
+	analogix_dp_write(dp, ANALOGIX_DP_AUDIO_MARGIN, 0x20);
+
+	analogix_dp_write(dp, ANALOGIX_DP_M_VID_GEN_FILTER_TH, 0x4);
+	analogix_dp_write(dp, ANALOGIX_DP_M_AUD_GEN_FILTER_TH, 0x2);
+
+	analogix_dp_write(dp, ANALOGIX_DP_SOC_GENERAL_CTL, 0x00000101);
+}
+
+void analogix_dp_swreset(struct analogix_dp_device *dp)
+{
+	analogix_dp_write(dp, ANALOGIX_DP_TX_SW_RESET, RESET_DP_TX);
+}
+
+void analogix_dp_config_interrupt(struct analogix_dp_device *dp)
+{
+	u32 reg;
+
+	/* 0: mask, 1: unmask */
+	reg = COMMON_INT_MASK_1;
+	analogix_dp_write(dp, ANALOGIX_DP_COMMON_INT_MASK_1, reg);
+
+	reg = COMMON_INT_MASK_2;
+	analogix_dp_write(dp, ANALOGIX_DP_COMMON_INT_MASK_2, reg);
+
+	reg = COMMON_INT_MASK_3;
+	analogix_dp_write(dp, ANALOGIX_DP_COMMON_INT_MASK_3, reg);
+
+	reg = COMMON_INT_MASK_4;
+	analogix_dp_write(dp, ANALOGIX_DP_COMMON_INT_MASK_4, reg);
+
+	reg = INT_STA_MASK;
+	analogix_dp_write(dp, ANALOGIX_DP_INT_STA_MASK, reg);
+}
+
+void analogix_dp_mute_hpd_interrupt(struct analogix_dp_device *dp)
+{
+	u32 reg;
+
+	/* 0: mask, 1: unmask */
+	reg = analogix_dp_read(dp, ANALOGIX_DP_COMMON_INT_MASK_4);
+	reg &= ~COMMON_INT_MASK_4;
+	analogix_dp_write(dp, ANALOGIX_DP_COMMON_INT_MASK_4, reg);
+
+	reg = analogix_dp_read(dp, ANALOGIX_DP_INT_STA_MASK);
+	reg &= ~INT_STA_MASK;
+	analogix_dp_write(dp, ANALOGIX_DP_INT_STA_MASK, reg);
+}
+
+void analogix_dp_unmute_hpd_interrupt(struct analogix_dp_device *dp)
+{
+	u32 reg;
+
+	/* 0: mask, 1: unmask */
+	reg = COMMON_INT_MASK_4;
+	analogix_dp_write(dp, ANALOGIX_DP_COMMON_INT_MASK_4, reg);
+
+	reg = INT_STA_MASK;
+	analogix_dp_write(dp, ANALOGIX_DP_INT_STA_MASK, reg);
+}
+
+enum pll_status analogix_dp_get_pll_lock_status(struct analogix_dp_device *dp)
+{
+	u32 reg;
+
+	reg = analogix_dp_read(dp, ANALOGIX_DP_DEBUG_CTL);
+	if (reg & PLL_LOCK)
+		return PLL_LOCKED;
+	else
+		return PLL_UNLOCKED;
+}
+
+void analogix_dp_set_pll_power_down(struct analogix_dp_device *dp, bool enable)
+{
+	u32 reg;
+
+	if (enable) {
+		reg = analogix_dp_read(dp, ANALOGIX_DP_PLL_CTL);
+		reg |= DP_PLL_PD;
+		analogix_dp_write(dp, ANALOGIX_DP_PLL_CTL, reg);
+	} else {
+		reg = analogix_dp_read(dp, ANALOGIX_DP_PLL_CTL);
+		reg &= ~DP_PLL_PD;
+		analogix_dp_write(dp, ANALOGIX_DP_PLL_CTL, reg);
+	}
+}
+
+void analogix_dp_set_analog_power_down(struct analogix_dp_device *dp,
+				       enum analog_power_block block,
+				       bool enable)
+{
+	u32 reg;
+	u32 phy_pd_addr = ANALOGIX_DP_PHY_PD;
+
+	if (dp->plat_data.dev_type == ROCKCHIP_DP)
+		phy_pd_addr = ANALOGIX_DP_PD;
+
+	switch (block) {
+	case AUX_BLOCK:
+		if (enable) {
+			reg = analogix_dp_read(dp, phy_pd_addr);
+			reg |= AUX_PD;
+			analogix_dp_write(dp, phy_pd_addr, reg);
+		} else {
+			reg = analogix_dp_read(dp, phy_pd_addr);
+			reg &= ~AUX_PD;
+			analogix_dp_write(dp, phy_pd_addr, reg);
+		}
+		break;
+	case CH0_BLOCK:
+		if (enable) {
+			reg = analogix_dp_read(dp, phy_pd_addr);
+			reg |= CH0_PD;
+			analogix_dp_write(dp, phy_pd_addr, reg);
+		} else {
+			reg = analogix_dp_read(dp, phy_pd_addr);
+			reg &= ~CH0_PD;
+			analogix_dp_write(dp, phy_pd_addr, reg);
+		}
+		break;
+	case CH1_BLOCK:
+		if (enable) {
+			reg = analogix_dp_read(dp, phy_pd_addr);
+			reg |= CH1_PD;
+			analogix_dp_write(dp, phy_pd_addr, reg);
+		} else {
+			reg = analogix_dp_read(dp, phy_pd_addr);
+			reg &= ~CH1_PD;
+			analogix_dp_write(dp, phy_pd_addr, reg);
+		}
+		break;
+	case CH2_BLOCK:
+		if (enable) {
+			reg = analogix_dp_read(dp, phy_pd_addr);
+			reg |= CH2_PD;
+			analogix_dp_write(dp, phy_pd_addr, reg);
+		} else {
+			reg = analogix_dp_read(dp, phy_pd_addr);
+			reg &= ~CH2_PD;
+			analogix_dp_write(dp, phy_pd_addr, reg);
+		}
+		break;
+	case CH3_BLOCK:
+		if (enable) {
+			reg = analogix_dp_read(dp, phy_pd_addr);
+			reg |= CH3_PD;
+			analogix_dp_write(dp, phy_pd_addr, reg);
+		} else {
+			reg = analogix_dp_read(dp, phy_pd_addr);
+			reg &= ~CH3_PD;
+			analogix_dp_write(dp, phy_pd_addr, reg);
+		}
+		break;
+	case ANALOG_TOTAL:
+		if (enable) {
+			reg = analogix_dp_read(dp, phy_pd_addr);
+			reg |= DP_PHY_PD;
+			analogix_dp_write(dp, phy_pd_addr, reg);
+		} else {
+			reg = analogix_dp_read(dp, phy_pd_addr);
+			reg &= ~DP_PHY_PD;
+			analogix_dp_write(dp, phy_pd_addr, reg);
+		}
+		break;
+	case POWER_ALL:
+		if (enable) {
+			reg = DP_PHY_PD | AUX_PD | CH3_PD | CH2_PD |
+				CH1_PD | CH0_PD;
+			analogix_dp_write(dp, phy_pd_addr, reg);
+		} else {
+			analogix_dp_write(dp, phy_pd_addr, 0x00);
+		}
+		break;
+	default:
+		break;
+	}
+}
+
+void analogix_dp_init_analog_func(struct analogix_dp_device *dp)
+{
+	u32 reg;
+
+	analogix_dp_set_analog_power_down(dp, POWER_ALL, 0);
+
+	reg = PLL_LOCK_CHG;
+	analogix_dp_write(dp, ANALOGIX_DP_COMMON_INT_STA_1, reg);
+
+	reg = analogix_dp_read(dp, ANALOGIX_DP_DEBUG_CTL);
+	reg &= ~(F_PLL_LOCK | PLL_LOCK_CTRL);
+	analogix_dp_write(dp, ANALOGIX_DP_DEBUG_CTL, reg);
+
+	/* Power up PLL */
+	analogix_dp_set_pll_power_down(dp, 0);
+
+	/* Enable Serdes FIFO function and Link symbol clock domain module */
+	reg = analogix_dp_read(dp, ANALOGIX_DP_FUNC_EN_2);
+	reg &= ~(SERDES_FIFO_FUNC_EN_N | LS_CLK_DOMAIN_FUNC_EN_N
+		| AUX_FUNC_EN_N);
+	analogix_dp_write(dp, ANALOGIX_DP_FUNC_EN_2, reg);
+}
+
+void analogix_dp_clear_hotplug_interrupts(struct analogix_dp_device *dp)
+{
+	u32 reg;
+
+	if (dm_gpio_is_valid(&dp->hpd_gpio))
+		return;
+
+	reg = HOTPLUG_CHG | HPD_LOST | PLUG;
+	analogix_dp_write(dp, ANALOGIX_DP_COMMON_INT_STA_4, reg);
+
+	reg = INT_HPD;
+	analogix_dp_write(dp, ANALOGIX_DP_INT_STA, reg);
+}
+
+void analogix_dp_init_hpd(struct analogix_dp_device *dp)
+{
+	u32 reg;
+
+	if (dm_gpio_is_valid(&dp->hpd_gpio))
+		return;
+
+	analogix_dp_clear_hotplug_interrupts(dp);
+
+	reg = analogix_dp_read(dp, ANALOGIX_DP_SYS_CTL_3);
+	reg &= ~(F_HPD | HPD_CTRL);
+	analogix_dp_write(dp, ANALOGIX_DP_SYS_CTL_3, reg);
+}
+
+void analogix_dp_force_hpd(struct analogix_dp_device *dp)
+{
+	u32 reg;
+
+	reg = analogix_dp_read(dp, ANALOGIX_DP_SYS_CTL_3);
+	reg |= (F_HPD | HPD_CTRL);
+	analogix_dp_write(dp, ANALOGIX_DP_SYS_CTL_3, reg);
+}
+
+enum dp_irq_type analogix_dp_get_irq_type(struct analogix_dp_device *dp)
+{
+	u32 reg;
+
+	if (dm_gpio_is_valid(&dp->hpd_gpio)) {
+		reg = dm_gpio_get_value(&dp->hpd_gpio);
+		if (reg)
+			return DP_IRQ_TYPE_HP_CABLE_IN;
+		else
+			return DP_IRQ_TYPE_HP_CABLE_OUT;
+	} else {
+		/* Parse hotplug interrupt status register */
+		reg = analogix_dp_read(dp, ANALOGIX_DP_COMMON_INT_STA_4);
+
+		if (reg & PLUG)
+			return DP_IRQ_TYPE_HP_CABLE_IN;
+
+		if (reg & HPD_LOST)
+			return DP_IRQ_TYPE_HP_CABLE_OUT;
+
+		if (reg & HOTPLUG_CHG)
+			return DP_IRQ_TYPE_HP_CHANGE;
+
+		return DP_IRQ_TYPE_UNKNOWN;
+	}
+}
+
+void analogix_dp_reset_aux(struct analogix_dp_device *dp)
+{
+	u32 reg;
+
+	/* Disable AUX channel module */
+	reg = analogix_dp_read(dp, ANALOGIX_DP_FUNC_EN_2);
+	reg |= AUX_FUNC_EN_N;
+	analogix_dp_write(dp, ANALOGIX_DP_FUNC_EN_2, reg);
+}
+
+void analogix_dp_init_aux(struct analogix_dp_device *dp)
+{
+	u32 reg;
+
+	/* Clear inerrupts related to AUX channel */
+	reg = RPLY_RECEIV | AUX_ERR;
+	analogix_dp_write(dp, ANALOGIX_DP_INT_STA, reg);
+
+	analogix_dp_reset_aux(dp);
+
+	/* Disable AUX transaction H/W retry */
+	if (dp->plat_data.dev_type == ROCKCHIP_DP)
+		reg = AUX_BIT_PERIOD_EXPECTED_DELAY(0) |
+		      AUX_HW_RETRY_COUNT_SEL(3) |
+		      AUX_HW_RETRY_INTERVAL_600_MICROSECONDS;
+	else
+		reg = AUX_BIT_PERIOD_EXPECTED_DELAY(3) |
+		      AUX_HW_RETRY_COUNT_SEL(0) |
+		      AUX_HW_RETRY_INTERVAL_600_MICROSECONDS;
+	analogix_dp_write(dp, ANALOGIX_DP_AUX_HW_RETRY_CTL, reg);
+
+	/* Receive AUX Channel DEFER commands equal to DEFFER_COUNT*64 */
+	reg = DEFER_CTRL_EN | DEFER_COUNT(1);
+	analogix_dp_write(dp, ANALOGIX_DP_AUX_CH_DEFER_CTL, reg);
+
+	/* Enable AUX channel module */
+	reg = analogix_dp_read(dp, ANALOGIX_DP_FUNC_EN_2);
+	reg &= ~AUX_FUNC_EN_N;
+	analogix_dp_write(dp, ANALOGIX_DP_FUNC_EN_2, reg);
+}
+
+int analogix_dp_detect(struct analogix_dp_device *dp)
+{
+	u32 reg;
+
+	if (dm_gpio_is_valid(&dp->hpd_gpio))
+		return dm_gpio_get_value(&dp->hpd_gpio);
+
+	if (dp->force_hpd)
+		analogix_dp_force_hpd(dp);
+
+	reg = analogix_dp_read(dp, ANALOGIX_DP_SYS_CTL_3);
+	if (reg & HPD_STATUS)
+		return 1;
+
+	return 0;
+}
+
+void analogix_dp_enable_sw_function(struct analogix_dp_device *dp)
+{
+	u32 reg;
+
+	reg = analogix_dp_read(dp, ANALOGIX_DP_FUNC_EN_1);
+	reg &= ~SW_FUNC_EN_N;
+	analogix_dp_write(dp, ANALOGIX_DP_FUNC_EN_1, reg);
+}
+
+int analogix_dp_get_plug_in_status(struct analogix_dp_device *dp)
+{
+	u32 reg;
+
+	reg = analogix_dp_read(dp, ANALOGIX_DP_SYS_CTL_3);
+	if (reg & HPD_STATUS)
+		return 0;
+
+	return -EINVAL;
+}
+
+int analogix_dp_start_aux_transaction(struct analogix_dp_device *dp)
+{
+	int reg;
+	int retval = 0;
+	int timeout_loop = 0;
+
+	/* Enable AUX CH operation */
+	reg = analogix_dp_read(dp, ANALOGIX_DP_AUX_CH_CTL_2);
+	reg |= AUX_EN;
+	analogix_dp_write(dp, ANALOGIX_DP_AUX_CH_CTL_2, reg);
+
+	/* Is AUX CH command reply received? */
+	reg = analogix_dp_read(dp, ANALOGIX_DP_INT_STA);
+	while (!(reg & RPLY_RECEIV)) {
+		timeout_loop++;
+		if (DP_TIMEOUT_LOOP_COUNT < timeout_loop) {
+			dev_err(dp->dev, "AUX CH command reply failed!\n");
+			return -ETIMEDOUT;
+		}
+
+		reg = analogix_dp_read(dp, ANALOGIX_DP_INT_STA);
+		udelay(11);
+	}
+
+	/* Clear interrupt source for AUX CH command reply */
+	analogix_dp_write(dp, ANALOGIX_DP_INT_STA, reg);
+
+	/* Clear interrupt source for AUX CH access error */
+	reg = analogix_dp_read(dp, ANALOGIX_DP_INT_STA);
+	if (reg & AUX_ERR) {
+		analogix_dp_write(dp, ANALOGIX_DP_INT_STA, AUX_ERR);
+		return -EREMOTEIO;
+	}
+
+	/* Check AUX CH error access status */
+	reg = analogix_dp_read(dp, ANALOGIX_DP_AUX_CH_STA);
+	if ((reg & AUX_STATUS_MASK) != 0) {
+		dev_err(dp->dev,
+			"AUX CH error happens: %d\n", reg & AUX_STATUS_MASK);
+		return -EREMOTEIO;
+	}
+
+	return retval;
+}
+
+int analogix_dp_write_byte_to_dpcd(struct analogix_dp_device *dp,
+				   unsigned int reg_addr,
+				   unsigned char data)
+{
+	u32 reg;
+	int i;
+	int retval;
+
+	for (i = 0; i < 3; i++) {
+		/* Clear AUX CH data buffer */
+		reg = BUF_CLR;
+		analogix_dp_write(dp, ANALOGIX_DP_BUFFER_DATA_CTL, reg);
+
+		/* Select DPCD device address */
+		reg = AUX_ADDR_7_0(reg_addr);
+		analogix_dp_write(dp, ANALOGIX_DP_AUX_ADDR_7_0, reg);
+		reg = AUX_ADDR_15_8(reg_addr);
+		analogix_dp_write(dp, ANALOGIX_DP_AUX_ADDR_15_8, reg);
+		reg = AUX_ADDR_19_16(reg_addr);
+		analogix_dp_write(dp, ANALOGIX_DP_AUX_ADDR_19_16, reg);
+
+		/* Write data buffer */
+		reg = (unsigned int)data;
+		analogix_dp_write(dp, ANALOGIX_DP_BUF_DATA_0, reg);
+
+		/*
+		 * Set DisplayPort transaction and write 1 byte
+		 * If bit 3 is 1, DisplayPort transaction.
+		 * If Bit 3 is 0, I2C transaction.
+		 */
+		reg = AUX_TX_COMM_DP_TRANSACTION | AUX_TX_COMM_WRITE;
+		analogix_dp_write(dp, ANALOGIX_DP_AUX_CH_CTL_1, reg);
+
+		/* Start AUX transaction */
+		retval = analogix_dp_start_aux_transaction(dp);
+		if (retval == 0)
+			break;
+	}
+
+	return retval;
+}
+
+int analogix_dp_read_byte_from_dpcd(struct analogix_dp_device *dp,
+				    unsigned int reg_addr,
+				    unsigned char *data)
+{
+	u32 reg;
+	int i;
+	int retval;
+
+	for (i = 0; i < 3; i++) {
+		/* Clear AUX CH data buffer */
+		reg = BUF_CLR;
+		analogix_dp_write(dp, ANALOGIX_DP_BUFFER_DATA_CTL, reg);
+
+		/* Select DPCD device address */
+		reg = AUX_ADDR_7_0(reg_addr);
+		analogix_dp_write(dp, ANALOGIX_DP_AUX_ADDR_7_0, reg);
+		reg = AUX_ADDR_15_8(reg_addr);
+		analogix_dp_write(dp, ANALOGIX_DP_AUX_ADDR_15_8, reg);
+		reg = AUX_ADDR_19_16(reg_addr);
+		analogix_dp_write(dp, ANALOGIX_DP_AUX_ADDR_19_16, reg);
+
+		/*
+		 * Set DisplayPort transaction and read 1 byte
+		 * If bit 3 is 1, DisplayPort transaction.
+		 * If Bit 3 is 0, I2C transaction.
+		 */
+		reg = AUX_TX_COMM_DP_TRANSACTION | AUX_TX_COMM_READ;
+		analogix_dp_write(dp, ANALOGIX_DP_AUX_CH_CTL_1, reg);
+
+		/* Start AUX transaction */
+		retval = analogix_dp_start_aux_transaction(dp);
+		if (retval == 0)
+			break;
+	}
+
+	/* Read data buffer */
+	reg = analogix_dp_read(dp, ANALOGIX_DP_BUF_DATA_0);
+	*data = (unsigned char)(reg & 0xff);
+
+	return retval;
+}
+
+int analogix_dp_write_bytes_to_dpcd(struct analogix_dp_device *dp,
+				    unsigned int reg_addr,
+				    unsigned int count,
+				    unsigned char data[])
+{
+	u32 reg;
+	unsigned int start_offset;
+	unsigned int cur_data_count;
+	unsigned int cur_data_idx;
+	int i;
+	int retval = 0;
+
+	/* Clear AUX CH data buffer */
+	reg = BUF_CLR;
+	analogix_dp_write(dp, ANALOGIX_DP_BUFFER_DATA_CTL, reg);
+
+	start_offset = 0;
+	while (start_offset < count) {
+		/* Buffer size of AUX CH is 16 * 4bytes */
+		if ((count - start_offset) > 16)
+			cur_data_count = 16;
+		else
+			cur_data_count = count - start_offset;
+
+		for (i = 0; i < 3; i++) {
+			/* Select DPCD device address */
+			reg = AUX_ADDR_7_0(reg_addr + start_offset);
+			analogix_dp_write(dp, ANALOGIX_DP_AUX_ADDR_7_0, reg);
+			reg = AUX_ADDR_15_8(reg_addr + start_offset);
+			analogix_dp_write(dp, ANALOGIX_DP_AUX_ADDR_15_8, reg);
+			reg = AUX_ADDR_19_16(reg_addr + start_offset);
+			analogix_dp_write(dp, ANALOGIX_DP_AUX_ADDR_19_16, reg);
+
+			for (cur_data_idx = 0; cur_data_idx < cur_data_count;
+			     cur_data_idx++) {
+				reg = data[start_offset + cur_data_idx];
+				analogix_dp_write(dp, ANALOGIX_DP_BUF_DATA_0 +
+				       4 * cur_data_idx, reg);
+			}
+
+			/*
+			 * Set DisplayPort transaction and write
+			 * If bit 3 is 1, DisplayPort transaction.
+			 * If Bit 3 is 0, I2C transaction.
+			 */
+			reg = AUX_LENGTH(cur_data_count) |
+				AUX_TX_COMM_DP_TRANSACTION | AUX_TX_COMM_WRITE;
+			analogix_dp_write(dp, ANALOGIX_DP_AUX_CH_CTL_1, reg);
+
+			/* Start AUX transaction */
+			retval = analogix_dp_start_aux_transaction(dp);
+			if (retval == 0)
+				break;
+		}
+
+		start_offset += cur_data_count;
+	}
+
+	return retval;
+}
+
+int analogix_dp_read_bytes_from_dpcd(struct analogix_dp_device *dp,
+				     unsigned int reg_addr,
+				     unsigned int count,
+				     unsigned char data[])
+{
+	u32 reg;
+	unsigned int start_offset;
+	unsigned int cur_data_count;
+	unsigned int cur_data_idx;
+	int i;
+	int retval = 0;
+
+	/* Clear AUX CH data buffer */
+	reg = BUF_CLR;
+	analogix_dp_write(dp, ANALOGIX_DP_BUFFER_DATA_CTL, reg);
+
+	start_offset = 0;
+	while (start_offset < count) {
+		/* Buffer size of AUX CH is 16 * 4bytes */
+		if ((count - start_offset) > 16)
+			cur_data_count = 16;
+		else
+			cur_data_count = count - start_offset;
+
+		/* AUX CH Request Transaction process */
+		for (i = 0; i < 3; i++) {
+			/* Select DPCD device address */
+			reg = AUX_ADDR_7_0(reg_addr + start_offset);
+			analogix_dp_write(dp, ANALOGIX_DP_AUX_ADDR_7_0, reg);
+			reg = AUX_ADDR_15_8(reg_addr + start_offset);
+			analogix_dp_write(dp, ANALOGIX_DP_AUX_ADDR_15_8, reg);
+			reg = AUX_ADDR_19_16(reg_addr + start_offset);
+			analogix_dp_write(dp, ANALOGIX_DP_AUX_ADDR_19_16, reg);
+
+			/*
+			 * Set DisplayPort transaction and read
+			 * If bit 3 is 1, DisplayPort transaction.
+			 * If Bit 3 is 0, I2C transaction.
+			 */
+			reg = AUX_LENGTH(cur_data_count) |
+				AUX_TX_COMM_DP_TRANSACTION | AUX_TX_COMM_READ;
+			analogix_dp_write(dp, ANALOGIX_DP_AUX_CH_CTL_1, reg);
+
+			/* Start AUX transaction */
+			retval = analogix_dp_start_aux_transaction(dp);
+			if (retval == 0)
+				break;
+		}
+
+		for (cur_data_idx = 0; cur_data_idx < cur_data_count;
+		    cur_data_idx++) {
+			reg = analogix_dp_read(dp, ANALOGIX_DP_BUF_DATA_0
+						 + 4 * cur_data_idx);
+			data[start_offset + cur_data_idx] =
+				(unsigned char)reg;
+		}
+
+		start_offset += cur_data_count;
+	}
+
+	return retval;
+}
+
+int analogix_dp_select_i2c_device(struct analogix_dp_device *dp,
+				  unsigned int device_addr,
+				  unsigned int reg_addr)
+{
+	u32 reg;
+	int retval;
+
+	/* Set EDID device address */
+	reg = device_addr;
+	analogix_dp_write(dp, ANALOGIX_DP_AUX_ADDR_7_0, reg);
+	analogix_dp_write(dp, ANALOGIX_DP_AUX_ADDR_15_8, 0x0);
+	analogix_dp_write(dp, ANALOGIX_DP_AUX_ADDR_19_16, 0x0);
+
+	/* Set offset from base address of EDID device */
+	analogix_dp_write(dp, ANALOGIX_DP_BUF_DATA_0, reg_addr);
+
+	/*
+	 * Set I2C transaction and write address
+	 * If bit 3 is 1, DisplayPort transaction.
+	 * If Bit 3 is 0, I2C transaction.
+	 */
+	reg = AUX_TX_COMM_I2C_TRANSACTION | AUX_TX_COMM_MOT |
+		AUX_TX_COMM_WRITE;
+	analogix_dp_write(dp, ANALOGIX_DP_AUX_CH_CTL_1, reg);
+
+	/* Start AUX transaction */
+	retval = analogix_dp_start_aux_transaction(dp);
+	if (retval < 0)
+		return retval;
+
+	return 0;
+}
+
+int analogix_dp_read_byte_from_i2c(struct analogix_dp_device *dp,
+				   unsigned int device_addr,
+				   unsigned int reg_addr,
+				   unsigned int *data)
+{
+	u32 reg;
+	int i;
+	int retval;
+
+	for (i = 0; i < 3; i++) {
+		/* Clear AUX CH data buffer */
+		reg = BUF_CLR;
+		analogix_dp_write(dp, ANALOGIX_DP_BUFFER_DATA_CTL, reg);
+
+		/* Select EDID device */
+		retval = analogix_dp_select_i2c_device(dp, device_addr,
+						       reg_addr);
+		if (retval != 0)
+			continue;
+
+		/*
+		 * Set I2C transaction and read data
+		 * If bit 3 is 1, DisplayPort transaction.
+		 * If Bit 3 is 0, I2C transaction.
+		 */
+		reg = AUX_TX_COMM_I2C_TRANSACTION |
+			AUX_TX_COMM_READ;
+		analogix_dp_write(dp, ANALOGIX_DP_AUX_CH_CTL_1, reg);
+
+		/* Start AUX transaction */
+		retval = analogix_dp_start_aux_transaction(dp);
+		if (retval == 0)
+			break;
+	}
+
+	/* Read data */
+	if (retval == 0)
+		*data = analogix_dp_read(dp, ANALOGIX_DP_BUF_DATA_0);
+
+	return retval;
+}
+
+int analogix_dp_read_bytes_from_i2c(struct analogix_dp_device *dp,
+				    unsigned int device_addr,
+				    unsigned int reg_addr,
+				    unsigned int count,
+				    unsigned char edid[])
+{
+	u32 reg;
+	unsigned int i, j;
+	unsigned int cur_data_idx;
+	unsigned int defer = 0;
+	int retval = 0;
+
+	for (i = 0; i < count; i += 16) {
+		for (j = 0; j < 3; j++) {
+			/* Clear AUX CH data buffer */
+			reg = BUF_CLR;
+			analogix_dp_write(dp, ANALOGIX_DP_BUFFER_DATA_CTL, reg);
+
+			/* Set normal AUX CH command */
+			reg = analogix_dp_read(dp, ANALOGIX_DP_AUX_CH_CTL_2);
+			reg &= ~ADDR_ONLY;
+			analogix_dp_write(dp, ANALOGIX_DP_AUX_CH_CTL_2, reg);
+
+			/*
+			 * If Rx sends defer, Tx sends only reads
+			 * request without sending address
+			 */
+			if (!defer)
+				retval = analogix_dp_select_i2c_device(dp,
+						device_addr, reg_addr + i);
+			else
+				defer = 0;
+
+			if (retval == 0) {
+				/*
+				 * Set I2C transaction and write data
+				 * If bit 3 is 1, DisplayPort transaction.
+				 * If Bit 3 is 0, I2C transaction.
+				 */
+				reg = AUX_LENGTH(16) |
+					AUX_TX_COMM_I2C_TRANSACTION |
+					AUX_TX_COMM_READ;
+				analogix_dp_write(dp, ANALOGIX_DP_AUX_CH_CTL_1,
+						  reg);
+
+				/* Start AUX transaction */
+				retval = analogix_dp_start_aux_transaction(dp);
+				if (retval == 0)
+					break;
+			}
+			/* Check if Rx sends defer */
+			reg = analogix_dp_read(dp, ANALOGIX_DP_AUX_RX_COMM);
+			if (reg == AUX_RX_COMM_AUX_DEFER ||
+			    reg == AUX_RX_COMM_I2C_DEFER) {
+				dev_dbg(dp->dev, "Defer: %d\n\n", reg);
+				defer = 1;
+			}
+		}
+
+		for (cur_data_idx = 0; cur_data_idx < 16; cur_data_idx++) {
+			reg = analogix_dp_read(dp, ANALOGIX_DP_BUF_DATA_0
+						 + 4 * cur_data_idx);
+			edid[i + cur_data_idx] = (unsigned char)reg;
+		}
+	}
+
+	return retval;
+}
+
+bool analogix_dp_ssc_supported(struct analogix_dp_device *dp)
+{
+	/* Check if SSC is supported by both sides */
+	return dp->plat_data.ssc && dp->link_train.ssc;
+}
+
+void analogix_dp_set_link_bandwidth(struct analogix_dp_device *dp, u32 bwtype)
+{
+	union phy_configure_opts phy_cfg;
+	u32 status;
+	int ret;
+
+	analogix_dp_write(dp, ANALOGIX_DP_LINK_BW_SET, bwtype);
+
+	phy_cfg.dp.lanes = dp->link_train.lane_count;
+	phy_cfg.dp.link_rate =
+		drm_dp_bw_code_to_link_rate(dp->link_train.link_rate) / 100;
+	phy_cfg.dp.ssc = analogix_dp_ssc_supported(dp);
+	phy_cfg.dp.set_lanes = false;
+	phy_cfg.dp.set_rate = true;
+	phy_cfg.dp.set_voltages = false;
+	ret = generic_phy_configure(&dp->phy, &phy_cfg);
+	if (ret) {
+		dev_err(dp->dev, "%s: phy_configure() failed: %d\n",
+			__func__, ret);
+		return;
+	}
+
+	ret = readx_poll_timeout(analogix_dp_get_pll_lock_status, dp, status,
+				 status != PLL_UNLOCKED,
+				 120 * DP_TIMEOUT_LOOP_COUNT);
+	if (ret) {
+		dev_err(dp->dev, "Wait for pll lock failed %d\n", ret);
+		return;
+	}
+}
+
+void analogix_dp_get_link_bandwidth(struct analogix_dp_device *dp, u32 *bwtype)
+{
+	u32 reg;
+
+	reg = analogix_dp_read(dp, ANALOGIX_DP_LINK_BW_SET);
+	*bwtype = reg;
+}
+
+void analogix_dp_set_lane_count(struct analogix_dp_device *dp, u32 count)
+{
+	union phy_configure_opts phy_cfg;
+	u32 reg;
+	int ret;
+
+	reg = count;
+	analogix_dp_write(dp, ANALOGIX_DP_LANE_COUNT_SET, reg);
+
+	phy_cfg.dp.lanes = dp->link_train.lane_count;
+	phy_cfg.dp.set_lanes = true;
+	phy_cfg.dp.set_rate = false;
+	phy_cfg.dp.set_voltages = false;
+	ret = generic_phy_configure(&dp->phy, &phy_cfg);
+	if (ret) {
+		dev_err(dp->dev, "%s: phy_configure() failed: %d\n",
+			__func__, ret);
+		return;
+	}
+}
+
+void analogix_dp_get_lane_count(struct analogix_dp_device *dp, u32 *count)
+{
+	u32 reg;
+
+	reg = analogix_dp_read(dp, ANALOGIX_DP_LANE_COUNT_SET);
+	*count = reg;
+}
+
+void analogix_dp_set_lane_link_training(struct analogix_dp_device *dp)
+{
+	union phy_configure_opts phy_cfg;
+	u8 lane;
+	int ret;
+
+	for (lane = 0; lane < dp->link_train.lane_count; lane++) {
+		u8 training_lane = dp->link_train.training_lane[lane];
+		u8 vs, pe;
+
+		analogix_dp_write(dp,
+				  ANALOGIX_DP_LN0_LINK_TRAINING_CTL + 4 * lane,
+				  dp->link_train.training_lane[lane]);
+
+		vs = (training_lane & DP_TRAIN_VOLTAGE_SWING_MASK) >>
+		     DP_TRAIN_VOLTAGE_SWING_SHIFT;
+		pe = (training_lane & DP_TRAIN_PRE_EMPHASIS_MASK) >>
+		     DP_TRAIN_PRE_EMPHASIS_SHIFT;
+		phy_cfg.dp.voltage[lane] = vs;
+		phy_cfg.dp.pre[lane] = pe;
+	}
+
+	phy_cfg.dp.lanes = dp->link_train.lane_count;
+	phy_cfg.dp.link_rate =
+		drm_dp_bw_code_to_link_rate(dp->link_train.link_rate) / 100;
+	phy_cfg.dp.set_lanes = false;
+	phy_cfg.dp.set_rate = false;
+	phy_cfg.dp.set_voltages = true;
+	ret = generic_phy_configure(&dp->phy, &phy_cfg);
+	if (ret) {
+		dev_err(dp->dev, "%s: phy_configure() failed: %d\n",
+			__func__, ret);
+		return;
+	}
+}
+
+u32 analogix_dp_get_lane_link_training(struct analogix_dp_device *dp, u8 lane)
+{
+	return analogix_dp_read(dp,
+				ANALOGIX_DP_LN0_LINK_TRAINING_CTL + 4 * lane);
+}
+
+void analogix_dp_enable_enhanced_mode(struct analogix_dp_device *dp,
+				      bool enable)
+{
+	u32 reg;
+
+	if (enable) {
+		reg = analogix_dp_read(dp, ANALOGIX_DP_SYS_CTL_4);
+		reg |= ENHANCED;
+		analogix_dp_write(dp, ANALOGIX_DP_SYS_CTL_4, reg);
+	} else {
+		reg = analogix_dp_read(dp, ANALOGIX_DP_SYS_CTL_4);
+		reg &= ~ENHANCED;
+		analogix_dp_write(dp, ANALOGIX_DP_SYS_CTL_4, reg);
+	}
+}
+
+void analogix_dp_set_training_pattern(struct analogix_dp_device *dp,
+				      enum pattern_set pattern)
+{
+	u32 reg;
+
+	switch (pattern) {
+	case PRBS7:
+		reg = SCRAMBLING_ENABLE | LINK_QUAL_PATTERN_SET_PRBS7;
+		analogix_dp_write(dp, ANALOGIX_DP_TRAINING_PTN_SET, reg);
+		break;
+	case D10_2:
+		reg = SCRAMBLING_ENABLE | LINK_QUAL_PATTERN_SET_D10_2;
+		analogix_dp_write(dp, ANALOGIX_DP_TRAINING_PTN_SET, reg);
+		break;
+	case TRAINING_PTN1:
+		reg = SCRAMBLING_DISABLE | SW_TRAINING_PATTERN_SET_PTN1;
+		analogix_dp_write(dp, ANALOGIX_DP_TRAINING_PTN_SET, reg);
+		break;
+	case TRAINING_PTN2:
+		reg = SCRAMBLING_DISABLE | SW_TRAINING_PATTERN_SET_PTN2;
+		analogix_dp_write(dp, ANALOGIX_DP_TRAINING_PTN_SET, reg);
+		break;
+	case TRAINING_PTN3:
+		reg = SCRAMBLING_DISABLE | SW_TRAINING_PATTERN_SET_PTN3;
+		analogix_dp_write(dp, ANALOGIX_DP_TRAINING_PTN_SET, reg);
+		break;
+	case DP_NONE:
+		reg = SCRAMBLING_ENABLE |
+			LINK_QUAL_PATTERN_SET_DISABLE |
+			SW_TRAINING_PATTERN_SET_NORMAL;
+		analogix_dp_write(dp, ANALOGIX_DP_TRAINING_PTN_SET, reg);
+		break;
+	default:
+		break;
+	}
+}
+
+void analogix_dp_reset_macro(struct analogix_dp_device *dp)
+{
+	u32 reg;
+
+	reg = analogix_dp_read(dp, ANALOGIX_DP_PHY_TEST);
+	reg |= MACRO_RST;
+	analogix_dp_write(dp, ANALOGIX_DP_PHY_TEST, reg);
+
+	/* 10 us is the minimum reset time. */
+	udelay(20);
+
+	reg &= ~MACRO_RST;
+	analogix_dp_write(dp, ANALOGIX_DP_PHY_TEST, reg);
+}
+
+void analogix_dp_init_video(struct analogix_dp_device *dp)
+{
+	u32 reg;
+
+	reg = VSYNC_DET | VID_FORMAT_CHG | VID_CLK_CHG;
+	analogix_dp_write(dp, ANALOGIX_DP_COMMON_INT_STA_1, reg);
+
+	reg = 0x0;
+	analogix_dp_write(dp, ANALOGIX_DP_SYS_CTL_1, reg);
+
+	reg = CHA_CRI(4) | CHA_CTRL;
+	analogix_dp_write(dp, ANALOGIX_DP_SYS_CTL_2, reg);
+
+	if (dp->video_info.force_stream_valid) {
+		reg = analogix_dp_read(dp, ANALOGIX_DP_SYS_CTL_3);
+		reg |= VALID_CTRL | F_VALID;
+		analogix_dp_write(dp, ANALOGIX_DP_SYS_CTL_3, reg);
+	}
+
+	reg = VID_HRES_TH(2) | VID_VRES_TH(0);
+	analogix_dp_write(dp, ANALOGIX_DP_VIDEO_CTL_8, reg);
+}
+
+void analogix_dp_set_video_color_format(struct analogix_dp_device *dp)
+{
+	u32 reg;
+
+	/* Configure the input color depth, color space, dynamic range */
+	reg = (dp->video_info.dynamic_range << IN_D_RANGE_SHIFT) |
+		(dp->video_info.color_depth << IN_BPC_SHIFT) |
+		(dp->video_info.color_space << IN_COLOR_F_SHIFT);
+	analogix_dp_write(dp, ANALOGIX_DP_VIDEO_CTL_2, reg);
+
+	/* Set Input Color YCbCr Coefficients to ITU601 or ITU709 */
+	reg = analogix_dp_read(dp, ANALOGIX_DP_VIDEO_CTL_3);
+	reg &= ~IN_YC_COEFFI_MASK;
+	if (dp->video_info.ycbcr_coeff)
+		reg |= IN_YC_COEFFI_ITU709;
+	else
+		reg |= IN_YC_COEFFI_ITU601;
+	analogix_dp_write(dp, ANALOGIX_DP_VIDEO_CTL_3, reg);
+}
+
+int analogix_dp_is_slave_video_stream_clock_on(struct analogix_dp_device *dp)
+{
+	u32 reg;
+
+	reg = analogix_dp_read(dp, ANALOGIX_DP_SYS_CTL_1);
+	analogix_dp_write(dp, ANALOGIX_DP_SYS_CTL_1, reg);
+
+	reg = analogix_dp_read(dp, ANALOGIX_DP_SYS_CTL_1);
+
+	if (!(reg & DET_STA))
+		return -EINVAL;
+
+	reg = analogix_dp_read(dp, ANALOGIX_DP_SYS_CTL_2);
+	analogix_dp_write(dp, ANALOGIX_DP_SYS_CTL_2, reg);
+
+	reg = analogix_dp_read(dp, ANALOGIX_DP_SYS_CTL_2);
+
+	if (reg & CHA_STA)
+		return -EINVAL;
+
+	return 0;
+}
+
+void analogix_dp_set_video_cr_mn(struct analogix_dp_device *dp,
+				 enum clock_recovery_m_value_type type,
+				 u32 m_value, u32 n_value)
+{
+	u32 reg;
+
+	if (type == REGISTER_M) {
+		reg = analogix_dp_read(dp, ANALOGIX_DP_SYS_CTL_4);
+		reg |= FIX_M_VID;
+		analogix_dp_write(dp, ANALOGIX_DP_SYS_CTL_4, reg);
+		reg = m_value & 0xff;
+		analogix_dp_write(dp, ANALOGIX_DP_M_VID_0, reg);
+		reg = (m_value >> 8) & 0xff;
+		analogix_dp_write(dp, ANALOGIX_DP_M_VID_1, reg);
+		reg = (m_value >> 16) & 0xff;
+		analogix_dp_write(dp, ANALOGIX_DP_M_VID_2, reg);
+
+		reg = n_value & 0xff;
+		analogix_dp_write(dp, ANALOGIX_DP_N_VID_0, reg);
+		reg = (n_value >> 8) & 0xff;
+		analogix_dp_write(dp, ANALOGIX_DP_N_VID_1, reg);
+		reg = (n_value >> 16) & 0xff;
+		analogix_dp_write(dp, ANALOGIX_DP_N_VID_2, reg);
+	} else  {
+		reg = analogix_dp_read(dp, ANALOGIX_DP_SYS_CTL_4);
+		reg &= ~FIX_M_VID;
+		analogix_dp_write(dp, ANALOGIX_DP_SYS_CTL_4, reg);
+
+		analogix_dp_write(dp, ANALOGIX_DP_N_VID_0, 0x00);
+		analogix_dp_write(dp, ANALOGIX_DP_N_VID_1, 0x80);
+		analogix_dp_write(dp, ANALOGIX_DP_N_VID_2, 0x00);
+	}
+}
+
+void analogix_dp_set_video_timing_mode(struct analogix_dp_device *dp, u32 type)
+{
+	u32 reg;
+
+	if (type == VIDEO_TIMING_FROM_CAPTURE) {
+		reg = analogix_dp_read(dp, ANALOGIX_DP_VIDEO_CTL_10);
+		reg &= ~FORMAT_SEL;
+		analogix_dp_write(dp, ANALOGIX_DP_VIDEO_CTL_10, reg);
+	} else {
+		reg = analogix_dp_read(dp, ANALOGIX_DP_VIDEO_CTL_10);
+		reg |= FORMAT_SEL;
+		analogix_dp_write(dp, ANALOGIX_DP_VIDEO_CTL_10, reg);
+	}
+}
+
+void analogix_dp_enable_video_master(struct analogix_dp_device *dp, bool enable)
+{
+	u32 reg;
+
+	if (enable) {
+		reg = analogix_dp_read(dp, ANALOGIX_DP_SOC_GENERAL_CTL);
+		reg &= ~VIDEO_MODE_MASK;
+		reg |= VIDEO_MASTER_MODE_EN | VIDEO_MODE_MASTER_MODE;
+		analogix_dp_write(dp, ANALOGIX_DP_SOC_GENERAL_CTL, reg);
+	} else {
+		reg = analogix_dp_read(dp, ANALOGIX_DP_SOC_GENERAL_CTL);
+		reg &= ~VIDEO_MODE_MASK;
+		reg |= VIDEO_MODE_SLAVE_MODE;
+		analogix_dp_write(dp, ANALOGIX_DP_SOC_GENERAL_CTL, reg);
+	}
+}
+
+void analogix_dp_start_video(struct analogix_dp_device *dp)
+{
+	u32 reg;
+
+	reg = analogix_dp_read(dp, ANALOGIX_DP_VIDEO_CTL_1);
+	reg |= VIDEO_EN;
+	analogix_dp_write(dp, ANALOGIX_DP_VIDEO_CTL_1, reg);
+}
+
+int analogix_dp_is_video_stream_on(struct analogix_dp_device *dp)
+{
+	u32 reg;
+
+	reg = analogix_dp_read(dp, ANALOGIX_DP_SYS_CTL_3);
+	analogix_dp_write(dp, ANALOGIX_DP_SYS_CTL_3, reg);
+
+	reg = analogix_dp_read(dp, ANALOGIX_DP_SYS_CTL_3);
+	if (!(reg & STRM_VALID))
+		return -EINVAL;
+
+	return 0;
+}
+
+void analogix_dp_config_video_slave_mode(struct analogix_dp_device *dp)
+{
+	u32 reg;
+
+	reg = analogix_dp_read(dp, ANALOGIX_DP_FUNC_EN_1);
+	reg &= ~(MASTER_VID_FUNC_EN_N | SLAVE_VID_FUNC_EN_N);
+	reg |= MASTER_VID_FUNC_EN_N;
+	analogix_dp_write(dp, ANALOGIX_DP_FUNC_EN_1, reg);
+
+	reg = analogix_dp_read(dp, ANALOGIX_DP_VIDEO_CTL_10);
+	reg &= ~INTERACE_SCAN_CFG;
+	reg |= (dp->video_info.interlaced << 2);
+	analogix_dp_write(dp, ANALOGIX_DP_VIDEO_CTL_10, reg);
+
+	reg = analogix_dp_read(dp, ANALOGIX_DP_VIDEO_CTL_10);
+	reg &= ~VSYNC_POLARITY_CFG;
+	reg |= (dp->video_info.v_sync_polarity << 1);
+	analogix_dp_write(dp, ANALOGIX_DP_VIDEO_CTL_10, reg);
+
+	reg = analogix_dp_read(dp, ANALOGIX_DP_VIDEO_CTL_10);
+	reg &= ~HSYNC_POLARITY_CFG;
+	reg |= (dp->video_info.h_sync_polarity << 0);
+	analogix_dp_write(dp, ANALOGIX_DP_VIDEO_CTL_10, reg);
+
+	reg = AUDIO_MODE_SPDIF_MODE | VIDEO_MODE_SLAVE_MODE;
+	analogix_dp_write(dp, ANALOGIX_DP_SOC_GENERAL_CTL, reg);
+}
+
+void analogix_dp_enable_scrambling(struct analogix_dp_device *dp)
+{
+	u32 reg;
+
+	reg = analogix_dp_read(dp, ANALOGIX_DP_TRAINING_PTN_SET);
+	reg &= ~SCRAMBLING_DISABLE;
+	analogix_dp_write(dp, ANALOGIX_DP_TRAINING_PTN_SET, reg);
+}
+
+void analogix_dp_disable_scrambling(struct analogix_dp_device *dp)
+{
+	u32 reg;
+
+	reg = analogix_dp_read(dp, ANALOGIX_DP_TRAINING_PTN_SET);
+	reg |= SCRAMBLING_DISABLE;
+	analogix_dp_write(dp, ANALOGIX_DP_TRAINING_PTN_SET, reg);
+}
+
+void analogix_dp_set_video_format(struct analogix_dp_device *dp,
+				  const struct drm_display_mode *mode)
+{
+	unsigned int hsw, hfp, hbp, vsw, vfp, vbp;
+
+	dp->video_info.interlaced = !!(mode->flags & DRM_MODE_FLAG_INTERLACE);
+
+	if (dp->plat_data.subdev_type == RK3588_EDP) {
+		dp->video_info.v_sync_polarity = true;
+		dp->video_info.h_sync_polarity = true;
+	} else {
+		dp->video_info.v_sync_polarity = !!(mode->flags & DRM_MODE_FLAG_NVSYNC);
+		dp->video_info.h_sync_polarity = !!(mode->flags & DRM_MODE_FLAG_NHSYNC);
+	}
+
+	hsw = mode->hsync_end - mode->hsync_start;
+	hfp = mode->hsync_start - mode->hdisplay;
+	hbp = mode->htotal - mode->hsync_end;
+	vsw = mode->vsync_end - mode->vsync_start;
+	vfp = mode->vsync_start - mode->vdisplay;
+	vbp = mode->vtotal - mode->vsync_end;
+
+	/* Set Video Format Parameters */
+	analogix_dp_write(dp, ANALOGIX_DP_TOTAL_LINE_CFG_L,
+			  TOTAL_LINE_CFG_L(mode->vtotal));
+	analogix_dp_write(dp, ANALOGIX_DP_TOTAL_LINE_CFG_H,
+			  TOTAL_LINE_CFG_H(mode->vtotal >> 8));
+	analogix_dp_write(dp, ANALOGIX_DP_ACTIVE_LINE_CFG_L,
+			  ACTIVE_LINE_CFG_L(mode->vdisplay));
+	analogix_dp_write(dp, ANALOGIX_DP_ACTIVE_LINE_CFG_H,
+			  ACTIVE_LINE_CFG_H(mode->vdisplay >> 8));
+	analogix_dp_write(dp, ANALOGIX_DP_V_F_PORCH_CFG,
+			  V_F_PORCH_CFG(vfp));
+	analogix_dp_write(dp, ANALOGIX_DP_V_SYNC_WIDTH_CFG,
+			  V_SYNC_WIDTH_CFG(vsw));
+	analogix_dp_write(dp, ANALOGIX_DP_V_B_PORCH_CFG,
+			  V_B_PORCH_CFG(vbp));
+	analogix_dp_write(dp, ANALOGIX_DP_TOTAL_PIXEL_CFG_L,
+			  TOTAL_PIXEL_CFG_L(mode->htotal));
+	analogix_dp_write(dp, ANALOGIX_DP_TOTAL_PIXEL_CFG_H,
+			  TOTAL_PIXEL_CFG_H(mode->htotal >> 8));
+	analogix_dp_write(dp, ANALOGIX_DP_ACTIVE_PIXEL_CFG_L,
+			  ACTIVE_PIXEL_CFG_L(mode->hdisplay));
+	analogix_dp_write(dp, ANALOGIX_DP_ACTIVE_PIXEL_CFG_H,
+			  ACTIVE_PIXEL_CFG_H(mode->hdisplay >> 8));
+	analogix_dp_write(dp, ANALOGIX_DP_H_F_PORCH_CFG_L,
+			  H_F_PORCH_CFG_L(hfp));
+	analogix_dp_write(dp, ANALOGIX_DP_H_F_PORCH_CFG_H,
+			  H_F_PORCH_CFG_H(hfp >> 8));
+	analogix_dp_write(dp, ANALOGIX_DP_H_SYNC_CFG_L,
+			  H_SYNC_CFG_L(hsw));
+	analogix_dp_write(dp, ANALOGIX_DP_H_SYNC_CFG_H,
+			  H_SYNC_CFG_H(hsw >> 8));
+	analogix_dp_write(dp, ANALOGIX_DP_H_B_PORCH_CFG_L,
+			  H_B_PORCH_CFG_L(hbp));
+	analogix_dp_write(dp, ANALOGIX_DP_H_B_PORCH_CFG_H,
+			  H_B_PORCH_CFG_H(hbp >> 8));
+}
+
+void analogix_dp_video_bist_enable(struct analogix_dp_device *dp)
+{
+	u32 reg;
+
+	/* Enable Video BIST */
+	analogix_dp_write(dp, ANALOGIX_DP_VIDEO_CTL_4, BIST_EN);
+
+	/*
+	 * Note that if BIST_EN is set to 1, F_SEL must be cleared to 0
+	 * although video format information comes from registers set by user.
+	 */
+	reg = analogix_dp_read(dp, ANALOGIX_DP_VIDEO_CTL_10);
+	reg &= ~FORMAT_SEL;
+	analogix_dp_write(dp, ANALOGIX_DP_VIDEO_CTL_10, reg);
+}
diff --git a/drivers/video/drm/bmp_helper.c b/drivers/video/drm/bmp_helper.c
new file mode 100755
index 0000000000..c387a02f9e
--- /dev/null
+++ b/drivers/video/drm/bmp_helper.c
@@ -0,0 +1,239 @@
+/*
+ * (C) Copyright 2008-2017 Fuzhou Rockchip Electronics Co., Ltd
+ * Author: Mark Yao <mark.yao@rock-chips.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#include <config.h>
+#include <common.h>
+#include <malloc.h>
+#include <asm/unaligned.h>
+#include <bmp_layout.h>
+
+#define BMP_RLE8_ESCAPE		0
+#define BMP_RLE8_EOL		0
+#define BMP_RLE8_EOBMP		1
+#define BMP_RLE8_DELTA		2
+
+static void draw_unencoded_bitmap(uint16_t **dst, uint8_t *bmap, uint16_t *cmap,
+				  uint32_t cnt)
+{
+	while (cnt > 0) {
+		*(*dst)++ = cmap[*bmap++];
+		cnt--;
+	}
+}
+
+static void draw_encoded_bitmap(uint16_t **dst, uint16_t c, uint32_t cnt)
+{
+	uint16_t *fb = *dst;
+	int cnt_8copy = cnt >> 3;
+
+	cnt -= cnt_8copy << 3;
+	while (cnt_8copy > 0) {
+		*fb++ = c;
+		*fb++ = c;
+		*fb++ = c;
+		*fb++ = c;
+		*fb++ = c;
+		*fb++ = c;
+		*fb++ = c;
+		*fb++ = c;
+		cnt_8copy--;
+	}
+	while (cnt > 0) {
+		*fb++ = c;
+		cnt--;
+	}
+	*dst = fb;
+}
+
+static void decode_rle8_bitmap(void *psrc, void *pdst, uint16_t *cmap,
+			       int width, int height, int bits, int x_off,
+			       int y_off, bool flip)
+{
+	uint32_t cnt, runlen;
+	int x = 0, y = 0;
+	int decode = 1;
+	int linesize = width * 2;
+	uint8_t *bmap = psrc;
+	uint8_t *dst = pdst;
+
+	if (flip) {
+		y = height - 1;
+		dst = pdst + y * linesize;
+	}
+
+	while (decode) {
+		if (bmap[0] == BMP_RLE8_ESCAPE) {
+			switch (bmap[1]) {
+			case BMP_RLE8_EOL:
+				/* end of line */
+				bmap += 2;
+				x = 0;
+				if (flip) {
+					y--;
+					dst -= linesize * 2;
+				} else {
+					y++;
+				}
+				break;
+			case BMP_RLE8_EOBMP:
+				/* end of bitmap */
+				decode = 0;
+				break;
+			case BMP_RLE8_DELTA:
+				/* delta run */
+				x += bmap[2];
+				if (flip) {
+					y -= bmap[3];
+					dst -= bmap[3] * linesize;
+					dst += bmap[2] * 2;
+				} else {
+					y += bmap[3];
+					dst += bmap[3] * linesize;
+					dst += bmap[2] * 2;
+				}
+				bmap += 4;
+				break;
+			default:
+				/* unencoded run */
+				runlen = bmap[1];
+				bmap += 2;
+				if (y >= height || x >= width) {
+					decode = 0;
+					break;
+				}
+				if (x + runlen > width)
+					cnt = width - x;
+				else
+					cnt = runlen;
+				draw_unencoded_bitmap((uint16_t **)&dst, bmap,
+						      cmap, cnt);
+				x += runlen;
+				bmap += runlen;
+				if (runlen & 1)
+					bmap++;
+			}
+		} else {
+			/* encoded run */
+			if (y < height) {
+				runlen = bmap[0];
+				if (x < width) {
+					/* aggregate the same code */
+					while (bmap[0] == 0xff &&
+					       bmap[2] != BMP_RLE8_ESCAPE &&
+					       bmap[1] == bmap[3]) {
+						runlen += bmap[2];
+						bmap += 2;
+					}
+					if (x + runlen > width)
+						cnt = width - x;
+					else
+						cnt = runlen;
+					draw_encoded_bitmap((uint16_t **)&dst,
+							    cmap[bmap[1]], cnt);
+				}
+				x += runlen;
+			}
+			bmap += 2;
+		}
+	}
+}
+
+int bmpdecoder(void *bmp_addr, void *pdst, int dst_bpp)
+{
+	int stride, padded_width, bpp, i, width, height;
+	struct bmp_image *bmp = bmp_addr;
+	uint8_t *src = bmp_addr;
+	uint8_t *dst = pdst;
+	bool flip = false;
+	uint16_t *cmap;
+	uint8_t *cmap_base;
+
+	if (!bmp || !(bmp->header.signature[0] == 'B' &&
+	    bmp->header.signature[1] == 'M')) {
+		printf("cat not find bmp file\n");
+		return -1;
+	}
+	width = get_unaligned_le32(&bmp->header.width);
+	height = get_unaligned_le32(&bmp->header.height);
+	bpp = get_unaligned_le16(&bmp->header.bit_count);
+	padded_width = width & 0x3 ? (width & ~0x3) + 4 : width;
+
+	if (height < 0)
+		height = 0 - height;
+	else
+		flip = true;
+
+	cmap_base = src + sizeof(bmp->header);
+	src = bmp_addr + get_unaligned_le32(&bmp->header.data_offset);
+
+	switch (bpp) {
+	case 8:
+		if (dst_bpp != 16) {
+			printf("can't support covert bmap to bit[%d]\n",
+			       dst_bpp);
+			return -1;
+		}
+		cmap = malloc(sizeof(cmap) * 256);
+
+		/* Set color map */
+		for (i = 0; i < 256; i++) {
+			ushort colreg = ((cmap_base[2] << 8) & 0xf800) |
+					((cmap_base[1] << 3) & 0x07e0) |
+					((cmap_base[0] >> 3) & 0x001f) ;
+			cmap_base += 4;
+			cmap[i] = colreg;
+		}
+		/*
+		 * only support convert 8bit bmap file to RGB565.
+		 */
+		if (get_unaligned_le32(&bmp->header.compression)) {
+			decode_rle8_bitmap(src, dst, cmap, width, height,
+					   bpp, 0, 0, flip);
+		} else {
+			int j;
+			stride = width * 2;
+
+			if (flip)
+				dst += stride * (height - 1);
+
+			for (i = 0; i < height; ++i) {
+				for (j = 0; j < width; j++) {
+					*(uint16_t *)dst = cmap[*(src++)];
+					dst += sizeof(uint16_t) / sizeof(*dst);
+				}
+				src += (padded_width - width);
+				if (flip)
+					dst -= stride * 2;
+			}
+		}
+		free(cmap);
+		break;
+	case 24:
+		if (get_unaligned_le32(&bmp->header.compression)) {
+			printf("can't not support compression for 24bit bmap");
+			return -1;
+		}
+		stride = ALIGN(width * 3, 4);
+		if (flip)
+			src += stride * (height - 1);
+
+		for (i = 0; i < height; i++) {
+			memcpy(dst, src, 3 * width);
+			dst += stride;
+			src += stride;
+			if (flip)
+				src -= stride * 2;
+		}
+		break;
+	case 16:
+	case 32:
+	default:
+		printf("unsupport bit=%d now\n", bpp);
+		return -1;
+	}
+
+	return 0;
+}
diff --git a/drivers/video/drm/bmp_helper.h b/drivers/video/drm/bmp_helper.h
new file mode 100644
index 0000000000..5e125004d2
--- /dev/null
+++ b/drivers/video/drm/bmp_helper.h
@@ -0,0 +1,19 @@
+/*
+ * (C) Copyright 2008-2017 Fuzhou Rockchip Electronics Co., Ltd
+ * Author: Mark Yao <mark.yao@rock-chips.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _BMP_HELPER_H_
+#define _BMP_HELPER_H_
+
+#define BMP_RLE8_ESCAPE		0
+#define BMP_RLE8_EOL		0
+#define BMP_RLE8_EOBMP		1
+#define BMP_RLE8_DELTA		2
+
+#define range(x, min, max) ((x) < (min)) ? (min) : (((x) > (max)) ? (max) : (x))
+
+int bmpdecoder(void *bmp_addr, void *dst, int dst_bpp);
+#endif /* _BMP_HELPER_H_ */
diff --git a/drivers/video/drm/drm_dp_helper.c b/drivers/video/drm/drm_dp_helper.c
new file mode 100644
index 0000000000..e011f59c64
--- /dev/null
+++ b/drivers/video/drm/drm_dp_helper.c
@@ -0,0 +1,550 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright © 2009 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided "as
+ * is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+#include <common.h>
+#include <linux/bug.h>
+#include <drm/drm_dp_helper.h>
+
+/**
+ * DOC: dp helpers
+ *
+ * These functions contain some common logic and helpers at various abstraction
+ * levels to deal with Display Port sink devices and related things like DP aux
+ * channel transfers, EDID reading over DP aux channels, decoding certain DPCD
+ * blocks, ...
+ */
+
+/* Helpers for DP link training */
+static u8 dp_link_status(const u8 link_status[DP_LINK_STATUS_SIZE], int r)
+{
+	return link_status[r - DP_LANE0_1_STATUS];
+}
+
+static u8 dp_get_lane_status(const u8 link_status[DP_LINK_STATUS_SIZE],
+			     int lane)
+{
+	int i = DP_LANE0_1_STATUS + (lane >> 1);
+	int s = (lane & 1) * 4;
+	u8 l = dp_link_status(link_status, i);
+
+	return (l >> s) & 0xf;
+}
+
+bool drm_dp_channel_eq_ok(const u8 link_status[DP_LINK_STATUS_SIZE],
+			  int lane_count)
+{
+	u8 lane_align;
+	u8 lane_status;
+	int lane;
+
+	lane_align = dp_link_status(link_status,
+				    DP_LANE_ALIGN_STATUS_UPDATED);
+	if ((lane_align & DP_INTERLANE_ALIGN_DONE) == 0)
+		return false;
+	for (lane = 0; lane < lane_count; lane++) {
+		lane_status = dp_get_lane_status(link_status, lane);
+		if ((lane_status & DP_CHANNEL_EQ_BITS) != DP_CHANNEL_EQ_BITS)
+			return false;
+	}
+	return true;
+}
+
+bool drm_dp_clock_recovery_ok(const u8 link_status[DP_LINK_STATUS_SIZE],
+			      int lane_count)
+{
+	int lane;
+	u8 lane_status;
+
+	for (lane = 0; lane < lane_count; lane++) {
+		lane_status = dp_get_lane_status(link_status, lane);
+		if ((lane_status & DP_LANE_CR_DONE) == 0)
+			return false;
+	}
+	return true;
+}
+
+u8 drm_dp_get_adjust_request_voltage(const u8 link_status[DP_LINK_STATUS_SIZE],
+				     int lane)
+{
+	int i = DP_ADJUST_REQUEST_LANE0_1 + (lane >> 1);
+	int s = ((lane & 1) ?
+		 DP_ADJUST_VOLTAGE_SWING_LANE1_SHIFT :
+		 DP_ADJUST_VOLTAGE_SWING_LANE0_SHIFT);
+	u8 l = dp_link_status(link_status, i);
+
+	return ((l >> s) & 0x3) << DP_TRAIN_VOLTAGE_SWING_SHIFT;
+}
+
+u8 drm_dp_get_adjust_request_pre_emphasis(const u8 link_status[DP_LINK_STATUS_SIZE],
+					  int lane)
+{
+	int i = DP_ADJUST_REQUEST_LANE0_1 + (lane >> 1);
+	int s = ((lane & 1) ?
+		 DP_ADJUST_PRE_EMPHASIS_LANE1_SHIFT :
+		 DP_ADJUST_PRE_EMPHASIS_LANE0_SHIFT);
+	u8 l = dp_link_status(link_status, i);
+
+	return ((l >> s) & 0x3) << DP_TRAIN_PRE_EMPHASIS_SHIFT;
+}
+
+void drm_dp_link_train_clock_recovery_delay(const u8 dpcd[DP_RECEIVER_CAP_SIZE])
+{
+	int rd_interval = dpcd[DP_TRAINING_AUX_RD_INTERVAL] &
+			  DP_TRAINING_AUX_RD_MASK;
+
+	if (rd_interval > 4)
+		printf("AUX interval %d, out of range (max 4)\n", rd_interval);
+
+	if (rd_interval == 0 || dpcd[DP_DPCD_REV] >= DP_DPCD_REV_14)
+		udelay(100);
+	else
+		mdelay(rd_interval * 4);
+}
+
+void drm_dp_link_train_channel_eq_delay(const u8 dpcd[DP_RECEIVER_CAP_SIZE])
+{
+	int rd_interval = dpcd[DP_TRAINING_AUX_RD_INTERVAL] &
+			  DP_TRAINING_AUX_RD_MASK;
+
+	if (rd_interval > 4)
+		printf("AUX interval %d, out of range (max 4)\n", rd_interval);
+
+	if (rd_interval == 0)
+		udelay(400);
+	else
+		mdelay(rd_interval * 4);
+}
+
+u8 drm_dp_link_rate_to_bw_code(int link_rate)
+{
+	switch (link_rate) {
+	default:
+		WARN(1, "unknown DP link rate %d, using %x\n", link_rate,
+		     DP_LINK_BW_1_62);
+	case 162000:
+		return DP_LINK_BW_1_62;
+	case 270000:
+		return DP_LINK_BW_2_7;
+	case 540000:
+		return DP_LINK_BW_5_4;
+	case 810000:
+		return DP_LINK_BW_8_1;
+	}
+}
+
+int drm_dp_bw_code_to_link_rate(u8 link_bw)
+{
+	switch (link_bw) {
+	default:
+		WARN(1, "unknown DP link BW code %x, using 162000\n", link_bw);
+	case DP_LINK_BW_1_62:
+		return 162000;
+	case DP_LINK_BW_2_7:
+		return 270000;
+	case DP_LINK_BW_5_4:
+		return 540000;
+	case DP_LINK_BW_8_1:
+		return 810000;
+	}
+}
+
+#define AUX_RETRY_INTERVAL 500 /* us */
+
+static int drm_dp_dpcd_access(struct drm_dp_aux *aux, u8 request,
+			      unsigned int offset, void *buffer, size_t size)
+{
+	struct drm_dp_aux_msg msg;
+	unsigned int retry, native_reply;
+	int err = 0, ret = 0;
+
+	memset(&msg, 0, sizeof(msg));
+	msg.address = offset;
+	msg.request = request;
+	msg.buffer = buffer;
+	msg.size = size;
+
+	/*
+	 * The specification doesn't give any recommendation on how often to
+	 * retry native transactions. We used to retry 7 times like for
+	 * aux i2c transactions but real world devices this wasn't
+	 * sufficient, bump to 32 which makes Dell 4k monitors happier.
+	 */
+	for (retry = 0; retry < 32; retry++) {
+		if (ret != 0 && ret != -ETIMEDOUT)
+			udelay(AUX_RETRY_INTERVAL);
+
+		ret = aux->transfer(aux, &msg);
+		if (ret >= 0) {
+			native_reply = msg.reply & DP_AUX_NATIVE_REPLY_MASK;
+			if (native_reply == DP_AUX_NATIVE_REPLY_ACK) {
+				if (ret == size)
+					goto out;
+
+				ret = -EPROTO;
+			} else {
+				ret = -EIO;
+			}
+		}
+
+		/*
+		 * We want the error we return to be the error we received on
+		 * the first transaction, since we may get a different error the
+		 * next time we retry
+		 */
+		if (!err)
+			err = ret;
+	}
+
+	printf("%s: Too many retries, giving up. First error: %d\n",
+	       aux->name, err);
+	ret = err;
+
+out:
+	return ret;
+}
+
+ssize_t drm_dp_dpcd_read(struct drm_dp_aux *aux, unsigned int offset,
+			 void *buffer, size_t size)
+{
+	int ret;
+
+	ret = drm_dp_dpcd_access(aux, DP_AUX_NATIVE_READ, DP_DPCD_REV,
+				 buffer, 1);
+	if (ret != 1)
+		goto out;
+
+	ret = drm_dp_dpcd_access(aux, DP_AUX_NATIVE_READ, offset,
+				 buffer, size);
+
+out:
+	return ret;
+}
+
+ssize_t drm_dp_dpcd_write(struct drm_dp_aux *aux, unsigned int offset,
+			  void *buffer, size_t size)
+{
+	int ret;
+
+	ret = drm_dp_dpcd_access(aux, DP_AUX_NATIVE_WRITE, offset,
+				 buffer, size);
+
+	return ret;
+}
+
+int drm_dp_dpcd_read_link_status(struct drm_dp_aux *aux,
+				 u8 status[DP_LINK_STATUS_SIZE])
+{
+	return drm_dp_dpcd_read(aux, DP_LANE0_1_STATUS, status,
+				DP_LINK_STATUS_SIZE);
+}
+
+static int drm_dp_read_extended_dpcd_caps(struct drm_dp_aux *aux,
+					  u8 dpcd[DP_RECEIVER_CAP_SIZE])
+{
+	u8 dpcd_ext[6];
+	int ret;
+
+	/*
+	 * Prior to DP1.3 the bit represented by
+	 * DP_EXTENDED_RECEIVER_CAP_FIELD_PRESENT was reserved.
+	 * If it is set DP_DPCD_REV at 0000h could be at a value less than
+	 * the true capability of the panel. The only way to check is to
+	 * then compare 0000h and 2200h.
+	 */
+	if (!(dpcd[DP_TRAINING_AUX_RD_INTERVAL] &
+	      DP_EXTENDED_RECEIVER_CAP_FIELD_PRESENT))
+		return 0;
+
+	ret = drm_dp_dpcd_read(aux, DP_DP13_DPCD_REV, &dpcd_ext,
+			       sizeof(dpcd_ext));
+	if (ret < 0)
+		return ret;
+	if (ret != sizeof(dpcd_ext))
+		return -EIO;
+
+	if (dpcd[DP_DPCD_REV] > dpcd_ext[DP_DPCD_REV]) {
+		printf("%s: Extended DPCD rev less than base DPCD rev (%d > %d)\n",
+		       aux->name, dpcd[DP_DPCD_REV], dpcd_ext[DP_DPCD_REV]);
+		return 0;
+	}
+
+	if (!memcmp(dpcd, dpcd_ext, sizeof(dpcd_ext)))
+		return 0;
+
+	debug("%s: Base DPCD: %*ph\n",
+	       aux->name, DP_RECEIVER_CAP_SIZE, dpcd);
+
+	memcpy(dpcd, dpcd_ext, sizeof(dpcd_ext));
+
+	return 0;
+}
+
+int drm_dp_read_dpcd_caps(struct drm_dp_aux *aux,
+			  u8 dpcd[DP_RECEIVER_CAP_SIZE])
+{
+	int ret;
+
+	ret = drm_dp_dpcd_read(aux, DP_DPCD_REV, dpcd, DP_RECEIVER_CAP_SIZE);
+	if (ret < 0)
+		return ret;
+	if (ret != DP_RECEIVER_CAP_SIZE || dpcd[DP_DPCD_REV] == 0)
+		return -EIO;
+
+	ret = drm_dp_read_extended_dpcd_caps(aux, dpcd);
+	if (ret < 0)
+		return ret;
+
+	debug("%s: DPCD: %*ph\n",
+	       aux->name, DP_RECEIVER_CAP_SIZE, dpcd);
+
+	return ret;
+}
+
+static void drm_dp_i2c_msg_write_status_update(struct drm_dp_aux_msg *msg)
+{
+	/*
+	 * In case of i2c defer or short i2c ack reply to a write,
+	 * we need to switch to WRITE_STATUS_UPDATE to drain the
+	 * rest of the message
+	 */
+	if ((msg->request & ~DP_AUX_I2C_MOT) == DP_AUX_I2C_WRITE) {
+		msg->request &= DP_AUX_I2C_MOT;
+		msg->request |= DP_AUX_I2C_WRITE_STATUS_UPDATE;
+	}
+}
+
+static int drm_dp_i2c_do_msg(struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg)
+{
+	unsigned int retry, defer_i2c;
+	int ret;
+	/*
+	 * DP1.2 sections 2.7.7.1.5.6.1 and 2.7.7.1.6.6.1: A DP Source device
+	 * is required to retry at least seven times upon receiving AUX_DEFER
+	 * before giving up the AUX transaction.
+	 *
+	 * We also try to account for the i2c bus speed.
+	 */
+	int max_retries = 7;
+
+	for (retry = 0, defer_i2c = 0; retry < (max_retries + defer_i2c);
+	     retry++) {
+		ret = aux->transfer(aux, msg);
+		if (ret < 0) {
+			if (ret == -EBUSY)
+				continue;
+
+			/*
+			 * While timeouts can be errors, they're usually normal
+			 * behavior (for instance, when a driver tries to
+			 * communicate with a non-existent DisplayPort device).
+			 * Avoid spamming the kernel log with timeout errors.
+			 */
+			if (ret == -ETIMEDOUT)
+				printf("%s: transaction timed out\n",
+				       aux->name);
+			else
+				printf("%s: transaction failed: %d\n",
+				       aux->name, ret);
+			return ret;
+		}
+
+		switch (msg->reply & DP_AUX_NATIVE_REPLY_MASK) {
+		case DP_AUX_NATIVE_REPLY_ACK:
+			/*
+			 * For I2C-over-AUX transactions this isn't enough, we
+			 * need to check for the I2C ACK reply.
+			 */
+			break;
+
+		case DP_AUX_NATIVE_REPLY_NACK:
+			printf("%s: native nack (result=%d, size=%zu)\n",
+			       aux->name, ret, msg->size);
+			return -EREMOTEIO;
+
+		case DP_AUX_NATIVE_REPLY_DEFER:
+			printf("%s: native defer\n", aux->name);
+			/*
+			 * We could check for I2C bit rate capabilities and if
+			 * available adjust this interval. We could also be
+			 * more careful with DP-to-legacy adapters where a
+			 * long legacy cable may force very low I2C bit rates.
+			 *
+			 * For now just defer for long enough to hopefully be
+			 * safe for all use-cases.
+			 */
+			udelay(AUX_RETRY_INTERVAL);
+			continue;
+
+		default:
+			printf("%s: invalid native reply %#04x\n",
+			       aux->name, msg->reply);
+			return -EREMOTEIO;
+		}
+
+		switch (msg->reply & DP_AUX_I2C_REPLY_MASK) {
+		case DP_AUX_I2C_REPLY_ACK:
+			/*
+			 * Both native ACK and I2C ACK replies received. We
+			 * can assume the transfer was successful.
+			 */
+			if (ret != msg->size)
+				drm_dp_i2c_msg_write_status_update(msg);
+			return ret;
+
+		case DP_AUX_I2C_REPLY_NACK:
+			printf("%s: I2C nack (result=%d, size=%zu)\n",
+			       aux->name, ret, msg->size);
+			aux->i2c_nack_count++;
+			return -EREMOTEIO;
+
+		case DP_AUX_I2C_REPLY_DEFER:
+			printf("%s: I2C defer\n", aux->name);
+			/* DP Compliance Test 4.2.2.5 Requirement:
+			 * Must have at least 7 retries for I2C defers on the
+			 * transaction to pass this test
+			 */
+			aux->i2c_defer_count++;
+			if (defer_i2c < 7)
+				defer_i2c++;
+			udelay(AUX_RETRY_INTERVAL);
+			drm_dp_i2c_msg_write_status_update(msg);
+
+			continue;
+
+		default:
+			printf("%s: invalid I2C reply %#04x\n",
+			       aux->name, msg->reply);
+			return -EREMOTEIO;
+		}
+	}
+
+	printf("%s: Too many retries, giving up\n", aux->name);
+	return -EREMOTEIO;
+}
+
+static void drm_dp_i2c_msg_set_request(struct drm_dp_aux_msg *msg,
+				       const struct i2c_msg *i2c_msg)
+{
+	msg->request = (i2c_msg->flags & I2C_M_RD) ?
+		DP_AUX_I2C_READ : DP_AUX_I2C_WRITE;
+	if (!(i2c_msg->flags & I2C_M_STOP))
+		msg->request |= DP_AUX_I2C_MOT;
+}
+
+/*
+ * Keep retrying drm_dp_i2c_do_msg until all data has been transferred.
+ *
+ * Returns an error code on failure, or a recommended transfer size on success.
+ */
+static int drm_dp_i2c_drain_msg(struct drm_dp_aux *aux,
+				struct drm_dp_aux_msg *orig_msg)
+{
+	int err, ret = orig_msg->size;
+	struct drm_dp_aux_msg msg = *orig_msg;
+
+	while (msg.size > 0) {
+		err = drm_dp_i2c_do_msg(aux, &msg);
+		if (err <= 0)
+			return err == 0 ? -EPROTO : err;
+
+		if (err < msg.size && err < ret) {
+			printf("%s: Reply: requested %zu bytes got %d bytes\n",
+			       aux->name, msg.size, err);
+			ret = err;
+		}
+
+		msg.size -= err;
+		msg.buffer += err;
+	}
+
+	return ret;
+}
+
+int drm_dp_i2c_xfer(struct ddc_adapter *adapter, struct i2c_msg *msgs,
+		    int num)
+{
+	struct drm_dp_aux *aux = container_of(adapter, struct drm_dp_aux, ddc);
+	unsigned int i, j;
+	unsigned int transfer_size;
+	struct drm_dp_aux_msg msg;
+	int err = 0;
+
+	memset(&msg, 0, sizeof(msg));
+
+	for (i = 0; i < num; i++) {
+		msg.address = msgs[i].addr;
+		drm_dp_i2c_msg_set_request(&msg, &msgs[i]);
+		/* Send a bare address packet to start the transaction.
+		 * Zero sized messages specify an address only (bare
+		 * address) transaction.
+		 */
+		msg.buffer = NULL;
+		msg.size = 0;
+		err = drm_dp_i2c_do_msg(aux, &msg);
+
+		/*
+		 * Reset msg.request in case in case it got
+		 * changed into a WRITE_STATUS_UPDATE.
+		 */
+		drm_dp_i2c_msg_set_request(&msg, &msgs[i]);
+
+		if (err < 0)
+			break;
+		/* We want each transaction to be as large as possible, but
+		 * we'll go to smaller sizes if the hardware gives us a
+		 * short reply.
+		 */
+		transfer_size = DP_AUX_MAX_PAYLOAD_BYTES;
+		for (j = 0; j < msgs[i].len; j += msg.size) {
+			msg.buffer = msgs[i].buf + j;
+			msg.size = min(transfer_size, msgs[i].len - j);
+
+			err = drm_dp_i2c_drain_msg(aux, &msg);
+
+			/*
+			 * Reset msg.request in case in case it got
+			 * changed into a WRITE_STATUS_UPDATE.
+			 */
+			drm_dp_i2c_msg_set_request(&msg, &msgs[i]);
+
+			if (err < 0)
+				break;
+			transfer_size = err;
+		}
+		if (err < 0)
+			break;
+	}
+	if (err >= 0)
+		err = num;
+	/* Send a bare address packet to close out the transaction.
+	 * Zero sized messages specify an address only (bare
+	 * address) transaction.
+	 */
+	msg.request &= ~DP_AUX_I2C_MOT;
+	msg.buffer = NULL;
+	msg.size = 0;
+	(void)drm_dp_i2c_do_msg(aux, &msg);
+
+	return err;
+}
+
diff --git a/drivers/video/drm/drm_dsc.c b/drivers/video/drm/drm_dsc.c
new file mode 100644
index 0000000000..5bd873c7b2
--- /dev/null
+++ b/drivers/video/drm/drm_dsc.c
@@ -0,0 +1,374 @@
+// SPDX-License-Identifier: MIT
+/*
+ * Copyright © 2018 Intel Corp
+ *
+ * Author:
+ * Manasi Navare <manasi.d.navare@intel.com>
+ */
+
+#include <common.h>
+#include <drm/drm_dp_helper.h>
+#include <drm/drm_dsc.h>
+
+/**
+ * DOC: dsc helpers
+ *
+ * VESA specification for DP 1.4 adds a new feature called Display Stream
+ * Compression (DSC) used to compress the pixel bits before sending it on
+ * DP/eDP/MIPI DSI interface. DSC is required to be enabled so that the existing
+ * display interfaces can support high resolutions at higher frames rates using
+ * the maximum available link capacity of these interfaces.
+ *
+ * These functions contain some common logic and helpers to deal with VESA
+ * Display Stream Compression standard required for DSC on Display Port/eDP or
+ * MIPI display interfaces.
+ */
+
+/**
+ * drm_dsc_dp_pps_header_init() - Initializes the PPS Header
+ * for DisplayPort as per the DP 1.4 spec.
+ * @pps_header: Secondary data packet header for DSC Picture
+ *              Parameter Set as defined in &struct dp_sdp_header
+ *
+ * DP 1.4 spec defines the secondary data packet for sending the
+ * picture parameter infoframes from the source to the sink.
+ * This function populates the SDP header defined in
+ * &struct dp_sdp_header.
+ */
+void drm_dsc_dp_pps_header_init(struct dp_sdp_header *pps_header)
+{
+	memset(pps_header, 0, sizeof(*pps_header));
+
+	pps_header->HB1 = DP_SDP_PPS;
+	pps_header->HB2 = DP_SDP_PPS_HEADER_PAYLOAD_BYTES_MINUS_1;
+}
+
+/**
+ * drm_dsc_pps_payload_pack() - Populates the DSC PPS
+ *
+ * @pps_payload:
+ * Bitwise struct for DSC Picture Parameter Set. This is defined
+ * by &struct drm_dsc_picture_parameter_set
+ * @dsc_cfg:
+ * DSC Configuration data filled by driver as defined by
+ * &struct drm_dsc_config
+ *
+ * DSC source device sends a picture parameter set (PPS) containing the
+ * information required by the sink to decode the compressed frame. Driver
+ * populates the DSC PPS struct using the DSC configuration parameters in
+ * the order expected by the DSC Display Sink device. For the DSC, the sink
+ * device expects the PPS payload in big endian format for fields
+ * that span more than 1 byte.
+ */
+void drm_dsc_pps_payload_pack(struct drm_dsc_picture_parameter_set *pps_payload,
+			      const struct drm_dsc_config *dsc_cfg)
+{
+	int i;
+
+	/* Protect against someone accidentally changing struct size */
+	BUILD_BUG_ON(sizeof(*pps_payload) !=
+		     DP_SDP_PPS_HEADER_PAYLOAD_BYTES_MINUS_1 + 1);
+
+	memset(pps_payload, 0, sizeof(*pps_payload));
+
+	/* PPS 0 */
+	pps_payload->dsc_version =
+		dsc_cfg->dsc_version_minor |
+		dsc_cfg->dsc_version_major << DSC_PPS_VERSION_MAJOR_SHIFT;
+
+	/* PPS 1, 2 is 0 */
+
+	/* PPS 3 */
+	pps_payload->pps_3 =
+		dsc_cfg->line_buf_depth |
+		dsc_cfg->bits_per_component << DSC_PPS_BPC_SHIFT;
+
+	/* PPS 4 */
+	pps_payload->pps_4 =
+		((dsc_cfg->bits_per_pixel & DSC_PPS_BPP_HIGH_MASK) >>
+		 DSC_PPS_MSB_SHIFT) |
+		dsc_cfg->vbr_enable << DSC_PPS_VBR_EN_SHIFT |
+		dsc_cfg->simple_422 << DSC_PPS_SIMPLE422_SHIFT |
+		dsc_cfg->convert_rgb << DSC_PPS_CONVERT_RGB_SHIFT |
+		dsc_cfg->block_pred_enable << DSC_PPS_BLOCK_PRED_EN_SHIFT;
+
+	/* PPS 5 */
+	pps_payload->bits_per_pixel_low =
+		(dsc_cfg->bits_per_pixel & DSC_PPS_LSB_MASK);
+
+	/*
+	 * The DSC panel expects the PPS packet to have big endian format
+	 * for data spanning 2 bytes. Use a macro cpu_to_be16() to convert
+	 * to big endian format. If format is little endian, it will swap
+	 * bytes to convert to Big endian else keep it unchanged.
+	 */
+
+	/* PPS 6, 7 */
+	pps_payload->pic_height = cpu_to_be16(dsc_cfg->pic_height);
+
+	/* PPS 8, 9 */
+	pps_payload->pic_width = cpu_to_be16(dsc_cfg->pic_width);
+
+	/* PPS 10, 11 */
+	pps_payload->slice_height = cpu_to_be16(dsc_cfg->slice_height);
+
+	/* PPS 12, 13 */
+	pps_payload->slice_width = cpu_to_be16(dsc_cfg->slice_width);
+
+	/* PPS 14, 15 */
+	pps_payload->chunk_size = cpu_to_be16(dsc_cfg->slice_chunk_size);
+
+	/* PPS 16 */
+	pps_payload->initial_xmit_delay_high =
+		((dsc_cfg->initial_xmit_delay &
+		  DSC_PPS_INIT_XMIT_DELAY_HIGH_MASK) >>
+		 DSC_PPS_MSB_SHIFT);
+
+	/* PPS 17 */
+	pps_payload->initial_xmit_delay_low =
+		(dsc_cfg->initial_xmit_delay & DSC_PPS_LSB_MASK);
+
+	/* PPS 18, 19 */
+	pps_payload->initial_dec_delay =
+		cpu_to_be16(dsc_cfg->initial_dec_delay);
+
+	/* PPS 20 is 0 */
+
+	/* PPS 21 */
+	pps_payload->initial_scale_value =
+		dsc_cfg->initial_scale_value;
+
+	/* PPS 22, 23 */
+	pps_payload->scale_increment_interval =
+		cpu_to_be16(dsc_cfg->scale_increment_interval);
+
+	/* PPS 24 */
+	pps_payload->scale_decrement_interval_high =
+		((dsc_cfg->scale_decrement_interval &
+		  DSC_PPS_SCALE_DEC_INT_HIGH_MASK) >>
+		 DSC_PPS_MSB_SHIFT);
+
+	/* PPS 25 */
+	pps_payload->scale_decrement_interval_low =
+		(dsc_cfg->scale_decrement_interval & DSC_PPS_LSB_MASK);
+
+	/* PPS 26[7:0], PPS 27[7:5] RESERVED */
+
+	/* PPS 27 */
+	pps_payload->first_line_bpg_offset =
+		dsc_cfg->first_line_bpg_offset;
+
+	/* PPS 28, 29 */
+	pps_payload->nfl_bpg_offset =
+		cpu_to_be16(dsc_cfg->nfl_bpg_offset);
+
+	/* PPS 30, 31 */
+	pps_payload->slice_bpg_offset =
+		cpu_to_be16(dsc_cfg->slice_bpg_offset);
+
+	/* PPS 32, 33 */
+	pps_payload->initial_offset =
+		cpu_to_be16(dsc_cfg->initial_offset);
+
+	/* PPS 34, 35 */
+	pps_payload->final_offset = cpu_to_be16(dsc_cfg->final_offset);
+
+	/* PPS 36 */
+	pps_payload->flatness_min_qp = dsc_cfg->flatness_min_qp;
+
+	/* PPS 37 */
+	pps_payload->flatness_max_qp = dsc_cfg->flatness_max_qp;
+
+	/* PPS 38, 39 */
+	pps_payload->rc_model_size =
+		cpu_to_be16(DSC_RC_MODEL_SIZE_CONST);
+
+	/* PPS 40 */
+	pps_payload->rc_edge_factor = DSC_RC_EDGE_FACTOR_CONST;
+
+	/* PPS 41 */
+	pps_payload->rc_quant_incr_limit0 =
+		dsc_cfg->rc_quant_incr_limit0;
+
+	/* PPS 42 */
+	pps_payload->rc_quant_incr_limit1 =
+		dsc_cfg->rc_quant_incr_limit1;
+
+	/* PPS 43 */
+	pps_payload->rc_tgt_offset = DSC_RC_TGT_OFFSET_LO_CONST |
+		DSC_RC_TGT_OFFSET_HI_CONST << DSC_PPS_RC_TGT_OFFSET_HI_SHIFT;
+
+	/* PPS 44 - 57 */
+	for (i = 0; i < DSC_NUM_BUF_RANGES - 1; i++)
+		pps_payload->rc_buf_thresh[i] =
+			dsc_cfg->rc_buf_thresh[i];
+
+	/* PPS 58 - 87 */
+	/*
+	 * For DSC sink programming the RC Range parameter fields
+	 * are as follows: Min_qp[15:11], max_qp[10:6], offset[5:0]
+	 */
+	for (i = 0; i < DSC_NUM_BUF_RANGES; i++) {
+		pps_payload->rc_range_parameters[i] =
+			cpu_to_be16((dsc_cfg->rc_range_params[i].range_min_qp <<
+				     DSC_PPS_RC_RANGE_MINQP_SHIFT) |
+				    (dsc_cfg->rc_range_params[i].range_max_qp <<
+				     DSC_PPS_RC_RANGE_MAXQP_SHIFT) |
+				    (dsc_cfg->rc_range_params[i].range_bpg_offset));
+	}
+
+	/* PPS 88 */
+	pps_payload->native_422_420 = dsc_cfg->native_422 |
+		dsc_cfg->native_420 << DSC_PPS_NATIVE_420_SHIFT;
+
+	/* PPS 89 */
+	pps_payload->second_line_bpg_offset =
+		dsc_cfg->second_line_bpg_offset;
+
+	/* PPS 90, 91 */
+	pps_payload->nsl_bpg_offset =
+		cpu_to_be16(dsc_cfg->nsl_bpg_offset);
+
+	/* PPS 92, 93 */
+	pps_payload->second_line_offset_adj =
+		cpu_to_be16(dsc_cfg->second_line_offset_adj);
+
+	/* PPS 94 - 127 are O */
+}
+
+/**
+ * drm_dsc_compute_rc_parameters() - Write rate control
+ * parameters to the dsc configuration defined in
+ * &struct drm_dsc_config in accordance with the DSC 1.2
+ * specification. Some configuration fields must be present
+ * beforehand.
+ *
+ * @vdsc_cfg:
+ * DSC Configuration data partially filled by driver
+ */
+int drm_dsc_compute_rc_parameters(struct drm_dsc_config *vdsc_cfg)
+{
+	unsigned long groups_per_line = 0;
+	unsigned long groups_total = 0;
+	unsigned long num_extra_mux_bits = 0;
+	unsigned long slice_bits = 0;
+	unsigned long hrd_delay = 0;
+	unsigned long final_scale = 0;
+	unsigned long rbs_min = 0;
+
+	if (vdsc_cfg->native_420 || vdsc_cfg->native_422) {
+		/* Number of groups used to code each line of a slice */
+		groups_per_line = DIV_ROUND_UP(vdsc_cfg->slice_width / 2,
+					       DSC_RC_PIXELS_PER_GROUP);
+
+		/* chunksize in Bytes */
+		vdsc_cfg->slice_chunk_size = DIV_ROUND_UP(vdsc_cfg->slice_width / 2 *
+							  vdsc_cfg->bits_per_pixel,
+							  (8 * 16));
+	} else {
+		/* Number of groups used to code each line of a slice */
+		groups_per_line = DIV_ROUND_UP(vdsc_cfg->slice_width,
+					       DSC_RC_PIXELS_PER_GROUP);
+
+		/* chunksize in Bytes */
+		vdsc_cfg->slice_chunk_size = DIV_ROUND_UP(vdsc_cfg->slice_width *
+							  vdsc_cfg->bits_per_pixel,
+							  (8 * 16));
+	}
+
+	if (vdsc_cfg->convert_rgb)
+		num_extra_mux_bits = 3 * (vdsc_cfg->mux_word_size +
+					  (4 * vdsc_cfg->bits_per_component + 4)
+					  - 2);
+	else if (vdsc_cfg->native_422)
+		num_extra_mux_bits = 4 * vdsc_cfg->mux_word_size +
+			(4 * vdsc_cfg->bits_per_component + 4) +
+			3 * (4 * vdsc_cfg->bits_per_component) - 2;
+	else
+		num_extra_mux_bits = 3 * vdsc_cfg->mux_word_size +
+			(4 * vdsc_cfg->bits_per_component + 4) +
+			2 * (4 * vdsc_cfg->bits_per_component) - 2;
+	/* Number of bits in one Slice */
+	slice_bits = 8 * vdsc_cfg->slice_chunk_size * vdsc_cfg->slice_height;
+
+	while ((num_extra_mux_bits > 0) &&
+	       ((slice_bits - num_extra_mux_bits) % vdsc_cfg->mux_word_size))
+		num_extra_mux_bits--;
+
+	if (groups_per_line < vdsc_cfg->initial_scale_value - 8)
+		vdsc_cfg->initial_scale_value = groups_per_line + 8;
+
+	/* scale_decrement_interval calculation according to DSC spec 1.11 */
+	if (vdsc_cfg->initial_scale_value > 8)
+		vdsc_cfg->scale_decrement_interval = groups_per_line /
+			(vdsc_cfg->initial_scale_value - 8);
+	else
+		vdsc_cfg->scale_decrement_interval = DSC_SCALE_DECREMENT_INTERVAL_MAX;
+
+	vdsc_cfg->final_offset = vdsc_cfg->rc_model_size -
+		(vdsc_cfg->initial_xmit_delay *
+		 vdsc_cfg->bits_per_pixel + 8) / 16 + num_extra_mux_bits;
+
+	if (vdsc_cfg->final_offset >= vdsc_cfg->rc_model_size) {
+		printf("FinalOfs < RcModelSze for this InitialXmitDelay\n");
+		return -ERANGE;
+	}
+
+	final_scale = (vdsc_cfg->rc_model_size * 8) /
+		(vdsc_cfg->rc_model_size - vdsc_cfg->final_offset);
+	if (vdsc_cfg->slice_height > 1)
+		/*
+		 * NflBpgOffset is 16 bit value with 11 fractional bits
+		 * hence we multiply by 2^11 for preserving the
+		 * fractional part
+		 */
+		vdsc_cfg->nfl_bpg_offset = DIV_ROUND_UP((vdsc_cfg->first_line_bpg_offset << 11),
+							(vdsc_cfg->slice_height - 1));
+	else
+		vdsc_cfg->nfl_bpg_offset = 0;
+
+	/* Number of groups used to code the entire slice */
+	groups_total = groups_per_line * vdsc_cfg->slice_height;
+
+	/* slice_bpg_offset is 16 bit value with 11 fractional bits */
+	vdsc_cfg->slice_bpg_offset = DIV_ROUND_UP(((vdsc_cfg->rc_model_size -
+						    vdsc_cfg->initial_offset +
+						    num_extra_mux_bits) << 11),
+						  groups_total);
+
+	if (final_scale > 9) {
+		/*
+		 * ScaleIncrementInterval =
+		 * finaloffset/((NflBpgOffset + SliceBpgOffset)*8(finalscale - 1.125))
+		 * as (NflBpgOffset + SliceBpgOffset) has 11 bit fractional value,
+		 * we need divide by 2^11 from pstDscCfg values
+		 */
+		vdsc_cfg->scale_increment_interval =
+				(vdsc_cfg->final_offset * (1 << 11)) /
+				((vdsc_cfg->nfl_bpg_offset +
+				vdsc_cfg->slice_bpg_offset) *
+				(final_scale - 9));
+	} else {
+		/*
+		 * If finalScaleValue is less than or equal to 9, a value of 0 should
+		 * be used to disable the scale increment at the end of the slice
+		 */
+		vdsc_cfg->scale_increment_interval = 0;
+	}
+
+	/*
+	 * DSC spec mentions that bits_per_pixel specifies the target
+	 * bits/pixel (bpp) rate that is used by the encoder,
+	 * in steps of 1/16 of a bit per pixel
+	 */
+	rbs_min = vdsc_cfg->rc_model_size - vdsc_cfg->initial_offset +
+		DIV_ROUND_UP(vdsc_cfg->initial_xmit_delay *
+			     vdsc_cfg->bits_per_pixel, 16) +
+		groups_per_line * vdsc_cfg->first_line_bpg_offset;
+
+	hrd_delay = DIV_ROUND_UP((rbs_min * 16), vdsc_cfg->bits_per_pixel);
+	vdsc_cfg->rc_bits = (hrd_delay * vdsc_cfg->bits_per_pixel) / 16;
+	vdsc_cfg->initial_dec_delay = hrd_delay - vdsc_cfg->initial_xmit_delay;
+
+	return 0;
+}
diff --git a/drivers/video/drm/drm_mipi_dsi.c b/drivers/video/drm/drm_mipi_dsi.c
new file mode 100644
index 0000000000..42c3ff6100
--- /dev/null
+++ b/drivers/video/drm/drm_mipi_dsi.c
@@ -0,0 +1,795 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * MIPI DSI Bus
+ *
+ * Copyright (C) 2012-2013, Samsung Electronics, Co., Ltd.
+ * Andrzej Hajda <a.hajda@samsung.com>
+ */
+
+#include <drm/drm_mipi_dsi.h>
+
+#include <config.h>
+#include <common.h>
+#include <errno.h>
+#include <malloc.h>
+
+/**
+ * mipi_dsi_attach - attach a DSI device to its DSI host
+ * @dsi: DSI peripheral
+ */
+int mipi_dsi_attach(struct mipi_dsi_device *dsi)
+{
+	const struct mipi_dsi_host_ops *ops = dsi->host->ops;
+
+	if (!ops || !ops->attach)
+		return -ENOSYS;
+
+	return ops->attach(dsi->host, dsi);
+}
+
+/**
+ * mipi_dsi_detach - detach a DSI device from its DSI host
+ * @dsi: DSI peripheral
+ */
+int mipi_dsi_detach(struct mipi_dsi_device *dsi)
+{
+	const struct mipi_dsi_host_ops *ops = dsi->host->ops;
+
+	if (!ops || !ops->detach)
+		return -ENOSYS;
+
+	return ops->detach(dsi->host, dsi);
+}
+
+static ssize_t mipi_dsi_device_transfer(struct mipi_dsi_device *dsi,
+					struct mipi_dsi_msg *msg)
+{
+	const struct mipi_dsi_host_ops *ops = dsi->host->ops;
+
+	if (!ops || !ops->transfer)
+		return -ENOSYS;
+
+	if (dsi->mode_flags & MIPI_DSI_MODE_LPM)
+		msg->flags |= MIPI_DSI_MSG_USE_LPM;
+
+	return ops->transfer(dsi->host, msg);
+}
+
+/**
+ * mipi_dsi_packet_format_is_short - check if a packet is of the short format
+ * @type: MIPI DSI data type of the packet
+ *
+ * Return: true if the packet for the given data type is a short packet, false
+ * otherwise.
+ */
+bool mipi_dsi_packet_format_is_short(u8 type)
+{
+	switch (type) {
+	case MIPI_DSI_V_SYNC_START:
+	case MIPI_DSI_V_SYNC_END:
+	case MIPI_DSI_H_SYNC_START:
+	case MIPI_DSI_H_SYNC_END:
+	case MIPI_DSI_COMPRESSION_MODE:
+	case MIPI_DSI_END_OF_TRANSMISSION:
+	case MIPI_DSI_COLOR_MODE_OFF:
+	case MIPI_DSI_COLOR_MODE_ON:
+	case MIPI_DSI_SHUTDOWN_PERIPHERAL:
+	case MIPI_DSI_TURN_ON_PERIPHERAL:
+	case MIPI_DSI_GENERIC_SHORT_WRITE_0_PARAM:
+	case MIPI_DSI_GENERIC_SHORT_WRITE_1_PARAM:
+	case MIPI_DSI_GENERIC_SHORT_WRITE_2_PARAM:
+	case MIPI_DSI_GENERIC_READ_REQUEST_0_PARAM:
+	case MIPI_DSI_GENERIC_READ_REQUEST_1_PARAM:
+	case MIPI_DSI_GENERIC_READ_REQUEST_2_PARAM:
+	case MIPI_DSI_DCS_SHORT_WRITE:
+	case MIPI_DSI_DCS_SHORT_WRITE_PARAM:
+	case MIPI_DSI_DCS_READ:
+	case MIPI_DSI_SET_MAXIMUM_RETURN_PACKET_SIZE:
+		return true;
+	}
+
+	return false;
+}
+
+/**
+ * mipi_dsi_packet_format_is_long - check if a packet is of the long format
+ * @type: MIPI DSI data type of the packet
+ *
+ * Return: true if the packet for the given data type is a long packet, false
+ * otherwise.
+ */
+bool mipi_dsi_packet_format_is_long(u8 type)
+{
+	switch (type) {
+	case MIPI_DSI_NULL_PACKET:
+	case MIPI_DSI_BLANKING_PACKET:
+	case MIPI_DSI_GENERIC_LONG_WRITE:
+	case MIPI_DSI_DCS_LONG_WRITE:
+	case MIPI_DSI_PICTURE_PARAMETER_SET:
+	case MIPI_DSI_COMPRESSED_PIXEL_STREAM:
+	case MIPI_DSI_LOOSELY_PACKED_PIXEL_STREAM_YCBCR20:
+	case MIPI_DSI_PACKED_PIXEL_STREAM_YCBCR24:
+	case MIPI_DSI_PACKED_PIXEL_STREAM_YCBCR16:
+	case MIPI_DSI_PACKED_PIXEL_STREAM_30:
+	case MIPI_DSI_PACKED_PIXEL_STREAM_36:
+	case MIPI_DSI_PACKED_PIXEL_STREAM_YCBCR12:
+	case MIPI_DSI_PACKED_PIXEL_STREAM_16:
+	case MIPI_DSI_PACKED_PIXEL_STREAM_18:
+	case MIPI_DSI_PIXEL_STREAM_3BYTE_18:
+	case MIPI_DSI_PACKED_PIXEL_STREAM_24:
+		return true;
+	}
+
+	return false;
+}
+
+/**
+ * mipi_dsi_create_packet - create a packet from a message according to the
+ *	DSI protocol
+ * @packet: pointer to a DSI packet structure
+ * @msg: message to translate into a packet
+ *
+ * Return: 0 on success or a negative error code on failure.
+ */
+int mipi_dsi_create_packet(struct mipi_dsi_packet *packet,
+			   const struct mipi_dsi_msg *msg)
+{
+	if (!packet || !msg)
+		return -EINVAL;
+
+	/* do some minimum sanity checking */
+	if (!mipi_dsi_packet_format_is_short(msg->type) &&
+	    !mipi_dsi_packet_format_is_long(msg->type))
+		return -EINVAL;
+
+	if (msg->channel > 3)
+		return -EINVAL;
+
+	memset(packet, 0, sizeof(*packet));
+	packet->header[0] = ((msg->channel & 0x3) << 6) | (msg->type & 0x3f);
+	if (mipi_dsi_packet_format_is_long(msg->type)) {
+		packet->header[1] = (msg->tx_len >> 0) & 0xff;
+		packet->header[2] = (msg->tx_len >> 8) & 0xff;
+
+		packet->payload_length = msg->tx_len;
+		packet->payload = msg->tx_buf;
+	} else {
+		const u8 *tx = msg->tx_buf;
+
+		packet->header[1] = (msg->tx_len > 0) ? tx[0] : 0;
+		packet->header[2] = (msg->tx_len > 1) ? tx[1] : 0;
+	}
+
+	packet->size = sizeof(packet->header) + packet->payload_length;
+
+	return 0;
+}
+
+/**
+ * mipi_dsi_shutdown_peripheral() - sends a Shutdown Peripheral command
+ * @dsi: DSI peripheral device
+ *
+ * Return: 0 on success or a negative error code on failure.
+ */
+int mipi_dsi_shutdown_peripheral(struct mipi_dsi_device *dsi)
+{
+	struct mipi_dsi_msg msg = {
+		.channel = dsi->channel,
+		.type = MIPI_DSI_SHUTDOWN_PERIPHERAL,
+		.tx_buf = (u8 [2]) { 0, 0 },
+		.tx_len = 2,
+	};
+	int ret = mipi_dsi_device_transfer(dsi, &msg);
+
+	return (ret < 0) ? ret : 0;
+}
+
+/**
+ * mipi_dsi_turn_on_peripheral() - sends a Turn On Peripheral command
+ * @dsi: DSI peripheral device
+ *
+ * Return: 0 on success or a negative error code on failure.
+ */
+int mipi_dsi_turn_on_peripheral(struct mipi_dsi_device *dsi)
+{
+	struct mipi_dsi_msg msg = {
+		.channel = dsi->channel,
+		.type = MIPI_DSI_TURN_ON_PERIPHERAL,
+		.tx_buf = (u8 [2]) { 0, 0 },
+		.tx_len = 2,
+	};
+	int ret = mipi_dsi_device_transfer(dsi, &msg);
+
+	return (ret < 0) ? ret : 0;
+}
+
+/*
+ * mipi_dsi_set_maximum_return_packet_size() - specify the maximum size of the
+ *	the payload in a long packet transmitted from the peripheral back to the
+ *	host processor
+ * @dsi: DSI peripheral device
+ * @value: the maximum size of the payload
+ *
+ * Return: 0 on success or a negative error code on failure.
+ */
+int mipi_dsi_set_maximum_return_packet_size(struct mipi_dsi_device *dsi,
+					    u16 value)
+{
+	u8 tx[2] = { value & 0xff, value >> 8 };
+	struct mipi_dsi_msg msg = {
+		.channel = dsi->channel,
+		.type = MIPI_DSI_SET_MAXIMUM_RETURN_PACKET_SIZE,
+		.tx_len = sizeof(tx),
+		.tx_buf = tx,
+	};
+	int ret = mipi_dsi_device_transfer(dsi, &msg);
+
+	return (ret < 0) ? ret : 0;
+}
+
+/**
+ * mipi_dsi_compression_mode() - enable/disable DSC on the peripheral
+ * @dsi: DSI peripheral device
+ * @enable: Whether to enable or disable the DSC
+ *
+ * Enable or disable Display Stream Compression on the peripheral using the
+ * default Picture Parameter Set and VESA DSC 1.1 algorithm.
+ *
+ * Return: 0 on success or a negative error code on failure.
+ */
+ssize_t mipi_dsi_compression_mode(struct mipi_dsi_device *dsi, bool enable)
+{
+	/* Note: Needs updating for non-default PPS or algorithm */
+	u8 tx[2] = { enable << 0, 0 };
+	struct mipi_dsi_msg msg = {
+		.channel = dsi->channel,
+		.type = MIPI_DSI_COMPRESSION_MODE,
+		.tx_len = sizeof(tx),
+		.tx_buf = tx,
+	};
+	int ret = mipi_dsi_device_transfer(dsi, &msg);
+
+	return (ret < 0) ? ret : 0;
+}
+
+/**
+ * mipi_dsi_picture_parameter_set() - transmit the DSC PPS to the peripheral
+ * @dsi: DSI peripheral device
+ * @pps: VESA DSC 1.1 Picture Parameter Set
+ *
+ * Transmit the VESA DSC 1.1 Picture Parameter Set to the peripheral.
+ *
+ * Return: 0 on success or a negative error code on failure.
+ */
+ssize_t mipi_dsi_picture_parameter_set(struct mipi_dsi_device *dsi,
+				       const struct drm_dsc_picture_parameter_set *pps)
+{
+	struct mipi_dsi_msg msg = {
+		.channel = dsi->channel,
+		.type = MIPI_DSI_PICTURE_PARAMETER_SET,
+		.tx_len = sizeof(*pps),
+		.tx_buf = pps,
+	};
+	int ret = mipi_dsi_device_transfer(dsi, &msg);
+
+	return (ret < 0) ? ret : 0;
+}
+
+/**
+ * mipi_dsi_generic_write() - transmit data using a generic write packet
+ * @dsi: DSI peripheral device
+ * @payload: buffer containing the payload
+ * @size: size of payload buffer
+ *
+ * This function will automatically choose the right data type depending on
+ * the payload length.
+ *
+ * Return: The number of bytes transmitted on success or a negative error code
+ * on failure.
+ */
+ssize_t mipi_dsi_generic_write(struct mipi_dsi_device *dsi, const void *payload,
+			       size_t size)
+{
+	struct mipi_dsi_msg msg = {
+		.channel = dsi->channel,
+		.tx_buf = payload,
+		.tx_len = size
+	};
+
+	switch (size) {
+	case 0:
+		msg.type = MIPI_DSI_GENERIC_SHORT_WRITE_0_PARAM;
+		break;
+	case 1:
+		msg.type = MIPI_DSI_GENERIC_SHORT_WRITE_1_PARAM;
+		break;
+	case 2:
+		msg.type = MIPI_DSI_GENERIC_SHORT_WRITE_2_PARAM;
+		break;
+	default:
+		msg.type = MIPI_DSI_GENERIC_LONG_WRITE;
+		break;
+	}
+
+	return mipi_dsi_device_transfer(dsi, &msg);
+}
+
+/**
+ * mipi_dsi_generic_read() - receive data using a generic read packet
+ * @dsi: DSI peripheral device
+ * @params: buffer containing the request parameters
+ * @num_params: number of request parameters
+ * @data: buffer in which to return the received data
+ * @size: size of receive buffer
+ *
+ * This function will automatically choose the right data type depending on
+ * the number of parameters passed in.
+ *
+ * Return: The number of bytes successfully read or a negative error code on
+ * failure.
+ */
+ssize_t mipi_dsi_generic_read(struct mipi_dsi_device *dsi, const void *params,
+			      size_t num_params, void *data, size_t size)
+{
+	struct mipi_dsi_msg msg = {
+		.channel = dsi->channel,
+		.tx_len = num_params,
+		.tx_buf = params,
+		.rx_len = size,
+		.rx_buf = data
+	};
+
+	switch (num_params) {
+	case 0:
+		msg.type = MIPI_DSI_GENERIC_READ_REQUEST_0_PARAM;
+		break;
+
+	case 1:
+		msg.type = MIPI_DSI_GENERIC_READ_REQUEST_1_PARAM;
+		break;
+
+	case 2:
+		msg.type = MIPI_DSI_GENERIC_READ_REQUEST_2_PARAM;
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	return mipi_dsi_device_transfer(dsi, &msg);
+}
+
+/**
+ * mipi_dsi_dcs_write_buffer() - transmit a DCS command with payload
+ * @dsi: DSI peripheral device
+ * @data: buffer containing data to be transmitted
+ * @len: size of transmission buffer
+ *
+ * This function will automatically choose the right data type depending on
+ * the command payload length.
+ *
+ * Return: The number of bytes successfully transmitted or a negative error
+ * code on failure.
+ */
+ssize_t mipi_dsi_dcs_write_buffer(struct mipi_dsi_device *dsi,
+				  const void *data, size_t len)
+{
+	struct mipi_dsi_msg msg = {
+		.channel = dsi->channel,
+		.tx_buf = data,
+		.tx_len = len
+	};
+
+	switch (len) {
+	case 0:
+		return -EINVAL;
+
+	case 1:
+		msg.type = MIPI_DSI_DCS_SHORT_WRITE;
+		break;
+
+	case 2:
+		msg.type = MIPI_DSI_DCS_SHORT_WRITE_PARAM;
+		break;
+
+	default:
+		msg.type = MIPI_DSI_DCS_LONG_WRITE;
+		break;
+	}
+
+	return mipi_dsi_device_transfer(dsi, &msg);
+}
+
+/**
+ * mipi_dsi_dcs_write() - send DCS write command
+ * @dsi: DSI peripheral device
+ * @cmd: DCS command
+ * @data: buffer containing the command payload
+ * @len: command payload length
+ *
+ * This function will automatically choose the right data type depending on
+ * the command payload length.
+ *
+ * Return: The number of bytes successfully transmitted or a negative error
+ * code on failure.
+ */
+ssize_t mipi_dsi_dcs_write(struct mipi_dsi_device *dsi, u8 cmd,
+			   const void *data, size_t len)
+{
+	ssize_t err;
+	size_t size;
+	u8 *tx;
+
+	if (len > 0) {
+		size = 1 + len;
+
+		tx = malloc(size);
+		if (!tx)
+			return -ENOMEM;
+
+		/* concatenate the DCS command byte and the payload */
+		tx[0] = cmd;
+		memcpy(&tx[1], data, len);
+	} else {
+		tx = &cmd;
+		size = 1;
+	}
+
+	err = mipi_dsi_dcs_write_buffer(dsi, tx, size);
+
+	if (len > 0)
+		free(tx);
+
+	return err;
+}
+
+/**
+ * mipi_dsi_dcs_read() - send DCS read request command
+ * @dsi: DSI peripheral device
+ * @cmd: DCS command
+ * @data: buffer in which to receive data
+ * @len: size of receive buffer
+ * Return: The number of bytes read or a negative error code on failure.
+ */
+ssize_t mipi_dsi_dcs_read(struct mipi_dsi_device *dsi, u8 cmd, void *data,
+			  size_t len)
+{
+	struct mipi_dsi_msg msg = {
+		.channel = dsi->channel,
+		.type = MIPI_DSI_DCS_READ,
+		.tx_buf = &cmd,
+		.tx_len = 1,
+		.rx_buf = data,
+		.rx_len = len
+	};
+
+	return mipi_dsi_device_transfer(dsi, &msg);
+}
+
+/**
+ * mipi_dsi_dcs_nop() - send DCS nop packet
+ * @dsi: DSI peripheral device
+ *
+ * Return: 0 on success or a negative error code on failure.
+ */
+int mipi_dsi_dcs_nop(struct mipi_dsi_device *dsi)
+{
+	ssize_t err;
+
+	err = mipi_dsi_dcs_write(dsi, MIPI_DCS_NOP, NULL, 0);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+/**
+ * mipi_dsi_dcs_soft_reset() - perform a software reset of the display module
+ * @dsi: DSI peripheral device
+ *
+ * Return: 0 on success or a negative error code on failure.
+ */
+int mipi_dsi_dcs_soft_reset(struct mipi_dsi_device *dsi)
+{
+	ssize_t err;
+
+	err = mipi_dsi_dcs_write(dsi, MIPI_DCS_SOFT_RESET, NULL, 0);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+/**
+ * mipi_dsi_dcs_get_power_mode() - query the display module's current power
+ *	mode
+ * @dsi: DSI peripheral device
+ * @mode: return location for the current power mode
+ *
+ * Return: 0 on success or a negative error code on failure.
+ */
+int mipi_dsi_dcs_get_power_mode(struct mipi_dsi_device *dsi, u8 *mode)
+{
+	ssize_t err;
+
+	err = mipi_dsi_dcs_read(dsi, MIPI_DCS_GET_POWER_MODE, mode,
+				sizeof(*mode));
+	if (err <= 0) {
+		if (err == 0)
+			err = -ENODATA;
+
+		return err;
+	}
+
+	return 0;
+}
+
+/**
+ * mipi_dsi_dcs_get_pixel_format() - gets the pixel format for the RGB image
+ *	data used by the interface
+ * @dsi: DSI peripheral device
+ * @format: return location for the pixel format
+ *
+ * Return: 0 on success or a negative error code on failure.
+ */
+int mipi_dsi_dcs_get_pixel_format(struct mipi_dsi_device *dsi, u8 *format)
+{
+	ssize_t err;
+
+	err = mipi_dsi_dcs_read(dsi, MIPI_DCS_GET_PIXEL_FORMAT, format,
+				sizeof(*format));
+	if (err <= 0) {
+		if (err == 0)
+			err = -ENODATA;
+
+		return err;
+	}
+
+	return 0;
+}
+
+/**
+ * mipi_dsi_dcs_enter_sleep_mode() - disable all unnecessary blocks inside the
+ *	display module except interface communication
+ * @dsi: DSI peripheral device
+ *
+ * Return: 0 on success or a negative error code on failure.
+ */
+int mipi_dsi_dcs_enter_sleep_mode(struct mipi_dsi_device *dsi)
+{
+	ssize_t err;
+
+	err = mipi_dsi_dcs_write(dsi, MIPI_DCS_ENTER_SLEEP_MODE, NULL, 0);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+/**
+ * mipi_dsi_dcs_exit_sleep_mode() - enable all blocks inside the display
+ *	module
+ * @dsi: DSI peripheral device
+ *
+ * Return: 0 on success or a negative error code on failure.
+ */
+int mipi_dsi_dcs_exit_sleep_mode(struct mipi_dsi_device *dsi)
+{
+	ssize_t err;
+
+	err = mipi_dsi_dcs_write(dsi, MIPI_DCS_EXIT_SLEEP_MODE, NULL, 0);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+/**
+ * mipi_dsi_dcs_set_display_off() - stop displaying the image data on the
+ *	display device
+ * @dsi: DSI peripheral device
+ *
+ * Return: 0 on success or a negative error code on failure.
+ */
+int mipi_dsi_dcs_set_display_off(struct mipi_dsi_device *dsi)
+{
+	ssize_t err;
+
+	err = mipi_dsi_dcs_write(dsi, MIPI_DCS_SET_DISPLAY_OFF, NULL, 0);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+/**
+ * mipi_dsi_dcs_set_display_on() - start displaying the image data on the
+ *	display device
+ * @dsi: DSI peripheral device
+ *
+ * Return: 0 on success or a negative error code on failure
+ */
+int mipi_dsi_dcs_set_display_on(struct mipi_dsi_device *dsi)
+{
+	ssize_t err;
+
+	err = mipi_dsi_dcs_write(dsi, MIPI_DCS_SET_DISPLAY_ON, NULL, 0);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+/**
+ * mipi_dsi_dcs_set_column_address() - define the column extent of the frame
+ *	memory accessed by the host processor
+ * @dsi: DSI peripheral device
+ * @start: first column of frame memory
+ * @end: last column of frame memory
+ *
+ * Return: 0 on success or a negative error code on failure.
+ */
+int mipi_dsi_dcs_set_column_address(struct mipi_dsi_device *dsi, u16 start,
+				    u16 end)
+{
+	u8 payload[4] = { start >> 8, start & 0xff, end >> 8, end & 0xff };
+	ssize_t err;
+
+	err = mipi_dsi_dcs_write(dsi, MIPI_DCS_SET_COLUMN_ADDRESS, payload,
+				 sizeof(payload));
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+/**
+ * mipi_dsi_dcs_set_page_address() - define the page extent of the frame
+ *	memory accessed by the host processor
+ * @dsi: DSI peripheral device
+ * @start: first page of frame memory
+ * @end: last page of frame memory
+ *
+ * Return: 0 on success or a negative error code on failure.
+ */
+int mipi_dsi_dcs_set_page_address(struct mipi_dsi_device *dsi, u16 start,
+				  u16 end)
+{
+	u8 payload[4] = { start >> 8, start & 0xff, end >> 8, end & 0xff };
+	ssize_t err;
+
+	err = mipi_dsi_dcs_write(dsi, MIPI_DCS_SET_PAGE_ADDRESS, payload,
+				 sizeof(payload));
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+/**
+ * mipi_dsi_dcs_set_tear_off() - turn off the display module's Tearing Effect
+ *	output signal on the TE signal line
+ * @dsi: DSI peripheral device
+ *
+ * Return: 0 on success or a negative error code on failure
+ */
+int mipi_dsi_dcs_set_tear_off(struct mipi_dsi_device *dsi)
+{
+	ssize_t err;
+
+	err = mipi_dsi_dcs_write(dsi, MIPI_DCS_SET_TEAR_OFF, NULL, 0);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+/**
+ * mipi_dsi_dcs_set_tear_on() - turn on the display module's Tearing Effect
+ *	output signal on the TE signal line.
+ * @dsi: DSI peripheral device
+ * @mode: the Tearing Effect Output Line mode
+ *
+ * Return: 0 on success or a negative error code on failure
+ */
+int mipi_dsi_dcs_set_tear_on(struct mipi_dsi_device *dsi,
+			     enum mipi_dsi_dcs_tear_mode mode)
+{
+	u8 value = mode;
+	ssize_t err;
+
+	err = mipi_dsi_dcs_write(dsi, MIPI_DCS_SET_TEAR_ON, &value,
+				 sizeof(value));
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+/**
+ * mipi_dsi_dcs_set_pixel_format() - sets the pixel format for the RGB image
+ *	data used by the interface
+ * @dsi: DSI peripheral device
+ * @format: pixel format
+ *
+ * Return: 0 on success or a negative error code on failure.
+ */
+int mipi_dsi_dcs_set_pixel_format(struct mipi_dsi_device *dsi, u8 format)
+{
+	ssize_t err;
+
+	err = mipi_dsi_dcs_write(dsi, MIPI_DCS_SET_PIXEL_FORMAT, &format,
+				 sizeof(format));
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+/**
+ * mipi_dsi_dcs_set_tear_scanline() - set the scanline to use as trigger for
+ *	the Tearing Effect output signal of the display module
+ * @dsi: DSI peripheral device
+ * @scanline: scanline to use as trigger
+ *
+ * Return: 0 on success or a negative error code on failure
+ */
+int mipi_dsi_dcs_set_tear_scanline(struct mipi_dsi_device *dsi, u16 scanline)
+{
+	u8 payload[3] = { MIPI_DCS_SET_TEAR_SCANLINE, scanline >> 8,
+				scanline & 0xff };
+	ssize_t err;
+
+	err = mipi_dsi_generic_write(dsi, payload, sizeof(payload));
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+/**
+ * mipi_dsi_dcs_set_display_brightness() - sets the brightness value of the
+ *	display
+ * @dsi: DSI peripheral device
+ * @brightness: brightness value
+ *
+ * Return: 0 on success or a negative error code on failure.
+ */
+int mipi_dsi_dcs_set_display_brightness(struct mipi_dsi_device *dsi,
+					u16 brightness)
+{
+	u8 payload[2] = { brightness & 0xff, brightness >> 8 };
+	ssize_t err;
+
+	err = mipi_dsi_dcs_write(dsi, MIPI_DCS_SET_DISPLAY_BRIGHTNESS,
+				 payload, sizeof(payload));
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+/**
+ * mipi_dsi_dcs_get_display_brightness() - gets the current brightness value
+ *	of the display
+ * @dsi: DSI peripheral device
+ * @brightness: brightness value
+ *
+ * Return: 0 on success or a negative error code on failure.
+ */
+int mipi_dsi_dcs_get_display_brightness(struct mipi_dsi_device *dsi,
+					u16 *brightness)
+{
+	ssize_t err;
+
+	err = mipi_dsi_dcs_read(dsi, MIPI_DCS_GET_DISPLAY_BRIGHTNESS,
+				brightness, sizeof(*brightness));
+	if (err <= 0) {
+		if (err == 0)
+			err = -ENODATA;
+
+		return err;
+	}
+
+	return 0;
+}
diff --git a/drivers/video/drm/drm_modes.c b/drivers/video/drm/drm_modes.c
new file mode 100644
index 0000000000..2c35919273
--- /dev/null
+++ b/drivers/video/drm/drm_modes.c
@@ -0,0 +1,276 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright © 1997-2003 by The XFree86 Project, Inc.
+ * Copyright © 2007 Dave Airlie
+ * Copyright © 2007-2008 Intel Corporation
+ *   Jesse Barnes <jesse.barnes@intel.com>
+ * Copyright 2005-2006 Luc Verhaegen
+ * Copyright (c) 2001, Andy Ritger  aritger@nvidia.com
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+#include <common.h>
+#include <drm_modes.h>
+#include <linux/compat.h>
+#include <malloc.h>
+
+#define PICOS2KHZ(a)	(1000000000UL / (a))
+#define KHZ2PICOS(a)	(1000000000UL / (a))
+
+/**
+ * drm_mode_create - create a new display mode
+ *
+ * Create a new, cleared drm_display_mode.
+ *
+ * Returns:
+ * Pointer to new mode on success, NULL on error.
+ */
+struct drm_display_mode *drm_mode_create(void)
+{
+	struct drm_display_mode *nmode;
+
+	nmode = malloc(sizeof(struct drm_display_mode));
+	memset(nmode, 0, sizeof(struct drm_display_mode));
+	if (!nmode)
+		return NULL;
+
+	return nmode;
+}
+
+/**
+ * drm_mode_copy - copy the mode
+ * @dst: mode to overwrite
+ * @src: mode to copy
+ *
+ * Copy an existing mode into another mode, preserving the object id and
+ * list head of the destination mode.
+ */
+void drm_mode_copy(struct drm_display_mode *dst, const struct drm_display_mode *src)
+{
+	*dst = *src;
+}
+
+/**
+ * drm_mode_destroy - remove a mode
+ * @mode: mode to remove
+ */
+void drm_mode_destroy(struct drm_display_mode *mode)
+{
+	if (!mode)
+		return;
+
+	kfree(mode);
+}
+
+static bool drm_mode_match_timings(const struct drm_display_mode *mode1,
+				   const struct drm_display_mode *mode2)
+{
+	return mode1->hdisplay == mode2->hdisplay &&
+	       mode1->hsync_start == mode2->hsync_start &&
+	       mode1->hsync_end == mode2->hsync_end &&
+	       mode1->htotal == mode2->htotal &&
+	       mode1->hskew == mode2->hskew &&
+	       mode1->vdisplay == mode2->vdisplay &&
+	       mode1->vsync_start == mode2->vsync_start &&
+	       mode1->vsync_end == mode2->vsync_end &&
+	       mode1->vtotal == mode2->vtotal &&
+	       mode1->vscan == mode2->vscan;
+}
+
+static bool drm_mode_match_clock(const struct drm_display_mode *mode1,
+				 const struct drm_display_mode *mode2)
+{
+	/*
+	 * do clock check convert to PICOS
+	 * so fb modes get matched the same
+	 */
+	if (mode1->clock && mode2->clock)
+		return KHZ2PICOS(mode1->clock) == KHZ2PICOS(mode2->clock);
+	else
+		return mode1->clock == mode2->clock;
+}
+
+static bool drm_mode_match_flags(const struct drm_display_mode *mode1,
+				 const struct drm_display_mode *mode2)
+{
+	return (mode1->flags & ~DRM_MODE_FLAG_3D_MASK) ==
+	       (mode2->flags & ~DRM_MODE_FLAG_3D_MASK);
+}
+
+static bool drm_mode_match_3d_flags(const struct drm_display_mode *mode1,
+				    const struct drm_display_mode *mode2)
+{
+	return (mode1->flags & DRM_MODE_FLAG_3D_MASK) ==
+	       (mode2->flags & DRM_MODE_FLAG_3D_MASK);
+}
+
+static bool drm_mode_match_aspect_ratio(const struct drm_display_mode *mode1,
+					const struct drm_display_mode *mode2)
+{
+	return mode1->picture_aspect_ratio == mode2->picture_aspect_ratio;
+}
+
+/**
+ * drm_mode_match - test modes for (partial) equality
+ * @mode1: first mode
+ * @mode2: second mode
+ * @match_flags: which parts need to match (DRM_MODE_MATCH_*)
+ *
+ * Check to see if @mode1 and @mode2 are equivalent.
+ *
+ * Returns:
+ * True if the modes are (partially) equal, false otherwise.
+ */
+bool drm_mode_match(const struct drm_display_mode *mode1,
+		    const struct drm_display_mode *mode2,
+		    unsigned int match_flags)
+{
+	if (!mode1 && !mode2)
+		return true;
+
+	if (!mode1 || !mode2)
+		return false;
+
+	if (match_flags & DRM_MODE_MATCH_TIMINGS &&
+	    !drm_mode_match_timings(mode1, mode2))
+		return false;
+
+	if (match_flags & DRM_MODE_MATCH_CLOCK &&
+	    !drm_mode_match_clock(mode1, mode2))
+		return false;
+
+	if (match_flags & DRM_MODE_MATCH_FLAGS &&
+	    !drm_mode_match_flags(mode1, mode2))
+		return false;
+
+	if (match_flags & DRM_MODE_MATCH_3D_FLAGS &&
+	    !drm_mode_match_3d_flags(mode1, mode2))
+		return false;
+
+	if (match_flags & DRM_MODE_MATCH_ASPECT_RATIO &&
+	    !drm_mode_match_aspect_ratio(mode1, mode2))
+		return false;
+
+	return true;
+}
+
+/**
+ * drm_mode_equal - test modes for equality
+ * @mode1: first mode
+ * @mode2: second mode
+ *
+ * Check to see if @mode1 and @mode2 are equivalent.
+ *
+ * Returns:
+ * True if the modes are equal, false otherwise.
+ */
+bool drm_mode_equal(const struct drm_display_mode *mode1,
+		    const struct drm_display_mode *mode2)
+{
+	return drm_mode_match(mode1, mode2,
+			      DRM_MODE_MATCH_TIMINGS |
+			      DRM_MODE_MATCH_CLOCK |
+			      DRM_MODE_MATCH_FLAGS |
+			      DRM_MODE_MATCH_3D_FLAGS |
+			      DRM_MODE_MATCH_ASPECT_RATIO);
+}
+
+/**
+ * drm_display_mode_from_videomode - fill in @dmode using @vm,
+ * @vm: videomode structure to use as source
+ * @dmode: drm_display_mode structure to use as destination
+ *
+ * Fills out @dmode using the display mode specified in @vm.
+ */
+void drm_display_mode_from_videomode(const struct videomode *vm,
+				     struct drm_display_mode *dmode)
+{
+	dmode->hdisplay = vm->hactive;
+	dmode->hsync_start = dmode->hdisplay + vm->hfront_porch;
+	dmode->hsync_end = dmode->hsync_start + vm->hsync_len;
+	dmode->htotal = dmode->hsync_end + vm->hback_porch;
+
+	dmode->vdisplay = vm->vactive;
+	dmode->vsync_start = dmode->vdisplay + vm->vfront_porch;
+	dmode->vsync_end = dmode->vsync_start + vm->vsync_len;
+	dmode->vtotal = dmode->vsync_end + vm->vback_porch;
+
+	dmode->clock = vm->pixelclock / 1000;
+
+	dmode->flags = 0;
+	if (vm->flags & DISPLAY_FLAGS_HSYNC_HIGH)
+		dmode->flags |= DRM_MODE_FLAG_PHSYNC;
+	else if (vm->flags & DISPLAY_FLAGS_HSYNC_LOW)
+		dmode->flags |= DRM_MODE_FLAG_NHSYNC;
+	if (vm->flags & DISPLAY_FLAGS_VSYNC_HIGH)
+		dmode->flags |= DRM_MODE_FLAG_PVSYNC;
+	else if (vm->flags & DISPLAY_FLAGS_VSYNC_LOW)
+		dmode->flags |= DRM_MODE_FLAG_NVSYNC;
+	if (vm->flags & DISPLAY_FLAGS_INTERLACED)
+		dmode->flags |= DRM_MODE_FLAG_INTERLACE;
+	if (vm->flags & DISPLAY_FLAGS_DOUBLESCAN)
+		dmode->flags |= DRM_MODE_FLAG_DBLSCAN;
+	if (vm->flags & DISPLAY_FLAGS_DOUBLECLK)
+		dmode->flags |= DRM_MODE_FLAG_DBLCLK;
+}
+
+/**
+ * drm_display_mode_to_videomode - fill in @vm using @dmode,
+ * @dmode: drm_display_mode structure to use as source
+ * @vm: videomode structure to use as destination
+ *
+ * Fills out @vm using the display mode specified in @dmode.
+ */
+void drm_display_mode_to_videomode(const struct drm_display_mode *dmode,
+				   struct videomode *vm)
+{
+	vm->hactive = dmode->hdisplay;
+	vm->hfront_porch = dmode->hsync_start - dmode->hdisplay;
+	vm->hsync_len = dmode->hsync_end - dmode->hsync_start;
+	vm->hback_porch = dmode->htotal - dmode->hsync_end;
+
+	vm->vactive = dmode->vdisplay;
+	vm->vfront_porch = dmode->vsync_start - dmode->vdisplay;
+	vm->vsync_len = dmode->vsync_end - dmode->vsync_start;
+	vm->vback_porch = dmode->vtotal - dmode->vsync_end;
+
+	vm->pixelclock = dmode->clock * 1000;
+
+	vm->flags = 0;
+	if (dmode->flags & DRM_MODE_FLAG_PHSYNC)
+		vm->flags |= DISPLAY_FLAGS_HSYNC_HIGH;
+	else if (dmode->flags & DRM_MODE_FLAG_NHSYNC)
+		vm->flags |= DISPLAY_FLAGS_HSYNC_LOW;
+	if (dmode->flags & DRM_MODE_FLAG_PVSYNC)
+		vm->flags |= DISPLAY_FLAGS_VSYNC_HIGH;
+	else if (dmode->flags & DRM_MODE_FLAG_NVSYNC)
+		vm->flags |= DISPLAY_FLAGS_VSYNC_LOW;
+	if (dmode->flags & DRM_MODE_FLAG_INTERLACE)
+		vm->flags |= DISPLAY_FLAGS_INTERLACED;
+	if (dmode->flags & DRM_MODE_FLAG_DBLSCAN)
+		vm->flags |= DISPLAY_FLAGS_DOUBLESCAN;
+	if (dmode->flags & DRM_MODE_FLAG_DBLCLK)
+		vm->flags |= DISPLAY_FLAGS_DOUBLECLK;
+}
diff --git a/drivers/video/drm/drm_of.c b/drivers/video/drm/drm_of.c
new file mode 100644
index 0000000000..ed17382951
--- /dev/null
+++ b/drivers/video/drm/drm_of.c
@@ -0,0 +1,161 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * (C) Copyright 2023 Rockchip Electronics Co., Ltd
+ *
+ */
+#include <dm/device.h>
+#include <dm/read.h>
+
+#include "drm_of.h"
+
+enum drm_of_lvds_pixels {
+	DRM_OF_LVDS_EVEN = BIT(0),
+	DRM_OF_LVDS_ODD = BIT(1),
+	DRM_OF_LVDS_LEFT = BIT(2),
+	DRM_OF_LVDS_RIGHT = BIT(3),
+};
+
+static int
+drm_of_lvds_get_port_pixels_type(const struct device_node *port_node)
+{
+	ofnode node = np_to_ofnode(port_node);
+
+	bool even_pixels =
+		ofnode_read_bool(node, "dual-lvds-even-pixels");
+	bool odd_pixels =
+		ofnode_read_bool(node, "dual-lvds-odd-pixels");
+	bool left_pixels =
+		ofnode_read_bool(node, "dual-lvds-left-pixels");
+	bool right_pixels =
+		ofnode_read_bool(node, "dual-lvds-right-pixels");
+
+	return (even_pixels ? DRM_OF_LVDS_EVEN : 0) |
+		   (odd_pixels ? DRM_OF_LVDS_ODD : 0) |
+		   (left_pixels ? DRM_OF_LVDS_LEFT : 0) |
+		   (right_pixels ? DRM_OF_LVDS_RIGHT : 0);
+}
+
+static int
+drm_of_lvds_get_remote_pixels_type(const struct device_node *port_node)
+{
+	ofnode node = np_to_ofnode(port_node);
+	ofnode endpoint;
+	uint phandle;
+	int pixels_type = -EPIPE;
+
+	ofnode_for_each_subnode(endpoint, node) {
+		int current_pt;
+		const char *name;
+
+		if (!ofnode_is_enabled(endpoint))
+			continue;
+
+		name = ofnode_get_name(endpoint);
+		if (strncmp(name, "endpoint", 8) != 0)
+			continue;
+
+		if (ofnode_read_u32(endpoint, "remote-endpoint", &phandle))
+			continue;
+
+		endpoint = ofnode_get_by_phandle(phandle);
+		if (!ofnode_valid(endpoint) || !ofnode_is_enabled(endpoint))
+			continue;
+
+		endpoint = ofnode_get_parent(endpoint);
+		if (!ofnode_valid(endpoint))
+			continue;
+
+		current_pt =
+			drm_of_lvds_get_port_pixels_type(ofnode_to_np(endpoint
+				));
+		if (pixels_type < 0)
+			pixels_type = current_pt;
+
+		/*
+		 * Sanity check, ensure that all remote endpoints have the same
+		 * pixel type. We may lift this restriction later if we need to
+		 * support multiple sinks with different dual-link
+		 * configurations by passing the endpoints explicitly to
+		 * drm_of_lvds_get_dual_link_pixel_order().
+		 */
+		if (!current_pt || pixels_type != current_pt)
+			return -EINVAL;
+	}
+
+	return pixels_type;
+}
+
+/**
+ * drm_of_lvds_get_dual_link_pixel_order - Get LVDS dual-link pixel order
+ * @port1: First DT port node of the Dual-link LVDS source
+ * @port2: Second DT port node of the Dual-link LVDS source
+ *
+ * An LVDS dual-link connection is made of two links, the two link can transmit
+ * odd pixels and even pixels independently, or the two link can also transmit
+ * left pixels and right pixels independently. This function returns for two
+ * ports of an LVDS dual-link source, based on the requirements of the connected
+ * sink.
+ *
+ * The pixel order is determined from the dual-lvds-even-pixels +
+ * dual-lvds-odd-pixels or dual-lvds-left-pixels + dual-lvds-right-pixels
+ * properties in the sink's DT port nodes. If those
+ * properties are not present, or if their usage is not valid, this function
+ * returns -EINVAL.
+ *
+ * If either port is not connected, this function returns -EPIPE.
+ *
+ * @port1 and @port2 are typically DT sibling nodes, but may have different
+ * parents when, for instance, two separate LVDS encoders carry the even and
+ * odd pixels.
+ *
+ * Return:
+ * * DRM_LVDS_DUAL_LINK_EVEN_ODD_PIXELS - @port1 carries even pixels and @port2
+ *   carries odd pixels
+ * * DRM_LVDS_DUAL_LINK_ODD_EVEN_PIXELS - @port1 carries odd pixels and @port2
+ *   carries even pixels
+ * * DRM_LVDS_DUAL_LINK_LEFT_RIGHT_PIXELS - @port1 carries left pixels and
+ *   @port2 carries right pixels
+ * * DRM_LVDS_DUAL_LINK_RIGHT_LEFT_PIXELS - @port1 carries right pixels and
+ *   @port2 carries left pixels
+
+ * * -EINVAL - @port1 and @port2 are not connected to a dual-link LVDS sink, or
+ *   the sink configuration is invalid
+ * * -EPIPE - when @port1 or @port2 are not connected
+ */
+int drm_of_lvds_get_dual_link_pixel_order(const struct device_node *port1,
+					  const struct device_node *port2)
+{
+	int remote_p1_pt, remote_p2_pt;
+
+	if (!port1 || !port2)
+		return -EINVAL;
+
+	remote_p1_pt = drm_of_lvds_get_remote_pixels_type(port1);
+	if (remote_p1_pt < 0)
+		return remote_p1_pt;
+
+	remote_p2_pt = drm_of_lvds_get_remote_pixels_type(port2);
+	if (remote_p2_pt < 0)
+		return remote_p2_pt;
+
+	/*
+	 * A valid dual-lVDS bus is found when one remote port is marked with
+	 * "dual-lvds-even-pixels" or "dual-lvds-left-pixels", and the other
+	 * remote port is marked with "dual-lvds-odd-pixels"or
+	 * "dual-lvds-right-pixels", bail out if the markers are not right.
+	 */
+	if ((remote_p1_pt + remote_p2_pt !=
+		DRM_OF_LVDS_EVEN + DRM_OF_LVDS_ODD) &&
+		(remote_p1_pt + remote_p2_pt !=
+		DRM_OF_LVDS_LEFT + DRM_OF_LVDS_RIGHT))
+		return -EINVAL;
+
+	if (remote_p1_pt == DRM_OF_LVDS_EVEN)
+		return DRM_LVDS_DUAL_LINK_EVEN_ODD_PIXELS;
+	else if (remote_p1_pt == DRM_OF_LVDS_ODD)
+		return DRM_LVDS_DUAL_LINK_ODD_EVEN_PIXELS;
+	else if (remote_p1_pt == DRM_OF_LVDS_LEFT)
+		return DRM_LVDS_DUAL_LINK_LEFT_RIGHT_PIXELS;
+	else
+		return DRM_LVDS_DUAL_LINK_RIGHT_LEFT_PIXELS;
+}
diff --git a/drivers/video/drm/drm_of.h b/drivers/video/drm/drm_of.h
new file mode 100644
index 0000000000..f0cb3460ca
--- /dev/null
+++ b/drivers/video/drm/drm_of.h
@@ -0,0 +1,33 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * (C) Copyright 2023 Rockchip Electronics Co., Ltd
+ *
+ */
+#ifndef __DRM_OF_H__
+#define __DRM_OF_H__
+
+#include <dm/ofnode.h>
+#include <dm/of_access.h>
+
+/**
+ * enum drm_lvds_dual_link_pixels - Pixel order of an LVDS dual-link connection
+ * @DRM_LVDS_DUAL_LINK_EVEN_ODD_PIXELS: Even pixels are expected to be
+ *    generated from the first port, odd pixels from the second port
+ * @DRM_LVDS_DUAL_LINK_ODD_EVEN_PIXELS: Odd pixels are expected to be
+ *    generated from the first port, even pixels from the second port
+ * @DRM_LVDS_DUAL_LINK_LEFT_RIGHT_PIXELS: Left pixels are expected to be
+ *    generated from the first port, right pixels from the second port
+ * @DRM_LVDS_DUAL_LINK_RIGHT_LEFT_PIXELS: Right pixels are expected to be
+ *    generated from the first port, left pixels from the second port
+ */
+enum drm_lvds_dual_link_pixels {
+	DRM_LVDS_DUAL_LINK_EVEN_ODD_PIXELS = 0,
+	DRM_LVDS_DUAL_LINK_ODD_EVEN_PIXELS = 1,
+	DRM_LVDS_DUAL_LINK_LEFT_RIGHT_PIXELS = 2,
+	DRM_LVDS_DUAL_LINK_RIGHT_LEFT_PIXELS = 3,
+};
+
+int drm_of_lvds_get_dual_link_pixel_order(const struct device_node *port1,
+					  const struct device_node *port2);
+
+#endif
diff --git a/drivers/video/drm/dw-dp.c b/drivers/video/drm/dw-dp.c
new file mode 100644
index 0000000000..3c9b7c56e7
--- /dev/null
+++ b/drivers/video/drm/dw-dp.c
@@ -0,0 +1,1809 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Rockchip USBDP Combo PHY with Samsung IP block driver
+ *
+ * Copyright (C) 2021 Rockchip Electronics Co., Ltd
+ */
+
+#include <config.h>
+#include <common.h>
+#include <errno.h>
+#include <malloc.h>
+#include <asm/unaligned.h>
+#include <asm/io.h>
+#include <clk.h>
+#include <dm/device.h>
+#include <dm/of_access.h>
+#include <dm/read.h>
+#include <generic-phy.h>
+#include <linux/bitfield.h>
+#include <linux/hdmi.h>
+#include <linux/media-bus-format.h>
+#include <linux/list.h>
+#include <dm/device_compat.h>
+#include <asm/gpio.h>
+#include <regmap.h>
+#include <reset.h>
+#include <drm/drm_dp_helper.h>
+
+#include "rockchip_display.h"
+#include "rockchip_crtc.h"
+#include "rockchip_connector.h"
+
+#define DPTX_VERSION_NUMBER			0x0000
+#define DPTX_VERSION_TYPE			0x0004
+#define DPTX_ID					0x0008
+
+#define DPTX_CONFIG_REG1			0x0100
+#define DPTX_CONFIG_REG2			0x0104
+#define DPTX_CONFIG_REG3			0x0108
+
+#define DPTX_CCTL				0x0200
+#define FORCE_HPD				BIT(4)
+#define DEFAULT_FAST_LINK_TRAIN_EN		BIT(2)
+#define ENHANCE_FRAMING_EN			BIT(1)
+#define SCRAMBLE_DIS				BIT(0)
+#define DPTX_SOFT_RESET_CTRL			0x0204
+#define VIDEO_RESET				BIT(5)
+#define AUX_RESET				BIT(4)
+#define AUDIO_SAMPLER_RESET			BIT(3)
+#define PHY_SOFT_RESET				BIT(1)
+#define CONTROLLER_RESET			BIT(0)
+
+#define DPTX_VSAMPLE_CTRL			0x0300
+#define PIXEL_MODE_SELECT			GENMASK(22, 21)
+#define VIDEO_MAPPING				GENMASK(20, 16)
+#define VIDEO_STREAM_ENABLE			BIT(5)
+#define DPTX_VSAMPLE_STUFF_CTRL1		0x0304
+#define DPTX_VSAMPLE_STUFF_CTRL2		0x0308
+#define DPTX_VINPUT_POLARITY_CTRL		0x030c
+#define DE_IN_POLARITY				BIT(2)
+#define HSYNC_IN_POLARITY			BIT(1)
+#define VSYNC_IN_POLARITY			BIT(0)
+#define DPTX_VIDEO_CONFIG1			0x0310
+#define HACTIVE					GENMASK(31, 16)
+#define HBLANK					GENMASK(15, 2)
+#define I_P					BIT(1)
+#define R_V_BLANK_IN_OSC			BIT(0)
+#define DPTX_VIDEO_CONFIG2			0x0314
+#define VBLANK					GENMASK(31, 16)
+#define VACTIVE					GENMASK(15, 0)
+#define DPTX_VIDEO_CONFIG3			0x0318
+#define H_SYNC_WIDTH				GENMASK(31, 16)
+#define H_FRONT_PORCH				GENMASK(15, 0)
+#define DPTX_VIDEO_CONFIG4			0x031c
+#define V_SYNC_WIDTH				GENMASK(31, 16)
+#define V_FRONT_PORCH				GENMASK(15, 0)
+#define DPTX_VIDEO_CONFIG5			0x0320
+#define INIT_THRESHOLD_HI			GENMASK(22, 21)
+#define AVERAGE_BYTES_PER_TU_FRAC		GENMASK(19, 16)
+#define INIT_THRESHOLD				GENMASK(13, 7)
+#define AVERAGE_BYTES_PER_TU			GENMASK(6, 0)
+#define DPTX_VIDEO_MSA1				0x0324
+#define VSTART					GENMASK(31, 16)
+#define HSTART					GENMASK(15, 0)
+#define DPTX_VIDEO_MSA2				0x0328
+#define MISC0					GENMASK(31, 24)
+#define DPTX_VIDEO_MSA3				0x032c
+#define MISC1					GENMASK(31, 24)
+#define DPTX_VIDEO_HBLANK_INTERVAL		0x0330
+#define HBLANK_INTERVAL_EN			BIT(16)
+#define HBLANK_INTERVAL				GENMASK(15, 0)
+
+#define DPTX_AUD_CONFIG1			0x0400
+#define AUDIO_TIMESTAMP_VERSION_NUM		GENMASK(29, 24)
+#define AUDIO_PACKET_ID				GENMASK(23, 16)
+#define AUDIO_MUTE				BIT(15)
+#define NUM_CHANNELS				GENMASK(14, 12)
+#define HBR_MODE_ENABLE				BIT(10)
+#define AUDIO_DATA_WIDTH			GENMASK(9, 5)
+#define AUDIO_DATA_IN_EN			GENMASK(4, 1)
+#define AUDIO_INF_SELECT			BIT(0)
+
+#define DPTX_SDP_VERTICAL_CTRL			0x0500
+#define EN_VERTICAL_SDP				BIT(2)
+#define EN_AUDIO_STREAM_SDP			BIT(1)
+#define EN_AUDIO_TIMESTAMP_SDP			BIT(0)
+#define DPTX_SDP_HORIZONTAL_CTRL		0x0504
+#define EN_HORIZONTAL_SDP			BIT(2)
+#define DPTX_SDP_STATUS_REGISTER		0x0508
+#define DPTX_SDP_MANUAL_CTRL			0x050c
+#define DPTX_SDP_STATUS_EN			0x0510
+
+#define DPTX_SDP_REGISTER_BANK			0x0600
+#define SDP_REGS				GENMASK(31, 0)
+
+#define DPTX_PHYIF_CTRL				0x0a00
+#define PHY_WIDTH				BIT(25)
+#define PHY_POWERDOWN				GENMASK(20, 17)
+#define PHY_BUSY				GENMASK(15, 12)
+#define SSC_DIS					BIT(16)
+#define XMIT_ENABLE				GENMASK(11, 8)
+#define PHY_LANES				GENMASK(7, 6)
+#define PHY_RATE				GENMASK(5, 4)
+#define TPS_SEL					GENMASK(3, 0)
+#define DPTX_PHY_TX_EQ				0x0a04
+#define DPTX_CUSTOMPAT0				0x0a08
+#define DPTX_CUSTOMPAT1				0x0a0c
+#define DPTX_CUSTOMPAT2				0x0a10
+#define DPTX_HBR2_COMPLIANCE_SCRAMBLER_RESET	0x0a14
+#define DPTX_PHYIF_PWRDOWN_CTRL			0x0a18
+
+#define DPTX_AUX_CMD				0x0b00
+#define AUX_CMD_TYPE				GENMASK(31, 28)
+#define AUX_ADDR				GENMASK(27, 8)
+#define I2C_ADDR_ONLY				BIT(4)
+#define AUX_LEN_REQ				GENMASK(3, 0)
+#define DPTX_AUX_STATUS				0x0b04
+#define AUX_TIMEOUT				BIT(17)
+#define AUX_BYTES_READ				GENMASK(23, 19)
+#define AUX_STATUS				GENMASK(7, 4)
+#define DPTX_AUX_DATA0				0x0b08
+#define DPTX_AUX_DATA1				0x0b0c
+#define DPTX_AUX_DATA2				0x0b10
+#define DPTX_AUX_DATA3				0x0b14
+
+#define DPTX_GENERAL_INTERRUPT			0x0d00
+#define VIDEO_FIFO_OVERFLOW_STREAM0		BIT(6)
+#define AUDIO_FIFO_OVERFLOW_STREAM0		BIT(5)
+#define SDP_EVENT_STREAM0			BIT(4)
+#define AUX_CMD_INVALID				BIT(3)
+#define AUX_REPLY_EVENT				BIT(1)
+#define HPD_EVENT				BIT(0)
+#define DPTX_GENERAL_INTERRUPT_ENABLE		0x0d04
+#define AUX_REPLY_EVENT_EN			BIT(1)
+#define HPD_EVENT_EN				BIT(0)
+#define DPTX_HPD_STATUS				0x0d08
+#define HPD_STATE				GENMASK(11, 9)
+#define HPD_STATUS				BIT(8)
+#define HPD_HOT_UNPLUG				BIT(2)
+#define HPD_HOT_PLUG				BIT(1)
+#define HPD_IRQ					BIT(0)
+#define DPTX_HPD_INTERRUPT_ENABLE		0x0d0c
+#define HPD_UNPLUG_ERR_EN			BIT(3)
+#define HPD_UNPLUG_EN				BIT(2)
+#define HPD_PLUG_EN				BIT(1)
+#define HPD_IRQ_EN				BIT(0)
+
+#define DPTX_MAX_REGISTER			DPTX_HPD_INTERRUPT_ENABLE
+
+#define SDP_REG_BANK_SIZE			16
+
+struct drm_dp_link_caps {
+	bool enhanced_framing;
+	bool tps3_supported;
+	bool tps4_supported;
+	bool channel_coding;
+	bool ssc;
+};
+
+struct drm_dp_link_train_set {
+	unsigned int voltage_swing[4];
+	unsigned int pre_emphasis[4];
+};
+
+struct drm_dp_link_train {
+	struct drm_dp_link_train_set request;
+	struct drm_dp_link_train_set adjust;
+	bool clock_recovered;
+	bool channel_equalized;
+};
+
+struct dw_dp_link {
+	u8 dpcd[DP_RECEIVER_CAP_SIZE];
+	unsigned char revision;
+	unsigned int rate;
+	unsigned int lanes;
+	struct drm_dp_link_caps caps;
+	struct drm_dp_link_train train;
+	u8 sink_count;
+	u8 vsc_sdp_extension_for_colorimetry_supported;
+};
+
+struct dw_dp_video {
+	struct drm_display_mode mode;
+	u32 bus_format;
+	u8 video_mapping;
+	u8 pixel_mode;
+	u8 color_format;
+	u8 bpc;
+	u8 bpp;
+};
+
+struct dw_dp_sdp {
+	struct dp_sdp_header header;
+	u8 db[32];
+	unsigned long flags;
+};
+
+struct dw_dp {
+	struct rockchip_connector connector;
+	struct udevice *dev;
+	struct regmap *regmap;
+	struct phy phy;
+	struct reset_ctl reset;
+	int id;
+
+	struct gpio_desc hpd_gpio;
+	struct drm_dp_aux aux;
+	struct dw_dp_link link;
+	struct dw_dp_video video;
+
+	bool force_hpd;
+	bool force_output;
+	u32 max_link_rate;
+};
+
+enum {
+	SOURCE_STATE_IDLE,
+	SOURCE_STATE_UNPLUG,
+	SOURCE_STATE_HPD_TIMEOUT = 4,
+	SOURCE_STATE_PLUG = 7
+};
+
+enum {
+	DPTX_VM_RGB_6BIT,
+	DPTX_VM_RGB_8BIT,
+	DPTX_VM_RGB_10BIT,
+	DPTX_VM_RGB_12BIT,
+	DPTX_VM_RGB_16BIT,
+	DPTX_VM_YCBCR444_8BIT,
+	DPTX_VM_YCBCR444_10BIT,
+	DPTX_VM_YCBCR444_12BIT,
+	DPTX_VM_YCBCR444_16BIT,
+	DPTX_VM_YCBCR422_8BIT,
+	DPTX_VM_YCBCR422_10BIT,
+	DPTX_VM_YCBCR422_12BIT,
+	DPTX_VM_YCBCR422_16BIT,
+	DPTX_VM_YCBCR420_8BIT,
+	DPTX_VM_YCBCR420_10BIT,
+	DPTX_VM_YCBCR420_12BIT,
+	DPTX_VM_YCBCR420_16BIT,
+};
+
+enum {
+	DPTX_MP_SINGLE_PIXEL,
+	DPTX_MP_DUAL_PIXEL,
+	DPTX_MP_QUAD_PIXEL,
+};
+
+enum {
+	DPTX_SDP_VERTICAL_INTERVAL = BIT(0),
+	DPTX_SDP_HORIZONTAL_INTERVAL = BIT(1),
+};
+
+enum {
+	DPTX_PHY_PATTERN_NONE,
+	DPTX_PHY_PATTERN_TPS_1,
+	DPTX_PHY_PATTERN_TPS_2,
+	DPTX_PHY_PATTERN_TPS_3,
+	DPTX_PHY_PATTERN_TPS_4,
+	DPTX_PHY_PATTERN_SERM,
+	DPTX_PHY_PATTERN_PBRS7,
+	DPTX_PHY_PATTERN_CUSTOM_80BIT,
+	DPTX_PHY_PATTERN_CP2520_1,
+	DPTX_PHY_PATTERN_CP2520_2,
+};
+
+enum {
+	DPTX_PHYRATE_RBR,
+	DPTX_PHYRATE_HBR,
+	DPTX_PHYRATE_HBR2,
+	DPTX_PHYRATE_HBR3,
+};
+
+struct dw_dp_output_format {
+	u32 bus_format;
+	u32 color_format;
+	u8 video_mapping;
+	u8 bpc;
+	u8 bpp;
+};
+
+static const struct dw_dp_output_format possible_output_fmts[] = {
+	{ MEDIA_BUS_FMT_RGB101010_1X30, DRM_COLOR_FORMAT_RGB444,
+	  DPTX_VM_RGB_10BIT, 10, 30 },
+	{ MEDIA_BUS_FMT_RGB888_1X24, DRM_COLOR_FORMAT_RGB444,
+	  DPTX_VM_RGB_8BIT, 8, 24 },
+	{ MEDIA_BUS_FMT_YUV10_1X30, DRM_COLOR_FORMAT_YCRCB444,
+	  DPTX_VM_YCBCR444_10BIT, 10, 30 },
+	{ MEDIA_BUS_FMT_YUV8_1X24, DRM_COLOR_FORMAT_YCRCB444,
+	  DPTX_VM_YCBCR444_8BIT, 8, 24},
+	{ MEDIA_BUS_FMT_YUYV10_1X20, DRM_COLOR_FORMAT_YCRCB422,
+	  DPTX_VM_YCBCR422_10BIT, 10, 20 },
+	{ MEDIA_BUS_FMT_YUYV8_1X16, DRM_COLOR_FORMAT_YCRCB422,
+	  DPTX_VM_YCBCR422_8BIT, 8, 16 },
+	{ MEDIA_BUS_FMT_UYYVYY10_0_5X30, DRM_COLOR_FORMAT_YCRCB420,
+	  DPTX_VM_YCBCR420_10BIT, 10, 15 },
+	{ MEDIA_BUS_FMT_UYYVYY8_0_5X24, DRM_COLOR_FORMAT_YCRCB420,
+	  DPTX_VM_YCBCR420_8BIT, 8, 12 },
+	{ MEDIA_BUS_FMT_RGB666_1X24_CPADHI, DRM_COLOR_FORMAT_RGB444,
+	  DPTX_VM_RGB_6BIT, 6, 18 },
+};
+
+static int dw_dp_aux_write_data(struct dw_dp *dp, const u8 *buffer, size_t size)
+{
+	size_t i, j;
+
+	for (i = 0; i < DIV_ROUND_UP(size, 4); i++) {
+		size_t num = min_t(size_t, size - i * 4, 4);
+		u32 value = 0;
+
+		for (j = 0; j < num; j++)
+			value |= buffer[i * 4 + j] << (j * 8);
+
+		regmap_write(dp->regmap, DPTX_AUX_DATA0 + i * 4, value);
+	}
+
+	return size;
+}
+
+static int dw_dp_aux_read_data(struct dw_dp *dp, u8 *buffer, size_t size)
+{
+	size_t i, j;
+
+	for (i = 0; i < DIV_ROUND_UP(size, 4); i++) {
+		size_t num = min_t(size_t, size - i * 4, 4);
+		u32 value;
+
+		regmap_read(dp->regmap, DPTX_AUX_DATA0 + i * 4, &value);
+
+		for (j = 0; j < num; j++)
+			buffer[i * 4 + j] = value >> (j * 8);
+	}
+
+	return size;
+}
+
+static ssize_t dw_dp_aux_transfer(struct drm_dp_aux *aux,
+				  struct drm_dp_aux_msg *msg)
+{
+	u32 status, value;
+	ssize_t ret = 0;
+	int timeout = 0;
+	struct dw_dp *dp = dev_get_priv(aux->dev);
+
+	if (WARN_ON(msg->size > 16))
+		return -E2BIG;
+
+	switch (msg->request & ~DP_AUX_I2C_MOT) {
+	case DP_AUX_NATIVE_WRITE:
+	case DP_AUX_I2C_WRITE:
+	case DP_AUX_I2C_WRITE_STATUS_UPDATE:
+		ret = dw_dp_aux_write_data(dp, msg->buffer, msg->size);
+		if (ret < 0)
+			return ret;
+		break;
+	case DP_AUX_NATIVE_READ:
+	case DP_AUX_I2C_READ:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (msg->size > 0)
+		value = FIELD_PREP(AUX_LEN_REQ, msg->size - 1);
+	else
+		value = FIELD_PREP(I2C_ADDR_ONLY, 1);
+
+	value |= FIELD_PREP(AUX_CMD_TYPE, msg->request);
+	value |= FIELD_PREP(AUX_ADDR, msg->address);
+	regmap_write(dp->regmap, DPTX_AUX_CMD, value);
+
+	timeout = regmap_read_poll_timeout(dp->regmap, DPTX_GENERAL_INTERRUPT,
+					   status, status & AUX_REPLY_EVENT,
+					   200, 10);
+
+	if (timeout) {
+		printf("timeout waiting for AUX reply\n");
+		return -ETIMEDOUT;
+	}
+	regmap_write(dp->regmap, DPTX_GENERAL_INTERRUPT, AUX_REPLY_EVENT);
+
+	regmap_read(dp->regmap, DPTX_AUX_STATUS, &value);
+	if (value & AUX_TIMEOUT) {
+		printf("aux timeout\n");
+		return -ETIMEDOUT;
+	}
+
+	msg->reply = FIELD_GET(AUX_STATUS, value);
+
+	if (msg->size > 0 && msg->reply == DP_AUX_NATIVE_REPLY_ACK) {
+		if (msg->request & DP_AUX_I2C_READ) {
+			size_t count = FIELD_GET(AUX_BYTES_READ, value) - 1;
+
+			if (count != msg->size) {
+				printf("aux fail to read %lu bytes\n", count);
+				return -EBUSY;
+			}
+
+			ret = dw_dp_aux_read_data(dp, msg->buffer, count);
+			if (ret < 0)
+				return ret;
+		}
+	}
+
+	return ret;
+}
+
+static bool dw_dp_bandwidth_ok(struct dw_dp *dp,
+			       const struct drm_display_mode *mode, u32 bpp,
+			       unsigned int lanes, unsigned int rate)
+{
+	u32 max_bw, req_bw;
+
+	req_bw = mode->clock * bpp / 8;
+	max_bw = lanes * rate;
+	if (req_bw > max_bw)
+		return false;
+
+	return true;
+}
+
+static void dw_dp_hpd_init(struct dw_dp *dp)
+{
+	if (dm_gpio_is_valid(&dp->hpd_gpio) || dp->force_hpd) {
+		regmap_update_bits(dp->regmap, DPTX_CCTL, FORCE_HPD,
+				   FIELD_PREP(FORCE_HPD, 1));
+		return;
+	}
+
+	/* Enable all HPD interrupts */
+	regmap_update_bits(dp->regmap, DPTX_HPD_INTERRUPT_ENABLE,
+			   HPD_UNPLUG_EN | HPD_PLUG_EN | HPD_IRQ_EN,
+			   FIELD_PREP(HPD_UNPLUG_EN, 1) |
+			   FIELD_PREP(HPD_PLUG_EN, 1) |
+			   FIELD_PREP(HPD_IRQ_EN, 1));
+
+	/* Enable all top-level interrupts */
+	regmap_update_bits(dp->regmap, DPTX_GENERAL_INTERRUPT_ENABLE,
+			   HPD_EVENT_EN, FIELD_PREP(HPD_EVENT_EN, 1));
+}
+
+static void dw_dp_aux_init(struct dw_dp *dp)
+{
+	regmap_update_bits(dp->regmap, DPTX_SOFT_RESET_CTRL, AUX_RESET,
+			   FIELD_PREP(AUX_RESET, 1));
+	udelay(10);
+	regmap_update_bits(dp->regmap, DPTX_SOFT_RESET_CTRL, AUX_RESET,
+			   FIELD_PREP(AUX_RESET, 0));
+
+	regmap_update_bits(dp->regmap, DPTX_GENERAL_INTERRUPT_ENABLE,
+			   AUX_REPLY_EVENT_EN,
+			   FIELD_PREP(AUX_REPLY_EVENT_EN, 1));
+}
+
+static void dw_dp_init(struct dw_dp *dp)
+{
+	regmap_update_bits(dp->regmap, DPTX_SOFT_RESET_CTRL, CONTROLLER_RESET,
+			   FIELD_PREP(CONTROLLER_RESET, 1));
+	udelay(10);
+	regmap_update_bits(dp->regmap, DPTX_SOFT_RESET_CTRL, CONTROLLER_RESET,
+			   FIELD_PREP(CONTROLLER_RESET, 0));
+
+	regmap_update_bits(dp->regmap, DPTX_SOFT_RESET_CTRL, PHY_SOFT_RESET,
+			   FIELD_PREP(PHY_SOFT_RESET, 1));
+	udelay(10);
+	regmap_update_bits(dp->regmap, DPTX_SOFT_RESET_CTRL, PHY_SOFT_RESET,
+			   FIELD_PREP(PHY_SOFT_RESET, 0));
+
+	regmap_update_bits(dp->regmap, DPTX_CCTL, DEFAULT_FAST_LINK_TRAIN_EN,
+			   FIELD_PREP(DEFAULT_FAST_LINK_TRAIN_EN, 0));
+
+	dw_dp_hpd_init(dp);
+	dw_dp_aux_init(dp);
+}
+
+static void dw_dp_phy_set_pattern(struct dw_dp *dp, u32 pattern)
+{
+	regmap_update_bits(dp->regmap, DPTX_PHYIF_CTRL, TPS_SEL,
+			   FIELD_PREP(TPS_SEL, pattern));
+}
+
+static void dw_dp_phy_xmit_enable(struct dw_dp *dp, u32 lanes)
+{
+	u32 xmit_enable;
+
+	switch (lanes) {
+	case 4:
+	case 2:
+	case 1:
+		xmit_enable = GENMASK(lanes - 1, 0);
+		break;
+	case 0:
+	default:
+		xmit_enable = 0;
+		break;
+	}
+
+	regmap_update_bits(dp->regmap, DPTX_PHYIF_CTRL, XMIT_ENABLE,
+			   FIELD_PREP(XMIT_ENABLE, xmit_enable));
+}
+
+static int dw_dp_link_power_up(struct dw_dp *dp)
+{
+	struct dw_dp_link *link = &dp->link;
+	u8 value;
+	int ret;
+
+	if (link->revision < 0x11)
+		return 0;
+
+	ret = drm_dp_dpcd_readb(&dp->aux, DP_SET_POWER, &value);
+	if (ret < 0)
+		return ret;
+
+	value &= ~DP_SET_POWER_MASK;
+	value |= DP_SET_POWER_D0;
+
+	ret = drm_dp_dpcd_writeb(&dp->aux, DP_SET_POWER, value);
+	if (ret < 0)
+		return ret;
+
+	udelay(1000);
+	return 0;
+}
+
+static int dw_dp_link_probe(struct dw_dp *dp)
+{
+	struct dw_dp_link *link = &dp->link;
+	u8 dpcd;
+	int ret;
+
+	ret = drm_dp_read_dpcd_caps(&dp->aux, link->dpcd);
+	if (ret < 0)
+		return ret;
+
+	ret = drm_dp_dpcd_readb(&dp->aux, DP_DPRX_FEATURE_ENUMERATION_LIST,
+				&dpcd);
+	if (ret < 0)
+		return ret;
+
+	link->vsc_sdp_extension_for_colorimetry_supported =
+		!!(dpcd & DP_VSC_SDP_EXT_FOR_COLORIMETRY_SUPPORTED);
+
+	link->revision = link->dpcd[DP_DPCD_REV];
+	link->rate = min_t(u32, min(dp->max_link_rate, dp->phy.attrs.max_link_rate * 100),
+			   drm_dp_max_link_rate(link->dpcd));
+	link->lanes = min_t(u8, dp->phy.attrs.bus_width,
+			    drm_dp_max_lane_count(link->dpcd));
+
+	link->caps.enhanced_framing = drm_dp_enhanced_frame_cap(link->dpcd);
+	link->caps.tps3_supported = drm_dp_tps3_supported(link->dpcd);
+	link->caps.tps4_supported = drm_dp_tps4_supported(link->dpcd);
+	link->caps.channel_coding = drm_dp_channel_coding_supported(link->dpcd);
+	link->caps.ssc = !!(link->dpcd[DP_MAX_DOWNSPREAD] &
+			    DP_MAX_DOWNSPREAD_0_5);
+
+	return 0;
+}
+
+static int dw_dp_link_train_update_vs_emph(struct dw_dp *dp)
+{
+	struct dw_dp_link *link = &dp->link;
+	struct drm_dp_link_train_set *request = &link->train.request;
+	struct phy_configure_opts_dp phy_cfg;
+	unsigned int lanes = link->lanes, *vs, *pe;
+	u8 buf[4];
+	int i, ret;
+
+	vs = request->voltage_swing;
+	pe = request->pre_emphasis;
+
+	for (i = 0; i < lanes; i++) {
+		phy_cfg.voltage[i] = vs[i];
+		phy_cfg.pre[i] = pe[i];
+	}
+	phy_cfg.lanes = lanes;
+	phy_cfg.link_rate = link->rate / 100;
+	phy_cfg.set_lanes = false;
+	phy_cfg.set_rate = false;
+	phy_cfg.set_voltages = true;
+	ret = generic_phy_configure(&dp->phy, &phy_cfg);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < lanes; i++)
+		buf[i] = (vs[i] << DP_TRAIN_VOLTAGE_SWING_SHIFT) |
+			 (pe[i] << DP_TRAIN_PRE_EMPHASIS_SHIFT);
+	ret = drm_dp_dpcd_write(&dp->aux, DP_TRAINING_LANE0_SET, buf, lanes);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int dw_dp_link_configure(struct dw_dp *dp)
+{
+	struct dw_dp_link *link = &dp->link;
+	struct phy_configure_opts_dp phy_cfg;
+	u8 buf[2];
+	int ret, phy_rate;
+
+	/* Move PHY to P3 */
+	regmap_update_bits(dp->regmap, DPTX_PHYIF_CTRL, PHY_POWERDOWN,
+			   FIELD_PREP(PHY_POWERDOWN, 0x3));
+
+	phy_cfg.lanes = link->lanes;
+	phy_cfg.link_rate = link->rate / 100;
+	phy_cfg.ssc = link->caps.ssc;
+	phy_cfg.set_lanes = true;
+	phy_cfg.set_rate = true;
+	phy_cfg.set_voltages = false;
+	ret = generic_phy_configure(&dp->phy, &phy_cfg);
+	if (ret)
+		return ret;
+
+	regmap_update_bits(dp->regmap, DPTX_PHYIF_CTRL, PHY_LANES,
+			   FIELD_PREP(PHY_LANES, link->lanes / 2));
+
+	switch (link->rate) {
+	case 810000:
+		phy_rate = DPTX_PHYRATE_HBR3;
+		break;
+	case 540000:
+		phy_rate = DPTX_PHYRATE_HBR2;
+		break;
+	case 270000:
+		phy_rate = DPTX_PHYRATE_HBR;
+		break;
+	case 162000:
+	default:
+		phy_rate = DPTX_PHYRATE_RBR;
+		break;
+	}
+	regmap_update_bits(dp->regmap, DPTX_PHYIF_CTRL, PHY_RATE,
+			   FIELD_PREP(PHY_RATE, phy_rate));
+
+	/* Move PHY to P0 */
+	regmap_update_bits(dp->regmap, DPTX_PHYIF_CTRL, PHY_POWERDOWN,
+			   FIELD_PREP(PHY_POWERDOWN, 0x0));
+
+	dw_dp_phy_xmit_enable(dp, link->lanes);
+
+	buf[0] = drm_dp_link_rate_to_bw_code(link->rate);
+	buf[1] = link->lanes;
+
+	if (link->caps.enhanced_framing) {
+		buf[1] |= DP_LANE_COUNT_ENHANCED_FRAME_EN;
+		regmap_update_bits(dp->regmap, DPTX_CCTL, ENHANCE_FRAMING_EN,
+				   FIELD_PREP(ENHANCE_FRAMING_EN, 1));
+	} else {
+		regmap_update_bits(dp->regmap, DPTX_CCTL, ENHANCE_FRAMING_EN,
+				   FIELD_PREP(ENHANCE_FRAMING_EN, 0));
+	}
+
+	ret = drm_dp_dpcd_write(&dp->aux, DP_LINK_BW_SET, buf, sizeof(buf));
+	if (ret < 0)
+		return ret;
+
+	buf[0] = link->caps.ssc ? DP_SPREAD_AMP_0_5 : 0;
+	buf[1] = link->caps.channel_coding ? DP_SET_ANSI_8B10B : 0;
+
+	ret = drm_dp_dpcd_write(&dp->aux, DP_DOWNSPREAD_CTRL, buf,
+				sizeof(buf));
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static void dw_dp_link_train_init(struct drm_dp_link_train *train)
+{
+	struct drm_dp_link_train_set *request = &train->request;
+	struct drm_dp_link_train_set *adjust = &train->adjust;
+	unsigned int i;
+
+	for (i = 0; i < 4; i++) {
+		request->voltage_swing[i] = 0;
+		adjust->voltage_swing[i] = 0;
+
+		request->pre_emphasis[i] = 0;
+		adjust->pre_emphasis[i] = 0;
+	}
+
+	train->clock_recovered = false;
+	train->channel_equalized = false;
+}
+
+static int dw_dp_link_train_set_pattern(struct dw_dp *dp, u32 pattern)
+{
+	u8 buf = 0;
+	int ret;
+
+	if (pattern && pattern != DP_TRAINING_PATTERN_4) {
+		buf |= DP_LINK_SCRAMBLING_DISABLE;
+
+		regmap_update_bits(dp->regmap, DPTX_CCTL, SCRAMBLE_DIS,
+				   FIELD_PREP(SCRAMBLE_DIS, 1));
+	} else {
+		regmap_update_bits(dp->regmap, DPTX_CCTL, SCRAMBLE_DIS,
+				   FIELD_PREP(SCRAMBLE_DIS, 0));
+	}
+
+	switch (pattern) {
+	case DP_TRAINING_PATTERN_DISABLE:
+		dw_dp_phy_set_pattern(dp, DPTX_PHY_PATTERN_NONE);
+		break;
+	case DP_TRAINING_PATTERN_1:
+		dw_dp_phy_set_pattern(dp, DPTX_PHY_PATTERN_TPS_1);
+		break;
+	case DP_TRAINING_PATTERN_2:
+		dw_dp_phy_set_pattern(dp, DPTX_PHY_PATTERN_TPS_2);
+		break;
+	case DP_TRAINING_PATTERN_3:
+		dw_dp_phy_set_pattern(dp, DPTX_PHY_PATTERN_TPS_3);
+		break;
+	case DP_TRAINING_PATTERN_4:
+		dw_dp_phy_set_pattern(dp, DPTX_PHY_PATTERN_TPS_4);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	ret = drm_dp_dpcd_writeb(&dp->aux, DP_TRAINING_PATTERN_SET,
+				 buf | pattern);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static void dw_dp_link_get_adjustments(struct dw_dp_link *link,
+				       u8 status[DP_LINK_STATUS_SIZE])
+{
+	struct drm_dp_link_train_set *adjust = &link->train.adjust;
+	unsigned int i;
+
+	for (i = 0; i < link->lanes; i++) {
+		adjust->voltage_swing[i] =
+			drm_dp_get_adjust_request_voltage(status, i) >>
+				DP_TRAIN_VOLTAGE_SWING_SHIFT;
+
+		adjust->pre_emphasis[i] =
+			drm_dp_get_adjust_request_pre_emphasis(status, i) >>
+				DP_TRAIN_PRE_EMPHASIS_SHIFT;
+	}
+}
+
+static void dw_dp_link_train_adjust(struct drm_dp_link_train *train)
+{
+	struct drm_dp_link_train_set *request = &train->request;
+	struct drm_dp_link_train_set *adjust = &train->adjust;
+	unsigned int i;
+
+	for (i = 0; i < 4; i++)
+		if (request->voltage_swing[i] != adjust->voltage_swing[i])
+			request->voltage_swing[i] = adjust->voltage_swing[i];
+
+	for (i = 0; i < 4; i++)
+		if (request->pre_emphasis[i] != adjust->pre_emphasis[i])
+			request->pre_emphasis[i] = adjust->pre_emphasis[i];
+}
+
+static int dw_dp_link_clock_recovery(struct dw_dp *dp)
+{
+	struct dw_dp_link *link = &dp->link;
+	u8 status[DP_LINK_STATUS_SIZE];
+	unsigned int tries = 0;
+	int ret;
+
+	ret = dw_dp_link_train_set_pattern(dp, DP_TRAINING_PATTERN_1);
+	if (ret)
+		return ret;
+
+	for (;;) {
+		ret = dw_dp_link_train_update_vs_emph(dp);
+		if (ret)
+			return ret;
+
+		drm_dp_link_train_clock_recovery_delay(link->dpcd);
+
+		ret = drm_dp_dpcd_read_link_status(&dp->aux, status);
+		if (ret < 0) {
+			dev_err(dp->dev, "failed to read link status: %d\n",
+				ret);
+			return ret;
+		}
+
+		if (drm_dp_clock_recovery_ok(status, link->lanes)) {
+			link->train.clock_recovered = true;
+			break;
+		}
+
+		dw_dp_link_get_adjustments(link, status);
+
+		if (link->train.request.voltage_swing[0] ==
+		    link->train.adjust.voltage_swing[0])
+			tries++;
+		else
+			tries = 0;
+
+		if (tries == 5)
+			break;
+
+		dw_dp_link_train_adjust(&link->train);
+	}
+
+	return 0;
+}
+
+static int dw_dp_link_channel_equalization(struct dw_dp *dp)
+{
+	struct dw_dp_link *link = &dp->link;
+	u8 status[DP_LINK_STATUS_SIZE], pattern;
+	unsigned int tries;
+	int ret;
+
+	if (link->caps.tps4_supported)
+		pattern = DP_TRAINING_PATTERN_4;
+	else if (link->caps.tps3_supported)
+		pattern = DP_TRAINING_PATTERN_3;
+	else
+		pattern = DP_TRAINING_PATTERN_2;
+	ret = dw_dp_link_train_set_pattern(dp, pattern);
+	if (ret)
+		return ret;
+
+	for (tries = 1; tries < 5; tries++) {
+		ret = dw_dp_link_train_update_vs_emph(dp);
+		if (ret)
+			return ret;
+
+		drm_dp_link_train_channel_eq_delay(link->dpcd);
+
+		ret = drm_dp_dpcd_read_link_status(&dp->aux, status);
+		if (ret < 0)
+			return ret;
+
+		if (!drm_dp_clock_recovery_ok(status, link->lanes)) {
+			dev_err(dp->dev,
+				"clock recovery lost while eq\n");
+			link->train.clock_recovered = false;
+			break;
+		}
+
+		if (drm_dp_channel_eq_ok(status, link->lanes)) {
+			link->train.channel_equalized = true;
+			break;
+		}
+
+		dw_dp_link_get_adjustments(link, status);
+		dw_dp_link_train_adjust(&link->train);
+	}
+
+	return 0;
+}
+
+static int dw_dp_link_downgrade(struct dw_dp *dp)
+{
+	struct dw_dp_link *link = &dp->link;
+	struct dw_dp_video *video = &dp->video;
+
+	switch (link->rate) {
+	case 162000:
+		return -EINVAL;
+	case 270000:
+		link->rate = 162000;
+		break;
+	case 540000:
+		link->rate = 270000;
+		break;
+	case 810000:
+		link->rate = 540000;
+		break;
+	}
+
+	if (!dw_dp_bandwidth_ok(dp, &video->mode, video->bpp, link->lanes,
+				link->rate))
+		return -E2BIG;
+
+	return 0;
+}
+
+static int dw_dp_link_train(struct dw_dp *dp)
+{
+	struct dw_dp_link *link = &dp->link;
+	int ret;
+
+retry:
+	dw_dp_link_train_init(&link->train);
+
+	printf("training link: %u lane%s at %u MHz\n",
+	       link->lanes, (link->lanes > 1) ? "s" : "", link->rate / 100);
+
+	ret = dw_dp_link_configure(dp);
+	if (ret < 0) {
+		dev_err(dp->dev, "failed to configure DP link: %d\n", ret);
+		return ret;
+	}
+
+	ret = dw_dp_link_clock_recovery(dp);
+	if (ret < 0) {
+		dev_err(dp->dev, "clock recovery failed: %d\n", ret);
+		goto out;
+	}
+
+	if (!link->train.clock_recovered) {
+		dev_err(dp->dev, "clock recovery failed, downgrading link\n");
+
+		ret = dw_dp_link_downgrade(dp);
+		if (ret < 0)
+			goto out;
+		else
+			goto retry;
+	}
+
+	printf("clock recovery succeeded\n");
+
+	ret = dw_dp_link_channel_equalization(dp);
+	if (ret < 0) {
+		dev_err(dp->dev, "channel equalization failed: %d\n", ret);
+		goto out;
+	}
+
+	if (!link->train.channel_equalized) {
+		dev_err(dp->dev,
+			"channel equalization failed, downgrading link\n");
+
+		ret = dw_dp_link_downgrade(dp);
+		if (ret < 0)
+			goto out;
+		else
+			goto retry;
+	}
+
+	printf("channel equalization succeeded\n");
+
+out:
+	dw_dp_link_train_set_pattern(dp, DP_TRAINING_PATTERN_DISABLE);
+	return ret;
+}
+
+static int dw_dp_link_enable(struct dw_dp *dp)
+{
+	int ret;
+
+	ret = dw_dp_link_power_up(dp);
+	if (ret < 0)
+		return ret;
+
+	ret = dw_dp_link_train(dp);
+	if (ret < 0) {
+		dev_err(dp->dev, "link training failed: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int dw_dp_set_phy_default_config(struct dw_dp *dp)
+{
+	struct dw_dp_link *link = &dp->link;
+	struct phy_configure_opts_dp phy_cfg;
+	int ret, i, phy_rate;
+
+	link->vsc_sdp_extension_for_colorimetry_supported = false;
+	link->rate = 270000;
+	link->lanes = dp->phy.attrs.bus_width;
+
+	link->caps.enhanced_framing = true;
+	link->caps.channel_coding = true;
+	link->caps.ssc = true;
+
+	/* Move PHY to P3 */
+	regmap_update_bits(dp->regmap, DPTX_PHYIF_CTRL, PHY_POWERDOWN,
+			   FIELD_PREP(PHY_POWERDOWN, 0x3));
+
+	for (i = 0; i < link->lanes; i++) {
+		phy_cfg.voltage[i] = 3;
+		phy_cfg.pre[i] = 0;
+	}
+	phy_cfg.lanes = link->lanes;
+	phy_cfg.link_rate = link->rate / 100;
+	phy_cfg.ssc = link->caps.ssc;
+	phy_cfg.set_lanes = true;
+	phy_cfg.set_rate = true;
+	phy_cfg.set_voltages = true;
+	ret = generic_phy_configure(&dp->phy, &phy_cfg);
+	if (ret)
+		return ret;
+
+	regmap_update_bits(dp->regmap, DPTX_PHYIF_CTRL, PHY_LANES,
+			   FIELD_PREP(PHY_LANES, link->lanes / 2));
+
+	switch (link->rate) {
+	case 810000:
+		phy_rate = DPTX_PHYRATE_HBR3;
+		break;
+	case 540000:
+		phy_rate = DPTX_PHYRATE_HBR2;
+		break;
+	case 270000:
+		phy_rate = DPTX_PHYRATE_HBR;
+		break;
+	case 162000:
+	default:
+		phy_rate = DPTX_PHYRATE_RBR;
+		break;
+	}
+	regmap_update_bits(dp->regmap, DPTX_PHYIF_CTRL, PHY_RATE,
+			   FIELD_PREP(PHY_RATE, phy_rate));
+
+	/* Move PHY to P0 */
+	regmap_update_bits(dp->regmap, DPTX_PHYIF_CTRL, PHY_POWERDOWN,
+			   FIELD_PREP(PHY_POWERDOWN, 0x0));
+
+	dw_dp_phy_xmit_enable(dp, link->lanes);
+
+	regmap_update_bits(dp->regmap, DPTX_CCTL, ENHANCE_FRAMING_EN,
+			   FIELD_PREP(ENHANCE_FRAMING_EN, 1));
+
+	dw_dp_phy_set_pattern(dp, DPTX_PHY_PATTERN_NONE);
+	return 0;
+}
+
+static int dw_dp_send_sdp(struct dw_dp *dp, struct dw_dp_sdp *sdp)
+{
+	const u8 *payload = sdp->db;
+	u32 reg;
+	int i, nr = 0;
+
+	reg = DPTX_SDP_REGISTER_BANK + nr * 9 * 4;
+
+	/* SDP header */
+	regmap_write(dp->regmap, reg, get_unaligned_le32(&sdp->header));
+
+	/* SDP data payload */
+	for (i = 1; i < 9; i++, payload += 4)
+		regmap_write(dp->regmap, reg + i * 4,
+			     FIELD_PREP(SDP_REGS, get_unaligned_le32(payload)));
+
+	if (sdp->flags & DPTX_SDP_VERTICAL_INTERVAL)
+		regmap_update_bits(dp->regmap, DPTX_SDP_VERTICAL_CTRL,
+				   EN_VERTICAL_SDP << nr,
+				   EN_VERTICAL_SDP << nr);
+
+	if (sdp->flags & DPTX_SDP_HORIZONTAL_INTERVAL)
+		regmap_update_bits(dp->regmap, DPTX_SDP_HORIZONTAL_CTRL,
+				   EN_HORIZONTAL_SDP << nr,
+				   EN_HORIZONTAL_SDP << nr);
+
+	return 0;
+}
+
+static void dw_dp_vsc_sdp_pack(const struct drm_dp_vsc_sdp *vsc,
+			       struct dw_dp_sdp *sdp)
+{
+	sdp->header.HB0 = 0;
+	sdp->header.HB1 = DP_SDP_VSC;
+	sdp->header.HB2 = vsc->revision;
+	sdp->header.HB3 = vsc->length;
+
+	sdp->db[16] = (vsc->pixelformat & 0xf) << 4;
+	sdp->db[16] |= vsc->colorimetry & 0xf;
+
+	switch (vsc->bpc) {
+	case 8:
+		sdp->db[17] = 0x1;
+		break;
+	case 10:
+		sdp->db[17] = 0x2;
+		break;
+	case 12:
+		sdp->db[17] = 0x3;
+		break;
+	case 16:
+		sdp->db[17] = 0x4;
+		break;
+	case 6:
+	default:
+		break;
+	}
+
+	if (vsc->dynamic_range == DP_DYNAMIC_RANGE_CTA)
+		sdp->db[17] |= 0x80;
+
+	sdp->db[18] = vsc->content_type & 0x7;
+
+	sdp->flags |= DPTX_SDP_VERTICAL_INTERVAL;
+}
+
+static int dw_dp_send_vsc_sdp(struct dw_dp *dp)
+{
+	struct dw_dp_video *video = &dp->video;
+	struct drm_dp_vsc_sdp vsc = {};
+	struct dw_dp_sdp sdp = {};
+
+	vsc.revision = 0x5;
+	vsc.length = 0x13;
+
+	switch (video->color_format) {
+	case DRM_COLOR_FORMAT_YCRCB444:
+		vsc.pixelformat = DP_PIXELFORMAT_YUV444;
+		break;
+	case DRM_COLOR_FORMAT_YCRCB420:
+		vsc.pixelformat = DP_PIXELFORMAT_YUV420;
+		break;
+	case DRM_COLOR_FORMAT_YCRCB422:
+		vsc.pixelformat = DP_PIXELFORMAT_YUV422;
+		break;
+	case DRM_COLOR_FORMAT_RGB444:
+	default:
+		vsc.pixelformat = DP_PIXELFORMAT_RGB;
+		break;
+	}
+
+	if (video->color_format == DRM_COLOR_FORMAT_RGB444)
+		vsc.colorimetry = DP_COLORIMETRY_DEFAULT;
+	else
+		vsc.colorimetry = DP_COLORIMETRY_BT709_YCC;
+
+	vsc.bpc = video->bpc;
+	vsc.dynamic_range = DP_DYNAMIC_RANGE_CTA;
+	vsc.content_type = DP_CONTENT_TYPE_NOT_DEFINED;
+
+	dw_dp_vsc_sdp_pack(&vsc, &sdp);
+
+	return dw_dp_send_sdp(dp, &sdp);
+}
+
+static int dw_dp_video_set_pixel_mode(struct dw_dp *dp, u8 pixel_mode)
+{
+	switch (pixel_mode) {
+	case DPTX_MP_SINGLE_PIXEL:
+	case DPTX_MP_DUAL_PIXEL:
+	case DPTX_MP_QUAD_PIXEL:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	regmap_update_bits(dp->regmap, DPTX_VSAMPLE_CTRL, PIXEL_MODE_SELECT,
+			   FIELD_PREP(PIXEL_MODE_SELECT, pixel_mode));
+
+	return 0;
+}
+
+static int dw_dp_video_set_msa(struct dw_dp *dp, u8 color_format, u8 bpc,
+			       u16 vstart, u16 hstart)
+{
+	struct dw_dp_link *link = &dp->link;
+	u16 misc = 0;
+
+	if (link->vsc_sdp_extension_for_colorimetry_supported)
+		misc |= DP_MSA_MISC_COLOR_VSC_SDP;
+
+	switch (color_format) {
+	case DRM_COLOR_FORMAT_RGB444:
+		misc |= DP_MSA_MISC_COLOR_RGB;
+		break;
+	case DRM_COLOR_FORMAT_YCRCB444:
+		misc |= DP_MSA_MISC_COLOR_YCBCR_444_BT709;
+		break;
+	case DRM_COLOR_FORMAT_YCRCB422:
+		misc |= DP_MSA_MISC_COLOR_YCBCR_422_BT709;
+		break;
+	case DRM_COLOR_FORMAT_YCRCB420:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (bpc) {
+	case 6:
+		misc |= DP_MSA_MISC_6_BPC;
+		break;
+	case 8:
+		misc |= DP_MSA_MISC_8_BPC;
+		break;
+	case 10:
+		misc |= DP_MSA_MISC_10_BPC;
+		break;
+	case 12:
+		misc |= DP_MSA_MISC_12_BPC;
+		break;
+	case 16:
+		misc |= DP_MSA_MISC_16_BPC;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	regmap_write(dp->regmap, DPTX_VIDEO_MSA1,
+		     FIELD_PREP(VSTART, vstart) | FIELD_PREP(HSTART, hstart));
+	regmap_write(dp->regmap, DPTX_VIDEO_MSA2, FIELD_PREP(MISC0, misc));
+	regmap_write(dp->regmap, DPTX_VIDEO_MSA3, FIELD_PREP(MISC1, misc >> 8));
+
+	return 0;
+}
+
+static int dw_dp_video_enable(struct dw_dp *dp)
+{
+	struct dw_dp_video *video = &dp->video;
+	struct dw_dp_link *link = &dp->link;
+	struct drm_display_mode *mode = &video->mode;
+	u8 color_format = video->color_format;
+	u8 bpc = video->bpc;
+	u8 pixel_mode = video->pixel_mode;
+	u8 bpp = video->bpp, init_threshold, vic;
+	u32 hactive, hblank, h_sync_width, h_front_porch;
+	u32 vactive, vblank, v_sync_width, v_front_porch;
+	u32 vstart = mode->vtotal - mode->vsync_start;
+	u32 hstart = mode->htotal - mode->hsync_start;
+	u32 peak_stream_bandwidth, link_bandwidth;
+	u32 average_bytes_per_tu, average_bytes_per_tu_frac;
+	u32 ts, hblank_interval;
+	u32 value;
+	int ret;
+
+	ret = dw_dp_video_set_pixel_mode(dp, pixel_mode);
+	if (ret)
+		return ret;
+
+	ret = dw_dp_video_set_msa(dp, color_format, bpc, vstart, hstart);
+	if (ret)
+		return ret;
+
+	regmap_update_bits(dp->regmap, DPTX_VSAMPLE_CTRL, VIDEO_MAPPING,
+			   FIELD_PREP(VIDEO_MAPPING, video->video_mapping));
+
+	/* Configure DPTX_VINPUT_POLARITY_CTRL register */
+	value = 0;
+	if (mode->flags & DRM_MODE_FLAG_PHSYNC)
+		value |= FIELD_PREP(HSYNC_IN_POLARITY, 1);
+	if (mode->flags & DRM_MODE_FLAG_PVSYNC)
+		value |= FIELD_PREP(VSYNC_IN_POLARITY, 1);
+	regmap_write(dp->regmap, DPTX_VINPUT_POLARITY_CTRL, value);
+
+	/* Configure DPTX_VIDEO_CONFIG1 register */
+	hactive = mode->hdisplay;
+	hblank = mode->htotal - mode->hdisplay;
+	value = FIELD_PREP(HACTIVE, hactive) | FIELD_PREP(HBLANK, hblank);
+	if (mode->flags & DRM_MODE_FLAG_INTERLACE)
+		value |= FIELD_PREP(I_P, 1);
+	vic = drm_match_cea_mode(mode);
+	if (vic == 5 || vic == 6 || vic == 7 ||
+	    vic == 10 || vic == 11 || vic == 20 ||
+	    vic == 21 || vic == 22 || vic == 39 ||
+	    vic == 25 || vic == 26 || vic == 40 ||
+	    vic == 44 || vic == 45 || vic == 46 ||
+	    vic == 50 || vic == 51 || vic == 54 ||
+	    vic == 55 || vic == 58 || vic  == 59)
+		value |= R_V_BLANK_IN_OSC;
+	regmap_write(dp->regmap, DPTX_VIDEO_CONFIG1, value);
+
+	/* Configure DPTX_VIDEO_CONFIG2 register */
+	vblank = mode->vtotal - mode->vdisplay;
+	vactive = mode->vdisplay;
+	regmap_write(dp->regmap, DPTX_VIDEO_CONFIG2,
+		     FIELD_PREP(VBLANK, vblank) | FIELD_PREP(VACTIVE, vactive));
+
+	/* Configure DPTX_VIDEO_CONFIG3 register */
+	h_sync_width = mode->hsync_end - mode->hsync_start;
+	h_front_porch = mode->hsync_start - mode->hdisplay;
+	regmap_write(dp->regmap, DPTX_VIDEO_CONFIG3,
+		     FIELD_PREP(H_SYNC_WIDTH, h_sync_width) |
+		     FIELD_PREP(H_FRONT_PORCH, h_front_porch));
+
+	/* Configure DPTX_VIDEO_CONFIG4 register */
+	v_sync_width = mode->vsync_end - mode->vsync_start;
+	v_front_porch = mode->vsync_start - mode->vdisplay;
+	regmap_write(dp->regmap, DPTX_VIDEO_CONFIG4,
+		     FIELD_PREP(V_SYNC_WIDTH, v_sync_width) |
+		     FIELD_PREP(V_FRONT_PORCH, v_front_porch));
+
+	/* Configure DPTX_VIDEO_CONFIG5 register */
+	peak_stream_bandwidth = mode->clock * bpp / 8;
+	link_bandwidth = (link->rate / 1000) * link->lanes;
+	ts = peak_stream_bandwidth * 64 / link_bandwidth;
+	average_bytes_per_tu = ts / 1000;
+	average_bytes_per_tu_frac = ts / 100 - average_bytes_per_tu * 10;
+	if (pixel_mode == DPTX_MP_SINGLE_PIXEL) {
+		if (average_bytes_per_tu < 6)
+			init_threshold = 32;
+		else if (hblank <= 80 &&
+			 color_format != DRM_COLOR_FORMAT_YCRCB420)
+			init_threshold = 12;
+		else if (hblank <= 40 &&
+			 color_format == DRM_COLOR_FORMAT_YCRCB420)
+			init_threshold = 3;
+		else
+			init_threshold = 16;
+	} else {
+		u32 t1 = 0, t2 = 0, t3 = 0;
+
+		switch (bpc) {
+		case 6:
+			t1 = (4 * 1000 / 9) * link->lanes;
+			break;
+		case 8:
+			if (color_format == DRM_COLOR_FORMAT_YCRCB422) {
+				t1 = (1000 / 2) * link->lanes;
+			} else {
+				if (pixel_mode == DPTX_MP_DUAL_PIXEL)
+					t1 = (1000 / 3) * link->lanes;
+				else
+					t1 = (3000 / 16) * link->lanes;
+			}
+			break;
+		case 10:
+			if (color_format == DRM_COLOR_FORMAT_YCRCB422)
+				t1 = (2000 / 5) * link->lanes;
+			else
+				t1 = (4000 / 15) * link->lanes;
+			break;
+		case 12:
+			if (color_format == DRM_COLOR_FORMAT_YCRCB422) {
+				if (pixel_mode == DPTX_MP_DUAL_PIXEL)
+					t1 = (1000 / 6) * link->lanes;
+				else
+					t1 = (1000 / 3) * link->lanes;
+			} else {
+				t1 = (2000 / 9) * link->lanes;
+			}
+			break;
+		case 16:
+			if (color_format != DRM_COLOR_FORMAT_YCRCB422 &&
+			    pixel_mode == DPTX_MP_DUAL_PIXEL)
+				t1 = (1000 / 6) * link->lanes;
+			else
+				t1 = (1000 / 4) * link->lanes;
+			break;
+		default:
+			return -EINVAL;
+		}
+
+		if (color_format == DRM_COLOR_FORMAT_YCRCB420)
+			t2 = (link->rate / 4) * 1000 / (mode->clock / 2);
+		else
+			t2 = (link->rate / 4) * 1000 / mode->clock;
+
+		if (average_bytes_per_tu_frac)
+			t3 = average_bytes_per_tu + 1;
+		else
+			t3 = average_bytes_per_tu;
+		init_threshold = t1 * t2 * t3 / (1000 * 1000);
+		if (init_threshold <= 16 || average_bytes_per_tu < 10)
+			init_threshold = 40;
+	}
+
+	regmap_write(dp->regmap, DPTX_VIDEO_CONFIG5,
+		     FIELD_PREP(INIT_THRESHOLD_HI, init_threshold >> 6) |
+		     FIELD_PREP(AVERAGE_BYTES_PER_TU_FRAC,
+				average_bytes_per_tu_frac) |
+		     FIELD_PREP(INIT_THRESHOLD, init_threshold) |
+		     FIELD_PREP(AVERAGE_BYTES_PER_TU, average_bytes_per_tu));
+
+	/* Configure DPTX_VIDEO_HBLANK_INTERVAL register */
+	hblank_interval = hblank * (link->rate / 4) / mode->clock;
+	regmap_write(dp->regmap, DPTX_VIDEO_HBLANK_INTERVAL,
+		     FIELD_PREP(HBLANK_INTERVAL_EN, 1) |
+		     FIELD_PREP(HBLANK_INTERVAL, hblank_interval));
+
+	/* Video stream enable */
+	regmap_update_bits(dp->regmap, DPTX_VSAMPLE_CTRL, VIDEO_STREAM_ENABLE,
+			   FIELD_PREP(VIDEO_STREAM_ENABLE, 1));
+
+	if (link->vsc_sdp_extension_for_colorimetry_supported)
+		dw_dp_send_vsc_sdp(dp);
+
+	return 0;
+}
+
+static bool dw_dp_detect(struct dw_dp *dp)
+{
+	u32 value;
+
+	if (dm_gpio_is_valid(&dp->hpd_gpio))
+		return dm_gpio_get_value(&dp->hpd_gpio);
+
+	regmap_read(dp->regmap, DPTX_HPD_STATUS, &value);
+	if (FIELD_GET(HPD_STATE, value) == SOURCE_STATE_PLUG) {
+		regmap_write(dp->regmap, DPTX_HPD_STATUS, HPD_HOT_PLUG);
+		return true;
+	}
+
+	return false;
+}
+
+static int dw_dp_connector_init(struct rockchip_connector *conn, struct display_state *state)
+{
+	struct connector_state *conn_state = &state->conn_state;
+	struct dw_dp *dp = dev_get_priv(conn->dev);
+	int ret;
+
+	conn_state->output_if |= dp->id ? VOP_OUTPUT_IF_DP1 : VOP_OUTPUT_IF_DP0;
+	conn_state->output_mode = ROCKCHIP_OUT_MODE_AAAA;
+	conn_state->color_space = V4L2_COLORSPACE_DEFAULT;
+
+	clk_set_defaults(dp->dev, CLK_DEFAULTS_PRE);
+
+	reset_assert(&dp->reset);
+	udelay(20);
+	reset_deassert(&dp->reset);
+
+	conn_state->disp_info  = rockchip_get_disp_info(conn_state->type,
+							dp->id);
+	dw_dp_init(dp);
+	ret = generic_phy_power_on(&dp->phy);
+
+	return ret;
+}
+
+static int dw_dp_connector_get_edid(struct rockchip_connector *conn, struct display_state *state)
+{
+	int ret;
+	struct connector_state *conn_state = &state->conn_state;
+	struct dw_dp *dp = dev_get_priv(conn->dev);
+
+	ret = drm_do_get_edid(&dp->aux.ddc, conn_state->edid);
+
+	return ret;
+}
+
+static int dw_dp_get_output_fmts_index(u32 bus_format)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(possible_output_fmts); i++) {
+		const struct dw_dp_output_format *fmt = &possible_output_fmts[i];
+
+		if (fmt->bus_format == bus_format)
+			break;
+	}
+
+	if (i == ARRAY_SIZE(possible_output_fmts))
+		return 1;
+
+	return i;
+}
+
+static int dw_dp_connector_prepare(struct rockchip_connector *conn, struct display_state *state)
+{
+	struct connector_state *conn_state = &state->conn_state;
+	struct dw_dp *dp = dev_get_priv(conn->dev);
+	struct dw_dp_video *video = &dp->video;
+	int bus_fmt;
+
+	bus_fmt = dw_dp_get_output_fmts_index(conn_state->bus_format);
+	video->video_mapping = possible_output_fmts[bus_fmt].video_mapping;
+	video->color_format = possible_output_fmts[bus_fmt].color_format;
+	video->bus_format = possible_output_fmts[bus_fmt].bus_format;
+	video->bpc = possible_output_fmts[bus_fmt].bpc;
+	video->bpp = possible_output_fmts[bus_fmt].bpp;
+
+	return 0;
+}
+
+static int dw_dp_connector_enable(struct rockchip_connector *conn, struct display_state *state)
+{
+	struct connector_state *conn_state = &state->conn_state;
+	struct drm_display_mode *mode = &conn_state->mode;
+	struct dw_dp *dp = dev_get_priv(conn->dev);
+	struct dw_dp_video *video = &dp->video;
+	int ret;
+
+	memcpy(&video->mode, mode, sizeof(video->mode));
+	video->pixel_mode = DPTX_MP_QUAD_PIXEL;
+
+	if (dp->force_output) {
+		ret = dw_dp_set_phy_default_config(dp);
+		if (ret < 0)
+			printf("failed to set phy_default config: %d\n", ret);
+	} else {
+		ret = dw_dp_link_enable(dp);
+		if (ret < 0) {
+			printf("failed to enable link: %d\n", ret);
+			return ret;
+		}
+	}
+
+	ret = dw_dp_video_enable(dp);
+	if (ret < 0) {
+		printf("failed to enable video: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int dw_dp_connector_disable(struct rockchip_connector *conn, struct display_state *state)
+{
+	/* TODO */
+
+	return 0;
+}
+
+static int dw_dp_connector_detect(struct rockchip_connector *conn, struct display_state *state)
+{
+	struct dw_dp *dp = dev_get_priv(conn->dev);
+	int status, tries, ret;
+
+	for (tries = 0; tries < 200; tries++) {
+		status = dw_dp_detect(dp);
+		if (status)
+			break;
+		mdelay(2);
+	}
+
+	if (state->force_output && !status)
+		dp->force_output = true;
+
+	if (!status && !dp->force_output)
+		generic_phy_power_off(&dp->phy);
+
+	if (status && !dp->force_output) {
+		ret = dw_dp_link_probe(dp);
+		if (ret)
+			printf("failed to probe DP link: %d\n", ret);
+	}
+
+	return status;
+}
+
+static int dw_dp_mode_valid(struct dw_dp *dp, struct hdmi_edid_data *edid_data)
+{
+	struct dw_dp_link *link = &dp->link;
+	struct drm_display_info *di = &edid_data->display_info;
+	u32 min_bpp;
+	int i;
+
+	if (di->color_formats & DRM_COLOR_FORMAT_YCRCB420 &&
+	    link->vsc_sdp_extension_for_colorimetry_supported)
+		min_bpp = 12;
+	else if (di->color_formats & DRM_COLOR_FORMAT_YCRCB422)
+		min_bpp = 16;
+	else if (di->color_formats & DRM_COLOR_FORMAT_RGB444)
+		min_bpp = 18;
+	else
+		min_bpp = 24;
+
+	for (i = 0; i < edid_data->modes; i++) {
+		if (!dw_dp_bandwidth_ok(dp, &edid_data->mode_buf[i], min_bpp, link->lanes,
+					link->rate))
+			edid_data->mode_buf[i].invalid = true;
+	}
+
+	return 0;
+}
+
+static u32 dw_dp_get_output_bus_fmts(struct dw_dp *dp, struct hdmi_edid_data *edid_data)
+{
+	struct dw_dp_link *link = &dp->link;
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(possible_output_fmts); i++) {
+		const struct dw_dp_output_format *fmt = &possible_output_fmts[i];
+
+		if (fmt->bpc > edid_data->display_info.bpc)
+			continue;
+
+		if (!(edid_data->display_info.color_formats & fmt->color_format))
+			continue;
+
+		if (fmt->color_format == DRM_COLOR_FORMAT_YCRCB420 &&
+		    !link->vsc_sdp_extension_for_colorimetry_supported)
+			continue;
+
+		if (drm_mode_is_420(&edid_data->display_info, edid_data->preferred_mode) &&
+		    fmt->color_format != DRM_COLOR_FORMAT_YCRCB420)
+			continue;
+
+		if (!dw_dp_bandwidth_ok(dp, edid_data->preferred_mode, fmt->bpp, link->lanes,
+					link->rate))
+			continue;
+
+		break;
+	}
+
+	if (i == ARRAY_SIZE(possible_output_fmts))
+		return 1;
+
+	return i;
+}
+
+static int dw_dp_connector_get_timing(struct rockchip_connector *conn, struct display_state *state)
+{
+	int ret, i;
+	struct connector_state *conn_state = &state->conn_state;
+	struct dw_dp *dp = dev_get_priv(conn->dev);
+	struct drm_display_mode *mode = &conn_state->mode;
+	struct hdmi_edid_data edid_data;
+	struct drm_display_mode *mode_buf;
+	struct vop_rect rect;
+	u32 bus_fmt;
+
+	mode_buf = malloc(MODE_LEN * sizeof(struct drm_display_mode));
+	if (!mode_buf)
+		return -ENOMEM;
+
+	memset(mode_buf, 0, MODE_LEN * sizeof(struct drm_display_mode));
+	memset(&edid_data, 0, sizeof(struct hdmi_edid_data));
+	edid_data.mode_buf = mode_buf;
+
+	if (!dp->force_output) {
+		ret = drm_do_get_edid(&dp->aux.ddc, conn_state->edid);
+		if (!ret)
+			ret = drm_add_edid_modes(&edid_data, conn_state->edid);
+
+		if (ret < 0) {
+			printf("failed to get edid\n");
+			goto err;
+		}
+
+		drm_rk_filter_whitelist(&edid_data);
+		if (state->conn_state.secondary) {
+			rect.width = state->crtc_state.max_output.width / 2;
+			rect.height = state->crtc_state.max_output.height / 2;
+		} else {
+			rect.width = state->crtc_state.max_output.width;
+			rect.height = state->crtc_state.max_output.height;
+		}
+
+		drm_mode_max_resolution_filter(&edid_data, &rect);
+		dw_dp_mode_valid(dp, &edid_data);
+
+		if (!drm_mode_prune_invalid(&edid_data)) {
+			printf("can't find valid hdmi mode\n");
+			ret = -EINVAL;
+			goto err;
+		}
+
+		for (i = 0; i < edid_data.modes; i++)
+			edid_data.mode_buf[i].vrefresh =
+				drm_mode_vrefresh(&edid_data.mode_buf[i]);
+
+		drm_mode_sort(&edid_data);
+		memcpy(mode, edid_data.preferred_mode, sizeof(struct drm_display_mode));
+	}
+
+	if (state->force_output)
+		bus_fmt = dw_dp_get_output_fmts_index(state->force_bus_format);
+	else
+		bus_fmt = dw_dp_get_output_bus_fmts(dp, &edid_data);
+
+	conn_state->bus_format = possible_output_fmts[bus_fmt].bus_format;
+
+	switch (possible_output_fmts[bus_fmt].color_format) {
+	case DRM_COLOR_FORMAT_YCRCB420:
+		conn_state->output_mode = ROCKCHIP_OUT_MODE_YUV420;
+		break;
+	case DRM_COLOR_FORMAT_YCRCB422:
+		conn_state->output_mode = ROCKCHIP_OUT_MODE_S888_DUMMY;
+		break;
+	case DRM_COLOR_FORMAT_RGB444:
+	case DRM_COLOR_FORMAT_YCRCB444:
+	default:
+		conn_state->output_mode = ROCKCHIP_OUT_MODE_AAAA;
+		break;
+	}
+
+err:
+	free(mode_buf);
+
+	return 0;
+}
+
+static const struct rockchip_connector_funcs dw_dp_connector_funcs = {
+	.init = dw_dp_connector_init,
+	.get_edid = dw_dp_connector_get_edid,
+	.prepare = dw_dp_connector_prepare,
+	.enable = dw_dp_connector_enable,
+	.disable = dw_dp_connector_disable,
+	.detect = dw_dp_connector_detect,
+	.get_timing = dw_dp_connector_get_timing,
+};
+
+static int dw_dp_ddc_init(struct dw_dp *dp)
+{
+	dp->aux.name = "dw-dp";
+	dp->aux.dev = dp->dev;
+	dp->aux.transfer = dw_dp_aux_transfer;
+	dp->aux.ddc.ddc_xfer = drm_dp_i2c_xfer;
+
+	return 0;
+}
+
+static u32 dw_dp_parse_link_frequencies(struct dw_dp *dp)
+{
+	struct udevice *dev = dp->dev;
+	const struct device_node *endpoint;
+	u64 frequency = 0;
+
+	endpoint = rockchip_of_graph_get_endpoint_by_regs(dev->node_, 1, 0);
+	if (!endpoint)
+		return 0;
+
+	if (of_read_u64(endpoint, "link-frequencies", &frequency) < 0)
+		return 0;
+
+	if (!frequency)
+		return 0;
+
+	do_div(frequency, 10 * 1000);	/* symbol rate kbytes */
+
+	switch (frequency) {
+	case 162000:
+	case 270000:
+	case 540000:
+	case 810000:
+		break;
+	default:
+		dev_err(dev, "invalid link frequency value: %llu\n", frequency);
+		return 0;
+	}
+
+	return frequency;
+}
+
+static int dw_dp_parse_dt(struct dw_dp *dp)
+{
+	dp->force_hpd = dev_read_bool(dp->dev, "force-hpd");
+
+	dp->max_link_rate = dw_dp_parse_link_frequencies(dp);
+	if (!dp->max_link_rate)
+		dp->max_link_rate = 810000;
+
+	return 0;
+}
+
+static int dw_dp_probe(struct udevice *dev)
+{
+	struct dw_dp *dp = dev_get_priv(dev);
+	int ret;
+
+	ret = regmap_init_mem(dev_ofnode(dev), &dp->regmap);
+	if (ret)
+		return ret;
+
+	dp->id = of_alias_get_id(ofnode_to_np(dev->node_), "dp");
+	if (dp->id < 0)
+		dp->id = 0;
+
+	ret = reset_get_by_index(dev, 0, &dp->reset);
+	if (ret) {
+		dev_err(dev, "failed to get reset control: %d\n", ret);
+		return ret;
+	}
+
+	ret = gpio_request_by_name(dev, "hpd-gpios", 0, &dp->hpd_gpio,
+				   GPIOD_IS_IN);
+	if (ret && ret != -ENOENT) {
+		dev_err(dev, "failed to get hpd GPIO: %d\n", ret);
+		return ret;
+	}
+
+	generic_phy_get_by_index(dev, 0, &dp->phy);
+
+	dp->dev = dev;
+
+	ret = dw_dp_parse_dt(dp);
+	if (ret) {
+		dev_err(dev, "failed to parse DT\n");
+		return ret;
+	}
+
+	dw_dp_ddc_init(dp);
+
+	rockchip_connector_bind(&dp->connector, dev, dp->id, &dw_dp_connector_funcs, NULL,
+				DRM_MODE_CONNECTOR_DisplayPort);
+
+	return 0;
+}
+
+static const struct udevice_id dw_dp_ids[] = {
+	{
+		.compatible = "rockchip,rk3588-dp",
+	},
+	{}
+};
+
+U_BOOT_DRIVER(dw_dp) = {
+	.name = "dw_dp",
+	.id = UCLASS_DISPLAY,
+	.of_match = dw_dp_ids,
+	.probe = dw_dp_probe,
+	.priv_auto= sizeof(struct dw_dp),
+};
+
diff --git a/drivers/video/drm/dw_hdmi.c b/drivers/video/drm/dw_hdmi.c
new file mode 100644
index 0000000000..eaf8d2e491
--- /dev/null
+++ b/drivers/video/drm/dw_hdmi.c
@@ -0,0 +1,2745 @@
+/*
+ * (C) Copyright 2008-2017 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <syscon.h>
+#include <asm/gpio.h>
+#include <asm/arch-rockchip/clock.h>
+#include <edid.h>
+#include <dm/device.h>
+#include <dm/of_access.h>
+#include <dm/ofnode.h>
+#include <dm/read.h>
+#include <linux/hdmi.h>
+#include <linux/media-bus-format.h>
+#include <linux/dw_hdmi.h>
+#include <asm/io.h>
+#include "rockchip_display.h"
+#include "rockchip_crtc.h"
+#include "rockchip_connector.h"
+#include "dw_hdmi.h"
+#include "rockchip_phy.h"
+
+#define HDCP_PRIVATE_KEY_SIZE   280
+#define HDCP_KEY_SHA_SIZE       20
+#define HDMI_HDCP1X_ID		5
+#define HDMI_EDID_BLOCK_LEN	128
+/*
+ * Unless otherwise noted, entries in this table are 100% optimization.
+ * Values can be obtained from hdmi_compute_n() but that function is
+ * slow so we pre-compute values we expect to see.
+ *
+ * All 32k and 48k values are expected to be the same (due to the way
+ * the math works) for any rate that's an exact kHz.
+ */
+static const struct dw_hdmi_audio_tmds_n common_tmds_n_table[] = {
+	{ .tmds = 25175000, .n_32k = 4096, .n_44k1 = 12854, .n_48k = 6144, },
+	{ .tmds = 25200000, .n_32k = 4096, .n_44k1 = 5656, .n_48k = 6144, },
+	{ .tmds = 27000000, .n_32k = 4096, .n_44k1 = 5488, .n_48k = 6144, },
+	{ .tmds = 28320000, .n_32k = 4096, .n_44k1 = 5586, .n_48k = 6144, },
+	{ .tmds = 30240000, .n_32k = 4096, .n_44k1 = 5642, .n_48k = 6144, },
+	{ .tmds = 31500000, .n_32k = 4096, .n_44k1 = 5600, .n_48k = 6144, },
+	{ .tmds = 32000000, .n_32k = 4096, .n_44k1 = 5733, .n_48k = 6144, },
+	{ .tmds = 33750000, .n_32k = 4096, .n_44k1 = 6272, .n_48k = 6144, },
+	{ .tmds = 36000000, .n_32k = 4096, .n_44k1 = 5684, .n_48k = 6144, },
+	{ .tmds = 40000000, .n_32k = 4096, .n_44k1 = 5733, .n_48k = 6144, },
+	{ .tmds = 49500000, .n_32k = 4096, .n_44k1 = 5488, .n_48k = 6144, },
+	{ .tmds = 50000000, .n_32k = 4096, .n_44k1 = 5292, .n_48k = 6144, },
+	{ .tmds = 54000000, .n_32k = 4096, .n_44k1 = 5684, .n_48k = 6144, },
+	{ .tmds = 65000000, .n_32k = 4096, .n_44k1 = 7056, .n_48k = 6144, },
+	{ .tmds = 68250000, .n_32k = 4096, .n_44k1 = 5376, .n_48k = 6144, },
+	{ .tmds = 71000000, .n_32k = 4096, .n_44k1 = 7056, .n_48k = 6144, },
+	{ .tmds = 72000000, .n_32k = 4096, .n_44k1 = 5635, .n_48k = 6144, },
+	{ .tmds = 73250000, .n_32k = 4096, .n_44k1 = 14112, .n_48k = 6144, },
+	{ .tmds = 74250000, .n_32k = 4096, .n_44k1 = 6272, .n_48k = 6144, },
+	{ .tmds = 75000000, .n_32k = 4096, .n_44k1 = 5880, .n_48k = 6144, },
+	{ .tmds = 78750000, .n_32k = 4096, .n_44k1 = 5600, .n_48k = 6144, },
+	{ .tmds = 78800000, .n_32k = 4096, .n_44k1 = 5292, .n_48k = 6144, },
+	{ .tmds = 79500000, .n_32k = 4096, .n_44k1 = 4704, .n_48k = 6144, },
+	{ .tmds = 83500000, .n_32k = 4096, .n_44k1 = 7056, .n_48k = 6144, },
+	{ .tmds = 85500000, .n_32k = 4096, .n_44k1 = 5488, .n_48k = 6144, },
+	{ .tmds = 88750000, .n_32k = 4096, .n_44k1 = 14112, .n_48k = 6144, },
+	{ .tmds = 97750000, .n_32k = 4096, .n_44k1 = 14112, .n_48k = 6144, },
+	{ .tmds = 101000000, .n_32k = 4096, .n_44k1 = 7056, .n_48k = 6144, },
+	{ .tmds = 106500000, .n_32k = 4096, .n_44k1 = 4704, .n_48k = 6144, },
+	{ .tmds = 108000000, .n_32k = 4096, .n_44k1 = 5684, .n_48k = 6144, },
+	{ .tmds = 115500000, .n_32k = 4096, .n_44k1 = 5712, .n_48k = 6144, },
+	{ .tmds = 119000000, .n_32k = 4096, .n_44k1 = 5544, .n_48k = 6144, },
+	{ .tmds = 135000000, .n_32k = 4096, .n_44k1 = 5488, .n_48k = 6144, },
+	{ .tmds = 146250000, .n_32k = 4096, .n_44k1 = 6272, .n_48k = 6144, },
+	{ .tmds = 148500000, .n_32k = 4096, .n_44k1 = 5488, .n_48k = 6144, },
+	{ .tmds = 154000000, .n_32k = 4096, .n_44k1 = 5544, .n_48k = 6144, },
+	{ .tmds = 162000000, .n_32k = 4096, .n_44k1 = 5684, .n_48k = 6144, },
+
+	/* For 297 MHz+ HDMI spec have some other rule for setting N */
+	{ .tmds = 297000000, .n_32k = 3073, .n_44k1 = 4704, .n_48k = 5120, },
+	{ .tmds = 594000000, .n_32k = 3073, .n_44k1 = 9408, .n_48k = 10240, },
+
+	/* End of table */
+	{ .tmds = 0,         .n_32k = 0,    .n_44k1 = 0,    .n_48k = 0, },
+};
+
+static const u16 csc_coeff_default[3][4] = {
+	{ 0x2000, 0x0000, 0x0000, 0x0000 },
+	{ 0x0000, 0x2000, 0x0000, 0x0000 },
+	{ 0x0000, 0x0000, 0x2000, 0x0000 }
+};
+
+static const u16 csc_coeff_rgb_out_eitu601[3][4] = {
+	{ 0x2000, 0x6926, 0x74fd, 0x010e },
+	{ 0x2000, 0x2cdd, 0x0000, 0x7e9a },
+	{ 0x2000, 0x0000, 0x38b4, 0x7e3b }
+};
+
+static const u16 csc_coeff_rgb_out_eitu709[3][4] = {
+	{ 0x2000, 0x7106, 0x7a02, 0x00a7 },
+	{ 0x2000, 0x3264, 0x0000, 0x7e6d },
+	{ 0x2000, 0x0000, 0x3b61, 0x7e25 }
+};
+
+static const u16 csc_coeff_rgb_in_eitu601[3][4] = {
+	{ 0x2591, 0x1322, 0x074b, 0x0000 },
+	{ 0x6535, 0x2000, 0x7acc, 0x0200 },
+	{ 0x6acd, 0x7534, 0x2000, 0x0200 }
+};
+
+static const u16 csc_coeff_rgb_in_eitu709[3][4] = {
+	{ 0x2dc5, 0x0d9b, 0x049e, 0x0000 },
+	{ 0x62f0, 0x2000, 0x7d11, 0x0200 },
+	{ 0x6756, 0x78ab, 0x2000, 0x0200 }
+};
+
+static const u16 csc_coeff_full_to_limited[3][4] = {
+	{ 0x36f7, 0x0000, 0x0000, 0x0040 },
+	{ 0x0000, 0x36f7, 0x0000, 0x0040 },
+	{ 0x0000, 0x0000, 0x36f7, 0x0040 }
+};
+
+struct hdmi_vmode {
+	bool mdataenablepolarity;
+
+	unsigned int mpixelclock;
+	unsigned int mpixelrepetitioninput;
+	unsigned int mpixelrepetitionoutput;
+	unsigned int mtmdsclock;
+};
+
+struct hdmi_data_info {
+	unsigned int enc_in_bus_format;
+	unsigned int enc_out_bus_format;
+	unsigned int enc_in_encoding;
+	unsigned int enc_out_encoding;
+	unsigned int quant_range;
+	unsigned int pix_repet_factor;
+	struct hdmi_vmode video_mode;
+};
+
+struct dw_hdmi_phy_data {
+	enum dw_hdmi_phy_type type;
+	const char *name;
+	unsigned int gen;
+	bool has_svsret;
+	int (*configure)(struct dw_hdmi *hdmi,
+			 const struct dw_hdmi_plat_data *pdata,
+			 unsigned long mpixelclock);
+};
+
+struct hdcp_keys {
+	u8 KSV[8];
+	u8 devicekey[HDCP_PRIVATE_KEY_SIZE];
+	u8 sha1[HDCP_KEY_SHA_SIZE];
+	u8 seeds[2];
+};
+
+struct dw_hdmi_i2c {
+	u8			slave_reg;
+	bool			is_regaddr;
+	bool			is_segment;
+
+	unsigned int		scl_high_ns;
+	unsigned int		scl_low_ns;
+};
+
+struct dw_hdmi {
+	int id;
+	enum dw_hdmi_devtype dev_type;
+	unsigned int version;
+	struct hdmi_data_info hdmi_data;
+	struct hdmi_edid_data edid_data;
+	const struct dw_hdmi_plat_data *plat_data;
+	struct ddc_adapter adap;
+
+	int vic;
+	int io_width;
+
+	unsigned long bus_format;
+	bool cable_plugin;
+	bool sink_is_hdmi;
+	bool sink_has_audio;
+	bool force_output;
+	void *regs;
+	void *grf;
+	void *gpio_base;
+	struct dw_hdmi_i2c *i2c;
+
+	struct {
+		const struct dw_hdmi_phy_ops *ops;
+		const char *name;
+		void *data;
+		bool enabled;
+	} phy;
+
+	struct drm_display_mode previous_mode;
+
+	unsigned int sample_rate;
+	unsigned int audio_cts;
+	unsigned int audio_n;
+	bool audio_enable;
+	bool scramble_low_rates;
+
+	void (*write)(struct dw_hdmi *hdmi, u8 val, int offset);
+	u8 (*read)(struct dw_hdmi *hdmi, int offset);
+
+	bool hdcp1x_enable;
+	bool output_bus_format_rgb;
+
+	struct gpio_desc hpd_gpiod;
+};
+
+static void dw_hdmi_writel(struct dw_hdmi *hdmi, u8 val, int offset)
+{
+	writel(val, hdmi->regs + (offset << 2));
+}
+
+static u8 dw_hdmi_readl(struct dw_hdmi *hdmi, int offset)
+{
+	return readl(hdmi->regs + (offset << 2));
+}
+
+static void dw_hdmi_writeb(struct dw_hdmi *hdmi, u8 val, int offset)
+{
+	writeb(val, hdmi->regs + offset);
+}
+
+static u8 dw_hdmi_readb(struct dw_hdmi *hdmi, int offset)
+{
+	return readb(hdmi->regs + offset);
+}
+
+static inline void hdmi_writeb(struct dw_hdmi *hdmi, u8 val, int offset)
+{
+	hdmi->write(hdmi, val, offset);
+}
+
+static inline u8 hdmi_readb(struct dw_hdmi *hdmi, int offset)
+{
+	return hdmi->read(hdmi, offset);
+}
+
+static void hdmi_modb(struct dw_hdmi *hdmi, u8 data, u8 mask, unsigned reg)
+{
+	u8 val = hdmi_readb(hdmi, reg) & ~mask;
+
+	val |= data & mask;
+	hdmi_writeb(hdmi, val, reg);
+}
+
+static void hdmi_mask_writeb(struct dw_hdmi *hdmi, u8 data, unsigned int reg,
+			     u8 shift, u8 mask)
+{
+	hdmi_modb(hdmi, data << shift, mask, reg);
+}
+
+static bool hdmi_bus_fmt_is_rgb(unsigned int bus_format)
+{
+	switch (bus_format) {
+	case MEDIA_BUS_FMT_RGB888_1X24:
+	case MEDIA_BUS_FMT_RGB101010_1X30:
+	case MEDIA_BUS_FMT_RGB121212_1X36:
+	case MEDIA_BUS_FMT_RGB161616_1X48:
+		return true;
+
+	default:
+		return false;
+	}
+}
+
+static bool hdmi_bus_fmt_is_yuv444(unsigned int bus_format)
+{
+	switch (bus_format) {
+	case MEDIA_BUS_FMT_YUV8_1X24:
+	case MEDIA_BUS_FMT_YUV10_1X30:
+	case MEDIA_BUS_FMT_YUV12_1X36:
+	case MEDIA_BUS_FMT_YUV16_1X48:
+		return true;
+
+	default:
+		return false;
+	}
+}
+
+static bool hdmi_bus_fmt_is_yuv422(unsigned int bus_format)
+{
+	switch (bus_format) {
+	case MEDIA_BUS_FMT_UYVY8_1X16:
+	case MEDIA_BUS_FMT_UYVY10_1X20:
+	case MEDIA_BUS_FMT_UYVY12_1X24:
+		return true;
+
+	default:
+		return false;
+	}
+}
+
+static bool hdmi_bus_fmt_is_yuv420(unsigned int bus_format)
+{
+	switch (bus_format) {
+	case MEDIA_BUS_FMT_UYYVYY8_0_5X24:
+	case MEDIA_BUS_FMT_UYYVYY10_0_5X30:
+	case MEDIA_BUS_FMT_UYYVYY12_0_5X36:
+	case MEDIA_BUS_FMT_UYYVYY16_0_5X48:
+		return true;
+
+	default:
+		return false;
+	}
+}
+
+static int hdmi_bus_fmt_color_depth(unsigned int bus_format)
+{
+	switch (bus_format) {
+	case MEDIA_BUS_FMT_RGB888_1X24:
+	case MEDIA_BUS_FMT_YUV8_1X24:
+	case MEDIA_BUS_FMT_UYVY8_1X16:
+	case MEDIA_BUS_FMT_UYYVYY8_0_5X24:
+		return 8;
+
+	case MEDIA_BUS_FMT_RGB101010_1X30:
+	case MEDIA_BUS_FMT_YUV10_1X30:
+	case MEDIA_BUS_FMT_UYVY10_1X20:
+	case MEDIA_BUS_FMT_UYYVYY10_0_5X30:
+		return 10;
+
+	case MEDIA_BUS_FMT_RGB121212_1X36:
+	case MEDIA_BUS_FMT_YUV12_1X36:
+	case MEDIA_BUS_FMT_UYVY12_1X24:
+	case MEDIA_BUS_FMT_UYYVYY12_0_5X36:
+		return 12;
+
+	case MEDIA_BUS_FMT_RGB161616_1X48:
+	case MEDIA_BUS_FMT_YUV16_1X48:
+	case MEDIA_BUS_FMT_UYYVYY16_0_5X48:
+		return 16;
+
+	default:
+		return 0;
+	}
+}
+
+static int is_color_space_conversion(struct dw_hdmi *hdmi)
+{
+	struct drm_display_mode *mode =
+		hdmi->edid_data.preferred_mode;
+	bool is_cea_default;
+
+	is_cea_default = (drm_match_cea_mode(mode) > 1) &&
+			 (hdmi->hdmi_data.quant_range ==
+			  HDMI_QUANTIZATION_RANGE_DEFAULT);
+
+	/*
+	 * When output is rgb limited range or default range with
+	 * cea mode, csc should be enabled.
+	 */
+	if (hdmi->hdmi_data.enc_in_bus_format !=
+	    hdmi->hdmi_data.enc_out_bus_format ||
+	    ((hdmi->hdmi_data.quant_range == HDMI_QUANTIZATION_RANGE_LIMITED ||
+	      is_cea_default) &&
+	     hdmi_bus_fmt_is_rgb(hdmi->hdmi_data.enc_in_bus_format)))
+		return 1;
+
+	return 0;
+}
+
+static int is_color_space_decimation(struct dw_hdmi *hdmi)
+{
+	if (!hdmi_bus_fmt_is_yuv422(hdmi->hdmi_data.enc_out_bus_format))
+		return 0;
+
+	if (hdmi_bus_fmt_is_rgb(hdmi->hdmi_data.enc_in_bus_format) ||
+	    hdmi_bus_fmt_is_yuv444(hdmi->hdmi_data.enc_in_bus_format))
+		return 1;
+
+	return 0;
+}
+
+static inline void hdmi_phy_test_clear(struct dw_hdmi *hdmi,
+				       unsigned char bit)
+{
+	hdmi_modb(hdmi, bit << HDMI_PHY_TST0_TSTCLR_OFFSET,
+		  HDMI_PHY_TST0_TSTCLR_MASK, HDMI_PHY_TST0);
+}
+
+static inline void hdmi_phy_test_enable(struct dw_hdmi *hdmi,
+					unsigned char bit)
+{
+	hdmi_modb(hdmi, bit << HDMI_PHY_TST0_TSTEN_OFFSET,
+		  HDMI_PHY_TST0_TSTEN_MASK, HDMI_PHY_TST0);
+}
+
+static inline void hdmi_phy_test_clock(struct dw_hdmi *hdmi,
+				       unsigned char bit)
+{
+	hdmi_modb(hdmi, bit << HDMI_PHY_TST0_TSTCLK_OFFSET,
+		  HDMI_PHY_TST0_TSTCLK_MASK, HDMI_PHY_TST0);
+}
+
+static inline void hdmi_phy_test_din(struct dw_hdmi *hdmi,
+				     unsigned char bit)
+{
+	hdmi_writeb(hdmi, bit, HDMI_PHY_TST1);
+}
+
+static inline void hdmi_phy_test_dout(struct dw_hdmi *hdmi,
+				      unsigned char bit)
+{
+	hdmi_writeb(hdmi, bit, HDMI_PHY_TST2);
+}
+
+static int dw_hdmi_i2c_read(struct dw_hdmi *hdmi,
+			    unsigned char *buf, unsigned int length)
+{
+	struct dw_hdmi_i2c *i2c = hdmi->i2c;
+	int interrupt = 0, i = 20;
+	bool read_edid = false;
+
+	if (!i2c->is_regaddr) {
+		printf("set read register address to 0\n");
+		i2c->slave_reg = 0x00;
+		i2c->is_regaddr = true;
+	}
+
+	/* edid reads are in 128 bytes. scdc reads are in 1 byte */
+	if (length == HDMI_EDID_BLOCK_LEN)
+		read_edid = true;
+
+	while (length > 0) {
+		hdmi_writeb(hdmi, i2c->slave_reg, HDMI_I2CM_ADDRESS);
+
+		if (read_edid) {
+			i2c->slave_reg += 8;
+			length -= 8;
+		} else {
+			i2c->slave_reg++;
+			length--;
+		}
+
+		if (i2c->is_segment) {
+			if (read_edid)
+				hdmi_writeb(hdmi, HDMI_I2CM_OPERATION_READ8_EXT,
+					    HDMI_I2CM_OPERATION);
+			else
+				hdmi_writeb(hdmi, HDMI_I2CM_OPERATION_READ_EXT,
+					    HDMI_I2CM_OPERATION);
+		} else {
+			if (read_edid)
+				hdmi_writeb(hdmi, HDMI_I2CM_OPERATION_READ8,
+					    HDMI_I2CM_OPERATION);
+			else
+				hdmi_writeb(hdmi, HDMI_I2CM_OPERATION_READ,
+					    HDMI_I2CM_OPERATION);
+		}
+
+		while (i--) {
+			udelay(1000);
+			interrupt = hdmi_readb(hdmi, HDMI_IH_I2CM_STAT0);
+			if (interrupt)
+				hdmi_writeb(hdmi, interrupt,
+					    HDMI_IH_I2CM_STAT0);
+			if (interrupt & (m_SCDC_READREQ | m_I2CM_DONE |
+					 m_I2CM_ERROR))
+				break;
+		}
+
+		if (!interrupt) {
+			printf("[%s] i2c read reg[0x%02x] no interrupt\n",
+			       __func__, i2c->slave_reg);
+			hdmi_writeb(hdmi, 0, HDMI_I2CM_SOFTRSTZ);
+			hdmi_writeb(hdmi, HDMI_I2CM_OPERATION_BUS_CLEAR,
+				    HDMI_I2CM_OPERATION);
+			udelay(1000);
+			return -EAGAIN;
+		}
+
+		/* Check for error condition on the bus */
+		if (interrupt & HDMI_IH_I2CM_STAT0_ERROR) {
+			printf("[%s] read reg[0x%02x] data error:0x%02x\n",
+			       __func__, i2c->slave_reg, interrupt);
+			hdmi_writeb(hdmi, 0, HDMI_I2CM_SOFTRSTZ);
+			hdmi_writeb(hdmi, HDMI_I2CM_OPERATION_BUS_CLEAR,
+				    HDMI_I2CM_OPERATION);
+			udelay(1000);
+			return -EIO;
+		}
+
+		i = 20;
+		if (read_edid)
+			for (i = 0; i < 8; i++)
+				*buf++ = hdmi_readb(hdmi, HDMI_I2CM_READ_BUFF0 + i);
+		else
+			*buf++ = hdmi_readb(hdmi, HDMI_I2CM_DATAI);
+	}
+	i2c->is_segment = false;
+
+	return 0;
+}
+
+static int dw_hdmi_i2c_write(struct dw_hdmi *hdmi,
+			     unsigned char *buf, unsigned int length)
+{
+	struct dw_hdmi_i2c *i2c = hdmi->i2c;
+	int i = 20;
+	u8 interrupt = 0;
+
+	if (!i2c->is_regaddr) {
+		/* Use the first write byte as register address */
+		i2c->slave_reg = buf[0];
+		length--;
+		buf++;
+		i2c->is_regaddr = true;
+	}
+
+	while (length--) {
+		hdmi_writeb(hdmi, *buf++, HDMI_I2CM_DATAO);
+		hdmi_writeb(hdmi, i2c->slave_reg++, HDMI_I2CM_ADDRESS);
+		hdmi_writeb(hdmi, HDMI_I2CM_OPERATION_WRITE,
+			    HDMI_I2CM_OPERATION);
+
+		while (i--) {
+			udelay(1000);
+			interrupt = hdmi_readb(hdmi, HDMI_IH_I2CM_STAT0);
+			if (interrupt)
+				hdmi_writeb(hdmi,
+					    interrupt, HDMI_IH_I2CM_STAT0);
+
+			if (interrupt & (m_SCDC_READREQ |
+					 m_I2CM_DONE | m_I2CM_ERROR))
+				break;
+		}
+
+		if (!interrupt) {
+			printf("[%s] i2c write reg[0x%02x] no interrupt\n",
+			       __func__, i2c->slave_reg);
+			hdmi_writeb(hdmi, 0, HDMI_I2CM_SOFTRSTZ);
+			hdmi_writeb(hdmi, HDMI_I2CM_OPERATION_BUS_CLEAR,
+				    HDMI_I2CM_OPERATION);
+			udelay(1000);
+			return -EAGAIN;
+		}
+
+		if ((interrupt & m_I2CM_ERROR) || (i == -1)) {
+			printf("[%s] write data error\n", __func__);
+			hdmi_writeb(hdmi, 0, HDMI_I2CM_SOFTRSTZ);
+			hdmi_writeb(hdmi, HDMI_I2CM_OPERATION_BUS_CLEAR,
+				    HDMI_I2CM_OPERATION);
+			udelay(1000);
+			return -EIO;
+		} else if (interrupt & m_I2CM_DONE) {
+			printf("[%s] write offset %02x success\n",
+			       __func__, i2c->slave_reg);
+			return -EAGAIN;
+		}
+
+		i = 20;
+	}
+
+	return 0;
+}
+
+static int dw_hdmi_i2c_xfer(struct ddc_adapter *adap,
+			    struct i2c_msg *msgs, int num)
+{
+	struct dw_hdmi *hdmi = container_of(adap, struct dw_hdmi, adap);
+	struct dw_hdmi_i2c *i2c = hdmi->i2c;
+	u8 addr = msgs[0].addr;
+	int i, ret = 0;
+
+	printf("xfer: num: %d, addr: %#x\n", num, addr);
+	for (i = 0; i < num; i++) {
+		if (msgs[i].len == 0) {
+			printf("unsupported transfer %d/%d, no data\n",
+			       i + 1, num);
+			return -EOPNOTSUPP;
+		}
+	}
+
+	hdmi_writeb(hdmi, 0x00, HDMI_IH_MUTE_I2CM_STAT0);
+
+	/* Set slave device address taken from the first I2C message */
+	if (addr == DDC_SEGMENT_ADDR && msgs[0].len == 1)
+		addr = DDC_ADDR;
+	hdmi_writeb(hdmi, addr, HDMI_I2CM_SLAVE);
+
+	/* Set slave device register address on transfer */
+	i2c->is_regaddr = false;
+
+	/* Set segment pointer for I2C extended read mode operation */
+	i2c->is_segment = false;
+
+	for (i = 0; i < num; i++) {
+		debug("xfer: num: %d/%d, len: %d, flags: %#x\n",
+		      i + 1, num, msgs[i].len, msgs[i].flags);
+		if (msgs[i].addr == DDC_SEGMENT_ADDR && msgs[i].len == 1) {
+			i2c->is_segment = true;
+			hdmi_writeb(hdmi, DDC_SEGMENT_ADDR, HDMI_I2CM_SEGADDR);
+			hdmi_writeb(hdmi, *msgs[i].buf, HDMI_I2CM_SEGPTR);
+		} else {
+			if (msgs[i].flags & I2C_M_RD)
+				ret = dw_hdmi_i2c_read(hdmi, msgs[i].buf,
+						       msgs[i].len);
+			else
+				ret = dw_hdmi_i2c_write(hdmi, msgs[i].buf,
+							msgs[i].len);
+		}
+		if (ret < 0)
+			break;
+	}
+
+	if (!ret)
+		ret = num;
+
+	/* Mute DONE and ERROR interrupts */
+	hdmi_writeb(hdmi, HDMI_IH_I2CM_STAT0_ERROR | HDMI_IH_I2CM_STAT0_DONE,
+		    HDMI_IH_MUTE_I2CM_STAT0);
+
+	return ret;
+}
+
+static bool hdmi_phy_wait_i2c_done(struct dw_hdmi *hdmi, int msec)
+{
+	u32 val;
+
+	while ((val = hdmi_readb(hdmi, HDMI_IH_I2CMPHY_STAT0) & 0x3) == 0) {
+		if (msec-- == 0)
+			return false;
+		udelay(1000);
+	}
+	hdmi_writeb(hdmi, val, HDMI_IH_I2CMPHY_STAT0);
+
+	return true;
+}
+
+static void dw_hdmi_phy_i2c_write(struct dw_hdmi *hdmi, unsigned short data,
+				  unsigned char addr)
+{
+	hdmi_writeb(hdmi, 0xFF, HDMI_IH_I2CMPHY_STAT0);
+	hdmi_writeb(hdmi, addr, HDMI_PHY_I2CM_ADDRESS_ADDR);
+	hdmi_writeb(hdmi, (unsigned char)(data >> 8),
+		    HDMI_PHY_I2CM_DATAO_1_ADDR);
+	hdmi_writeb(hdmi, (unsigned char)(data >> 0),
+		    HDMI_PHY_I2CM_DATAO_0_ADDR);
+	hdmi_writeb(hdmi, HDMI_PHY_I2CM_OPERATION_ADDR_WRITE,
+		    HDMI_PHY_I2CM_OPERATION_ADDR);
+	hdmi_phy_wait_i2c_done(hdmi, 1000);
+}
+
+static void dw_hdmi_phy_enable_powerdown(struct dw_hdmi *hdmi, bool enable)
+{
+	hdmi_mask_writeb(hdmi, !enable, HDMI_PHY_CONF0,
+			 HDMI_PHY_CONF0_PDZ_OFFSET,
+			 HDMI_PHY_CONF0_PDZ_MASK);
+}
+
+static void dw_hdmi_phy_enable_tmds(struct dw_hdmi *hdmi, u8 enable)
+{
+	hdmi_mask_writeb(hdmi, enable, HDMI_PHY_CONF0,
+			 HDMI_PHY_CONF0_ENTMDS_OFFSET,
+			 HDMI_PHY_CONF0_ENTMDS_MASK);
+}
+
+static void dw_hdmi_phy_enable_svsret(struct dw_hdmi *hdmi, u8 enable)
+{
+	hdmi_mask_writeb(hdmi, enable, HDMI_PHY_CONF0,
+			 HDMI_PHY_CONF0_SVSRET_OFFSET,
+			 HDMI_PHY_CONF0_SVSRET_MASK);
+}
+
+static void dw_hdmi_phy_gen2_pddq(struct dw_hdmi *hdmi, u8 enable)
+{
+	hdmi_mask_writeb(hdmi, enable, HDMI_PHY_CONF0,
+			 HDMI_PHY_CONF0_GEN2_PDDQ_OFFSET,
+			 HDMI_PHY_CONF0_GEN2_PDDQ_MASK);
+}
+
+static void dw_hdmi_phy_gen2_txpwron(struct dw_hdmi *hdmi, u8 enable)
+{
+	hdmi_mask_writeb(hdmi, enable, HDMI_PHY_CONF0,
+			 HDMI_PHY_CONF0_GEN2_TXPWRON_OFFSET,
+			 HDMI_PHY_CONF0_GEN2_TXPWRON_MASK);
+}
+
+static void dw_hdmi_phy_sel_data_en_pol(struct dw_hdmi *hdmi, u8 enable)
+{
+	hdmi_mask_writeb(hdmi, enable, HDMI_PHY_CONF0,
+			 HDMI_PHY_CONF0_SELDATAENPOL_OFFSET,
+			 HDMI_PHY_CONF0_SELDATAENPOL_MASK);
+}
+
+static void dw_hdmi_phy_sel_interface_control(struct dw_hdmi *hdmi, u8 enable)
+{
+	hdmi_mask_writeb(hdmi, enable, HDMI_PHY_CONF0,
+			 HDMI_PHY_CONF0_SELDIPIF_OFFSET,
+			 HDMI_PHY_CONF0_SELDIPIF_MASK);
+}
+
+static void dw_hdmi_phy_power_off(struct dw_hdmi *hdmi)
+{
+	const struct dw_hdmi_phy_data *phy = hdmi->phy.data;
+	unsigned int i;
+	u16 val;
+
+	if (phy->gen == 1) {
+		dw_hdmi_phy_enable_tmds(hdmi, 0);
+		dw_hdmi_phy_enable_powerdown(hdmi, true);
+		return;
+	}
+
+	dw_hdmi_phy_gen2_txpwron(hdmi, 0);
+
+	/*
+	 * Wait for TX_PHY_LOCK to be deasserted to indicate that the PHY went
+	 * to low power mode.
+	 */
+	for (i = 0; i < 5; ++i) {
+		val = hdmi_readb(hdmi, HDMI_PHY_STAT0);
+		if (!(val & HDMI_PHY_TX_PHY_LOCK))
+			break;
+
+		udelay(2000);
+	}
+
+	if (val & HDMI_PHY_TX_PHY_LOCK)
+		printf("PHY failed to power down\n");
+	else
+		printf("PHY powered down in %u iterations\n", i);
+
+	dw_hdmi_phy_gen2_pddq(hdmi, 1);
+}
+
+static int dw_hdmi_phy_power_on(struct dw_hdmi *hdmi)
+{
+	const struct dw_hdmi_phy_data *phy = hdmi->phy.data;
+	unsigned int i;
+	u8 val;
+
+	if (phy->gen == 1) {
+		dw_hdmi_phy_enable_powerdown(hdmi, false);
+
+		/* Toggle TMDS enable. */
+		dw_hdmi_phy_enable_tmds(hdmi, 0);
+		dw_hdmi_phy_enable_tmds(hdmi, 1);
+		return 0;
+	}
+
+	dw_hdmi_phy_gen2_txpwron(hdmi, 1);
+	dw_hdmi_phy_gen2_pddq(hdmi, 0);
+
+	/* Wait for PHY PLL lock */
+	for (i = 0; i < 5; ++i) {
+		val = hdmi_readb(hdmi, HDMI_PHY_STAT0) & HDMI_PHY_TX_PHY_LOCK;
+		if (val)
+			break;
+
+		udelay(2000);
+	}
+
+	if (!val) {
+		printf("PHY PLL failed to lock\n");
+		return -ETIMEDOUT;
+	}
+	printf("PHY PLL locked %u iterations\n", i);
+
+	return 0;
+}
+
+/*
+ * PHY configuration function for the DWC HDMI 3D TX PHY. Based on the available
+ * information the DWC MHL PHY has the same register layout and is thus also
+ * supported by this function.
+ */
+static
+int hdmi_phy_configure_dwc_hdmi_3d_tx(struct dw_hdmi *hdmi,
+				      const struct dw_hdmi_plat_data *pdata,
+				      unsigned long mpixelclock)
+{
+	const struct dw_hdmi_mpll_config *mpll_config = pdata->mpll_cfg;
+	const struct dw_hdmi_curr_ctrl *curr_ctrl = pdata->cur_ctr;
+	const struct dw_hdmi_phy_config *phy_config = pdata->phy_config;
+	unsigned int tmdsclock = hdmi->hdmi_data.video_mode.mtmdsclock;
+	unsigned int depth =
+		hdmi_bus_fmt_color_depth(hdmi->hdmi_data.enc_out_bus_format);
+
+	if (hdmi_bus_fmt_is_yuv420(hdmi->hdmi_data.enc_out_bus_format) &&
+	    pdata->mpll_cfg_420)
+		mpll_config = pdata->mpll_cfg_420;
+
+	/* PLL/MPLL Cfg - always match on final entry */
+	for (; mpll_config->mpixelclock != ~0UL; mpll_config++)
+		if (mpixelclock <= mpll_config->mpixelclock)
+			break;
+
+	for (; curr_ctrl->mpixelclock != ~0UL; curr_ctrl++)
+		if (tmdsclock <= curr_ctrl->mpixelclock)
+			break;
+
+	for (; phy_config->mpixelclock != ~0UL; phy_config++)
+		if (tmdsclock <= phy_config->mpixelclock)
+			break;
+
+	if (mpll_config->mpixelclock == ~0UL ||
+	    curr_ctrl->mpixelclock == ~0UL ||
+	    phy_config->mpixelclock == ~0UL)
+		return -EINVAL;
+
+	if (!hdmi_bus_fmt_is_yuv422(hdmi->hdmi_data.enc_out_bus_format))
+		depth = fls(depth - 8);
+	else
+		depth = 0;
+	if (depth)
+		depth--;
+
+	dw_hdmi_phy_i2c_write(hdmi, mpll_config->res[depth].cpce,
+			      HDMI_3D_TX_PHY_CPCE_CTRL);
+
+	dw_hdmi_phy_i2c_write(hdmi, mpll_config->res[depth].gmp,
+			      HDMI_3D_TX_PHY_GMPCTRL);
+	dw_hdmi_phy_i2c_write(hdmi, curr_ctrl->curr[depth],
+			      HDMI_3D_TX_PHY_CURRCTRL);
+
+	dw_hdmi_phy_i2c_write(hdmi, 0, HDMI_3D_TX_PHY_PLLPHBYCTRL);
+	dw_hdmi_phy_i2c_write(hdmi, HDMI_3D_TX_PHY_MSM_CTRL_CKO_SEL_FB_CLK,
+			      HDMI_3D_TX_PHY_MSM_CTRL);
+
+	dw_hdmi_phy_i2c_write(hdmi, phy_config->term, HDMI_3D_TX_PHY_TXTERM);
+	dw_hdmi_phy_i2c_write(hdmi, phy_config->sym_ctr,
+			      HDMI_3D_TX_PHY_CKSYMTXCTRL);
+	dw_hdmi_phy_i2c_write(hdmi, phy_config->vlev_ctr,
+			      HDMI_3D_TX_PHY_VLEVCTRL);
+
+	return 0;
+}
+
+static const struct dw_hdmi_phy_data dw_hdmi_phys[] = {
+	{
+		.type = DW_HDMI_PHY_DWC_HDMI_TX_PHY,
+		.name = "DWC HDMI TX PHY",
+		.gen = 1,
+	}, {
+		.type = DW_HDMI_PHY_DWC_MHL_PHY_HEAC,
+		.name = "DWC MHL PHY + HEAC PHY",
+		.gen = 2,
+		.has_svsret = true,
+		.configure = hdmi_phy_configure_dwc_hdmi_3d_tx,
+	}, {
+		.type = DW_HDMI_PHY_DWC_MHL_PHY,
+		.name = "DWC MHL PHY",
+		.gen = 2,
+		.has_svsret = true,
+		.configure = hdmi_phy_configure_dwc_hdmi_3d_tx,
+	}, {
+		.type = DW_HDMI_PHY_DWC_HDMI_3D_TX_PHY_HEAC,
+		.name = "DWC HDMI 3D TX PHY + HEAC PHY",
+		.gen = 2,
+		.configure = hdmi_phy_configure_dwc_hdmi_3d_tx,
+	}, {
+		.type = DW_HDMI_PHY_DWC_HDMI_3D_TX_PHY,
+		.name = "DWC HDMI 3D TX PHY",
+		.gen = 2,
+		.configure = hdmi_phy_configure_dwc_hdmi_3d_tx,
+	}, {
+		.type = DW_HDMI_PHY_DWC_HDMI20_TX_PHY,
+		.name = "DWC HDMI 2.0 TX PHY",
+		.gen = 2,
+		.has_svsret = true,
+		.configure = hdmi_phy_configure_dwc_hdmi_3d_tx,
+	}, {
+		.type = DW_HDMI_PHY_VENDOR_PHY,
+		.name = "Vendor PHY",
+	}
+};
+
+static int rockchip_dw_hdmi_scrambling_enable(struct dw_hdmi *hdmi,
+					      int enable)
+{
+	u8 stat;
+
+	drm_scdc_readb(&hdmi->adap, SCDC_TMDS_CONFIG, &stat);
+
+	if (stat < 0 && !hdmi->force_output) {
+		debug("Failed to read tmds config\n");
+		return false;
+	}
+
+	if (enable == 1) {
+		/* Write on Rx the bit Scrambling_Enable, register 0x20 */
+		stat |= SCDC_SCRAMBLING_ENABLE;
+		drm_scdc_writeb(&hdmi->adap, SCDC_TMDS_CONFIG, stat);
+		/* TMDS software reset request */
+		hdmi_writeb(hdmi, (u8)~HDMI_MC_SWRSTZ_TMDSSWRST_REQ,
+			    HDMI_MC_SWRSTZ);
+		/* Enable/Disable Scrambling */
+		hdmi_writeb(hdmi, 1, HDMI_FC_SCRAMBLER_CTRL);
+	} else {
+		/* Enable/Disable Scrambling */
+		hdmi_writeb(hdmi, 0, HDMI_FC_SCRAMBLER_CTRL);
+		/* TMDS software reset request */
+		hdmi_writeb(hdmi, (u8)~HDMI_MC_SWRSTZ_TMDSSWRST_REQ,
+			    HDMI_MC_SWRSTZ);
+		/* Write on Rx the bit Scrambling_Enable, register 0x20 */
+		stat &= ~SCDC_SCRAMBLING_ENABLE;
+		drm_scdc_writeb(&hdmi->adap, SCDC_TMDS_CONFIG, stat);
+	}
+
+	return 0;
+}
+
+static void rockchip_dw_hdmi_scdc_set_tmds_rate(struct dw_hdmi *hdmi)
+{
+	u8 stat;
+
+	drm_scdc_readb(&hdmi->adap, SCDC_TMDS_CONFIG, &stat);
+	if (hdmi->hdmi_data.video_mode.mtmdsclock > 340000000)
+		stat |= SCDC_TMDS_BIT_CLOCK_RATIO_BY_40;
+	else
+		stat &= ~SCDC_TMDS_BIT_CLOCK_RATIO_BY_40;
+	drm_scdc_writeb(&hdmi->adap, SCDC_TMDS_CONFIG, stat);
+}
+
+static int hdmi_phy_configure(struct dw_hdmi *hdmi)
+{
+	const struct dw_hdmi_phy_data *phy = hdmi->phy.data;
+	const struct dw_hdmi_plat_data *pdata = hdmi->plat_data;
+	unsigned long mpixelclock = hdmi->hdmi_data.video_mode.mpixelclock;
+	unsigned long mtmdsclock = hdmi->hdmi_data.video_mode.mtmdsclock;
+	int ret;
+
+	dw_hdmi_phy_power_off(hdmi);
+
+	/* Control for TMDS Bit Period/TMDS Clock-Period Ratio */
+	if (hdmi->edid_data.display_info.hdmi.scdc.supported)
+		rockchip_dw_hdmi_scdc_set_tmds_rate(hdmi);
+
+	/* Leave low power consumption mode by asserting SVSRET. */
+	if (phy->has_svsret)
+		dw_hdmi_phy_enable_svsret(hdmi, 1);
+
+	/* PHY reset. The reset signal is active high on Gen2 PHYs. */
+	hdmi_writeb(hdmi, HDMI_MC_PHYRSTZ_PHYRSTZ, HDMI_MC_PHYRSTZ);
+	hdmi_writeb(hdmi, 0, HDMI_MC_PHYRSTZ);
+
+	hdmi_writeb(hdmi, HDMI_MC_HEACPHY_RST_ASSERT, HDMI_MC_HEACPHY_RST);
+
+	hdmi_phy_test_clear(hdmi, 1);
+	hdmi_writeb(hdmi, HDMI_PHY_I2CM_SLAVE_ADDR_PHY_GEN2,
+		    HDMI_PHY_I2CM_SLAVE_ADDR);
+	hdmi_phy_test_clear(hdmi, 0);
+
+	/* Write to the PHY as configured by the platform */
+	if (pdata->configure_phy)
+		ret = pdata->configure_phy(hdmi, pdata, mpixelclock);
+	else
+		ret = phy->configure(hdmi, pdata, mpixelclock);
+	if (ret) {
+		printf("PHY configuration failed (clock %lu)\n",
+		       mpixelclock);
+		return ret;
+	}
+
+	/* Wait for resuming transmission of TMDS clock and data */
+	if (mtmdsclock > 340000000)
+		mdelay(100);
+
+	return dw_hdmi_phy_power_on(hdmi);
+}
+
+static int dw_hdmi_phy_init(struct rockchip_connector *conn, struct dw_hdmi *hdmi,
+			    void *data)
+{
+	int i, ret;
+
+	/* HDMI Phy spec says to do the phy initialization sequence twice */
+	for (i = 0; i < 2; i++) {
+		dw_hdmi_phy_sel_data_en_pol(hdmi, 1);
+		dw_hdmi_phy_sel_interface_control(hdmi, 0);
+		ret = hdmi_phy_configure(hdmi);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static void dw_hdmi_phy_disable(struct rockchip_connector *conn, struct dw_hdmi *hdmi,
+				void *data)
+{
+	dw_hdmi_phy_power_off(hdmi);
+}
+
+static enum drm_connector_status
+dw_hdmi_phy_read_hpd(struct dw_hdmi *hdmi, void *data)
+{
+	return hdmi_readb(hdmi, HDMI_PHY_STAT0) & HDMI_PHY_HPD ?
+		connector_status_connected : connector_status_disconnected;
+}
+
+static const struct dw_hdmi_phy_ops dw_hdmi_synopsys_phy_ops = {
+	.init = dw_hdmi_phy_init,
+	.disable = dw_hdmi_phy_disable,
+	.read_hpd = dw_hdmi_phy_read_hpd,
+};
+
+static int dw_hdmi_detect_phy(struct dw_hdmi *hdmi)
+{
+	unsigned int i;
+	u8 phy_type;
+
+	phy_type = hdmi_readb(hdmi, HDMI_CONFIG2_ID);
+
+	/*
+	 * RK3228 and RK3328 phy_type is DW_HDMI_PHY_DWC_HDMI20_TX_PHY,
+	 * but it has a vedor phy.
+	 */
+	if (phy_type == DW_HDMI_PHY_VENDOR_PHY ||
+	    hdmi->dev_type == RK3528_HDMI ||
+	    hdmi->dev_type == RK3328_HDMI ||
+	    hdmi->dev_type == RK3228_HDMI) {
+		/* Vendor PHYs require support from the glue layer. */
+		if (!hdmi->plat_data->phy_ops || !hdmi->plat_data->phy_name) {
+			printf(
+				"Vendor HDMI PHY not supported by glue layer\n");
+			return -ENODEV;
+		}
+
+		hdmi->phy.ops = hdmi->plat_data->phy_ops;
+		hdmi->phy.data = hdmi->plat_data->phy_data;
+		hdmi->phy.name = hdmi->plat_data->phy_name;
+		return 0;
+	}
+
+	/* Synopsys PHYs are handled internally. */
+	for (i = 0; i < ARRAY_SIZE(dw_hdmi_phys); ++i) {
+		if (dw_hdmi_phys[i].type == phy_type) {
+			hdmi->phy.ops = &dw_hdmi_synopsys_phy_ops;
+			hdmi->phy.name = dw_hdmi_phys[i].name;
+			hdmi->phy.data = (void *)&dw_hdmi_phys[i];
+
+			if (!dw_hdmi_phys[i].configure &&
+			    !hdmi->plat_data->configure_phy) {
+				printf("%s requires platform support\n",
+				       hdmi->phy.name);
+				return -ENODEV;
+			}
+
+			return 0;
+		}
+	}
+
+	printf("Unsupported HDMI PHY type (%02x)\n", phy_type);
+	return -ENODEV;
+}
+
+static unsigned int
+hdmi_get_tmdsclock(struct dw_hdmi *hdmi, unsigned long mpixelclock)
+{
+	unsigned int tmdsclock = mpixelclock;
+	unsigned int depth =
+		hdmi_bus_fmt_color_depth(hdmi->hdmi_data.enc_out_bus_format);
+
+	if (!hdmi_bus_fmt_is_yuv422(hdmi->hdmi_data.enc_out_bus_format)) {
+		switch (depth) {
+		case 16:
+			tmdsclock = mpixelclock * 2;
+			break;
+		case 12:
+			tmdsclock = mpixelclock * 3 / 2;
+			break;
+		case 10:
+			tmdsclock = mpixelclock * 5 / 4;
+			break;
+		default:
+			break;
+		}
+	}
+
+	return tmdsclock;
+}
+
+static void hdmi_av_composer(struct dw_hdmi *hdmi,
+			     const struct drm_display_mode *mode)
+{
+	u8 bytes = 0, inv_val = 0;
+	struct hdmi_vmode *vmode = &hdmi->hdmi_data.video_mode;
+	struct drm_hdmi_info *hdmi_info = &hdmi->edid_data.display_info.hdmi;
+	int hblank, vblank, h_de_hs, v_de_vs, hsync_len, vsync_len;
+	unsigned int hdisplay, vdisplay;
+
+	vmode->mpixelclock = mode->crtc_clock * 1000;
+	if ((mode->flags & DRM_MODE_FLAG_3D_MASK) ==
+		DRM_MODE_FLAG_3D_FRAME_PACKING)
+		vmode->mpixelclock *= 2;
+	vmode->mtmdsclock = hdmi_get_tmdsclock(hdmi, vmode->mpixelclock);
+	if (hdmi_bus_fmt_is_yuv420(hdmi->hdmi_data.enc_out_bus_format))
+		vmode->mtmdsclock /= 2;
+	printf("final pixclk = %d tmdsclk = %d\n",
+	       vmode->mpixelclock, vmode->mtmdsclock);
+
+	/* Set up HDMI_FC_INVIDCONF
+	 * Some display equipments require that the interval
+	 * between Video Data and Data island must be at least 58 pixels,
+	 * and fc_invidconf.HDCP_keepout set (1'b1) can meet the requirement.
+	 */
+	inv_val = HDMI_FC_INVIDCONF_HDCP_KEEPOUT_ACTIVE;
+
+	inv_val |= mode->flags & DRM_MODE_FLAG_PVSYNC ?
+		HDMI_FC_INVIDCONF_VSYNC_IN_POLARITY_ACTIVE_HIGH :
+		HDMI_FC_INVIDCONF_VSYNC_IN_POLARITY_ACTIVE_LOW;
+
+	inv_val |= mode->flags & DRM_MODE_FLAG_PHSYNC ?
+		HDMI_FC_INVIDCONF_HSYNC_IN_POLARITY_ACTIVE_HIGH :
+		HDMI_FC_INVIDCONF_HSYNC_IN_POLARITY_ACTIVE_LOW;
+
+	inv_val |= (vmode->mdataenablepolarity ?
+		HDMI_FC_INVIDCONF_DE_IN_POLARITY_ACTIVE_HIGH :
+		HDMI_FC_INVIDCONF_DE_IN_POLARITY_ACTIVE_LOW);
+
+	if (hdmi->vic == 39)
+		inv_val |= HDMI_FC_INVIDCONF_R_V_BLANK_IN_OSC_ACTIVE_HIGH;
+	else
+		inv_val |= mode->flags & DRM_MODE_FLAG_INTERLACE ?
+			HDMI_FC_INVIDCONF_R_V_BLANK_IN_OSC_ACTIVE_HIGH :
+			HDMI_FC_INVIDCONF_R_V_BLANK_IN_OSC_ACTIVE_LOW;
+
+	inv_val |= mode->flags & DRM_MODE_FLAG_INTERLACE ?
+		HDMI_FC_INVIDCONF_IN_I_P_INTERLACED :
+		HDMI_FC_INVIDCONF_IN_I_P_PROGRESSIVE;
+
+	inv_val |= hdmi->sink_is_hdmi ?
+		HDMI_FC_INVIDCONF_DVI_MODEZ_HDMI_MODE :
+		HDMI_FC_INVIDCONF_DVI_MODEZ_DVI_MODE;
+
+	hdmi_writeb(hdmi, inv_val, HDMI_FC_INVIDCONF);
+
+	hdisplay = mode->hdisplay;
+	hblank = mode->htotal - mode->hdisplay;
+	h_de_hs = mode->hsync_start - mode->hdisplay;
+	hsync_len = mode->hsync_end - mode->hsync_start;
+
+	/*
+	 * When we're setting a YCbCr420 mode, we need
+	 * to adjust the horizontal timing to suit.
+	 */
+	if (hdmi_bus_fmt_is_yuv420(hdmi->hdmi_data.enc_out_bus_format)) {
+		hdisplay /= 2;
+		hblank /= 2;
+		h_de_hs /= 2;
+		hsync_len /= 2;
+	}
+
+	vdisplay = mode->vdisplay;
+	vblank = mode->vtotal - mode->vdisplay;
+	v_de_vs = mode->vsync_start - mode->vdisplay;
+	vsync_len = mode->vsync_end - mode->vsync_start;
+
+	/*
+	 * When we're setting an interlaced mode, we need
+	 * to adjust the vertical timing to suit.
+	 */
+	if (mode->flags & DRM_MODE_FLAG_INTERLACE) {
+		vdisplay /= 2;
+		vblank /= 2;
+		v_de_vs /= 2;
+		vsync_len /= 2;
+	} else if ((mode->flags & DRM_MODE_FLAG_3D_MASK) ==
+		DRM_MODE_FLAG_3D_FRAME_PACKING) {
+		vdisplay += mode->vtotal;
+	}
+
+	/* Scrambling Control */
+	if (hdmi_info->scdc.supported || hdmi->force_output) {
+		if (vmode->mtmdsclock > 340000000 ||
+		    (hdmi_info->scdc.scrambling.low_rates &&
+		     hdmi->scramble_low_rates)) {
+			drm_scdc_readb(&hdmi->adap, SCDC_SINK_VERSION, &bytes);
+			drm_scdc_writeb(&hdmi->adap, SCDC_SOURCE_VERSION,
+					bytes);
+			rockchip_dw_hdmi_scrambling_enable(hdmi, 1);
+		} else {
+			rockchip_dw_hdmi_scrambling_enable(hdmi, 0);
+		}
+	}
+
+	/* Set up horizontal active pixel width */
+	hdmi_writeb(hdmi, hdisplay >> 8, HDMI_FC_INHACTV1);
+	hdmi_writeb(hdmi, hdisplay, HDMI_FC_INHACTV0);
+
+	/* Set up vertical active lines */
+	hdmi_writeb(hdmi, vdisplay >> 8, HDMI_FC_INVACTV1);
+	hdmi_writeb(hdmi, vdisplay, HDMI_FC_INVACTV0);
+
+	/* Set up horizontal blanking pixel region width */
+	hdmi_writeb(hdmi, hblank >> 8, HDMI_FC_INHBLANK1);
+	hdmi_writeb(hdmi, hblank, HDMI_FC_INHBLANK0);
+
+	/* Set up vertical blanking pixel region width */
+	hdmi_writeb(hdmi, vblank, HDMI_FC_INVBLANK);
+
+	/* Set up HSYNC active edge delay width (in pixel clks) */
+	hdmi_writeb(hdmi, h_de_hs >> 8, HDMI_FC_HSYNCINDELAY1);
+	hdmi_writeb(hdmi, h_de_hs, HDMI_FC_HSYNCINDELAY0);
+
+	/* Set up VSYNC active edge delay (in lines) */
+	hdmi_writeb(hdmi, v_de_vs, HDMI_FC_VSYNCINDELAY);
+
+	/* Set up HSYNC active pulse width (in pixel clks) */
+	hdmi_writeb(hdmi, hsync_len >> 8, HDMI_FC_HSYNCINWIDTH1);
+	hdmi_writeb(hdmi, hsync_len, HDMI_FC_HSYNCINWIDTH0);
+
+	/* Set up VSYNC active edge delay (in lines) */
+	hdmi_writeb(hdmi, vsync_len, HDMI_FC_VSYNCINWIDTH);
+}
+
+static void dw_hdmi_update_csc_coeffs(struct dw_hdmi *hdmi)
+{
+	const u16 (*csc_coeff)[3][4] = &csc_coeff_default;
+	unsigned i;
+	u32 csc_scale = 1;
+	int enc_out_rgb, enc_in_rgb;
+
+	enc_out_rgb = hdmi_bus_fmt_is_rgb(hdmi->hdmi_data.enc_out_bus_format);
+	enc_in_rgb = hdmi_bus_fmt_is_rgb(hdmi->hdmi_data.enc_in_bus_format);
+
+	if (is_color_space_conversion(hdmi)) {
+		if (enc_out_rgb && enc_in_rgb) {
+			csc_coeff = &csc_coeff_full_to_limited;
+			csc_scale = 0;
+		} else if (enc_out_rgb) {
+			if (hdmi->hdmi_data.enc_out_encoding ==
+						V4L2_YCBCR_ENC_601)
+				csc_coeff = &csc_coeff_rgb_out_eitu601;
+			else
+				csc_coeff = &csc_coeff_rgb_out_eitu709;
+		} else if (enc_in_rgb) {
+			if (hdmi->hdmi_data.enc_out_encoding ==
+						V4L2_YCBCR_ENC_601)
+				csc_coeff = &csc_coeff_rgb_in_eitu601;
+			else
+				csc_coeff = &csc_coeff_rgb_in_eitu709;
+			csc_scale = 0;
+		}
+	}
+
+	/* The CSC registers are sequential, alternating MSB then LSB */
+	for (i = 0; i < ARRAY_SIZE(csc_coeff_default[0]); i++) {
+		u16 coeff_a = (*csc_coeff)[0][i];
+		u16 coeff_b = (*csc_coeff)[1][i];
+		u16 coeff_c = (*csc_coeff)[2][i];
+
+		hdmi_writeb(hdmi, coeff_a & 0xff, HDMI_CSC_COEF_A1_LSB + i * 2);
+		hdmi_writeb(hdmi, coeff_a >> 8, HDMI_CSC_COEF_A1_MSB + i * 2);
+		hdmi_writeb(hdmi, coeff_b & 0xff, HDMI_CSC_COEF_B1_LSB + i * 2);
+		hdmi_writeb(hdmi, coeff_b >> 8, HDMI_CSC_COEF_B1_MSB + i * 2);
+		hdmi_writeb(hdmi, coeff_c & 0xff, HDMI_CSC_COEF_C1_LSB + i * 2);
+		hdmi_writeb(hdmi, coeff_c >> 8, HDMI_CSC_COEF_C1_MSB + i * 2);
+	}
+
+	hdmi_modb(hdmi, csc_scale, HDMI_CSC_SCALE_CSCSCALE_MASK,
+		  HDMI_CSC_SCALE);
+}
+
+static int is_color_space_interpolation(struct dw_hdmi *hdmi)
+{
+	if (!hdmi_bus_fmt_is_yuv422(hdmi->hdmi_data.enc_in_bus_format))
+		return 0;
+
+	if (hdmi_bus_fmt_is_rgb(hdmi->hdmi_data.enc_out_bus_format) ||
+	    hdmi_bus_fmt_is_yuv444(hdmi->hdmi_data.enc_out_bus_format))
+		return 1;
+
+	return 0;
+}
+
+static void hdmi_video_csc(struct dw_hdmi *hdmi)
+{
+	int color_depth = 0;
+	int interpolation = HDMI_CSC_CFG_INTMODE_DISABLE;
+	int decimation = 0;
+
+	/* YCC422 interpolation to 444 mode */
+	if (is_color_space_interpolation(hdmi))
+		interpolation = HDMI_CSC_CFG_INTMODE_CHROMA_INT_FORMULA1;
+	else if (is_color_space_decimation(hdmi))
+		decimation = HDMI_CSC_CFG_DECMODE_CHROMA_INT_FORMULA3;
+
+	switch (hdmi_bus_fmt_color_depth(hdmi->hdmi_data.enc_out_bus_format)) {
+	case 8:
+		color_depth = HDMI_CSC_SCALE_CSC_COLORDE_PTH_24BPP;
+		break;
+	case 10:
+		color_depth = HDMI_CSC_SCALE_CSC_COLORDE_PTH_30BPP;
+		break;
+	case 12:
+		color_depth = HDMI_CSC_SCALE_CSC_COLORDE_PTH_36BPP;
+		break;
+	case 16:
+		color_depth = HDMI_CSC_SCALE_CSC_COLORDE_PTH_48BPP;
+		break;
+
+	default:
+		return;
+	}
+
+	/* Configure the CSC registers */
+	hdmi_writeb(hdmi, interpolation | decimation, HDMI_CSC_CFG);
+	hdmi_modb(hdmi, color_depth, HDMI_CSC_SCALE_CSC_COLORDE_PTH_MASK,
+		  HDMI_CSC_SCALE);
+
+	dw_hdmi_update_csc_coeffs(hdmi);
+}
+
+static void dw_hdmi_enable_video_path(struct dw_hdmi *hdmi)
+{
+	u8 clkdis;
+
+	/* control period minimum duration */
+	hdmi_writeb(hdmi, 12, HDMI_FC_CTRLDUR);
+	hdmi_writeb(hdmi, 32, HDMI_FC_EXCTRLDUR);
+	hdmi_writeb(hdmi, 1, HDMI_FC_EXCTRLSPAC);
+
+	/* Set to fill TMDS data channels */
+	hdmi_writeb(hdmi, 0x0B, HDMI_FC_CH0PREAM);
+	hdmi_writeb(hdmi, 0x16, HDMI_FC_CH1PREAM);
+	hdmi_writeb(hdmi, 0x21, HDMI_FC_CH2PREAM);
+
+	/* Enable pixel clock and tmds data path */
+	clkdis = 0x7F;
+	clkdis &= ~HDMI_MC_CLKDIS_PIXELCLK_DISABLE;
+	hdmi_writeb(hdmi, clkdis, HDMI_MC_CLKDIS);
+
+	clkdis &= ~HDMI_MC_CLKDIS_TMDSCLK_DISABLE;
+	hdmi_writeb(hdmi, clkdis, HDMI_MC_CLKDIS);
+
+	/* Enable csc path */
+	if (is_color_space_conversion(hdmi)) {
+		clkdis &= ~HDMI_MC_CLKDIS_CSCCLK_DISABLE;
+		hdmi_writeb(hdmi, clkdis, HDMI_MC_CLKDIS);
+	}
+
+	/* Enable pixel repetition path */
+	if (hdmi->hdmi_data.video_mode.mpixelrepetitioninput) {
+		clkdis &= ~HDMI_MC_CLKDIS_PREPCLK_DISABLE;
+		hdmi_writeb(hdmi, clkdis, HDMI_MC_CLKDIS);
+	}
+
+	/* Enable color space conversion if needed */
+	if (is_color_space_conversion(hdmi))
+		hdmi_writeb(hdmi, HDMI_MC_FLOWCTRL_FEED_THROUGH_OFF_CSC_IN_PATH,
+			    HDMI_MC_FLOWCTRL);
+	else
+		hdmi_writeb(hdmi, HDMI_MC_FLOWCTRL_FEED_THROUGH_OFF_CSC_BYPASS,
+			    HDMI_MC_FLOWCTRL);
+}
+
+static void dw_hdmi_clear_overflow(struct dw_hdmi *hdmi)
+{
+	unsigned int count;
+	unsigned int i;
+	u8 val;
+
+	/*
+	 * Under some circumstances the Frame Composer arithmetic unit can miss
+	 * an FC register write due to being busy processing the previous one.
+	 * The issue can be worked around by issuing a TMDS software reset and
+	 * then write one of the FC registers several times.
+	 *
+	 * The number of iterations matters and depends on the HDMI TX revision
+	 * (and possibly on the platform). So far only i.MX6Q (v1.30a) and
+	 * i.MX6DL (v1.31a) have been identified as needing the workaround, with
+	 * 4 and 1 iterations respectively.
+	 */
+
+	switch (hdmi->version) {
+	case 0x130a:
+		count = 4;
+		break;
+	case 0x131a:
+	case 0x200a:
+	case 0x201a:
+	case 0x211a:
+		count = 1;
+		break;
+	default:
+		return;
+	}
+
+	/* TMDS software reset */
+	hdmi_writeb(hdmi, (u8)~HDMI_MC_SWRSTZ_TMDSSWRST_REQ, HDMI_MC_SWRSTZ);
+
+	val = hdmi_readb(hdmi, HDMI_FC_INVIDCONF);
+	for (i = 0; i < count; i++)
+		hdmi_writeb(hdmi, val, HDMI_FC_INVIDCONF);
+}
+
+static void hdmi_disable_overflow_interrupts(struct dw_hdmi *hdmi)
+{
+	hdmi_writeb(hdmi, HDMI_IH_MUTE_FC_STAT2_OVERFLOW_MASK,
+		    HDMI_IH_MUTE_FC_STAT2);
+}
+
+static void hdmi_video_packetize(struct dw_hdmi *hdmi)
+{
+	unsigned int color_depth = 0;
+	unsigned int remap_size = HDMI_VP_REMAP_YCC422_16bit;
+	unsigned int output_select = HDMI_VP_CONF_OUTPUT_SELECTOR_PP;
+	struct hdmi_data_info *hdmi_data = &hdmi->hdmi_data;
+	u8 val, vp_conf;
+
+	if (hdmi_bus_fmt_is_rgb(hdmi->hdmi_data.enc_out_bus_format) ||
+	    hdmi_bus_fmt_is_yuv444(hdmi->hdmi_data.enc_out_bus_format) ||
+	    hdmi_bus_fmt_is_yuv420(hdmi->hdmi_data.enc_out_bus_format)) {
+		switch (hdmi_bus_fmt_color_depth(
+					hdmi->hdmi_data.enc_out_bus_format)) {
+		case 8:
+			color_depth = 0;
+			output_select = HDMI_VP_CONF_OUTPUT_SELECTOR_BYPASS;
+			break;
+		case 10:
+			color_depth = 5;
+			break;
+		case 12:
+			color_depth = 6;
+			break;
+		case 16:
+			color_depth = 7;
+			break;
+		default:
+			output_select = HDMI_VP_CONF_OUTPUT_SELECTOR_BYPASS;
+		}
+	} else if (hdmi_bus_fmt_is_yuv422(hdmi->hdmi_data.enc_out_bus_format)) {
+		switch (hdmi_bus_fmt_color_depth(
+					hdmi->hdmi_data.enc_out_bus_format)) {
+		case 0:
+		case 8:
+			remap_size = HDMI_VP_REMAP_YCC422_16bit;
+			break;
+		case 10:
+			remap_size = HDMI_VP_REMAP_YCC422_20bit;
+			break;
+		case 12:
+			remap_size = HDMI_VP_REMAP_YCC422_24bit;
+			break;
+
+		default:
+			return;
+		}
+		output_select = HDMI_VP_CONF_OUTPUT_SELECTOR_YCC422;
+	} else {
+		return;
+	}
+
+	/* set the packetizer registers */
+	val = (color_depth << HDMI_VP_PR_CD_COLOR_DEPTH_OFFSET) &
+	      HDMI_VP_PR_CD_COLOR_DEPTH_MASK;
+	hdmi_writeb(hdmi, val, HDMI_VP_PR_CD);
+
+	hdmi_modb(hdmi, HDMI_VP_STUFF_PR_STUFFING_STUFFING_MODE,
+		  HDMI_VP_STUFF_PR_STUFFING_MASK, HDMI_VP_STUFF);
+
+	/* Data from pixel repeater block */
+	if (hdmi_data->pix_repet_factor > 0) {
+		vp_conf = HDMI_VP_CONF_PR_EN_ENABLE |
+			  HDMI_VP_CONF_BYPASS_SELECT_PIX_REPEATER;
+	} else { /* data from packetizer block */
+		vp_conf = HDMI_VP_CONF_PR_EN_DISABLE |
+			  HDMI_VP_CONF_BYPASS_SELECT_VID_PACKETIZER;
+	}
+
+	hdmi_modb(hdmi, vp_conf,
+		  HDMI_VP_CONF_PR_EN_MASK |
+		  HDMI_VP_CONF_BYPASS_SELECT_MASK, HDMI_VP_CONF);
+
+	hdmi_modb(hdmi, 0, HDMI_VP_STUFF_IDEFAULT_PHASE_MASK,
+		  HDMI_VP_STUFF);
+
+	hdmi_writeb(hdmi, remap_size, HDMI_VP_REMAP);
+
+	if (output_select == HDMI_VP_CONF_OUTPUT_SELECTOR_PP) {
+		vp_conf = HDMI_VP_CONF_BYPASS_EN_DISABLE |
+			  HDMI_VP_CONF_PP_EN_ENABLE |
+			  HDMI_VP_CONF_YCC422_EN_DISABLE;
+	} else if (output_select == HDMI_VP_CONF_OUTPUT_SELECTOR_YCC422) {
+		vp_conf = HDMI_VP_CONF_BYPASS_EN_DISABLE |
+			  HDMI_VP_CONF_PP_EN_DISABLE |
+			  HDMI_VP_CONF_YCC422_EN_ENABLE;
+	} else if (output_select == HDMI_VP_CONF_OUTPUT_SELECTOR_BYPASS) {
+		vp_conf = HDMI_VP_CONF_BYPASS_EN_ENABLE |
+			  HDMI_VP_CONF_PP_EN_DISABLE |
+			  HDMI_VP_CONF_YCC422_EN_DISABLE;
+	} else {
+		return;
+	}
+
+	hdmi_modb(hdmi, vp_conf,
+		  HDMI_VP_CONF_BYPASS_EN_MASK | HDMI_VP_CONF_PP_EN_ENMASK |
+		  HDMI_VP_CONF_YCC422_EN_MASK, HDMI_VP_CONF);
+
+	hdmi_modb(hdmi, HDMI_VP_STUFF_PP_STUFFING_STUFFING_MODE |
+			HDMI_VP_STUFF_YCC422_STUFFING_STUFFING_MODE,
+		  HDMI_VP_STUFF_PP_STUFFING_MASK |
+		  HDMI_VP_STUFF_YCC422_STUFFING_MASK, HDMI_VP_STUFF);
+
+	hdmi_modb(hdmi, output_select, HDMI_VP_CONF_OUTPUT_SELECTOR_MASK,
+		  HDMI_VP_CONF);
+}
+
+static void hdmi_video_sample(struct dw_hdmi *hdmi)
+{
+	int color_format = 0;
+	u8 val;
+
+	switch (hdmi->hdmi_data.enc_in_bus_format) {
+	case MEDIA_BUS_FMT_RGB888_1X24:
+		color_format = 0x01;
+		break;
+	case MEDIA_BUS_FMT_RGB101010_1X30:
+		color_format = 0x03;
+		break;
+	case MEDIA_BUS_FMT_RGB121212_1X36:
+		color_format = 0x05;
+		break;
+	case MEDIA_BUS_FMT_RGB161616_1X48:
+		color_format = 0x07;
+		break;
+
+	case MEDIA_BUS_FMT_YUV8_1X24:
+	case MEDIA_BUS_FMT_UYYVYY8_0_5X24:
+		color_format = 0x09;
+		break;
+	case MEDIA_BUS_FMT_YUV10_1X30:
+	case MEDIA_BUS_FMT_UYYVYY10_0_5X30:
+		color_format = 0x0B;
+		break;
+	case MEDIA_BUS_FMT_YUV12_1X36:
+	case MEDIA_BUS_FMT_UYYVYY12_0_5X36:
+		color_format = 0x0D;
+		break;
+	case MEDIA_BUS_FMT_YUV16_1X48:
+	case MEDIA_BUS_FMT_UYYVYY16_0_5X48:
+		color_format = 0x0F;
+		break;
+
+	case MEDIA_BUS_FMT_UYVY8_1X16:
+		color_format = 0x16;
+		break;
+	case MEDIA_BUS_FMT_UYVY10_1X20:
+		color_format = 0x14;
+		break;
+	case MEDIA_BUS_FMT_UYVY12_1X24:
+		color_format = 0x12;
+		break;
+
+	default:
+		return;
+	}
+
+	val = HDMI_TX_INVID0_INTERNAL_DE_GENERATOR_DISABLE |
+		((color_format << HDMI_TX_INVID0_VIDEO_MAPPING_OFFSET) &
+		HDMI_TX_INVID0_VIDEO_MAPPING_MASK);
+	hdmi_writeb(hdmi, val, HDMI_TX_INVID0);
+
+	/* Enable TX stuffing: When DE is inactive, fix the output data to 0 */
+	val = HDMI_TX_INSTUFFING_BDBDATA_STUFFING_ENABLE |
+		HDMI_TX_INSTUFFING_RCRDATA_STUFFING_ENABLE |
+		HDMI_TX_INSTUFFING_GYDATA_STUFFING_ENABLE;
+	hdmi_writeb(hdmi, val, HDMI_TX_INSTUFFING);
+	hdmi_writeb(hdmi, 0x0, HDMI_TX_GYDATA0);
+	hdmi_writeb(hdmi, 0x0, HDMI_TX_GYDATA1);
+	hdmi_writeb(hdmi, 0x0, HDMI_TX_RCRDATA0);
+	hdmi_writeb(hdmi, 0x0, HDMI_TX_RCRDATA1);
+	hdmi_writeb(hdmi, 0x0, HDMI_TX_BCBDATA0);
+	hdmi_writeb(hdmi, 0x0, HDMI_TX_BCBDATA1);
+}
+
+static void dw_hdmi_disable(struct rockchip_connector *conn, struct dw_hdmi *hdmi,
+			    struct display_state *state)
+{
+	if (hdmi->phy.enabled) {
+		hdmi->phy.ops->disable(conn, hdmi, state);
+		hdmi->phy.enabled = false;
+	}
+}
+
+static void hdmi_config_AVI(struct dw_hdmi *hdmi, struct drm_display_mode *mode)
+{
+	struct hdmi_avi_infoframe frame;
+	u8 val;
+	bool is_hdmi2 = false;
+	enum hdmi_quantization_range rgb_quant_range =
+		hdmi->hdmi_data.quant_range;
+
+	if (hdmi_bus_fmt_is_yuv420(hdmi->hdmi_data.enc_out_bus_format) ||
+	    hdmi->edid_data.display_info.hdmi.scdc.supported)
+		is_hdmi2 = true;
+	/* Initialise info frame from DRM mode */
+	drm_hdmi_avi_infoframe_from_display_mode(&frame, mode, is_hdmi2);
+
+	/*
+	 * Ignore monitor selectable quantization, use quantization set
+	 * by the user
+	 */
+	drm_hdmi_avi_infoframe_quant_range(&frame, mode, rgb_quant_range,
+					   true);
+	if (hdmi_bus_fmt_is_yuv444(hdmi->hdmi_data.enc_out_bus_format))
+		frame.colorspace = HDMI_COLORSPACE_YUV444;
+	else if (hdmi_bus_fmt_is_yuv422(hdmi->hdmi_data.enc_out_bus_format))
+		frame.colorspace = HDMI_COLORSPACE_YUV422;
+	else if (hdmi_bus_fmt_is_yuv420(hdmi->hdmi_data.enc_out_bus_format))
+		frame.colorspace = HDMI_COLORSPACE_YUV420;
+	else
+		frame.colorspace = HDMI_COLORSPACE_RGB;
+
+	/* Set up colorimetry */
+	switch (hdmi->hdmi_data.enc_out_encoding) {
+	case V4L2_YCBCR_ENC_601:
+		if (hdmi->hdmi_data.enc_in_encoding == V4L2_YCBCR_ENC_XV601)
+			frame.colorimetry = HDMI_COLORIMETRY_EXTENDED;
+		else
+			frame.colorimetry = HDMI_COLORIMETRY_ITU_601;
+		frame.extended_colorimetry =
+				HDMI_EXTENDED_COLORIMETRY_XV_YCC_601;
+		break;
+	case V4L2_YCBCR_ENC_709:
+		if (hdmi->hdmi_data.enc_in_encoding == V4L2_YCBCR_ENC_XV709)
+			frame.colorimetry = HDMI_COLORIMETRY_EXTENDED;
+		else
+			frame.colorimetry = HDMI_COLORIMETRY_ITU_709;
+		frame.extended_colorimetry =
+				HDMI_EXTENDED_COLORIMETRY_XV_YCC_709;
+		break;
+	default: /* Carries no data */
+		frame.colorimetry = HDMI_COLORIMETRY_ITU_601;
+		frame.extended_colorimetry =
+				HDMI_EXTENDED_COLORIMETRY_XV_YCC_601;
+		break;
+	}
+
+	frame.scan_mode = HDMI_SCAN_MODE_NONE;
+
+	/*
+	 * The Designware IP uses a different byte format from standard
+	 * AVI info frames, though generally the bits are in the correct
+	 * bytes.
+	 */
+
+	/*
+	 * AVI data byte 1 differences: Colorspace in bits 0,1,7 rather than
+	 * 5,6,7, active aspect present in bit 6 rather than 4.
+	 */
+	val = (frame.scan_mode & 3) << 4 | (frame.colorspace & 0x3);
+	if (frame.active_aspect & 15)
+		val |= HDMI_FC_AVICONF0_ACTIVE_FMT_INFO_PRESENT;
+	if (frame.top_bar || frame.bottom_bar)
+		val |= HDMI_FC_AVICONF0_BAR_DATA_HORIZ_BAR;
+	if (frame.left_bar || frame.right_bar)
+		val |= HDMI_FC_AVICONF0_BAR_DATA_VERT_BAR;
+	hdmi_writeb(hdmi, val, HDMI_FC_AVICONF0);
+
+	/* AVI data byte 2 differences: none */
+	val = ((frame.colorimetry & 0x3) << 6) |
+	      ((frame.picture_aspect & 0x3) << 4) |
+	      (frame.active_aspect & 0xf);
+	hdmi_writeb(hdmi, val, HDMI_FC_AVICONF1);
+
+	/* AVI data byte 3 differences: none */
+	val = ((frame.extended_colorimetry & 0x7) << 4) |
+	      ((frame.quantization_range & 0x3) << 2) |
+	      (frame.nups & 0x3);
+	if (frame.itc)
+		val |= HDMI_FC_AVICONF2_IT_CONTENT_VALID;
+	hdmi_writeb(hdmi, val, HDMI_FC_AVICONF2);
+
+	/* AVI data byte 4 differences: none */
+	val = frame.video_code & 0x7f;
+	hdmi_writeb(hdmi, val, HDMI_FC_AVIVID);
+
+	/* AVI Data Byte 5- set up input and output pixel repetition */
+	val = (((hdmi->hdmi_data.video_mode.mpixelrepetitioninput + 1) <<
+		HDMI_FC_PRCONF_INCOMING_PR_FACTOR_OFFSET) &
+		HDMI_FC_PRCONF_INCOMING_PR_FACTOR_MASK) |
+		((hdmi->hdmi_data.video_mode.mpixelrepetitionoutput <<
+		HDMI_FC_PRCONF_OUTPUT_PR_FACTOR_OFFSET) &
+		HDMI_FC_PRCONF_OUTPUT_PR_FACTOR_MASK);
+	hdmi_writeb(hdmi, val, HDMI_FC_PRCONF);
+
+	/*
+	 * AVI data byte 5 differences: content type in 0,1 rather than 4,5,
+	 * ycc range in bits 2,3 rather than 6,7
+	 */
+	val = ((frame.ycc_quantization_range & 0x3) << 2) |
+	      (frame.content_type & 0x3);
+	hdmi_writeb(hdmi, val, HDMI_FC_AVICONF3);
+
+	/* AVI Data Bytes 6-13 */
+	hdmi_writeb(hdmi, frame.top_bar & 0xff, HDMI_FC_AVIETB0);
+	hdmi_writeb(hdmi, (frame.top_bar >> 8) & 0xff, HDMI_FC_AVIETB1);
+	hdmi_writeb(hdmi, frame.bottom_bar & 0xff, HDMI_FC_AVISBB0);
+	hdmi_writeb(hdmi, (frame.bottom_bar >> 8) & 0xff, HDMI_FC_AVISBB1);
+	hdmi_writeb(hdmi, frame.left_bar & 0xff, HDMI_FC_AVIELB0);
+	hdmi_writeb(hdmi, (frame.left_bar >> 8) & 0xff, HDMI_FC_AVIELB1);
+	hdmi_writeb(hdmi, frame.right_bar & 0xff, HDMI_FC_AVISRB0);
+	hdmi_writeb(hdmi, (frame.right_bar >> 8) & 0xff, HDMI_FC_AVISRB1);
+}
+
+static void hdmi_config_vendor_specific_infoframe(struct dw_hdmi *hdmi,
+						  struct drm_display_mode *mode)
+{
+	struct hdmi_vendor_infoframe frame;
+	u8 buffer[10];
+	ssize_t err;
+
+	/* Disable HDMI vendor specific infoframe send */
+	hdmi_mask_writeb(hdmi, 0, HDMI_FC_DATAUTO0, HDMI_FC_DATAUTO0_VSD_OFFSET,
+			 HDMI_FC_DATAUTO0_VSD_MASK);
+
+	err = drm_hdmi_vendor_infoframe_from_display_mode(&frame, mode);
+	if (err < 0)
+		/*
+		 * Going into that statement does not means vendor infoframe
+		 * fails. It just informed us that vendor infoframe is not
+		 * needed for the selected mode. Only 4k or stereoscopic 3D
+		 * mode requires vendor infoframe. So just simply return.
+		 */
+		return;
+
+	err = hdmi_vendor_infoframe_pack(&frame, buffer, sizeof(buffer));
+	if (err < 0) {
+		printf("Failed to pack vendor infoframe: %zd\n", err);
+		return;
+	}
+
+	/* Set the length of HDMI vendor specific InfoFrame payload */
+	hdmi_writeb(hdmi, buffer[2], HDMI_FC_VSDSIZE);
+
+	/* Set 24bit IEEE Registration Identifier */
+	hdmi_writeb(hdmi, buffer[4], HDMI_FC_VSDIEEEID0);
+	hdmi_writeb(hdmi, buffer[5], HDMI_FC_VSDIEEEID1);
+	hdmi_writeb(hdmi, buffer[6], HDMI_FC_VSDIEEEID2);
+
+	/* Set HDMI_Video_Format and HDMI_VIC/3D_Structure */
+	hdmi_writeb(hdmi, buffer[7], HDMI_FC_VSDPAYLOAD0);
+	hdmi_writeb(hdmi, buffer[8], HDMI_FC_VSDPAYLOAD1);
+
+	if (frame.s3d_struct >= HDMI_3D_STRUCTURE_SIDE_BY_SIDE_HALF)
+		hdmi_writeb(hdmi, buffer[9], HDMI_FC_VSDPAYLOAD2);
+
+	/* Packet frame interpolation */
+	hdmi_writeb(hdmi, 1, HDMI_FC_DATAUTO1);
+
+	/* Auto packets per frame and line spacing */
+	hdmi_writeb(hdmi, 0x11, HDMI_FC_DATAUTO2);
+
+	/* Configures the Frame Composer On RDRB mode */
+	hdmi_mask_writeb(hdmi, 1, HDMI_FC_DATAUTO0, HDMI_FC_DATAUTO0_VSD_OFFSET,
+			 HDMI_FC_DATAUTO0_VSD_MASK);
+}
+
+static void hdmi_set_cts_n(struct dw_hdmi *hdmi, unsigned int cts,
+			   unsigned int n)
+{
+	/* Must be set/cleared first */
+	hdmi_modb(hdmi, 0, HDMI_AUD_CTS3_CTS_MANUAL, HDMI_AUD_CTS3);
+
+	/* nshift factor = 0 */
+	hdmi_modb(hdmi, 0, HDMI_AUD_CTS3_N_SHIFT_MASK, HDMI_AUD_CTS3);
+
+	hdmi_writeb(hdmi, ((cts >> 16) & HDMI_AUD_CTS3_AUDCTS19_16_MASK) |
+		    HDMI_AUD_CTS3_CTS_MANUAL, HDMI_AUD_CTS3);
+	hdmi_writeb(hdmi, (cts >> 8) & 0xff, HDMI_AUD_CTS2);
+	hdmi_writeb(hdmi, cts & 0xff, HDMI_AUD_CTS1);
+
+	hdmi_writeb(hdmi, (n >> 16) & 0x0f, HDMI_AUD_N3);
+	hdmi_writeb(hdmi, (n >> 8) & 0xff, HDMI_AUD_N2);
+	hdmi_writeb(hdmi, n & 0xff, HDMI_AUD_N1);
+}
+
+static int hdmi_match_tmds_n_table(struct dw_hdmi *hdmi,
+				   unsigned long pixel_clk,
+				   unsigned long freq)
+{
+	const struct dw_hdmi_plat_data *plat_data = hdmi->plat_data;
+	const struct dw_hdmi_audio_tmds_n *tmds_n = NULL;
+	int i;
+
+	if (plat_data->tmds_n_table) {
+		for (i = 0; plat_data->tmds_n_table[i].tmds != 0; i++) {
+			if (pixel_clk == plat_data->tmds_n_table[i].tmds) {
+				tmds_n = &plat_data->tmds_n_table[i];
+				break;
+			}
+		}
+	}
+
+	if (!tmds_n) {
+		for (i = 0; common_tmds_n_table[i].tmds != 0; i++) {
+			if (pixel_clk == common_tmds_n_table[i].tmds) {
+				tmds_n = &common_tmds_n_table[i];
+				break;
+			}
+		}
+	}
+
+	if (!tmds_n)
+		return -ENOENT;
+
+	switch (freq) {
+	case 32000:
+		return tmds_n->n_32k;
+	case 44100:
+	case 88200:
+	case 176400:
+		return (freq / 44100) * tmds_n->n_44k1;
+	case 48000:
+	case 96000:
+	case 192000:
+		return (freq / 48000) * tmds_n->n_48k;
+	default:
+		return -ENOENT;
+	}
+}
+
+static u64 hdmi_audio_math_diff(unsigned int freq, unsigned int n,
+				unsigned int pixel_clk)
+{
+	u64 final, diff;
+	u64 cts;
+
+	final = (u64)pixel_clk * n;
+
+	cts = final;
+	do_div(cts, 128 * freq);
+
+	diff = final - (u64)cts * (128 * freq);
+
+	return diff;
+}
+
+static unsigned int hdmi_compute_n(struct dw_hdmi *hdmi,
+				   unsigned long pixel_clk,
+				   unsigned long freq)
+{
+	unsigned int min_n = DIV_ROUND_UP((128 * freq), 1500);
+	unsigned int max_n = (128 * freq) / 300;
+	unsigned int ideal_n = (128 * freq) / 1000;
+	unsigned int best_n_distance = ideal_n;
+	unsigned int best_n = 0;
+	u64 best_diff = U64_MAX;
+	int n;
+
+	/* If the ideal N could satisfy the audio math, then just take it */
+	if (hdmi_audio_math_diff(freq, ideal_n, pixel_clk) == 0)
+		return ideal_n;
+
+	for (n = min_n; n <= max_n; n++) {
+		u64 diff = hdmi_audio_math_diff(freq, n, pixel_clk);
+
+		if (diff < best_diff || (diff == best_diff &&
+					 abs(n - ideal_n) < best_n_distance)) {
+			best_n = n;
+			best_diff = diff;
+			best_n_distance = abs(best_n - ideal_n);
+		}
+
+		/*
+		 * The best N already satisfy the audio math, and also be
+		 * the closest value to ideal N, so just cut the loop.
+		 */
+		if ((best_diff == 0) && (abs(n - ideal_n) > best_n_distance))
+			break;
+	}
+
+	return best_n;
+}
+
+static unsigned int hdmi_find_n(struct dw_hdmi *hdmi, unsigned long pixel_clk,
+				unsigned long sample_rate)
+{
+	int n;
+
+	n = hdmi_match_tmds_n_table(hdmi, pixel_clk, sample_rate);
+	if (n > 0)
+		return n;
+
+	printf("Rate %lu missing; compute N dynamically\n",
+	       pixel_clk);
+
+	return hdmi_compute_n(hdmi, pixel_clk, sample_rate);
+}
+
+static
+void hdmi_set_clk_regenerator(struct dw_hdmi *hdmi, unsigned long pixel_clk,
+			      unsigned int sample_rate)
+{
+	unsigned long ftdms = pixel_clk;
+	unsigned int n, cts;
+	u64 tmp;
+
+	n = hdmi_find_n(hdmi, pixel_clk, sample_rate);
+
+	/*
+	 * Compute the CTS value from the N value.  Note that CTS and N
+	 * can be up to 20 bits in total, so we need 64-bit math.  Also
+	 * note that our TDMS clock is not fully accurate; it is accurate
+	 * to kHz.  This can introduce an unnecessary remainder in the
+	 * calculation below, so we don't try to warn about that.
+	 */
+	tmp = (u64)ftdms * n;
+	do_div(tmp, 128 * sample_rate);
+	cts = tmp;
+
+	printf("%s: fs=%uHz ftdms=%lu.%03luMHz N=%d cts=%d\n", __func__,
+	       sample_rate, ftdms / 1000000, (ftdms / 1000) % 1000, n, cts);
+
+	hdmi->audio_n = n;
+	hdmi->audio_cts = cts;
+	hdmi_set_cts_n(hdmi, cts, hdmi->audio_enable ? n : 0);
+}
+
+static void hdmi_clk_regenerator_update_pixel_clock(struct dw_hdmi *hdmi)
+{
+	hdmi_set_clk_regenerator(hdmi, hdmi->hdmi_data.video_mode.mtmdsclock,
+				 hdmi->sample_rate);
+}
+
+static void hdmi_enable_audio_clk(struct dw_hdmi *hdmi)
+{
+	hdmi_modb(hdmi, 0, HDMI_MC_CLKDIS_AUDCLK_DISABLE, HDMI_MC_CLKDIS);
+}
+
+void dw_hdmi_set_sample_rate(struct dw_hdmi *hdmi, unsigned int rate)
+{
+	hdmi->sample_rate = rate;
+	hdmi_set_clk_regenerator(hdmi, hdmi->hdmi_data.video_mode.mtmdsclock,
+				 hdmi->sample_rate);
+}
+
+#ifndef CONFIG_SPL_BUILD
+static int dw_hdmi_hdcp_load_key(struct dw_hdmi *hdmi)
+{
+	int i, j, ret, val;
+	struct hdcp_keys *hdcp_keys;
+
+	val = sizeof(*hdcp_keys);
+	hdcp_keys = malloc(val);
+	if (!hdcp_keys)
+		return -ENOMEM;
+
+	memset(hdcp_keys, 0, val);
+
+	ret = vendor_storage_read(HDMI_HDCP1X_ID, hdcp_keys, val);
+	if (ret < val) {
+		printf("HDCP: read size %d\n", ret);
+		free(hdcp_keys);
+		return -EINVAL;
+	}
+
+	if (hdcp_keys->KSV[0] == 0x00 &&
+	    hdcp_keys->KSV[1] == 0x00 &&
+	    hdcp_keys->KSV[2] == 0x00 &&
+	    hdcp_keys->KSV[3] == 0x00 &&
+	    hdcp_keys->KSV[4] == 0x00) {
+		printf("HDCP: Invalid hdcp key\n");
+		free(hdcp_keys);
+		return -EINVAL;
+	}
+
+	/* Disable decryption logic */
+	hdmi_writeb(hdmi, 0, HDMI_HDCPREG_RMCTL);
+	/* Poll untile DPK write is allowed */
+	do {
+		val = hdmi_readb(hdmi, HDMI_HDCPREG_RMSTS);
+	} while ((val & DPK_WR_OK_STS) == 0);
+
+	hdmi_writeb(hdmi, 0, HDMI_HDCPREG_DPK6);
+	hdmi_writeb(hdmi, 0, HDMI_HDCPREG_DPK5);
+
+	/* The useful data in ksv should be 5 byte */
+	for (i = 4; i >= 0; i--)
+		hdmi_writeb(hdmi, hdcp_keys->KSV[i], HDMI_HDCPREG_DPK0 + i);
+	/* Poll untile DPK write is allowed */
+	do {
+		val = hdmi_readb(hdmi, HDMI_HDCPREG_RMSTS);
+	} while ((val & DPK_WR_OK_STS) == 0);
+
+	/* Enable decryption logic */
+	hdmi_writeb(hdmi, 1, HDMI_HDCPREG_RMCTL);
+	hdmi_writeb(hdmi, hdcp_keys->seeds[0], HDMI_HDCPREG_SEED1);
+	hdmi_writeb(hdmi, hdcp_keys->seeds[1], HDMI_HDCPREG_SEED0);
+
+	/* Write encrypt device private key */
+	for (i = 0; i < DW_HDMI_HDCP_DPK_LEN - 6; i += 7) {
+		for (j = 6; j >= 0; j--)
+			hdmi_writeb(hdmi, hdcp_keys->devicekey[i + j],
+				    HDMI_HDCPREG_DPK0 + j);
+		do {
+			val = hdmi_readb(hdmi, HDMI_HDCPREG_RMSTS);
+		} while ((val & DPK_WR_OK_STS) == 0);
+	}
+
+	free(hdcp_keys);
+	return 0;
+}
+#endif
+
+static void hdmi_tx_hdcp_config(struct dw_hdmi *hdmi,
+				const struct drm_display_mode *mode)
+{
+	u8 vsync_pol, hsync_pol, data_pol, hdmi_dvi;
+
+	if (!hdmi->hdcp1x_enable)
+		return;
+
+	/* Configure the video polarity */
+	vsync_pol = mode->flags & DRM_MODE_FLAG_PVSYNC ?
+		    HDMI_A_VIDPOLCFG_VSYNCPOL_ACTIVE_HIGH :
+		    HDMI_A_VIDPOLCFG_VSYNCPOL_ACTIVE_LOW;
+	hsync_pol = mode->flags & DRM_MODE_FLAG_PHSYNC ?
+		    HDMI_A_VIDPOLCFG_HSYNCPOL_ACTIVE_HIGH :
+		    HDMI_A_VIDPOLCFG_HSYNCPOL_ACTIVE_LOW;
+	data_pol = HDMI_A_VIDPOLCFG_DATAENPOL_ACTIVE_HIGH;
+	hdmi_modb(hdmi, vsync_pol | hsync_pol | data_pol,
+		  HDMI_A_VIDPOLCFG_VSYNCPOL_MASK |
+		  HDMI_A_VIDPOLCFG_HSYNCPOL_MASK |
+		  HDMI_A_VIDPOLCFG_DATAENPOL_MASK,
+		  HDMI_A_VIDPOLCFG);
+
+	/* Config the display mode */
+	hdmi_dvi = hdmi->sink_is_hdmi ? HDMI_A_HDCPCFG0_HDMIDVI_HDMI :
+		   HDMI_A_HDCPCFG0_HDMIDVI_DVI;
+	hdmi_modb(hdmi, hdmi_dvi, HDMI_A_HDCPCFG0_HDMIDVI_MASK,
+		  HDMI_A_HDCPCFG0);
+
+#ifndef CONFIG_SPL_BUILD
+	if (!(hdmi_readb(hdmi, HDMI_HDCPREG_RMSTS) & 0x3f)){
+		printf("VENDOR: read vendor blk not implemented\n");
+		return -ENOMEM;
+	}
+#endif
+
+	hdmi_modb(hdmi, HDMI_FC_INVIDCONF_HDCP_KEEPOUT_ACTIVE,
+		  HDMI_FC_INVIDCONF_HDCP_KEEPOUT_MASK,
+		  HDMI_FC_INVIDCONF);
+
+	if (hdmi_readb(hdmi, HDMI_CONFIG1_ID) & HDMI_A_HDCP22_MASK) {
+		hdmi_modb(hdmi, HDMI_HDCP2_OVR_ENABLE |
+			  HDMI_HDCP2_FORCE_DISABLE,
+			  HDMI_HDCP2_OVR_EN_MASK |
+			  HDMI_HDCP2_FORCE_MASK,
+			  HDMI_HDCP2REG_CTRL);
+		hdmi_writeb(hdmi, 0xff, HDMI_HDCP2REG_MASK);
+		hdmi_writeb(hdmi, 0xff, HDMI_HDCP2REG_MUTE);
+	}
+
+	hdmi_writeb(hdmi, 0x40, HDMI_A_OESSWCFG);
+		    hdmi_modb(hdmi, HDMI_A_HDCPCFG0_BYPENCRYPTION_DISABLE |
+		    HDMI_A_HDCPCFG0_EN11FEATURE_DISABLE |
+		    HDMI_A_HDCPCFG0_SYNCRICHECK_ENABLE,
+		    HDMI_A_HDCPCFG0_BYPENCRYPTION_MASK |
+		    HDMI_A_HDCPCFG0_EN11FEATURE_MASK |
+		    HDMI_A_HDCPCFG0_SYNCRICHECK_MASK, HDMI_A_HDCPCFG0);
+
+	hdmi_modb(hdmi, HDMI_A_HDCPCFG1_ENCRYPTIONDISABLE_ENABLE |
+		  HDMI_A_HDCPCFG1_PH2UPSHFTENC_ENABLE,
+		  HDMI_A_HDCPCFG1_ENCRYPTIONDISABLE_MASK |
+		  HDMI_A_HDCPCFG1_PH2UPSHFTENC_MASK, HDMI_A_HDCPCFG1);
+
+	/* Reset HDCP Engine */
+	if (hdmi_readb(hdmi, HDMI_MC_CLKDIS) & HDMI_MC_CLKDIS_HDCPCLK_MASK) {
+		hdmi_modb(hdmi, HDMI_A_HDCPCFG1_SWRESET_ASSERT,
+			  HDMI_A_HDCPCFG1_SWRESET_MASK, HDMI_A_HDCPCFG1);
+	}
+
+	hdmi_writeb(hdmi, 0x00, HDMI_A_APIINTMSK);
+	hdmi_modb(hdmi, HDMI_A_HDCPCFG0_RXDETECT_ENABLE,
+		  HDMI_A_HDCPCFG0_RXDETECT_MASK, HDMI_A_HDCPCFG0);
+
+	hdmi_modb(hdmi, HDMI_MC_CLKDIS_HDCPCLK_ENABLE,
+		  HDMI_MC_CLKDIS_HDCPCLK_MASK, HDMI_MC_CLKDIS);
+
+	printf("%s success\n", __func__);
+}
+
+static int dw_hdmi_setup(struct dw_hdmi *hdmi,
+			 struct rockchip_connector *conn,
+			 struct drm_display_mode *mode,
+			 struct display_state *state)
+{
+	int ret;
+	void *data = hdmi->plat_data->phy_data;
+
+	hdmi_disable_overflow_interrupts(hdmi);
+	if (!hdmi->vic)
+		printf("Non-CEA mode used in HDMI\n");
+	else
+		printf("CEA mode used vic=%d\n", hdmi->vic);
+
+	if (hdmi->plat_data->get_enc_out_encoding)
+		hdmi->hdmi_data.enc_out_encoding =
+			hdmi->plat_data->get_enc_out_encoding(data);
+	else if (hdmi->vic == 6 || hdmi->vic == 7 ||
+		 hdmi->vic == 21 || hdmi->vic == 22 ||
+		 hdmi->vic == 2 || hdmi->vic == 3 ||
+		 hdmi->vic == 17 || hdmi->vic == 18)
+		hdmi->hdmi_data.enc_out_encoding = V4L2_YCBCR_ENC_601;
+	else
+		hdmi->hdmi_data.enc_out_encoding = V4L2_YCBCR_ENC_709;
+
+	if (mode->flags & DRM_MODE_FLAG_DBLCLK) {
+		hdmi->hdmi_data.video_mode.mpixelrepetitionoutput = 1;
+		hdmi->hdmi_data.video_mode.mpixelrepetitioninput = 1;
+	} else {
+		hdmi->hdmi_data.video_mode.mpixelrepetitionoutput = 0;
+		hdmi->hdmi_data.video_mode.mpixelrepetitioninput = 0;
+	}
+
+	/* TOFIX: Get input encoding from plat data or fallback to none */
+	if (hdmi->plat_data->get_enc_in_encoding)
+		hdmi->hdmi_data.enc_in_encoding =
+			hdmi->plat_data->get_enc_in_encoding(data);
+	else if (hdmi->plat_data->input_bus_encoding)
+		hdmi->hdmi_data.enc_in_encoding =
+			hdmi->plat_data->input_bus_encoding;
+	else
+		hdmi->hdmi_data.enc_in_encoding = V4L2_YCBCR_ENC_DEFAULT;
+
+	if (hdmi->plat_data->get_quant_range)
+		hdmi->hdmi_data.quant_range =
+			hdmi->plat_data->get_quant_range(data);
+	else
+		hdmi->hdmi_data.quant_range = HDMI_QUANTIZATION_RANGE_DEFAULT;
+
+	/*
+	 * According to the dw-hdmi specification 6.4.2
+	 * vp_pr_cd[3:0]:
+	 * 0000b: No pixel repetition (pixel sent only once)
+	 * 0001b: Pixel sent two times (pixel repeated once)
+	 */
+	hdmi->hdmi_data.pix_repet_factor =
+		(mode->flags & DRM_MODE_FLAG_DBLCLK) ? 1 : 0;
+	hdmi->hdmi_data.video_mode.mdataenablepolarity = true;
+
+	/* HDMI Initialization Step B.1 */
+	hdmi_av_composer(hdmi, mode);
+
+	/* HDMI Initialization Step B.2 */
+	ret = hdmi->phy.ops->init(conn, hdmi, state);
+	if (ret)
+		return ret;
+	hdmi->phy.enabled = true;
+
+	/* HDMI Initializateion Step B.3 */
+	dw_hdmi_enable_video_path(hdmi);
+
+	/* HDMI Initialization Step E - Configure audio */
+	if (hdmi->sink_has_audio) {
+		printf("sink has audio support\n");
+		hdmi_clk_regenerator_update_pixel_clock(hdmi);
+		hdmi_enable_audio_clk(hdmi);
+	}
+
+	/* not for DVI mode */
+	if (hdmi->sink_is_hdmi) {
+		/* HDMI Initialization Step F - Configure AVI InfoFrame */
+		hdmi_config_AVI(hdmi, mode);
+		hdmi_config_vendor_specific_infoframe(hdmi, mode);
+		hdmi_modb(hdmi, HDMI_A_HDCPCFG0_HDMIDVI_HDMI,
+			  HDMI_A_HDCPCFG0_HDMIDVI_MASK,
+			  HDMI_A_HDCPCFG0);
+	} else {
+		hdmi_modb(hdmi, HDMI_A_HDCPCFG0_HDMIDVI_DVI,
+			  HDMI_A_HDCPCFG0_HDMIDVI_MASK,
+			  HDMI_A_HDCPCFG0);
+		printf("%s DVI mode\n", __func__);
+	}
+
+	hdmi_video_packetize(hdmi);
+	hdmi_video_csc(hdmi);
+	hdmi_video_sample(hdmi);
+	hdmi_tx_hdcp_config(hdmi, mode);
+	dw_hdmi_clear_overflow(hdmi);
+
+	return 0;
+}
+
+int dw_hdmi_detect_hotplug(struct dw_hdmi *hdmi,
+			   struct display_state *state)
+{
+	return hdmi->phy.ops->read_hpd(hdmi, state);
+}
+
+static int dw_hdmi_set_reg_wr(struct dw_hdmi *hdmi)
+{
+	switch (hdmi->io_width) {
+	case 4:
+		hdmi->write = dw_hdmi_writel;
+		hdmi->read = dw_hdmi_readl;
+		break;
+	case 1:
+		hdmi->write = dw_hdmi_writeb;
+		hdmi->read = dw_hdmi_readb;
+		break;
+	default:
+		printf("reg-io-width must be 1 or 4\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void initialize_hdmi_mutes(struct dw_hdmi *hdmi)
+{
+	/*mute unnecessary interrupt, only enable hpd */
+	hdmi_writeb(hdmi, 0xff, HDMI_FC_MASK0);
+	hdmi_writeb(hdmi, 0xff, HDMI_FC_MASK1);
+	hdmi_writeb(hdmi, 0xff, HDMI_FC_MASK2);
+	hdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_FC_STAT0);
+	hdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_FC_STAT1);
+	hdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_FC_STAT2);
+	hdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_AS_STAT0);
+	hdmi_writeb(hdmi, 0xfe, HDMI_IH_MUTE_PHY_STAT0);
+	hdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_I2CM_STAT0);
+	hdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_CEC_STAT0);
+	hdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_VP_STAT0);
+	hdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_I2CMPHY_STAT0);
+	hdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_AHBDMAAUD_STAT0);
+	hdmi_writeb(hdmi, 0xf1, HDMI_PHY_MASK0);
+
+	/*Force output black*/
+	dw_hdmi_writel(hdmi, 0x00, HDMI_FC_DBGTMDS2);
+	dw_hdmi_writel(hdmi, 0x00, HDMI_FC_DBGTMDS1);
+	dw_hdmi_writel(hdmi, 0x00, HDMI_FC_DBGTMDS0);
+}
+
+static void dw_hdmi_dev_init(struct dw_hdmi *hdmi)
+{
+	hdmi->version = (hdmi_readb(hdmi, HDMI_DESIGN_ID) << 8)
+		      | (hdmi_readb(hdmi, HDMI_REVISION_ID) << 0);
+
+	initialize_hdmi_mutes(hdmi);
+}
+
+static void dw_hdmi_i2c_set_divs(struct dw_hdmi *hdmi)
+{
+	unsigned long low_ns, high_ns;
+	unsigned long div_low, div_high;
+
+	/* Standard-mode */
+	if (hdmi->i2c->scl_high_ns < 4000)
+		high_ns = 4708;
+	else
+		high_ns = hdmi->i2c->scl_high_ns;
+
+	if (hdmi->i2c->scl_low_ns < 4700)
+		low_ns = 4916;
+	else
+		low_ns = hdmi->i2c->scl_low_ns;
+
+	div_low = (24000 * low_ns) / 1000000;
+	if ((24000 * low_ns) % 1000000)
+		div_low++;
+
+	div_high = (24000 * high_ns) / 1000000;
+	if ((24000 * high_ns) % 1000000)
+		div_high++;
+
+	/* Maximum divider supported by hw is 0xffff */
+	if (div_low > 0xffff)
+		div_low = 0xffff;
+
+	if (div_high > 0xffff)
+		div_high = 0xffff;
+
+	hdmi_writeb(hdmi, div_high & 0xff, HDMI_I2CM_SS_SCL_HCNT_0_ADDR);
+	hdmi_writeb(hdmi, (div_high >> 8) & 0xff,
+		    HDMI_I2CM_SS_SCL_HCNT_1_ADDR);
+	hdmi_writeb(hdmi, div_low & 0xff, HDMI_I2CM_SS_SCL_LCNT_0_ADDR);
+	hdmi_writeb(hdmi, (div_low >> 8) & 0xff,
+		    HDMI_I2CM_SS_SCL_LCNT_1_ADDR);
+}
+
+static void dw_hdmi_i2c_init(struct dw_hdmi *hdmi)
+{
+	/* Software reset */
+	hdmi_writeb(hdmi, 0x00, HDMI_I2CM_SOFTRSTZ);
+
+	/* Set Standard Mode speed */
+	hdmi_modb(hdmi, HDMI_I2CM_DIV_STD_MODE,
+		  HDMI_I2CM_DIV_FAST_STD_MODE, HDMI_I2CM_DIV);
+
+	/* Set done, not acknowledged and arbitration interrupt polarities */
+	hdmi_writeb(hdmi, HDMI_I2CM_INT_DONE_POL, HDMI_I2CM_INT);
+	hdmi_writeb(hdmi, HDMI_I2CM_CTLINT_NAC_POL | HDMI_I2CM_CTLINT_ARB_POL,
+		    HDMI_I2CM_CTLINT);
+
+	/* Clear DONE and ERROR interrupts */
+	hdmi_writeb(hdmi, HDMI_IH_I2CM_STAT0_ERROR | HDMI_IH_I2CM_STAT0_DONE,
+		    HDMI_IH_I2CM_STAT0);
+
+	/* Mute DONE and ERROR interrupts */
+	hdmi_writeb(hdmi, HDMI_IH_I2CM_STAT0_ERROR | HDMI_IH_I2CM_STAT0_DONE,
+		    HDMI_IH_MUTE_I2CM_STAT0);
+
+	/* set SDA high level holding time */
+	hdmi_writeb(hdmi, 0x48, HDMI_I2CM_SDA_HOLD);
+
+	dw_hdmi_i2c_set_divs(hdmi);
+}
+
+void dw_hdmi_audio_enable(struct dw_hdmi *hdmi)
+{
+	hdmi->audio_enable = true;
+	hdmi_set_cts_n(hdmi, hdmi->audio_cts, hdmi->audio_n);
+}
+
+void dw_hdmi_audio_disable(struct dw_hdmi *hdmi)
+{
+	hdmi->audio_enable = false;
+	hdmi_set_cts_n(hdmi, hdmi->audio_cts, 0);
+}
+
+int rockchip_dw_hdmi_init(struct rockchip_connector *conn, struct display_state *state)
+{
+	struct connector_state *conn_state = &state->conn_state;
+	const struct dw_hdmi_plat_data *pdata =
+#ifdef CONFIG_SPL_BUILD
+		(const struct dw_hdmi_plat_data *)conn->data;
+#else
+		(const struct dw_hdmi_plat_data *)dev_get_driver_data(conn->dev);
+	ofnode hdmi_node = conn->dev->node;
+	struct device_node *ddc_node;
+	int ret;
+#endif
+	struct crtc_state *crtc_state = &state->crtc_state;
+	struct dw_hdmi *hdmi;
+	struct drm_display_mode *mode_buf;
+	u32 val;
+
+	hdmi = malloc(sizeof(struct dw_hdmi));
+	if (!hdmi)
+		return -ENOMEM;
+
+	memset(hdmi, 0, sizeof(struct dw_hdmi));
+	mode_buf = malloc(MODE_LEN * sizeof(struct drm_display_mode));
+	if (!mode_buf)
+		return -ENOMEM;
+
+#ifdef CONFIG_SPL_BUILD
+	hdmi->id = 0;
+	hdmi->regs = (void *)RK3528_HDMI_BASE;
+	hdmi->io_width = 4;
+	hdmi->scramble_low_rates = false;
+	hdmi->hdcp1x_enable = false;
+	hdmi->output_bus_format_rgb = false;
+	conn_state->type = DRM_MODE_CONNECTOR_HDMIA;
+#else
+	hdmi->id = of_alias_get_id(ofnode_to_np(hdmi_node), "hdmi");
+	if (hdmi->id < 0)
+		hdmi->id = 0;
+	conn_state->disp_info = rockchip_get_disp_info(conn_state->type, hdmi->id);
+#endif
+
+	memset(mode_buf, 0, MODE_LEN * sizeof(struct drm_display_mode));
+
+	hdmi->dev_type = pdata->dev_type;
+	hdmi->plat_data = pdata;
+
+#ifndef CONFIG_SPL_BUILD
+	hdmi->regs = dev_read_addr_ptr(conn->dev);
+	hdmi->io_width = ofnode_read_s32_default(hdmi_node, "reg-io-width", -1);
+
+	if (ofnode_read_bool(hdmi_node, "scramble-low-rates"))
+		hdmi->scramble_low_rates = true;
+
+	if (ofnode_read_bool(hdmi_node, "hdcp1x-enable"))
+		hdmi->hdcp1x_enable = true;
+	else
+		hdmi->hdcp1x_enable = false;
+
+	if (ofnode_read_bool(hdmi_node, "force_output_bus_format_RGB") ||
+	    ofnode_read_bool(hdmi_node, "unsupported-yuv-input"))
+		hdmi->output_bus_format_rgb = true;
+	else
+		hdmi->output_bus_format_rgb = false;
+
+	ret = dev_read_size(conn->dev, "rockchip,phy-table");
+	if (ret > 0 && hdmi->plat_data->phy_config) {
+		u32 phy_config[ret / 4];
+		int i;
+
+		dev_read_u32_array(conn->dev, "rockchip,phy-table", phy_config, ret / 4);
+
+		for (i = 0; i < ret / 16; i++) {
+			if (phy_config[i * 4] != 0)
+				hdmi->plat_data->phy_config[i].mpixelclock = (u64)phy_config[i * 4];
+			else
+				hdmi->plat_data->phy_config[i].mpixelclock = ~0UL;
+			hdmi->plat_data->phy_config[i].sym_ctr = (u16)phy_config[i * 4 + 1];
+			hdmi->plat_data->phy_config[i].term = (u16)phy_config[i * 4 + 2];
+			hdmi->plat_data->phy_config[i].vlev_ctr = (u16)phy_config[i * 4 + 3];
+		}
+	}
+
+	ddc_node = of_parse_phandle(ofnode_to_np(hdmi_node), "ddc-i2c-bus", 0);
+	if (ddc_node) {
+		uclass_get_device_by_ofnode(UCLASS_I2C, np_to_ofnode(ddc_node),
+					    &hdmi->adap.i2c_bus);
+		if (hdmi->adap.i2c_bus)
+			hdmi->adap.ops = i2c_get_ops(hdmi->adap.i2c_bus);
+	}
+#endif
+
+	hdmi->grf = syscon_get_first_range(ROCKCHIP_SYSCON_GRF);
+	if (hdmi->grf <= 0) {
+		printf("%s: Get syscon grf failed (ret=%p)\n",
+		       __func__, hdmi->grf);
+		return -ENXIO;
+	}
+
+#ifdef CONFIG_SPL_BUILD
+	hdmi->gpio_base = (void *)RK3528_GPIO_BASE;
+#else
+	ret = gpio_request_by_name(conn->dev, "hpd-gpios", 0,
+				   &hdmi->hpd_gpiod, GPIOD_IS_IN);
+	if (ret && ret != -ENOENT) {
+		printf("%s: Cannot get HPD GPIO: %d\n", __func__, ret);
+		return ret;
+	}
+	hdmi->gpio_base = (void *)dev_read_addr_index(conn->dev, 1);
+#endif
+	if (!hdmi->gpio_base)
+		return -ENODEV;
+
+	dw_hdmi_set_reg_wr(hdmi);
+
+	if (pdata->grf_vop_sel_reg) {
+		if (crtc_state->crtc_id)
+			val = ((1 << pdata->vop_sel_bit) |
+			       (1 << (16 + pdata->vop_sel_bit)));
+		else
+			val = ((0 << pdata->vop_sel_bit) |
+			       (1 << (16 + pdata->vop_sel_bit)));
+		writel(val, hdmi->grf + pdata->grf_vop_sel_reg);
+	}
+
+	hdmi->i2c = malloc(sizeof(struct dw_hdmi_i2c));
+	if (!hdmi->i2c)
+		return -ENOMEM;
+	hdmi->adap.ddc_xfer = dw_hdmi_i2c_xfer;
+
+	/*
+	 * Read high and low time from device tree. If not available use
+	 * the default timing scl clock rate is about 99.6KHz.
+	 */
+#ifdef CONFIG_SPL_BUILD
+	hdmi->i2c->scl_high_ns = 9625;
+	hdmi->i2c->scl_low_ns = 10000;
+#else
+	hdmi->i2c->scl_high_ns =
+		ofnode_read_s32_default(hdmi_node,
+					"ddc-i2c-scl-high-time-ns", 4708);
+	hdmi->i2c->scl_low_ns =
+		ofnode_read_s32_default(hdmi_node,
+					"ddc-i2c-scl-low-time-ns", 4916);
+#endif
+
+	dw_hdmi_i2c_init(hdmi);
+	conn_state->output_if |= VOP_OUTPUT_IF_HDMI0;
+	conn_state->output_mode = ROCKCHIP_OUT_MODE_AAAA;
+
+	hdmi->edid_data.mode_buf = mode_buf;
+	hdmi->sample_rate = 48000;
+
+	conn->data = hdmi;
+	dw_hdmi_set_iomux(hdmi->grf, hdmi->gpio_base,
+			  &hdmi->hpd_gpiod, hdmi->dev_type);
+	dw_hdmi_detect_phy(hdmi);
+	dw_hdmi_dev_init(hdmi);
+
+	return 0;
+}
+
+void rockchip_dw_hdmi_deinit(struct rockchip_connector *conn, struct display_state *state)
+{
+	struct dw_hdmi *hdmi = conn->data;
+
+	if (hdmi->i2c)
+		free(hdmi->i2c);
+	if (hdmi->edid_data.mode_buf)
+		free(hdmi->edid_data.mode_buf);
+	if (hdmi)
+		free(hdmi);
+}
+
+int rockchip_dw_hdmi_prepare(struct rockchip_connector *conn, struct display_state *state)
+{
+	return 0;
+}
+
+int rockchip_dw_hdmi_enable(struct rockchip_connector *conn, struct display_state *state)
+{
+	struct connector_state *conn_state = &state->conn_state;
+	struct drm_display_mode *mode = &conn_state->mode;
+	struct dw_hdmi *hdmi = conn->data;
+
+	if (!hdmi)
+		return -EFAULT;
+
+	/* Store the display mode for plugin/DKMS poweron events */
+	memcpy(&hdmi->previous_mode, mode, sizeof(hdmi->previous_mode));
+
+	dw_hdmi_setup(hdmi, conn, mode, state);
+
+	return 0;
+}
+
+int rockchip_dw_hdmi_disable(struct rockchip_connector *conn, struct display_state *state)
+{
+	struct dw_hdmi *hdmi = conn->data;
+
+	dw_hdmi_disable(conn, hdmi, state);
+	return 0;
+}
+
+static void rockchip_dw_hdmi_mode_valid(struct dw_hdmi *hdmi)
+{
+	struct hdmi_edid_data *edid_data = &hdmi->edid_data;
+	int i;
+
+	for (i = 0; i < edid_data->modes; i++) {
+		if (edid_data->mode_buf[i].invalid)
+			continue;
+
+		if (edid_data->mode_buf[i].clock > 600000)
+			edid_data->mode_buf[i].invalid = true;
+	}
+}
+
+int rockchip_dw_hdmi_get_timing(struct rockchip_connector *conn, struct display_state *state)
+{
+	int ret, i, vic;
+	struct connector_state *conn_state = &state->conn_state;
+	struct drm_display_mode *mode = &conn_state->mode;
+	struct dw_hdmi *hdmi = conn->data;
+	struct edid *edid = (struct edid *)conn_state->edid;
+	unsigned int bus_format;
+	unsigned long enc_out_encoding;
+	struct overscan *overscan = &conn_state->overscan;
+	const u8 def_modes_vic[6] = {4, 16, 2, 17, 31, 19};
+
+	if (!hdmi)
+		return -EFAULT;
+
+	ret = drm_do_get_edid(&hdmi->adap, conn_state->edid);
+
+	if (!ret) {
+		hdmi->sink_is_hdmi =
+			drm_detect_hdmi_monitor(edid);
+		hdmi->sink_has_audio = drm_detect_monitor_audio(edid);
+		ret = drm_add_edid_modes(&hdmi->edid_data, conn_state->edid);
+	}
+	if (ret < 0) {
+		hdmi->sink_is_hdmi = true;
+		hdmi->sink_has_audio = true;
+		do_cea_modes(&hdmi->edid_data, def_modes_vic,
+			     sizeof(def_modes_vic));
+		hdmi->edid_data.mode_buf[0].type |= DRM_MODE_TYPE_PREFERRED;
+		hdmi->edid_data.preferred_mode = &hdmi->edid_data.mode_buf[0];
+		printf("failed to get edid\n");
+	}
+#ifdef CONFIG_SPL_BUILD
+	conn_state->disp_info = rockchip_get_disp_info(conn_state->type, hdmi->id);
+#endif
+	drm_rk_filter_whitelist(&hdmi->edid_data);
+	rockchip_dw_hdmi_mode_valid(hdmi);
+	if (hdmi->phy.ops->mode_valid)
+		hdmi->phy.ops->mode_valid(conn, hdmi, state);
+	drm_mode_max_resolution_filter(&hdmi->edid_data,
+				       &state->crtc_state.max_output);
+	if (!drm_mode_prune_invalid(&hdmi->edid_data)) {
+		printf("can't find valid hdmi mode\n");
+		return -EINVAL;
+	}
+
+	for (i = 0; i < hdmi->edid_data.modes; i++) {
+		hdmi->edid_data.mode_buf[i].vrefresh =
+			drm_mode_vrefresh(&hdmi->edid_data.mode_buf[i]);
+
+		vic = drm_match_cea_mode(&hdmi->edid_data.mode_buf[i]);
+		if (hdmi->edid_data.mode_buf[i].picture_aspect_ratio == HDMI_PICTURE_ASPECT_NONE) {
+			if (vic >= 93 && vic <= 95)
+				hdmi->edid_data.mode_buf[i].picture_aspect_ratio =
+					HDMI_PICTURE_ASPECT_16_9;
+			else if (vic == 98)
+				hdmi->edid_data.mode_buf[i].picture_aspect_ratio =
+					HDMI_PICTURE_ASPECT_256_135;
+		}
+	}
+
+	drm_mode_sort(&hdmi->edid_data);
+	drm_rk_selete_output(&hdmi->edid_data, conn_state, &bus_format,
+			     overscan, hdmi->dev_type, hdmi->output_bus_format_rgb);
+
+	*mode = *hdmi->edid_data.preferred_mode;
+	hdmi->vic = drm_match_cea_mode(mode);
+
+	if (state->force_output) {
+		hdmi->force_output = state->force_output;
+		hdmi->sink_is_hdmi = true;
+		hdmi->sink_has_audio = true;
+		bus_format = state->force_bus_format;
+	}
+	conn_state->bus_format = bus_format;
+	hdmi->hdmi_data.enc_in_bus_format = bus_format;
+	hdmi->hdmi_data.enc_out_bus_format = bus_format;
+
+	switch (bus_format) {
+	case MEDIA_BUS_FMT_UYVY10_1X20:
+		conn_state->bus_format = MEDIA_BUS_FMT_YUV10_1X30;
+		hdmi->hdmi_data.enc_in_bus_format =
+			MEDIA_BUS_FMT_YUV10_1X30;
+		break;
+	case MEDIA_BUS_FMT_UYVY8_1X16:
+		conn_state->bus_format = MEDIA_BUS_FMT_YUV8_1X24;
+		hdmi->hdmi_data.enc_in_bus_format =
+			MEDIA_BUS_FMT_YUV8_1X24;
+		break;
+	case MEDIA_BUS_FMT_UYYVYY8_0_5X24:
+	case MEDIA_BUS_FMT_UYYVYY10_0_5X30:
+		conn_state->output_mode = ROCKCHIP_OUT_MODE_YUV420;
+		break;
+	}
+
+	if (hdmi->vic == 6 || hdmi->vic == 7 || hdmi->vic == 21 ||
+	    hdmi->vic == 22 || hdmi->vic == 2 || hdmi->vic == 3 ||
+	    hdmi->vic == 17 || hdmi->vic == 18)
+		enc_out_encoding = V4L2_YCBCR_ENC_601;
+	else
+		enc_out_encoding = V4L2_YCBCR_ENC_709;
+
+	if (enc_out_encoding == V4L2_YCBCR_ENC_BT2020)
+		conn_state->color_space = V4L2_COLORSPACE_BT2020;
+	else if (bus_format == MEDIA_BUS_FMT_RGB888_1X24 ||
+		 bus_format == MEDIA_BUS_FMT_RGB101010_1X30)
+		conn_state->color_space = V4L2_COLORSPACE_DEFAULT;
+	else if (enc_out_encoding == V4L2_YCBCR_ENC_709)
+		conn_state->color_space = V4L2_COLORSPACE_REC709;
+	else
+		conn_state->color_space = V4L2_COLORSPACE_SMPTE170M;
+
+	return 0;
+}
+
+int rockchip_dw_hdmi_detect(struct rockchip_connector *conn, struct display_state *state)
+{
+	int ret;
+	struct dw_hdmi *hdmi = conn->data;
+
+	if (!hdmi)
+		return -EFAULT;
+
+	ret = dw_hdmi_detect_hotplug(hdmi, state);
+
+	return ret;
+}
+
+int rockchip_dw_hdmi_get_edid(struct rockchip_connector *conn, struct display_state *state)
+{
+	int ret;
+	struct connector_state *conn_state = &state->conn_state;
+	struct dw_hdmi *hdmi = conn->data;
+
+	ret = drm_do_get_edid(&hdmi->adap, conn_state->edid);
+
+	return ret;
+}
+
+int inno_dw_hdmi_phy_init(struct rockchip_connector *conn, struct dw_hdmi *hdmi, void *data)
+{
+	struct display_state *state = (struct display_state *)data;
+	struct connector_state *conn_state = &state->conn_state;
+	u32 color_depth, bus_width;
+
+	color_depth =
+		hdmi_bus_fmt_color_depth(hdmi->hdmi_data.enc_out_bus_format);
+
+	if (hdmi_bus_fmt_is_yuv420(hdmi->hdmi_data.enc_out_bus_format))
+		bus_width = color_depth / 2;
+	else if (!hdmi_bus_fmt_is_yuv422(hdmi->hdmi_data.enc_out_bus_format))
+		bus_width = color_depth;
+	else
+		bus_width = 8;
+	rockchip_phy_set_bus_width(conn->phy, bus_width);
+	rockchip_phy_set_pll(conn->phy,
+			     conn_state->mode.crtc_clock * 1000);
+	if (hdmi->edid_data.display_info.hdmi.scdc.supported)
+		rockchip_dw_hdmi_scdc_set_tmds_rate(hdmi);
+	rockchip_phy_power_on(conn->phy);
+
+	return 0;
+}
+
+void inno_dw_hdmi_phy_disable(struct rockchip_connector *conn, struct dw_hdmi *hdmi, void *data)
+{
+}
+
+enum drm_connector_status
+inno_dw_hdmi_phy_read_hpd(struct dw_hdmi *hdmi, void *data)
+{
+	enum drm_connector_status status;
+	struct display_state *state = (struct display_state *)data;
+
+	status = dw_hdmi_phy_read_hpd(hdmi, state);
+
+	if (hdmi->dev_type == RK3328_HDMI) {
+		if (status == connector_status_connected)
+			inno_dw_hdmi_set_domain(hdmi->grf, 1);
+		else
+			inno_dw_hdmi_set_domain(hdmi->grf, 0);
+	}
+
+	return status;
+}
+
+void inno_dw_hdmi_mode_valid(struct rockchip_connector *conn, struct dw_hdmi *hdmi, void *data)
+{
+	struct hdmi_edid_data *edid_data = &hdmi->edid_data;
+	unsigned long rate;
+	int i, ret;
+	struct drm_display_mode *mode_buf = edid_data->mode_buf;
+
+	for (i = 0; i < edid_data->modes; i++) {
+		if (edid_data->mode_buf[i].invalid)
+			continue;
+		if (edid_data->mode_buf[i].flags & DRM_MODE_FLAG_DBLCLK)
+			rate = mode_buf[i].clock * 1000 * 2;
+		else
+			rate = mode_buf[i].clock * 1000;
+
+		/* Check whether mode is out of phy cfg range. */
+		ret = rockchip_phy_round_rate(conn->phy, rate);
+
+		if (ret < 0)
+			edid_data->mode_buf[i].invalid = true;
+	}
+}
diff --git a/drivers/video/drm/dw_hdmi.h b/drivers/video/drm/dw_hdmi.h
new file mode 100644
index 0000000000..3872dae9fe
--- /dev/null
+++ b/drivers/video/drm/dw_hdmi.h
@@ -0,0 +1,1418 @@
+/*
+ * (C) Copyright 2008-2017 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _ROCKCHIP_HDMI_H_
+#define _ROCKCHIP_HDMI_H_
+
+#define HDMI_DESIGN_ID                          0x0000
+#define HDMI_REVISION_ID                        0x0001
+#define HDMI_PRODUCT_ID0                        0x0002
+#define HDMI_PRODUCT_ID1                        0x0003
+#define HDMI_CONFIG0_ID                         0x0004
+#define HDMI_CONFIG1_ID                         0x0005
+#define HDMI_CONFIG2_ID                         0x0006
+#define HDMI_CONFIG3_ID                         0x0007
+
+/* Interrupt Registers */
+#define HDMI_IH_FC_STAT0                        0x0100
+#define HDMI_IH_FC_STAT1                        0x0101
+#define HDMI_IH_FC_STAT2                        0x0102
+#define HDMI_IH_AS_STAT0                        0x0103
+#define HDMI_IH_PHY_STAT0                       0x0104
+#define HDMI_IH_I2CM_STAT0                      0x0105
+#define m_SCDC_READREQ                          BIT(2)
+#define m_I2CM_DONE                             BIT(1)
+#define m_I2CM_ERROR                            BIT(0)
+#define HDMI_IH_CEC_STAT0                       0x0106
+#define HDMI_IH_VP_STAT0                        0x0107
+#define HDMI_IH_I2CMPHY_STAT0                   0x0108
+#define HDMI_IH_AHBDMAAUD_STAT0                 0x0109
+
+#define HDMI_IH_MUTE_FC_STAT0                   0x0180
+#define HDMI_IH_MUTE_FC_STAT1                   0x0181
+#define HDMI_IH_MUTE_FC_STAT2                   0x0182
+#define HDMI_IH_MUTE_AS_STAT0                   0x0183
+#define HDMI_IH_MUTE_PHY_STAT0                  0x0184
+#define HDMI_IH_MUTE_I2CM_STAT0                 0x0185
+#define HDMI_IH_MUTE_CEC_STAT0                  0x0186
+#define HDMI_IH_MUTE_VP_STAT0                   0x0187
+#define HDMI_IH_MUTE_I2CMPHY_STAT0              0x0188
+#define HDMI_IH_MUTE_AHBDMAAUD_STAT0            0x0189
+#define HDMI_IH_MUTE                            0x01FF
+
+/* Video Sample Registers */
+#define HDMI_TX_INVID0                          0x0200
+#define HDMI_TX_INSTUFFING                      0x0201
+#define HDMI_TX_GYDATA0                         0x0202
+#define HDMI_TX_GYDATA1                         0x0203
+#define HDMI_TX_RCRDATA0                        0x0204
+#define HDMI_TX_RCRDATA1                        0x0205
+#define HDMI_TX_BCBDATA0                        0x0206
+#define HDMI_TX_BCBDATA1                        0x0207
+
+/* Video Packetizer Registers */
+#define HDMI_VP_STATUS                          0x0800
+#define HDMI_VP_PR_CD                           0x0801
+#define HDMI_VP_STUFF                           0x0802
+#define HDMI_VP_REMAP                           0x0803
+#define HDMI_VP_CONF                            0x0804
+#define HDMI_VP_STAT                            0x0805
+#define HDMI_VP_INT                             0x0806
+#define HDMI_VP_MASK                            0x0807
+#define HDMI_VP_POL                             0x0808
+
+/* Frame Composer Registers */
+#define HDMI_FC_INVIDCONF                       0x1000
+#define HDMI_FC_INHACTV0                        0x1001
+#define HDMI_FC_INHACTV1                        0x1002
+#define HDMI_FC_INHBLANK0                       0x1003
+#define HDMI_FC_INHBLANK1                       0x1004
+#define HDMI_FC_INVACTV0                        0x1005
+#define HDMI_FC_INVACTV1                        0x1006
+#define HDMI_FC_INVBLANK                        0x1007
+#define HDMI_FC_HSYNCINDELAY0                   0x1008
+#define HDMI_FC_HSYNCINDELAY1                   0x1009
+#define HDMI_FC_HSYNCINWIDTH0                   0x100A
+#define HDMI_FC_HSYNCINWIDTH1                   0x100B
+#define HDMI_FC_VSYNCINDELAY                    0x100C
+#define HDMI_FC_VSYNCINWIDTH                    0x100D
+#define HDMI_FC_INFREQ0                         0x100E
+#define HDMI_FC_INFREQ1                         0x100F
+#define HDMI_FC_INFREQ2                         0x1010
+#define HDMI_FC_CTRLDUR                         0x1011
+#define HDMI_FC_EXCTRLDUR                       0x1012
+#define HDMI_FC_EXCTRLSPAC                      0x1013
+#define HDMI_FC_CH0PREAM                        0x1014
+#define HDMI_FC_CH1PREAM                        0x1015
+#define HDMI_FC_CH2PREAM                        0x1016
+#define HDMI_FC_AVICONF3                        0x1017
+#define HDMI_FC_GCP                             0x1018
+#define HDMI_FC_AVICONF0                        0x1019
+#define HDMI_FC_AVICONF1                        0x101A
+#define HDMI_FC_AVICONF2                        0x101B
+#define HDMI_FC_AVIVID                          0x101C
+#define HDMI_FC_AVIETB0                         0x101D
+#define HDMI_FC_AVIETB1                         0x101E
+#define HDMI_FC_AVISBB0                         0x101F
+#define HDMI_FC_AVISBB1                         0x1020
+#define HDMI_FC_AVIELB0                         0x1021
+#define HDMI_FC_AVIELB1                         0x1022
+#define HDMI_FC_AVISRB0                         0x1023
+#define HDMI_FC_AVISRB1                         0x1024
+#define HDMI_FC_AUDICONF0                       0x1025
+#define HDMI_FC_AUDICONF1                       0x1026
+#define HDMI_FC_AUDICONF2                       0x1027
+#define HDMI_FC_AUDICONF3                       0x1028
+#define HDMI_FC_VSDIEEEID0                      0x1029
+#define HDMI_FC_VSDSIZE                         0x102A
+#define HDMI_FC_VSDIEEEID1                      0x1030
+#define HDMI_FC_VSDIEEEID2                      0x1031
+#define HDMI_FC_VSDPAYLOAD0                     0x1032
+#define HDMI_FC_VSDPAYLOAD1                     0x1033
+#define HDMI_FC_VSDPAYLOAD2                     0x1034
+#define HDMI_FC_VSDPAYLOAD3                     0x1035
+#define HDMI_FC_VSDPAYLOAD4                     0x1036
+#define HDMI_FC_VSDPAYLOAD5                     0x1037
+#define HDMI_FC_VSDPAYLOAD6                     0x1038
+#define HDMI_FC_VSDPAYLOAD7                     0x1039
+#define HDMI_FC_VSDPAYLOAD8                     0x103A
+#define HDMI_FC_VSDPAYLOAD9                     0x103B
+#define HDMI_FC_VSDPAYLOAD10                    0x103C
+#define HDMI_FC_VSDPAYLOAD11                    0x103D
+#define HDMI_FC_VSDPAYLOAD12                    0x103E
+#define HDMI_FC_VSDPAYLOAD13                    0x103F
+#define HDMI_FC_VSDPAYLOAD14                    0x1040
+#define HDMI_FC_VSDPAYLOAD15                    0x1041
+#define HDMI_FC_VSDPAYLOAD16                    0x1042
+#define HDMI_FC_VSDPAYLOAD17                    0x1043
+#define HDMI_FC_VSDPAYLOAD18                    0x1044
+#define HDMI_FC_VSDPAYLOAD19                    0x1045
+#define HDMI_FC_VSDPAYLOAD20                    0x1046
+#define HDMI_FC_VSDPAYLOAD21                    0x1047
+#define HDMI_FC_VSDPAYLOAD22                    0x1048
+#define HDMI_FC_VSDPAYLOAD23                    0x1049
+#define HDMI_FC_SPDVENDORNAME0                  0x104A
+#define HDMI_FC_SPDVENDORNAME1                  0x104B
+#define HDMI_FC_SPDVENDORNAME2                  0x104C
+#define HDMI_FC_SPDVENDORNAME3                  0x104D
+#define HDMI_FC_SPDVENDORNAME4                  0x104E
+#define HDMI_FC_SPDVENDORNAME5                  0x104F
+#define HDMI_FC_SPDVENDORNAME6                  0x1050
+#define HDMI_FC_SPDVENDORNAME7                  0x1051
+#define HDMI_FC_SDPPRODUCTNAME0                 0x1052
+#define HDMI_FC_SDPPRODUCTNAME1                 0x1053
+#define HDMI_FC_SDPPRODUCTNAME2                 0x1054
+#define HDMI_FC_SDPPRODUCTNAME3                 0x1055
+#define HDMI_FC_SDPPRODUCTNAME4                 0x1056
+#define HDMI_FC_SDPPRODUCTNAME5                 0x1057
+#define HDMI_FC_SDPPRODUCTNAME6                 0x1058
+#define HDMI_FC_SDPPRODUCTNAME7                 0x1059
+#define HDMI_FC_SDPPRODUCTNAME8                 0x105A
+#define HDMI_FC_SDPPRODUCTNAME9                 0x105B
+#define HDMI_FC_SDPPRODUCTNAME10                0x105C
+#define HDMI_FC_SDPPRODUCTNAME11                0x105D
+#define HDMI_FC_SDPPRODUCTNAME12                0x105E
+#define HDMI_FC_SDPPRODUCTNAME13                0x105F
+#define HDMI_FC_SDPPRODUCTNAME14                0x1060
+#define HDMI_FC_SPDPRODUCTNAME15                0x1061
+#define HDMI_FC_SPDDEVICEINF                    0x1062
+#define HDMI_FC_AUDSCONF                        0x1063
+#define HDMI_FC_AUDSSTAT                        0x1064
+#define HDMI_FC_AUDSCHNLS0                      0x1067
+#define HDMI_FC_AUDSCHNLS1                      0x1068
+#define HDMI_FC_AUDSCHNLS2                      0x1069
+#define HDMI_FC_AUDSCHNLS3                      0x106a
+#define HDMI_FC_AUDSCHNLS4                      0x106b
+#define HDMI_FC_AUDSCHNLS5                      0x106c
+#define HDMI_FC_AUDSCHNLS6                      0x106d
+#define HDMI_FC_AUDSCHNLS7                      0x106e
+#define HDMI_FC_AUDSCHNLS8                      0x106f
+#define HDMI_FC_DATACH0FILL                     0x1070
+#define HDMI_FC_DATACH1FILL                     0x1071
+#define HDMI_FC_DATACH2FILL                     0x1072
+#define HDMI_FC_CTRLQHIGH                       0x1073
+#define HDMI_FC_CTRLQLOW                        0x1074
+#define HDMI_FC_ACP0                            0x1075
+#define HDMI_FC_ACP28                           0x1076
+#define HDMI_FC_ACP27                           0x1077
+#define HDMI_FC_ACP26                           0x1078
+#define HDMI_FC_ACP25                           0x1079
+#define HDMI_FC_ACP24                           0x107A
+#define HDMI_FC_ACP23                           0x107B
+#define HDMI_FC_ACP22                           0x107C
+#define HDMI_FC_ACP21                           0x107D
+#define HDMI_FC_ACP20                           0x107E
+#define HDMI_FC_ACP19                           0x107F
+#define HDMI_FC_ACP18                           0x1080
+#define HDMI_FC_ACP17                           0x1081
+#define HDMI_FC_ACP16                           0x1082
+#define HDMI_FC_ACP15                           0x1083
+#define HDMI_FC_ACP14                           0x1084
+#define HDMI_FC_ACP13                           0x1085
+#define HDMI_FC_ACP12                           0x1086
+#define HDMI_FC_ACP11                           0x1087
+#define HDMI_FC_ACP10                           0x1088
+#define HDMI_FC_ACP9                            0x1089
+#define HDMI_FC_ACP8                            0x108A
+#define HDMI_FC_ACP7                            0x108B
+#define HDMI_FC_ACP6                            0x108C
+#define HDMI_FC_ACP5                            0x108D
+#define HDMI_FC_ACP4                            0x108E
+#define HDMI_FC_ACP3                            0x108F
+#define HDMI_FC_ACP2                            0x1090
+#define HDMI_FC_ACP1                            0x1091
+#define HDMI_FC_ISCR1_0                         0x1092
+#define HDMI_FC_ISCR1_16                        0x1093
+#define HDMI_FC_ISCR1_15                        0x1094
+#define HDMI_FC_ISCR1_14                        0x1095
+#define HDMI_FC_ISCR1_13                        0x1096
+#define HDMI_FC_ISCR1_12                        0x1097
+#define HDMI_FC_ISCR1_11                        0x1098
+#define HDMI_FC_ISCR1_10                        0x1099
+#define HDMI_FC_ISCR1_9                         0x109A
+#define HDMI_FC_ISCR1_8                         0x109B
+#define HDMI_FC_ISCR1_7                         0x109C
+#define HDMI_FC_ISCR1_6                         0x109D
+#define HDMI_FC_ISCR1_5                         0x109E
+#define HDMI_FC_ISCR1_4                         0x109F
+#define HDMI_FC_ISCR1_3                         0x10A0
+#define HDMI_FC_ISCR1_2                         0x10A1
+#define HDMI_FC_ISCR1_1                         0x10A2
+#define HDMI_FC_ISCR2_15                        0x10A3
+#define HDMI_FC_ISCR2_14                        0x10A4
+#define HDMI_FC_ISCR2_13                        0x10A5
+#define HDMI_FC_ISCR2_12                        0x10A6
+#define HDMI_FC_ISCR2_11                        0x10A7
+#define HDMI_FC_ISCR2_10                        0x10A8
+#define HDMI_FC_ISCR2_9                         0x10A9
+#define HDMI_FC_ISCR2_8                         0x10AA
+#define HDMI_FC_ISCR2_7                         0x10AB
+#define HDMI_FC_ISCR2_6                         0x10AC
+#define HDMI_FC_ISCR2_5                         0x10AD
+#define HDMI_FC_ISCR2_4                         0x10AE
+#define HDMI_FC_ISCR2_3                         0x10AF
+#define HDMI_FC_ISCR2_2                         0x10B0
+#define HDMI_FC_ISCR2_1                         0x10B1
+#define HDMI_FC_ISCR2_0                         0x10B2
+#define HDMI_FC_DATAUTO0                        0x10B3
+#define HDMI_FC_DATAUTO1                        0x10B4
+#define HDMI_FC_DATAUTO2                        0x10B5
+#define HDMI_FC_DATMAN                          0x10B6
+#define HDMI_FC_DATAUTO3                        0x10B7
+#define HDMI_FC_RDRB0                           0x10B8
+#define HDMI_FC_RDRB1                           0x10B9
+#define HDMI_FC_RDRB2                           0x10BA
+#define HDMI_FC_RDRB3                           0x10BB
+#define HDMI_FC_RDRB4                           0x10BC
+#define HDMI_FC_RDRB5                           0x10BD
+#define HDMI_FC_RDRB6                           0x10BE
+#define HDMI_FC_RDRB7                           0x10BF
+#define HDMI_FC_STAT0                           0x10D0
+#define HDMI_FC_INT0                            0x10D1
+#define HDMI_FC_MASK0                           0x10D2
+#define HDMI_FC_POL0                            0x10D3
+#define HDMI_FC_STAT1                           0x10D4
+#define HDMI_FC_INT1                            0x10D5
+#define HDMI_FC_MASK1                           0x10D6
+#define HDMI_FC_POL1                            0x10D7
+#define HDMI_FC_STAT2                           0x10D8
+#define HDMI_FC_INT2                            0x10D9
+#define HDMI_FC_MASK2                           0x10DA
+#define HDMI_FC_POL2                            0x10DB
+#define HDMI_FC_PRCONF                          0x10E0
+#define HDMI_FC_SCRAMBLER_CTRL                  0x10E1
+
+#define HDMI_FC_GMD_STAT                        0x1100
+#define HDMI_FC_GMD_EN                          0x1101
+#define HDMI_FC_GMD_UP                          0x1102
+#define HDMI_FC_GMD_CONF                        0x1103
+#define HDMI_FC_GMD_HB                          0x1104
+#define HDMI_FC_GMD_PB0                         0x1105
+#define HDMI_FC_GMD_PB1                         0x1106
+#define HDMI_FC_GMD_PB2                         0x1107
+#define HDMI_FC_GMD_PB3                         0x1108
+#define HDMI_FC_GMD_PB4                         0x1109
+#define HDMI_FC_GMD_PB5                         0x110A
+#define HDMI_FC_GMD_PB6                         0x110B
+#define HDMI_FC_GMD_PB7                         0x110C
+#define HDMI_FC_GMD_PB8                         0x110D
+#define HDMI_FC_GMD_PB9                         0x110E
+#define HDMI_FC_GMD_PB10                        0x110F
+#define HDMI_FC_GMD_PB11                        0x1110
+#define HDMI_FC_GMD_PB12                        0x1111
+#define HDMI_FC_GMD_PB13                        0x1112
+#define HDMI_FC_GMD_PB14                        0x1113
+#define HDMI_FC_GMD_PB15                        0x1114
+#define HDMI_FC_GMD_PB16                        0x1115
+#define HDMI_FC_GMD_PB17                        0x1116
+#define HDMI_FC_GMD_PB18                        0x1117
+#define HDMI_FC_GMD_PB19                        0x1118
+#define HDMI_FC_GMD_PB20                        0x1119
+#define HDMI_FC_GMD_PB21                        0x111A
+#define HDMI_FC_GMD_PB22                        0x111B
+#define HDMI_FC_GMD_PB23                        0x111C
+#define HDMI_FC_GMD_PB24                        0x111D
+#define HDMI_FC_GMD_PB25                        0x111E
+#define HDMI_FC_GMD_PB26                        0x111F
+#define HDMI_FC_GMD_PB27                        0x1120
+
+#define HDMI_FC_DBGFORCE                        0x1200
+#define HDMI_FC_DBGAUD0CH0                      0x1201
+#define HDMI_FC_DBGAUD1CH0                      0x1202
+#define HDMI_FC_DBGAUD2CH0                      0x1203
+#define HDMI_FC_DBGAUD0CH1                      0x1204
+#define HDMI_FC_DBGAUD1CH1                      0x1205
+#define HDMI_FC_DBGAUD2CH1                      0x1206
+#define HDMI_FC_DBGAUD0CH2                      0x1207
+#define HDMI_FC_DBGAUD1CH2                      0x1208
+#define HDMI_FC_DBGAUD2CH2                      0x1209
+#define HDMI_FC_DBGAUD0CH3                      0x120A
+#define HDMI_FC_DBGAUD1CH3                      0x120B
+#define HDMI_FC_DBGAUD2CH3                      0x120C
+#define HDMI_FC_DBGAUD0CH4                      0x120D
+#define HDMI_FC_DBGAUD1CH4                      0x120E
+#define HDMI_FC_DBGAUD2CH4                      0x120F
+#define HDMI_FC_DBGAUD0CH5                      0x1210
+#define HDMI_FC_DBGAUD1CH5                      0x1211
+#define HDMI_FC_DBGAUD2CH5                      0x1212
+#define HDMI_FC_DBGAUD0CH6                      0x1213
+#define HDMI_FC_DBGAUD1CH6                      0x1214
+#define HDMI_FC_DBGAUD2CH6                      0x1215
+#define HDMI_FC_DBGAUD0CH7                      0x1216
+#define HDMI_FC_DBGAUD1CH7                      0x1217
+#define HDMI_FC_DBGAUD2CH7                      0x1218
+#define HDMI_FC_DBGTMDS0                        0x1219
+#define HDMI_FC_DBGTMDS1                        0x121A
+#define HDMI_FC_DBGTMDS2                        0x121B
+
+/* HDMI Source PHY Registers */
+#define HDMI_PHY_CONF0                          0x3000
+#define HDMI_PHY_TST0                           0x3001
+#define HDMI_PHY_TST1                           0x3002
+#define HDMI_PHY_TST2                           0x3003
+#define HDMI_PHY_STAT0                          0x3004
+#define HDMI_PHY_INT0                           0x3005
+#define HDMI_PHY_MASK0                          0x3006
+#define HDMI_PHY_POL0                           0x3007
+
+/* HDMI Master PHY Registers */
+#define HDMI_PHY_I2CM_SLAVE_ADDR                0x3020
+#define HDMI_PHY_I2CM_ADDRESS_ADDR              0x3021
+#define HDMI_PHY_I2CM_DATAO_1_ADDR              0x3022
+#define HDMI_PHY_I2CM_DATAO_0_ADDR              0x3023
+#define HDMI_PHY_I2CM_DATAI_1_ADDR              0x3024
+#define HDMI_PHY_I2CM_DATAI_0_ADDR              0x3025
+#define HDMI_PHY_I2CM_OPERATION_ADDR            0x3026
+#define HDMI_PHY_I2CM_INT_ADDR                  0x3027
+#define HDMI_PHY_I2CM_CTLINT_ADDR               0x3028
+#define HDMI_PHY_I2CM_DIV_ADDR                  0x3029
+#define HDMI_PHY_I2CM_SOFTRSTZ_ADDR             0x302a
+#define HDMI_PHY_I2CM_SS_SCL_HCNT_1_ADDR        0x302b
+#define HDMI_PHY_I2CM_SS_SCL_HCNT_0_ADDR        0x302c
+#define HDMI_PHY_I2CM_SS_SCL_LCNT_1_ADDR        0x302d
+#define HDMI_PHY_I2CM_SS_SCL_LCNT_0_ADDR        0x302e
+#define HDMI_PHY_I2CM_FS_SCL_HCNT_1_ADDR        0x302f
+#define HDMI_PHY_I2CM_FS_SCL_HCNT_0_ADDR        0x3030
+#define HDMI_PHY_I2CM_FS_SCL_LCNT_1_ADDR        0x3031
+#define HDMI_PHY_I2CM_FS_SCL_LCNT_0_ADDR        0x3032
+
+/* Audio Sampler Registers */
+#define HDMI_AUD_CONF0                          0x3100
+#define HDMI_AUD_CONF1                          0x3101
+#define HDMI_AUD_INT                            0x3102
+#define HDMI_AUD_CONF2                          0x3103
+#define HDMI_AUD_N1                             0x3200
+#define HDMI_AUD_N2                             0x3201
+#define HDMI_AUD_N3                             0x3202
+#define HDMI_AUD_CTS1                           0x3203
+#define HDMI_AUD_CTS2                           0x3204
+#define HDMI_AUD_CTS3                           0x3205
+#define HDMI_AUD_INPUTCLKFS                     0x3206
+#define HDMI_AUD_SPDIFINT			                  0x3302
+#define HDMI_AUD_CONF0_HBR                      0x3400
+#define HDMI_AUD_HBR_STATUS                     0x3401
+#define HDMI_AUD_HBR_INT                        0x3402
+#define HDMI_AUD_HBR_POL                        0x3403
+#define HDMI_AUD_HBR_MASK                       0x3404
+
+/*
+ * Generic Parallel Audio Interface Registers
+ * Not used as GPAUD interface is not enabled in hw
+ */
+#define HDMI_GP_CONF0                           0x3500
+#define HDMI_GP_CONF1                           0x3501
+#define HDMI_GP_CONF2                           0x3502
+#define HDMI_GP_STAT                            0x3503
+#define HDMI_GP_INT                             0x3504
+#define HDMI_GP_MASK                            0x3505
+#define HDMI_GP_POL                             0x3506
+
+/* Audio DMA Registers */
+#define HDMI_AHB_DMA_CONF0                      0x3600
+#define HDMI_AHB_DMA_START                      0x3601
+#define HDMI_AHB_DMA_STOP                       0x3602
+#define HDMI_AHB_DMA_THRSLD                     0x3603
+#define HDMI_AHB_DMA_STRADDR0                   0x3604
+#define HDMI_AHB_DMA_STRADDR1                   0x3605
+#define HDMI_AHB_DMA_STRADDR2                   0x3606
+#define HDMI_AHB_DMA_STRADDR3                   0x3607
+#define HDMI_AHB_DMA_STPADDR0                   0x3608
+#define HDMI_AHB_DMA_STPADDR1                   0x3609
+#define HDMI_AHB_DMA_STPADDR2                   0x360a
+#define HDMI_AHB_DMA_STPADDR3                   0x360b
+#define HDMI_AHB_DMA_BSTADDR0                   0x360c
+#define HDMI_AHB_DMA_BSTADDR1                   0x360d
+#define HDMI_AHB_DMA_BSTADDR2                   0x360e
+#define HDMI_AHB_DMA_BSTADDR3                   0x360f
+#define HDMI_AHB_DMA_MBLENGTH0                  0x3610
+#define HDMI_AHB_DMA_MBLENGTH1                  0x3611
+#define HDMI_AHB_DMA_STAT                       0x3612
+#define HDMI_AHB_DMA_INT                        0x3613
+#define HDMI_AHB_DMA_MASK                       0x3614
+#define HDMI_AHB_DMA_POL                        0x3615
+#define HDMI_AHB_DMA_CONF1                      0x3616
+#define HDMI_AHB_DMA_BUFFSTAT                   0x3617
+#define HDMI_AHB_DMA_BUFFINT                    0x3618
+#define HDMI_AHB_DMA_BUFFMASK                   0x3619
+#define HDMI_AHB_DMA_BUFFPOL                    0x361a
+
+/* Main Controller Registers */
+#define HDMI_MC_SFRDIV                          0x4000
+#define HDMI_MC_CLKDIS                          0x4001
+#define HDMI_MC_SWRSTZ                          0x4002
+#define HDMI_MC_OPCTRL                          0x4003
+#define HDMI_MC_FLOWCTRL                        0x4004
+#define HDMI_MC_PHYRSTZ                         0x4005
+#define HDMI_MC_LOCKONCLOCK                     0x4006
+#define HDMI_MC_HEACPHY_RST                     0x4007
+
+/* Color Space  Converter Registers */
+#define HDMI_CSC_CFG                            0x4100
+#define HDMI_CSC_SCALE                          0x4101
+#define HDMI_CSC_COEF_A1_MSB                    0x4102
+#define HDMI_CSC_COEF_A1_LSB                    0x4103
+#define HDMI_CSC_COEF_A2_MSB                    0x4104
+#define HDMI_CSC_COEF_A2_LSB                    0x4105
+#define HDMI_CSC_COEF_A3_MSB                    0x4106
+#define HDMI_CSC_COEF_A3_LSB                    0x4107
+#define HDMI_CSC_COEF_A4_MSB                    0x4108
+#define HDMI_CSC_COEF_A4_LSB                    0x4109
+#define HDMI_CSC_COEF_B1_MSB                    0x410A
+#define HDMI_CSC_COEF_B1_LSB                    0x410B
+#define HDMI_CSC_COEF_B2_MSB                    0x410C
+#define HDMI_CSC_COEF_B2_LSB                    0x410D
+#define HDMI_CSC_COEF_B3_MSB                    0x410E
+#define HDMI_CSC_COEF_B3_LSB                    0x410F
+#define HDMI_CSC_COEF_B4_MSB                    0x4110
+#define HDMI_CSC_COEF_B4_LSB                    0x4111
+#define HDMI_CSC_COEF_C1_MSB                    0x4112
+#define HDMI_CSC_COEF_C1_LSB                    0x4113
+#define HDMI_CSC_COEF_C2_MSB                    0x4114
+#define HDMI_CSC_COEF_C2_LSB                    0x4115
+#define HDMI_CSC_COEF_C3_MSB                    0x4116
+#define HDMI_CSC_COEF_C3_LSB                    0x4117
+#define HDMI_CSC_COEF_C4_MSB                    0x4118
+#define HDMI_CSC_COEF_C4_LSB                    0x4119
+
+/* HDCP Encryption Engine Registers */
+#define HDMI_A_HDCPCFG0                         0x5000
+#define HDMI_A_HDCPCFG1                         0x5001
+#define HDMI_A_HDCPOBS0                         0x5002
+#define HDMI_A_HDCPOBS1                         0x5003
+#define HDMI_A_HDCPOBS2                         0x5004
+#define HDMI_A_HDCPOBS3                         0x5005
+#define HDMI_A_APIINTCLR                        0x5006
+#define HDMI_A_APIINTSTAT                       0x5007
+#define HDMI_A_APIINTMSK                        0x5008
+#define HDMI_A_VIDPOLCFG                        0x5009
+#define HDMI_A_OESSWCFG                         0x500A
+#define HDMI_A_TIMER1SETUP0                     0x500B
+#define HDMI_A_TIMER1SETUP1                     0x500C
+#define HDMI_A_TIMER2SETUP0                     0x500D
+#define HDMI_A_TIMER2SETUP1                     0x500E
+#define HDMI_A_100MSCFG                         0x500F
+#define HDMI_A_2SCFG0                           0x5010
+#define HDMI_A_2SCFG1                           0x5011
+#define HDMI_A_5SCFG0                           0x5012
+#define HDMI_A_5SCFG1                           0x5013
+#define HDMI_A_SRMVERLSB                        0x5014
+#define HDMI_A_SRMVERMSB                        0x5015
+#define HDMI_A_SRMCTRL                          0x5016
+#define HDMI_A_SFRSETUP                         0x5017
+#define HDMI_A_I2CHSETUP                        0x5018
+#define HDMI_A_INTSETUP                         0x5019
+#define HDMI_A_PRESETUP                         0x501A
+#define HDMI_A_SRM_BASE                         0x5020
+
+/* HDCP Registers */
+#define HDMI_HDCPREG_RMCTL                      0x780e
+#define HDMI_HDCPREG_RMSTS                      0x780f
+#define HDMI_HDCPREG_SEED0                      0x7810
+#define HDMI_HDCPREG_SEED1                      0x7811
+#define HDMI_HDCPREG_DPK0                       0x7812
+#define HDMI_HDCPREG_DPK1                       0x7813
+#define HDMI_HDCPREG_DPK2                       0x7814
+#define HDMI_HDCPREG_DPK3                       0x7815
+#define HDMI_HDCPREG_DPK4                       0x7816
+#define HDMI_HDCPREG_DPK5                       0x7817
+#define HDMI_HDCPREG_DPK6                       0x7818
+#define HDMI_HDCP2REG_CTRL                      0x7904
+#define HDMI_HDCP2REG_MASK                      0x790c
+#define HDMI_HDCP2REG_MUTE                      0x790e
+
+/* CEC Engine Registers */
+#define HDMI_CEC_CTRL                           0x7D00
+#define HDMI_CEC_STAT                           0x7D01
+#define HDMI_CEC_MASK                           0x7D02
+#define HDMI_CEC_POLARITY                       0x7D03
+#define HDMI_CEC_INT                            0x7D04
+#define HDMI_CEC_ADDR_L                         0x7D05
+#define HDMI_CEC_ADDR_H                         0x7D06
+#define HDMI_CEC_TX_CNT                         0x7D07
+#define HDMI_CEC_RX_CNT                         0x7D08
+#define HDMI_CEC_TX_DATA0                       0x7D10
+#define HDMI_CEC_TX_DATA1                       0x7D11
+#define HDMI_CEC_TX_DATA2                       0x7D12
+#define HDMI_CEC_TX_DATA3                       0x7D13
+#define HDMI_CEC_TX_DATA4                       0x7D14
+#define HDMI_CEC_TX_DATA5                       0x7D15
+#define HDMI_CEC_TX_DATA6                       0x7D16
+#define HDMI_CEC_TX_DATA7                       0x7D17
+#define HDMI_CEC_TX_DATA8                       0x7D18
+#define HDMI_CEC_TX_DATA9                       0x7D19
+#define HDMI_CEC_TX_DATA10                      0x7D1a
+#define HDMI_CEC_TX_DATA11                      0x7D1b
+#define HDMI_CEC_TX_DATA12                      0x7D1c
+#define HDMI_CEC_TX_DATA13                      0x7D1d
+#define HDMI_CEC_TX_DATA14                      0x7D1e
+#define HDMI_CEC_TX_DATA15                      0x7D1f
+#define HDMI_CEC_RX_DATA0                       0x7D20
+#define HDMI_CEC_RX_DATA1                       0x7D21
+#define HDMI_CEC_RX_DATA2                       0x7D22
+#define HDMI_CEC_RX_DATA3                       0x7D23
+#define HDMI_CEC_RX_DATA4                       0x7D24
+#define HDMI_CEC_RX_DATA5                       0x7D25
+#define HDMI_CEC_RX_DATA6                       0x7D26
+#define HDMI_CEC_RX_DATA7                       0x7D27
+#define HDMI_CEC_RX_DATA8                       0x7D28
+#define HDMI_CEC_RX_DATA9                       0x7D29
+#define HDMI_CEC_RX_DATA10                      0x7D2a
+#define HDMI_CEC_RX_DATA11                      0x7D2b
+#define HDMI_CEC_RX_DATA12                      0x7D2c
+#define HDMI_CEC_RX_DATA13                      0x7D2d
+#define HDMI_CEC_RX_DATA14                      0x7D2e
+#define HDMI_CEC_RX_DATA15                      0x7D2f
+#define HDMI_CEC_LOCK                           0x7D30
+#define HDMI_CEC_WKUPCTRL                       0x7D31
+
+/* I2C Master Registers (E-DDC) */
+#define HDMI_I2CM_SLAVE                         0x7E00
+#define HDMI_I2CM_ADDRESS                       0x7E01
+#define HDMI_I2CM_DATAO                         0x7E02
+#define HDMI_I2CM_DATAI                         0x7E03
+#define HDMI_I2CM_OPERATION                     0x7E04
+#define HDMI_I2CM_INT                           0x7E05
+#define HDMI_I2CM_CTLINT                        0x7E06
+#define HDMI_I2CM_DIV                           0x7E07
+#define HDMI_I2CM_SEGADDR                       0x7E08
+#define HDMI_I2CM_SOFTRSTZ                      0x7E09
+#define HDMI_I2CM_SEGPTR                        0x7E0A
+#define HDMI_I2CM_SS_SCL_HCNT_1_ADDR            0x7E0B
+#define HDMI_I2CM_SS_SCL_HCNT_0_ADDR            0x7E0C
+#define HDMI_I2CM_SS_SCL_LCNT_1_ADDR            0x7E0D
+#define HDMI_I2CM_SS_SCL_LCNT_0_ADDR            0x7E0E
+#define HDMI_I2CM_FS_SCL_HCNT_1_ADDR            0x7E0F
+#define HDMI_I2CM_FS_SCL_HCNT_0_ADDR            0x7E10
+#define HDMI_I2CM_FS_SCL_LCNT_1_ADDR            0x7E11
+#define HDMI_I2CM_FS_SCL_LCNT_0_ADDR            0x7E12
+#define HDMI_I2CM_SDA_HOLD                      0x7E13
+#define HDMI_I2CM_SCDC_READ_UPDATE              0x7E14
+#define HDMI_I2CM_READ_REQ_EN_MSK               BIT(4)
+#define HDMI_I2CM_READ_REQ_EN_OFFSET            4
+#define HDMI_I2CM_READ_UPDATE_MSK               BIT(0)
+#define HDMI_I2CM_READ_UPDATE_OFFSET            0
+#define HDMI_I2CM_I2CM_UPRD_VSYNC_EN_MSK        BIT(5)
+#define HDMI_I2CM_I2CM_UPRD_VSYNC_EN_OFFSET     5
+#define	HDMI_I2CM_READ_BUFF0                    0x7E20
+#define	HDMI_I2CM_SCDC_UPDATE0                  0x7E30
+#define	HDMI_I2CM_SCDC_UPDATE1                  0x7E31
+#define DDC_I2C_EDID_ADDR                       0x50
+#define DDC_I2C_SEG_ADDR                        0x30
+#define DDC_I2C_SCDC_ADDR                       0x54
+#define HDMI_EDID_BLOCK_SIZE                    128
+#define EDID_I2C_MIN_SS_SCL_HIGH_TIME           9625
+#define EDID_I2C_MIN_SS_SCL_LOW_TIME            10000
+#define I2C_DIV_FACTOR                          1000000
+
+/* SCDC Registers */
+#define SCDC_SINK_VERSION 0x01
+#define SCDC_SOURCE_VERSION 0x02
+
+#define SCDC_UPDATE_0 0x10
+#define SCDC_READ_REQUEST_TEST BIT(2)
+#define SCDC_CED_UPDATE BIT(1)
+#define SCDC_STATUS_UPDATE BIT(0)
+#define SCDC_UPDATE_1 0x11
+
+#define SCDC_TMDS_CONFIG 0x20
+#define SCDC_TMDS_BIT_CLOCK_RATIO_BY_40 BIT(1)
+#define SCDC_TMDS_BIT_CLOCK_RATIO_BY_10 (0 << 1)
+#define SCDC_SCRAMBLING_ENABLE BIT(0)
+#define SCDC_SCRAMBLER_STATUS 0x21
+#define SCDC_SCRAMBLING_STATUS BIT(0)
+
+#define SCDC_CONFIG_0 0x30
+#define SCDC_READ_REQUEST_ENABLE BIT(0)
+
+#define SCDC_STATUS_FLAGS_0 0x40
+#define SCDC_CH2_LOCK BIT(3)
+#define SCDC_CH1_LOCK BIT(2)
+#define SCDC_CH0_LOCK BIT(1)
+#define SCDC_CH_LOCK_MASK (SCDC_CH2_LOCK | SCDC_CH1_LOCK | SCDC_CH0_LOCK)
+#define SCDC_CLOCK_DETECT BIT(0)
+#define SCDC_STATUS_FLAGS_1 0x41
+
+#define SCDC_ERR_DET_0_L 0x50
+#define SCDC_ERR_DET_0_H 0x51
+#define SCDC_ERR_DET_1_L 0x52
+#define SCDC_ERR_DET_1_H 0x53
+#define SCDC_ERR_DET_2_L 0x54
+#define SCDC_ERR_DET_2_H 0x55
+#define SCDC_CHANNEL_VALID BIT(7)
+#define SCDC_ERR_DET_CHECKSUM 0x56
+
+#define SCDC_TEST_CONFIG_0 0xc0
+#define SCDC_TEST_READ_REQUEST BIT(7)
+#define SCDC_TEST_READ_REQUEST_DELAY(x) ((x) & 0x7f)
+
+#define SCDC_MANUFACTURER_IEEE_OUI 0xd0
+#define SCDC_MANUFACTURER_IEEE_OUI_SIZE 3
+#define SCDC_DEVICE_ID 0xd3
+#define SCDC_DEVICE_ID_SIZE 8
+#define SCDC_DEVICE_HARDWARE_REVISION 0xdb
+#define SCDC_DEVICE_HARDWARE_REVISION_MAJOR(x) (((x) >> 4) & 0xf)
+#define SCDC_DEVICE_HARDWARE_REVISION_MINOR(x) (((x) >> 0) & 0xf)
+#define SCDC_DEVICE_SOFTWARE_MAJOR_REVISION 0xdc
+#define SCDC_DEVICE_SOFTWARE_MINOR_REVISION 0xdd
+
+#define SCDC_MANUFACTURER_SPECIFIC 0xde
+#define SCDC_MANUFACTURER_SPECIFIC_SIZE 34
+
+enum {
+/* PRODUCT_ID0 field values */
+	HDMI_PRODUCT_ID0_HDMI_TX = 0xa0,
+
+/* PRODUCT_ID1 field values */
+	HDMI_PRODUCT_ID1_HDCP = 0xc0,
+	HDMI_PRODUCT_ID1_HDMI_RX = 0x02,
+	HDMI_PRODUCT_ID1_HDMI_TX = 0x01,
+
+/* CONFIG0_ID field values */
+	HDMI_CONFIG0_I2S = 0x10,
+
+/* CONFIG1_ID field values */
+	HDMI_CONFIG1_AHB = 0x01,
+
+/* CONFIG3_ID field values */
+	HDMI_CONFIG3_AHBAUDDMA = 0x02,
+	HDMI_CONFIG3_GPAUD = 0x01,
+
+/* IH_FC_INT2 field values */
+	HDMI_IH_FC_INT2_OVERFLOW_MASK = 0x03,
+	HDMI_IH_FC_INT2_LOW_PRIORITY_OVERFLOW = 0x02,
+	HDMI_IH_FC_INT2_HIGH_PRIORITY_OVERFLOW = 0x01,
+
+/* IH_FC_STAT2 field values */
+	HDMI_IH_FC_STAT2_OVERFLOW_MASK = 0x03,
+	HDMI_IH_FC_STAT2_LOW_PRIORITY_OVERFLOW = 0x02,
+	HDMI_IH_FC_STAT2_HIGH_PRIORITY_OVERFLOW = 0x01,
+
+/* IH_PHY_STAT0 field values */
+	HDMI_IH_PHY_STAT0_RX_SENSE3 = 0x20,
+	HDMI_IH_PHY_STAT0_RX_SENSE2 = 0x10,
+	HDMI_IH_PHY_STAT0_RX_SENSE1 = 0x8,
+	HDMI_IH_PHY_STAT0_RX_SENSE0 = 0x4,
+	HDMI_IH_PHY_STAT0_TX_PHY_LOCK = 0x2,
+	HDMI_IH_PHY_STAT0_HPD = 0x1,
+
+/* IH_I2CM_STAT0 and IH_MUTE_I2CM_STAT0 field values */
+	HDMI_IH_I2CM_STAT0_DONE = 0x2,
+	HDMI_IH_I2CM_STAT0_ERROR = 0x1,
+
+/* IH_MUTE_I2CMPHY_STAT0 field values */
+	HDMI_IH_MUTE_I2CMPHY_STAT0_I2CMPHYDONE = 0x2,
+	HDMI_IH_MUTE_I2CMPHY_STAT0_I2CMPHYERROR = 0x1,
+
+/* IH_AHBDMAAUD_STAT0 field values */
+	HDMI_IH_AHBDMAAUD_STAT0_ERROR = 0x20,
+	HDMI_IH_AHBDMAAUD_STAT0_LOST = 0x10,
+	HDMI_IH_AHBDMAAUD_STAT0_RETRY = 0x08,
+	HDMI_IH_AHBDMAAUD_STAT0_DONE = 0x04,
+	HDMI_IH_AHBDMAAUD_STAT0_BUFFFULL = 0x02,
+	HDMI_IH_AHBDMAAUD_STAT0_BUFFEMPTY = 0x01,
+
+/* IH_MUTE_FC_STAT2 field values */
+	HDMI_IH_MUTE_FC_STAT2_OVERFLOW_MASK = 0x03,
+	HDMI_IH_MUTE_FC_STAT2_LOW_PRIORITY_OVERFLOW = 0x02,
+	HDMI_IH_MUTE_FC_STAT2_HIGH_PRIORITY_OVERFLOW = 0x01,
+
+/* IH_MUTE_AHBDMAAUD_STAT0 field values */
+	HDMI_IH_MUTE_AHBDMAAUD_STAT0_ERROR = 0x20,
+	HDMI_IH_MUTE_AHBDMAAUD_STAT0_LOST = 0x10,
+	HDMI_IH_MUTE_AHBDMAAUD_STAT0_RETRY = 0x08,
+	HDMI_IH_MUTE_AHBDMAAUD_STAT0_DONE = 0x04,
+	HDMI_IH_MUTE_AHBDMAAUD_STAT0_BUFFFULL = 0x02,
+	HDMI_IH_MUTE_AHBDMAAUD_STAT0_BUFFEMPTY = 0x01,
+
+/* IH_MUTE field values */
+	HDMI_IH_MUTE_MUTE_WAKEUP_INTERRUPT = 0x2,
+	HDMI_IH_MUTE_MUTE_ALL_INTERRUPT = 0x1,
+
+/* TX_INVID0 field values */
+	HDMI_TX_INVID0_INTERNAL_DE_GENERATOR_MASK = 0x80,
+	HDMI_TX_INVID0_INTERNAL_DE_GENERATOR_ENABLE = 0x80,
+	HDMI_TX_INVID0_INTERNAL_DE_GENERATOR_DISABLE = 0x00,
+	HDMI_TX_INVID0_VIDEO_MAPPING_MASK = 0x1F,
+	HDMI_TX_INVID0_VIDEO_MAPPING_OFFSET = 0,
+
+/* TX_INSTUFFING field values */
+	HDMI_TX_INSTUFFING_BDBDATA_STUFFING_MASK = 0x4,
+	HDMI_TX_INSTUFFING_BDBDATA_STUFFING_ENABLE = 0x4,
+	HDMI_TX_INSTUFFING_BDBDATA_STUFFING_DISABLE = 0x0,
+	HDMI_TX_INSTUFFING_RCRDATA_STUFFING_MASK = 0x2,
+	HDMI_TX_INSTUFFING_RCRDATA_STUFFING_ENABLE = 0x2,
+	HDMI_TX_INSTUFFING_RCRDATA_STUFFING_DISABLE = 0x0,
+	HDMI_TX_INSTUFFING_GYDATA_STUFFING_MASK = 0x1,
+	HDMI_TX_INSTUFFING_GYDATA_STUFFING_ENABLE = 0x1,
+	HDMI_TX_INSTUFFING_GYDATA_STUFFING_DISABLE = 0x0,
+
+/* VP_PR_CD field values */
+	HDMI_VP_PR_CD_COLOR_DEPTH_MASK = 0xF0,
+	HDMI_VP_PR_CD_COLOR_DEPTH_OFFSET = 4,
+	HDMI_VP_PR_CD_DESIRED_PR_FACTOR_MASK = 0x0F,
+	HDMI_VP_PR_CD_DESIRED_PR_FACTOR_OFFSET = 0,
+
+/* VP_STUFF field values */
+	HDMI_VP_STUFF_IDEFAULT_PHASE_MASK = 0x20,
+	HDMI_VP_STUFF_IDEFAULT_PHASE_OFFSET = 5,
+	HDMI_VP_STUFF_IFIX_PP_TO_LAST_MASK = 0x10,
+	HDMI_VP_STUFF_IFIX_PP_TO_LAST_OFFSET = 4,
+	HDMI_VP_STUFF_ICX_GOTO_P0_ST_MASK = 0x8,
+	HDMI_VP_STUFF_ICX_GOTO_P0_ST_OFFSET = 3,
+	HDMI_VP_STUFF_YCC422_STUFFING_MASK = 0x4,
+	HDMI_VP_STUFF_YCC422_STUFFING_STUFFING_MODE = 0x4,
+	HDMI_VP_STUFF_YCC422_STUFFING_DIRECT_MODE = 0x0,
+	HDMI_VP_STUFF_PP_STUFFING_MASK = 0x2,
+	HDMI_VP_STUFF_PP_STUFFING_STUFFING_MODE = 0x2,
+	HDMI_VP_STUFF_PP_STUFFING_DIRECT_MODE = 0x0,
+	HDMI_VP_STUFF_PR_STUFFING_MASK = 0x1,
+	HDMI_VP_STUFF_PR_STUFFING_STUFFING_MODE = 0x1,
+	HDMI_VP_STUFF_PR_STUFFING_DIRECT_MODE = 0x0,
+
+/* VP_CONF field values */
+	HDMI_VP_CONF_BYPASS_EN_MASK = 0x40,
+	HDMI_VP_CONF_BYPASS_EN_ENABLE = 0x40,
+	HDMI_VP_CONF_BYPASS_EN_DISABLE = 0x00,
+	HDMI_VP_CONF_PP_EN_ENMASK = 0x20,
+	HDMI_VP_CONF_PP_EN_ENABLE = 0x20,
+	HDMI_VP_CONF_PP_EN_DISABLE = 0x00,
+	HDMI_VP_CONF_PR_EN_MASK = 0x10,
+	HDMI_VP_CONF_PR_EN_ENABLE = 0x10,
+	HDMI_VP_CONF_PR_EN_DISABLE = 0x00,
+	HDMI_VP_CONF_YCC422_EN_MASK = 0x8,
+	HDMI_VP_CONF_YCC422_EN_ENABLE = 0x8,
+	HDMI_VP_CONF_YCC422_EN_DISABLE = 0x0,
+	HDMI_VP_CONF_BYPASS_SELECT_MASK = 0x4,
+	HDMI_VP_CONF_BYPASS_SELECT_VID_PACKETIZER = 0x4,
+	HDMI_VP_CONF_BYPASS_SELECT_PIX_REPEATER = 0x0,
+	HDMI_VP_CONF_OUTPUT_SELECTOR_MASK = 0x3,
+	HDMI_VP_CONF_OUTPUT_SELECTOR_BYPASS = 0x3,
+	HDMI_VP_CONF_OUTPUT_SELECTOR_YCC422 = 0x1,
+	HDMI_VP_CONF_OUTPUT_SELECTOR_PP = 0x0,
+
+/* VP_REMAP field values */
+	HDMI_VP_REMAP_MASK = 0x3,
+	HDMI_VP_REMAP_YCC422_24bit = 0x2,
+	HDMI_VP_REMAP_YCC422_20bit = 0x1,
+	HDMI_VP_REMAP_YCC422_16bit = 0x0,
+
+/* FC_INVIDCONF field values */
+	HDMI_FC_INVIDCONF_HDCP_KEEPOUT_MASK = 0x80,
+	HDMI_FC_INVIDCONF_HDCP_KEEPOUT_ACTIVE = 0x80,
+	HDMI_FC_INVIDCONF_HDCP_KEEPOUT_INACTIVE = 0x00,
+	HDMI_FC_INVIDCONF_VSYNC_IN_POLARITY_MASK = 0x40,
+	HDMI_FC_INVIDCONF_VSYNC_IN_POLARITY_ACTIVE_HIGH = 0x40,
+	HDMI_FC_INVIDCONF_VSYNC_IN_POLARITY_ACTIVE_LOW = 0x00,
+	HDMI_FC_INVIDCONF_HSYNC_IN_POLARITY_MASK = 0x20,
+	HDMI_FC_INVIDCONF_HSYNC_IN_POLARITY_ACTIVE_HIGH = 0x20,
+	HDMI_FC_INVIDCONF_HSYNC_IN_POLARITY_ACTIVE_LOW = 0x00,
+	HDMI_FC_INVIDCONF_DE_IN_POLARITY_MASK = 0x10,
+	HDMI_FC_INVIDCONF_DE_IN_POLARITY_ACTIVE_HIGH = 0x10,
+	HDMI_FC_INVIDCONF_DE_IN_POLARITY_ACTIVE_LOW = 0x00,
+	HDMI_FC_INVIDCONF_DVI_MODEZ_MASK = 0x8,
+	HDMI_FC_INVIDCONF_DVI_MODEZ_HDMI_MODE = 0x8,
+	HDMI_FC_INVIDCONF_DVI_MODEZ_DVI_MODE = 0x0,
+	HDMI_FC_INVIDCONF_R_V_BLANK_IN_OSC_MASK = 0x2,
+	HDMI_FC_INVIDCONF_R_V_BLANK_IN_OSC_ACTIVE_HIGH = 0x2,
+	HDMI_FC_INVIDCONF_R_V_BLANK_IN_OSC_ACTIVE_LOW = 0x0,
+	HDMI_FC_INVIDCONF_IN_I_P_MASK = 0x1,
+	HDMI_FC_INVIDCONF_IN_I_P_INTERLACED = 0x1,
+	HDMI_FC_INVIDCONF_IN_I_P_PROGRESSIVE = 0x0,
+
+/* FC_AUDICONF0 field values */
+	HDMI_FC_AUDICONF0_CC_OFFSET = 4,
+	HDMI_FC_AUDICONF0_CC_MASK = 0x70,
+	HDMI_FC_AUDICONF0_CT_OFFSET = 0,
+	HDMI_FC_AUDICONF0_CT_MASK = 0xF,
+
+/* FC_AUDICONF1 field values */
+	HDMI_FC_AUDICONF1_SS_OFFSET = 3,
+	HDMI_FC_AUDICONF1_SS_MASK = 0x18,
+	HDMI_FC_AUDICONF1_SF_OFFSET = 0,
+	HDMI_FC_AUDICONF1_SF_MASK = 0x7,
+
+/* FC_AUDICONF3 field values */
+	HDMI_FC_AUDICONF3_LFEPBL_OFFSET = 5,
+	HDMI_FC_AUDICONF3_LFEPBL_MASK = 0x60,
+	HDMI_FC_AUDICONF3_DM_INH_OFFSET = 4,
+	HDMI_FC_AUDICONF3_DM_INH_MASK = 0x10,
+	HDMI_FC_AUDICONF3_LSV_OFFSET = 0,
+	HDMI_FC_AUDICONF3_LSV_MASK = 0xF,
+
+/* FC_AUDSCHNLS0 field values */
+	HDMI_FC_AUDSCHNLS0_CGMSA_OFFSET = 4,
+	HDMI_FC_AUDSCHNLS0_CGMSA_MASK = 0x30,
+	HDMI_FC_AUDSCHNLS0_COPYRIGHT_OFFSET = 0,
+	HDMI_FC_AUDSCHNLS0_COPYRIGHT_MASK = 0x01,
+
+/* FC_AUDSCHNLS3-6 field values */
+	HDMI_FC_AUDSCHNLS3_OIEC_CH0_OFFSET = 0,
+	HDMI_FC_AUDSCHNLS3_OIEC_CH0_MASK = 0x0f,
+	HDMI_FC_AUDSCHNLS3_OIEC_CH1_OFFSET = 4,
+	HDMI_FC_AUDSCHNLS3_OIEC_CH1_MASK = 0xf0,
+	HDMI_FC_AUDSCHNLS4_OIEC_CH2_OFFSET = 0,
+	HDMI_FC_AUDSCHNLS4_OIEC_CH2_MASK = 0x0f,
+	HDMI_FC_AUDSCHNLS4_OIEC_CH3_OFFSET = 4,
+	HDMI_FC_AUDSCHNLS4_OIEC_CH3_MASK = 0xf0,
+
+	HDMI_FC_AUDSCHNLS5_OIEC_CH0_OFFSET = 0,
+	HDMI_FC_AUDSCHNLS5_OIEC_CH0_MASK = 0x0f,
+	HDMI_FC_AUDSCHNLS5_OIEC_CH1_OFFSET = 4,
+	HDMI_FC_AUDSCHNLS5_OIEC_CH1_MASK = 0xf0,
+	HDMI_FC_AUDSCHNLS6_OIEC_CH2_OFFSET = 0,
+	HDMI_FC_AUDSCHNLS6_OIEC_CH2_MASK = 0x0f,
+	HDMI_FC_AUDSCHNLS6_OIEC_CH3_OFFSET = 4,
+	HDMI_FC_AUDSCHNLS6_OIEC_CH3_MASK = 0xf0,
+
+/* HDMI_FC_AUDSCHNLS7 field values */
+	HDMI_FC_AUDSCHNLS7_ACCURACY_OFFSET = 4,
+	HDMI_FC_AUDSCHNLS7_ACCURACY_MASK = 0x30,
+	HDMI_FC_AUDSCHNLS7_SAMPFREQ_OFFSET = 0,
+	HDMI_FC_AUDSCHNLS7_SAMPFREQ_MASK = 0x0f,
+
+/* HDMI_FC_AUDSCHNLS8 field values */
+	HDMI_FC_AUDSCHNLS8_ORIGSAMPFREQ_MASK = 0xf0,
+	HDMI_FC_AUDSCHNLS8_ORIGSAMPFREQ_OFFSET = 4,
+	HDMI_FC_AUDSCHNLS8_WORDLEGNTH_MASK = 0x0f,
+	HDMI_FC_AUDSCHNLS8_WORDLEGNTH_OFFSET = 0,
+
+/* HDMI_FC_AUDSCHNLS Sample Rate */
+	HDMI_FC_AUDSCHNLS_32K = 0x3,
+	HDMI_FC_AUDSCHNLS_441K = 0x0,
+	HDMI_FC_AUDSCHNLS_48K = 0x2,
+	HDMI_FC_AUDSCHNLS_882K = 0x8,
+	HDMI_FC_AUDSCHNLS_96K = 0xa,
+	HDMI_FC_AUDSCHNLS_1764K = 0xc,
+	HDMI_FC_AUDSCHNLS_192K = 0xe,
+
+/* FC_AUDSCONF field values */
+	HDMI_FC_AUDSCONF_AUD_PACKET_SAMPFIT_MASK = 0xF0,
+	HDMI_FC_AUDSCONF_AUD_PACKET_SAMPFIT_OFFSET = 4,
+	HDMI_FC_AUDSCONF_AUD_PACKET_LAYOUT_MASK = 0x1,
+	HDMI_FC_AUDSCONF_AUD_PACKET_LAYOUT_OFFSET = 0,
+	HDMI_FC_AUDSCONF_AUD_PACKET_LAYOUT_LAYOUT1 = 0x1,
+	HDMI_FC_AUDSCONF_AUD_PACKET_LAYOUT_LAYOUT0 = 0x0,
+
+/* FC_STAT2 field values */
+	HDMI_FC_STAT2_OVERFLOW_MASK = 0x03,
+	HDMI_FC_STAT2_LOW_PRIORITY_OVERFLOW = 0x02,
+	HDMI_FC_STAT2_HIGH_PRIORITY_OVERFLOW = 0x01,
+
+/* FC_INT2 field values */
+	HDMI_FC_INT2_OVERFLOW_MASK = 0x03,
+	HDMI_FC_INT2_LOW_PRIORITY_OVERFLOW = 0x02,
+	HDMI_FC_INT2_HIGH_PRIORITY_OVERFLOW = 0x01,
+
+/* FC_MASK2 field values */
+	HDMI_FC_MASK2_OVERFLOW_MASK = 0x03,
+	HDMI_FC_MASK2_LOW_PRIORITY_OVERFLOW = 0x02,
+	HDMI_FC_MASK2_HIGH_PRIORITY_OVERFLOW = 0x01,
+
+/* FC_PRCONF field values */
+	HDMI_FC_PRCONF_INCOMING_PR_FACTOR_MASK = 0xF0,
+	HDMI_FC_PRCONF_INCOMING_PR_FACTOR_OFFSET = 4,
+	HDMI_FC_PRCONF_OUTPUT_PR_FACTOR_MASK = 0x0F,
+	HDMI_FC_PRCONF_OUTPUT_PR_FACTOR_OFFSET = 0,
+
+/* FC_AVICONF0-FC_AVICONF3 field values */
+	HDMI_FC_AVICONF0_PIX_FMT_MASK = 0x03,
+	HDMI_FC_AVICONF0_PIX_FMT_RGB = 0x00,
+	HDMI_FC_AVICONF0_PIX_FMT_YCBCR422 = 0x01,
+	HDMI_FC_AVICONF0_PIX_FMT_YCBCR444 = 0x02,
+	HDMI_FC_AVICONF0_ACTIVE_FMT_MASK = 0x40,
+	HDMI_FC_AVICONF0_ACTIVE_FMT_INFO_PRESENT = 0x40,
+	HDMI_FC_AVICONF0_ACTIVE_FMT_NO_INFO = 0x00,
+	HDMI_FC_AVICONF0_BAR_DATA_MASK = 0x0C,
+	HDMI_FC_AVICONF0_BAR_DATA_NO_DATA = 0x00,
+	HDMI_FC_AVICONF0_BAR_DATA_VERT_BAR = 0x04,
+	HDMI_FC_AVICONF0_BAR_DATA_HORIZ_BAR = 0x08,
+	HDMI_FC_AVICONF0_BAR_DATA_VERT_HORIZ_BAR = 0x0C,
+	HDMI_FC_AVICONF0_SCAN_INFO_MASK = 0x30,
+	HDMI_FC_AVICONF0_SCAN_INFO_OVERSCAN = 0x10,
+	HDMI_FC_AVICONF0_SCAN_INFO_UNDERSCAN = 0x20,
+	HDMI_FC_AVICONF0_SCAN_INFO_NODATA = 0x00,
+
+	HDMI_FC_AVICONF1_ACTIVE_ASPECT_RATIO_MASK = 0x0F,
+	HDMI_FC_AVICONF1_ACTIVE_ASPECT_RATIO_USE_CODED = 0x08,
+	HDMI_FC_AVICONF1_ACTIVE_ASPECT_RATIO_4_3 = 0x09,
+	HDMI_FC_AVICONF1_ACTIVE_ASPECT_RATIO_16_9 = 0x0A,
+	HDMI_FC_AVICONF1_ACTIVE_ASPECT_RATIO_14_9 = 0x0B,
+	HDMI_FC_AVICONF1_CODED_ASPECT_RATIO_MASK = 0x30,
+	HDMI_FC_AVICONF1_CODED_ASPECT_RATIO_NO_DATA = 0x00,
+	HDMI_FC_AVICONF1_CODED_ASPECT_RATIO_4_3 = 0x10,
+	HDMI_FC_AVICONF1_CODED_ASPECT_RATIO_16_9 = 0x20,
+	HDMI_FC_AVICONF1_COLORIMETRY_MASK = 0xC0,
+	HDMI_FC_AVICONF1_COLORIMETRY_NO_DATA = 0x00,
+	HDMI_FC_AVICONF1_COLORIMETRY_SMPTE = 0x40,
+	HDMI_FC_AVICONF1_COLORIMETRY_ITUR = 0x80,
+	HDMI_FC_AVICONF1_COLORIMETRY_EXTENDED_INFO = 0xC0,
+
+	HDMI_FC_AVICONF2_SCALING_MASK = 0x03,
+	HDMI_FC_AVICONF2_SCALING_NONE = 0x00,
+	HDMI_FC_AVICONF2_SCALING_HORIZ = 0x01,
+	HDMI_FC_AVICONF2_SCALING_VERT = 0x02,
+	HDMI_FC_AVICONF2_SCALING_HORIZ_VERT = 0x03,
+	HDMI_FC_AVICONF2_RGB_QUANT_MASK = 0x0C,
+	HDMI_FC_AVICONF2_RGB_QUANT_DEFAULT = 0x00,
+	HDMI_FC_AVICONF2_RGB_QUANT_LIMITED_RANGE = 0x04,
+	HDMI_FC_AVICONF2_RGB_QUANT_FULL_RANGE = 0x08,
+	HDMI_FC_AVICONF2_EXT_COLORIMETRY_MASK = 0x70,
+	HDMI_FC_AVICONF2_EXT_COLORIMETRY_XVYCC601 = 0x00,
+	HDMI_FC_AVICONF2_EXT_COLORIMETRY_XVYCC709 = 0x10,
+	HDMI_FC_AVICONF2_EXT_COLORIMETRY_SYCC601 = 0x20,
+	HDMI_FC_AVICONF2_EXT_COLORIMETRY_ADOBE_YCC601 = 0x30,
+	HDMI_FC_AVICONF2_EXT_COLORIMETRY_ADOBE_RGB = 0x40,
+	HDMI_FC_AVICONF2_IT_CONTENT_MASK = 0x80,
+	HDMI_FC_AVICONF2_IT_CONTENT_NO_DATA = 0x00,
+	HDMI_FC_AVICONF2_IT_CONTENT_VALID = 0x80,
+
+	HDMI_FC_AVICONF3_IT_CONTENT_TYPE_MASK = 0x03,
+	HDMI_FC_AVICONF3_IT_CONTENT_TYPE_GRAPHICS = 0x00,
+	HDMI_FC_AVICONF3_IT_CONTENT_TYPE_PHOTO = 0x01,
+	HDMI_FC_AVICONF3_IT_CONTENT_TYPE_CINEMA = 0x02,
+	HDMI_FC_AVICONF3_IT_CONTENT_TYPE_GAME = 0x03,
+	HDMI_FC_AVICONF3_QUANT_RANGE_MASK = 0x0C,
+	HDMI_FC_AVICONF3_QUANT_RANGE_LIMITED = 0x00,
+	HDMI_FC_AVICONF3_QUANT_RANGE_FULL = 0x04,
+
+/* FC_DBGFORCE field values */
+	HDMI_FC_DBGFORCE_FORCEAUDIO = 0x10,
+	HDMI_FC_DBGFORCE_FORCEVIDEO = 0x1,
+
+/* FC_DATAUTO0 field values */
+	HDMI_FC_DATAUTO0_VSD_MASK = 0x08,
+	HDMI_FC_DATAUTO0_VSD_OFFSET = 3,
+
+/* PHY_CONF0 field values */
+	HDMI_PHY_CONF0_PDZ_MASK = 0x80,
+	HDMI_PHY_CONF0_PDZ_OFFSET = 7,
+	HDMI_PHY_CONF0_ENTMDS_MASK = 0x40,
+	HDMI_PHY_CONF0_ENTMDS_OFFSET = 6,
+	HDMI_PHY_CONF0_SVSRET_MASK = 0x20,
+	HDMI_PHY_CONF0_SVSRET_OFFSET = 5,
+	HDMI_PHY_CONF0_GEN2_PDDQ_MASK = 0x10,
+	HDMI_PHY_CONF0_GEN2_PDDQ_OFFSET = 4,
+	HDMI_PHY_CONF0_GEN2_TXPWRON_MASK = 0x8,
+	HDMI_PHY_CONF0_GEN2_TXPWRON_OFFSET = 3,
+	HDMI_PHY_CONF0_GEN2_ENHPDRXSENSE_MASK = 0x4,
+	HDMI_PHY_CONF0_GEN2_ENHPDRXSENSE_OFFSET = 2,
+	HDMI_PHY_CONF0_SELDATAENPOL_MASK = 0x2,
+	HDMI_PHY_CONF0_SELDATAENPOL_OFFSET = 1,
+	HDMI_PHY_CONF0_SELDIPIF_MASK = 0x1,
+	HDMI_PHY_CONF0_SELDIPIF_OFFSET = 0,
+
+/* PHY_TST0 field values */
+	HDMI_PHY_TST0_TSTCLR_MASK = 0x20,
+	HDMI_PHY_TST0_TSTCLR_OFFSET = 5,
+	HDMI_PHY_TST0_TSTEN_MASK = 0x10,
+	HDMI_PHY_TST0_TSTEN_OFFSET = 4,
+	HDMI_PHY_TST0_TSTCLK_MASK = 0x1,
+	HDMI_PHY_TST0_TSTCLK_OFFSET = 0,
+
+/* PHY_STAT0 field values */
+	HDMI_PHY_RX_SENSE3 = 0x80,
+	HDMI_PHY_RX_SENSE2 = 0x40,
+	HDMI_PHY_RX_SENSE1 = 0x20,
+	HDMI_PHY_RX_SENSE0 = 0x10,
+	HDMI_PHY_HPD = 0x02,
+	HDMI_PHY_TX_PHY_LOCK = 0x01,
+
+/* PHY_I2CM_SLAVE_ADDR field values */
+	HDMI_PHY_I2CM_SLAVE_ADDR_PHY_GEN2 = 0x69,
+	HDMI_PHY_I2CM_SLAVE_ADDR_HEAC_PHY = 0x49,
+
+/* PHY_I2CM_OPERATION_ADDR field values */
+	HDMI_PHY_I2CM_OPERATION_ADDR_WRITE = 0x10,
+	HDMI_PHY_I2CM_OPERATION_ADDR_READ = 0x1,
+
+/* HDMI_PHY_I2CM_INT_ADDR */
+	HDMI_PHY_I2CM_INT_ADDR_DONE_POL = 0x08,
+	HDMI_PHY_I2CM_INT_ADDR_DONE_MASK = 0x04,
+
+/* HDMI_PHY_I2CM_CTLINT_ADDR */
+	HDMI_PHY_I2CM_CTLINT_ADDR_NAC_POL = 0x80,
+	HDMI_PHY_I2CM_CTLINT_ADDR_NAC_MASK = 0x40,
+	HDMI_PHY_I2CM_CTLINT_ADDR_ARBITRATION_POL = 0x08,
+	HDMI_PHY_I2CM_CTLINT_ADDR_ARBITRATION_MASK = 0x04,
+
+/* AUD_CONF0 field values */
+	HDMI_AUD_CONF0_SW_RESET = 0x80,
+	HDMI_AUD_CONF0_I2S_2CHANNEL_ENABLE = 0x21,
+	HDMI_AUD_CONF0_I2S_4CHANNEL_ENABLE = 0x23,
+	HDMI_AUD_CONF0_I2S_6CHANNEL_ENABLE = 0x27,
+	HDMI_AUD_CONF0_I2S_8CHANNEL_ENABLE = 0x2F,
+	HDMI_AUD_CONF0_I2S_ALL_ENABLE = 0x2F,
+
+/* AUD_INT field values */
+	HDMI_AUD_INT_FIFO_EMPTY_MSK = BIT(3),
+	HDMI_AUD_INT_FIFO_FULL_MSK = BIT(2),
+
+/* AUD_CONF1 field values */
+	HDMI_AUD_CONF1_MODE_I2S = 0x00,
+	HDMI_AUD_CONF1_MODE_RIGHT_J = 0x02,
+	HDMI_AUD_CONF1_MODE_LEFT_J = 0x04,
+	HDMI_AUD_CONF1_WIDTH_16 = 0x10,
+	HDMI_AUD_CONF1_WIDTH_21 = 0x15,
+	HDMI_AUD_CONF1_WIDTH_24 = 0x18,
+
+/* AUD_CONF2 filed values */
+	HDMI_AUD_CONF2_HBR = 0x1,
+	HDMI_AUD_CONF2_NLPCM = 0x2,
+	HDMI_AUD_CONF2_INSERT_PCUV = 0x04,
+
+/* AUD_CTS3 field values */
+	HDMI_AUD_CTS3_N_SHIFT_OFFSET = 5,
+	HDMI_AUD_CTS3_N_SHIFT_MASK = 0xe0,
+	HDMI_AUD_CTS3_N_SHIFT_1 = 0,
+	HDMI_AUD_CTS3_N_SHIFT_16 = 0x20,
+	HDMI_AUD_CTS3_N_SHIFT_32 = 0x40,
+	HDMI_AUD_CTS3_N_SHIFT_64 = 0x60,
+	HDMI_AUD_CTS3_N_SHIFT_128 = 0x80,
+	HDMI_AUD_CTS3_N_SHIFT_256 = 0xa0,
+	/* note that the CTS3 MANUAL bit has been removed from our part. */
+	HDMI_AUD_CTS3_CTS_MANUAL = 0x10,
+	HDMI_AUD_CTS3_AUDCTS19_16_MASK = 0x0f,
+
+/* HDMI_AUD_INPUTCLKFS field values */
+	HDMI_AUD_INPUTCLKFS_128FS = 0,
+	HDMI_AUD_INPUTCLKFS_256FS = 1,
+	HDMI_AUD_INPUTCLKFS_512FS = 2,
+	HDMI_AUD_INPUTCLKFS_64FS = 4,
+
+/* AHB_DMA_CONF0 field values */
+	HDMI_AHB_DMA_CONF0_SW_FIFO_RST_OFFSET = 7,
+	HDMI_AHB_DMA_CONF0_SW_FIFO_RST_MASK = 0x80,
+	HDMI_AHB_DMA_CONF0_HBR = 0x10,
+	HDMI_AHB_DMA_CONF0_EN_HLOCK_OFFSET = 3,
+	HDMI_AHB_DMA_CONF0_EN_HLOCK_MASK = 0x08,
+	HDMI_AHB_DMA_CONF0_INCR_TYPE_OFFSET = 1,
+	HDMI_AHB_DMA_CONF0_INCR_TYPE_MASK = 0x06,
+	HDMI_AHB_DMA_CONF0_INCR4 = 0x0,
+	HDMI_AHB_DMA_CONF0_INCR8 = 0x2,
+	HDMI_AHB_DMA_CONF0_INCR16 = 0x4,
+	HDMI_AHB_DMA_CONF0_BURST_MODE = 0x1,
+
+/* HDMI_AHB_DMA_START field values */
+	HDMI_AHB_DMA_START_START_OFFSET = 0,
+	HDMI_AHB_DMA_START_START_MASK = 0x01,
+
+/* HDMI_AHB_DMA_STOP field values */
+	HDMI_AHB_DMA_STOP_STOP_OFFSET = 0,
+	HDMI_AHB_DMA_STOP_STOP_MASK = 0x01,
+
+/* AHB_DMA_STAT, AHB_DMA_INT, AHB_DMA_MASK, AHB_DMA_POL field values */
+	HDMI_AHB_DMA_DONE = 0x80,
+	HDMI_AHB_DMA_RETRY_SPLIT = 0x40,
+	HDMI_AHB_DMA_LOSTOWNERSHIP = 0x20,
+	HDMI_AHB_DMA_ERROR = 0x10,
+	HDMI_AHB_DMA_FIFO_THREMPTY = 0x04,
+	HDMI_AHB_DMA_FIFO_FULL = 0x02,
+	HDMI_AHB_DMA_FIFO_EMPTY = 0x01,
+
+/* AHB_DMA_BUFFSTAT, AHB_DMA_BUFFINT,AHB_DMA_BUFFMASK,AHB_DMA_BUFFPOL values */
+	HDMI_AHB_DMA_BUFFSTAT_FULL = 0x02,
+	HDMI_AHB_DMA_BUFFSTAT_EMPTY = 0x01,
+
+/* MC_CLKDIS field values */
+	HDMI_MC_CLKDIS_HDCPCLK_DISABLE = 0x40,
+	HDMI_MC_CLKDIS_CECCLK_DISABLE = 0x20,
+	HDMI_MC_CLKDIS_CSCCLK_DISABLE = 0x10,
+	HDMI_MC_CLKDIS_AUDCLK_DISABLE = 0x8,
+	HDMI_MC_CLKDIS_PREPCLK_DISABLE = 0x4,
+	HDMI_MC_CLKDIS_TMDSCLK_DISABLE = 0x2,
+	HDMI_MC_CLKDIS_PIXELCLK_DISABLE = 0x1,
+
+/* MC_SWRSTZ field values */
+	HDMI_MC_SWRSTZ_TMDSSWRST_REQ = 0x02,
+
+/* MC_FLOWCTRL field values */
+	HDMI_MC_FLOWCTRL_FEED_THROUGH_OFF_MASK = 0x1,
+	HDMI_MC_FLOWCTRL_FEED_THROUGH_OFF_CSC_IN_PATH = 0x1,
+	HDMI_MC_FLOWCTRL_FEED_THROUGH_OFF_CSC_BYPASS = 0x0,
+
+/* MC_PHYRSTZ field values */
+	HDMI_MC_PHYRSTZ_PHYRSTZ = 0x01,
+
+/* MC_HEACPHY_RST field values */
+	HDMI_MC_HEACPHY_RST_ASSERT = 0x1,
+	HDMI_MC_HEACPHY_RST_DEASSERT = 0x0,
+
+/* CSC_CFG field values */
+	HDMI_CSC_CFG_INTMODE_MASK = 0x30,
+	HDMI_CSC_CFG_INTMODE_OFFSET = 4,
+	HDMI_CSC_CFG_INTMODE_DISABLE = 0x00,
+	HDMI_CSC_CFG_INTMODE_CHROMA_INT_FORMULA1 = 0x10,
+	HDMI_CSC_CFG_INTMODE_CHROMA_INT_FORMULA2 = 0x20,
+	HDMI_CSC_CFG_DECMODE_MASK = 0x3,
+	HDMI_CSC_CFG_DECMODE_OFFSET = 0,
+	HDMI_CSC_CFG_DECMODE_DISABLE = 0x0,
+	HDMI_CSC_CFG_DECMODE_CHROMA_INT_FORMULA1 = 0x1,
+	HDMI_CSC_CFG_DECMODE_CHROMA_INT_FORMULA2 = 0x2,
+	HDMI_CSC_CFG_DECMODE_CHROMA_INT_FORMULA3 = 0x3,
+
+/* CSC_SCALE field values */
+	HDMI_CSC_SCALE_CSC_COLORDE_PTH_MASK = 0xF0,
+	HDMI_CSC_SCALE_CSC_COLORDE_PTH_24BPP = 0x00,
+	HDMI_CSC_SCALE_CSC_COLORDE_PTH_30BPP = 0x50,
+	HDMI_CSC_SCALE_CSC_COLORDE_PTH_36BPP = 0x60,
+	HDMI_CSC_SCALE_CSC_COLORDE_PTH_48BPP = 0x70,
+	HDMI_CSC_SCALE_CSCSCALE_MASK = 0x03,
+
+/* A_HDCPCFG0 field values */
+	HDMI_A_HDCPCFG0_ELVENA_MASK = 0x80,
+	HDMI_A_HDCPCFG0_ELVENA_ENABLE = 0x80,
+	HDMI_A_HDCPCFG0_ELVENA_DISABLE = 0x00,
+	HDMI_A_HDCPCFG0_I2CFASTMODE_MASK = 0x40,
+	HDMI_A_HDCPCFG0_I2CFASTMODE_ENABLE = 0x40,
+	HDMI_A_HDCPCFG0_I2CFASTMODE_DISABLE = 0x00,
+	HDMI_A_HDCPCFG0_BYPENCRYPTION_MASK = 0x20,
+	HDMI_A_HDCPCFG0_BYPENCRYPTION_ENABLE = 0x20,
+	HDMI_A_HDCPCFG0_BYPENCRYPTION_DISABLE = 0x00,
+	HDMI_A_HDCPCFG0_SYNCRICHECK_MASK = 0x10,
+	HDMI_A_HDCPCFG0_SYNCRICHECK_ENABLE = 0x10,
+	HDMI_A_HDCPCFG0_SYNCRICHECK_DISABLE = 0x00,
+	HDMI_A_HDCPCFG0_AVMUTE_MASK = 0x8,
+	HDMI_A_HDCPCFG0_AVMUTE_ENABLE = 0x8,
+	HDMI_A_HDCPCFG0_AVMUTE_DISABLE = 0x0,
+	HDMI_A_HDCPCFG0_RXDETECT_MASK = 0x4,
+	HDMI_A_HDCPCFG0_RXDETECT_ENABLE = 0x4,
+	HDMI_A_HDCPCFG0_RXDETECT_DISABLE = 0x0,
+	HDMI_A_HDCPCFG0_EN11FEATURE_MASK = 0x2,
+	HDMI_A_HDCPCFG0_EN11FEATURE_ENABLE = 0x2,
+	HDMI_A_HDCPCFG0_EN11FEATURE_DISABLE = 0x0,
+	HDMI_A_HDCPCFG0_HDMIDVI_MASK = 0x1,
+	HDMI_A_HDCPCFG0_HDMIDVI_HDMI = 0x1,
+	HDMI_A_HDCPCFG0_HDMIDVI_DVI = 0x0,
+
+/* A_HDCPCFG1 field values */
+	HDMI_A_HDCPCFG1_DISSHA1CHECK_MASK = 0x8,
+	HDMI_A_HDCPCFG1_DISSHA1CHECK_DISABLE = 0x8,
+	HDMI_A_HDCPCFG1_DISSHA1CHECK_ENABLE = 0x0,
+	HDMI_A_HDCPCFG1_PH2UPSHFTENC_MASK = 0x4,
+	HDMI_A_HDCPCFG1_PH2UPSHFTENC_ENABLE = 0x4,
+	HDMI_A_HDCPCFG1_PH2UPSHFTENC_DISABLE = 0x0,
+	HDMI_A_HDCPCFG1_ENCRYPTIONDISABLE_MASK = 0x2,
+	HDMI_A_HDCPCFG1_ENCRYPTIONDISABLE_DISABLE = 0x2,
+	HDMI_A_HDCPCFG1_ENCRYPTIONDISABLE_ENABLE = 0x0,
+	HDMI_A_HDCPCFG1_SWRESET_MASK = 0x1,
+	HDMI_A_HDCPCFG1_SWRESET_ASSERT = 0x0,
+
+/* A_VIDPOLCFG field values */
+	HDMI_A_VIDPOLCFG_UNENCRYPTCONF_MASK = 0x60,
+	HDMI_A_VIDPOLCFG_UNENCRYPTCONF_OFFSET = 5,
+	HDMI_A_VIDPOLCFG_DATAENPOL_MASK = 0x10,
+	HDMI_A_VIDPOLCFG_DATAENPOL_ACTIVE_HIGH = 0x10,
+	HDMI_A_VIDPOLCFG_DATAENPOL_ACTIVE_LOW = 0x0,
+	HDMI_A_VIDPOLCFG_VSYNCPOL_MASK = 0x8,
+	HDMI_A_VIDPOLCFG_VSYNCPOL_ACTIVE_HIGH = 0x8,
+	HDMI_A_VIDPOLCFG_VSYNCPOL_ACTIVE_LOW = 0x0,
+	HDMI_A_VIDPOLCFG_HSYNCPOL_MASK = 0x2,
+	HDMI_A_VIDPOLCFG_HSYNCPOL_ACTIVE_HIGH = 0x2,
+	HDMI_A_VIDPOLCFG_HSYNCPOL_ACTIVE_LOW = 0x0,
+
+/* I2CM_OPERATION field values */
+	HDMI_I2CM_OPERATION_BUS_CLEAR = 0x20,
+	HDMI_I2CM_OPERATION_WRITE = 0x10,
+	HDMI_I2CM_OPERATION_READ8_EXT = 0x8,
+	HDMI_I2CM_OPERATION_READ8 = 0x4,
+	HDMI_I2CM_OPERATION_READ_EXT = 0x2,
+	HDMI_I2CM_OPERATION_READ = 0x1,
+
+/* I2CM_INT field values */
+	HDMI_I2CM_INT_DONE_POL = 0x8,
+	HDMI_I2CM_INT_DONE_MASK = 0x4,
+
+/* I2CM_CTLINT field values */
+	HDMI_I2CM_CTLINT_NAC_POL = 0x80,
+	HDMI_I2CM_CTLINT_NAC_MASK = 0x40,
+	HDMI_I2CM_CTLINT_ARB_POL = 0x8,
+	HDMI_I2CM_CTLINT_ARB_MASK = 0x4,
+
+/* I2CM_DIV field values */
+	HDMI_I2CM_DIV_FAST_STD_MODE = 0x8,
+	HDMI_I2CM_DIV_FAST_MODE = 0x8,
+	HDMI_I2CM_DIV_STD_MODE = 0,
+
+/* HDMI_MC_SWRSTZ filed values */
+	HDMI_MC_SWRSTZ_I2S_RESET_MSK = BIT(3),
+};
+
+enum {
+	HDMI_MC_CLKDIS_HDCPCLK_MASK = 0x40,
+	HDMI_MC_CLKDIS_HDCPCLK_ENABLE = 0x00,
+
+	HDMI_A_SRMCTRL_SHA1_FAIL_MASK = 0X08,
+	HDMI_A_SRMCTRL_SHA1_FAIL_DISABLE = 0X00,
+	HDMI_A_SRMCTRL_SHA1_FAIL_ENABLE = 0X08,
+
+	HDMI_A_SRMCTRL_KSV_UPDATE_MASK = 0X04,
+	HDMI_A_SRMCTRL_KSV_UPDATE_DISABLE = 0X00,
+	HDMI_A_SRMCTRL_KSV_UPDATE_ENABLE = 0X04,
+
+	HDMI_A_SRMCTRL_KSV_MEM_REQ_MASK = 0X01,
+	HDMI_A_SRMCTRL_KSV_MEM_REQ_DISABLE = 0X00,
+	HDMI_A_SRMCTRL_KSV_MEM_REQ_ENABLE = 0X01,
+
+	HDMI_A_SRMCTRL_KSV_MEM_ACCESS_MASK = 0X02,
+	HDMI_A_SRMCTRL_KSV_MEM_ACCESS_DISABLE = 0X00,
+	HDMI_A_SRMCTRL_KSV_MEM_ACCESS_ENABLE = 0X02,
+
+	HDMI_A_SRM_BASE_MAX_DEVS_EXCEEDED = 0x80,
+	HDMI_A_SRM_BASE_DEVICE_COUNT = 0x7f,
+
+	HDMI_A_SRM_BASE_MAX_CASCADE_EXCEEDED = 0x08,
+
+	HDMI_A_APIINTSTAT_KSVSHA1_CALC_INT = 0x02,
+
+	/* HDCPREG_RMSTS field values */
+	DPK_WR_OK_STS = 0x40,
+
+	HDMI_A_HDCP22_MASK = 0x40,
+
+	HDMI_HDCP2_OVR_EN_MASK = 0x02,
+	HDMI_HDCP2_OVR_ENABLE = 0x02,
+	HDMI_HDCP2_OVR_DISABLE = 0x00,
+
+	HDMI_HDCP2_FORCE_MASK = 0x04,
+	HDMI_HDCP2_FORCE_ENABLE = 0x04,
+	HDMI_HDCP2_FORCE_DISABLE = 0x00,
+};
+
+enum {
+	DW_HDMI_HDCP_KSV_LEN = 8,
+	DW_HDMI_HDCP_SHA_LEN = 20,
+	DW_HDMI_HDCP_DPK_LEN = 280,
+	DW_HDMI_HDCP_KEY_LEN = 308,
+	DW_HDMI_HDCP_SEED_LEN = 2,
+};
+
+/*
+ * HDMI 3D TX PHY registers
+ */
+#define HDMI_3D_TX_PHY_PWRCTRL			0x00
+#define HDMI_3D_TX_PHY_SERDIVCTRL		0x01
+#define HDMI_3D_TX_PHY_SERCKCTRL		0x02
+#define HDMI_3D_TX_PHY_SERCKKILLCTRL		0x03
+#define HDMI_3D_TX_PHY_TXRESCTRL		0x04
+#define HDMI_3D_TX_PHY_CKCALCTRL		0x05
+#define HDMI_3D_TX_PHY_CPCE_CTRL		0x06
+#define HDMI_3D_TX_PHY_TXCLKMEASCTRL		0x07
+#define HDMI_3D_TX_PHY_TXMEASCTRL		0x08
+#define HDMI_3D_TX_PHY_CKSYMTXCTRL		0x09
+#define HDMI_3D_TX_PHY_CMPSEQCTRL		0x0a
+#define HDMI_3D_TX_PHY_CMPPWRCTRL		0x0b
+#define HDMI_3D_TX_PHY_CMPMODECTRL		0x0c
+#define HDMI_3D_TX_PHY_MEASCTRL			0x0d
+#define HDMI_3D_TX_PHY_VLEVCTRL			0x0e
+#define HDMI_3D_TX_PHY_D2ACTRL			0x0f
+#define HDMI_3D_TX_PHY_CURRCTRL			0x10
+#define HDMI_3D_TX_PHY_DRVANACTRL		0x11
+#define HDMI_3D_TX_PHY_PLLMEASCTRL		0x12
+#define HDMI_3D_TX_PHY_PLLPHBYCTRL		0x13
+#define HDMI_3D_TX_PHY_GRP_CTRL			0x14
+#define HDMI_3D_TX_PHY_GMPCTRL			0x15
+#define HDMI_3D_TX_PHY_MPLLMEASCTRL		0x16
+#define HDMI_3D_TX_PHY_MSM_CTRL			0x17
+#define HDMI_3D_TX_PHY_SCRPB_STATUS		0x18
+#define HDMI_3D_TX_PHY_TXTERM			0x19
+#define HDMI_3D_TX_PHY_PTRPT_ENBL		0x1a
+#define HDMI_3D_TX_PHY_PATTERNGEN		0x1b
+#define HDMI_3D_TX_PHY_SDCAP_MODE		0x1c
+#define HDMI_3D_TX_PHY_SCOPEMODE		0x1d
+#define HDMI_3D_TX_PHY_DIGTXMODE		0x1e
+#define HDMI_3D_TX_PHY_STR_STATUS		0x1f
+#define HDMI_3D_TX_PHY_SCOPECNT0		0x20
+#define HDMI_3D_TX_PHY_SCOPECNT1		0x21
+#define HDMI_3D_TX_PHY_SCOPECNT2		0x22
+#define HDMI_3D_TX_PHY_SCOPECNTCLK		0x23
+#define HDMI_3D_TX_PHY_SCOPESAMPLE		0x24
+#define HDMI_3D_TX_PHY_SCOPECNTMSB01		0x25
+#define HDMI_3D_TX_PHY_SCOPECNTMSB2CK		0x26
+
+/* HDMI_3D_TX_PHY_CKCALCTRL values */
+#define HDMI_3D_TX_PHY_CKCALCTRL_OVERRIDE		BIT(15)
+
+/* HDMI_3D_TX_PHY_MSM_CTRL values */
+#define HDMI_3D_TX_PHY_MSM_CTRL_MPLL_PH_SEL_CK		BIT(13)
+#define HDMI_3D_TX_PHY_MSM_CTRL_CKO_SEL_CLK_REF_MPLL	(0 << 1)
+#define HDMI_3D_TX_PHY_MSM_CTRL_CKO_SEL_OFF		BIT(1)
+#define HDMI_3D_TX_PHY_MSM_CTRL_CKO_SEL_PCLK		(2 << 1)
+#define HDMI_3D_TX_PHY_MSM_CTRL_CKO_SEL_FB_CLK		(3 << 1)
+#define HDMI_3D_TX_PHY_MSM_CTRL_SCOPE_CK_SEL		BIT(0)
+
+/* HDMI_3D_TX_PHY_PTRPT_ENBL values */
+#define HDMI_3D_TX_PHY_PTRPT_ENBL_OVERRIDE		BIT(15)
+#define HDMI_3D_TX_PHY_PTRPT_ENBL_PG_SKIP_BIT2		BIT(8)
+#define HDMI_3D_TX_PHY_PTRPT_ENBL_PG_SKIP_BIT1		BIT(7)
+#define HDMI_3D_TX_PHY_PTRPT_ENBL_PG_SKIP_BIT0		BIT(6)
+#define HDMI_3D_TX_PHY_PTRPT_ENBL_CK_REF_ENB		BIT(5)
+#define HDMI_3D_TX_PHY_PTRPT_ENBL_RCAL_ENB		BIT(4)
+#define HDMI_3D_TX_PHY_PTRPT_ENBL_TX_CLK_ALIGN_ENB	BIT(3)
+#define HDMI_3D_TX_PHY_PTRPT_ENBL_TX_READY		BIT(2)
+#define HDMI_3D_TX_PHY_PTRPT_ENBL_CKO_WORD_ENB		BIT(1)
+#define HDMI_3D_TX_PHY_PTRPT_ENBL_REFCLK_ENB		BIT(0)
+
+#define HDMI_VIDEO_DEFAULT_MODE 4
+
+enum v4l2_ycbcr_encoding {
+	/*
+	 * Mapping of V4L2_YCBCR_ENC_DEFAULT to actual encodings for the
+	 * various colorspaces:
+	 *
+	 * V4L2_COLORSPACE_SMPTE170M, V4L2_COLORSPACE_470_SYSTEM_M,
+	 * V4L2_COLORSPACE_470_SYSTEM_BG, V4L2_COLORSPACE_ADOBERGB and
+	 * V4L2_COLORSPACE_JPEG: V4L2_YCBCR_ENC_601
+	 *
+	 * V4L2_COLORSPACE_REC709 and V4L2_COLORSPACE_DCI_P3: V4L2_YCBCR_ENC_709
+	 *
+	 * V4L2_COLORSPACE_SRGB: V4L2_YCBCR_ENC_SYCC
+	 *
+	 * V4L2_COLORSPACE_BT2020: V4L2_YCBCR_ENC_BT2020
+	 *
+	 * V4L2_COLORSPACE_SMPTE240M: V4L2_YCBCR_ENC_SMPTE240M
+	 */
+	V4L2_YCBCR_ENC_DEFAULT        = 0,
+
+	/* ITU-R 601 -- SDTV */
+	V4L2_YCBCR_ENC_601            = 1,
+
+	/* Rec. 709 -- HDTV */
+	V4L2_YCBCR_ENC_709            = 2,
+
+	/* ITU-R 601/EN 61966-2-4 Extended Gamut -- SDTV */
+	V4L2_YCBCR_ENC_XV601          = 3,
+
+	/* Rec. 709/EN 61966-2-4 Extended Gamut -- HDTV */
+	V4L2_YCBCR_ENC_XV709          = 4,
+
+	/* sYCC (Y'CbCr encoding of sRGB) */
+	V4L2_YCBCR_ENC_SYCC           = 5,
+
+	/* BT.2020 Non-constant Luminance Y'CbCr */
+	V4L2_YCBCR_ENC_BT2020         = 6,
+
+	/* BT.2020 Constant Luminance Y'CbcCrc */
+	V4L2_YCBCR_ENC_BT2020_CONST_LUM = 7,
+
+	/* SMPTE 240M -- Obsolete HDTV */
+	V4L2_YCBCR_ENC_SMPTE240M      = 8,
+};
+
+/* Color Space Conversion Mode */
+enum {
+	CSC_RGB_0_255_TO_RGB_16_235_8BIT,
+	CSC_RGB_0_255_TO_RGB_16_235_10BIT,
+	CSC_RGB_0_255_TO_ITU601_16_235_8BIT,
+	CSC_RGB_0_255_TO_ITU601_16_235_10BIT,
+	CSC_RGB_0_255_TO_ITU709_16_235_8BIT,
+	CSC_RGB_0_255_TO_ITU709_16_235_10BIT,
+	CSC_ITU601_16_235_TO_RGB_0_255_8BIT,
+	CSC_ITU709_16_235_TO_RGB_0_255_8BIT,
+	CSC_ITU601_16_235_TO_RGB_16_235_8BIT,
+	CSC_ITU709_16_235_TO_RGB_16_235_8BIT
+};
+
+enum drm_connector_status {
+	connector_status_disconnected = 0,
+	connector_status_connected = 1,
+};
+
+enum {
+	STANDARD_MODE = 0,
+	FAST_MODE
+};
+
+void drm_rk_selete_output(struct hdmi_edid_data *edid_data,
+			  struct connector_state *conn_state,
+			  unsigned int *bus_format,
+			  struct overscan *overscan,
+			  enum dw_hdmi_devtype dev_type,
+			  bool output_bus_format_rgb);
+void inno_dw_hdmi_set_domain(void *grf, int status);
+void dw_hdmi_set_iomux(void *grf, void *gpio_base, struct gpio_desc *hpd_gpiod,
+		       int dev_type);
+
+#endif /* _ROCKCHIP_HDMI_H_ */
diff --git a/drivers/video/drm/dw_hdmi_qp.c b/drivers/video/drm/dw_hdmi_qp.c
new file mode 100644
index 0000000000..2bf82e6464
--- /dev/null
+++ b/drivers/video/drm/dw_hdmi_qp.c
@@ -0,0 +1,1449 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2021 Fuzhou Rockchip Electronics Co., Ltd
+ * Author: Algea Cao <algea.cao@rock-chips.com>
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <syscon.h>
+#include <asm/arch-rockchip/clock.h>
+#include <edid.h>
+#include <dm/device.h>
+#include <dm/device_compat.h>
+#include <dm/of_access.h>
+#include <dm/ofnode.h>
+#include <dm/read.h>
+#include <linux/hdmi.h>
+#include <linux/media-bus-format.h>
+#include <linux/dw_hdmi.h>
+#include <asm/io.h>
+#include "rockchip_bridge.h"
+#include "rockchip_display.h"
+#include "rockchip_crtc.h"
+#include "rockchip_connector.h"
+#include "dw_hdmi_qp.h"
+#include "rockchip_phy.h"
+
+enum frl_mask {
+	FRL_3GBPS_3LANE = 1,
+	FRL_6GBPS_3LANE,
+	FRL_6GBPS_4LANE,
+	FRL_8GBPS_4LANE,
+	FRL_10GBPS_4LANE,
+	FRL_12GBPS_4LANE,
+};
+
+#define DDC_CI_ADDR		0x37
+#define DDC_SEGMENT_ADDR	0x30
+
+#define HDMI_EDID_LEN		512
+
+/* DW-HDMI Controller >= 0x200a are at least compliant with SCDC version 1 */
+#define SCDC_MIN_SOURCE_VERSION	0x1
+
+#define HDMI14_MAX_TMDSCLK	340000000
+
+struct hdmi_vmode {
+	bool mdataenablepolarity;
+
+	unsigned int mpixelclock;
+	unsigned int mpixelrepetitioninput;
+	unsigned int mpixelrepetitionoutput;
+	unsigned int mtmdsclock;
+};
+
+struct hdmi_data_info {
+	unsigned int enc_in_bus_format;
+	unsigned int enc_out_bus_format;
+	unsigned int enc_in_encoding;
+	unsigned int enc_out_encoding;
+	unsigned int quant_range;
+	unsigned int pix_repet_factor;
+	struct hdmi_vmode video_mode;
+};
+
+struct dw_hdmi_phy_data {
+	enum dw_hdmi_phy_type type;
+	const char *name;
+	unsigned int gen;
+	bool has_svsret;
+	int (*configure)(struct dw_hdmi *hdmi,
+			 const struct dw_hdmi_plat_data *pdata,
+			 unsigned long mpixelclock);
+};
+
+struct dw_hdmi_i2c {
+	u8			slave_reg;
+	bool			is_regaddr;
+	bool			is_segment;
+
+	unsigned int		scl_high_ns;
+	unsigned int		scl_low_ns;
+};
+
+struct dw_hdmi_qp {
+	struct udevice *dev;
+	enum dw_hdmi_devtype dev_type;
+	unsigned int version;
+	struct hdmi_data_info hdmi_data;
+	struct hdmi_edid_data edid_data;
+	const struct dw_hdmi_plat_data *plat_data;
+	struct ddc_adapter adap;
+
+	int vic;
+	int id;
+
+	unsigned long bus_format;
+	bool cable_plugin;
+	bool sink_is_hdmi;
+	bool sink_has_audio;
+	void *regs;
+	void *rk_hdmi;
+	struct dw_hdmi_i2c *i2c;
+
+	struct {
+		const struct dw_hdmi_qp_phy_ops *ops;
+		const char *name;
+		void *data;
+		bool enabled;
+	} phy;
+
+	struct drm_display_mode previous_mode;
+
+	unsigned int sample_rate;
+	unsigned int audio_cts;
+	unsigned int audio_n;
+	bool audio_enable;
+	bool scramble_low_rates;
+
+	void (*write)(struct dw_hdmi_qp *hdmi, u32 val, int offset);
+	u8 (*read)(struct dw_hdmi_qp *hdmi, int offset);
+
+	bool hdcp1x_enable;
+	bool output_bus_format_rgb;
+};
+
+static inline void hdmi_writel(struct dw_hdmi_qp *hdmi, u32 val, int offset)
+{
+	writel(val, hdmi->regs + offset);
+}
+
+static inline u32 hdmi_readl(struct dw_hdmi_qp *hdmi, int offset)
+{
+	return readl(hdmi->regs + offset);
+}
+
+static void
+hdmi_modb(struct dw_hdmi_qp *hdmi, u32 data, u32 mask, unsigned int reg)
+{
+	u32 val = hdmi_readl(hdmi, reg) & ~mask;
+
+	val |= data & mask;
+	hdmi_writel(hdmi, val, reg);
+}
+
+static bool hdmi_bus_fmt_is_rgb(unsigned int bus_format)
+{
+	switch (bus_format) {
+	case MEDIA_BUS_FMT_RGB888_1X24:
+	case MEDIA_BUS_FMT_RGB101010_1X30:
+	case MEDIA_BUS_FMT_RGB121212_1X36:
+	case MEDIA_BUS_FMT_RGB161616_1X48:
+		return true;
+
+	default:
+		return false;
+	}
+}
+
+static bool hdmi_bus_fmt_is_yuv444(unsigned int bus_format)
+{
+	switch (bus_format) {
+	case MEDIA_BUS_FMT_YUV8_1X24:
+	case MEDIA_BUS_FMT_YUV10_1X30:
+	case MEDIA_BUS_FMT_YUV12_1X36:
+	case MEDIA_BUS_FMT_YUV16_1X48:
+		return true;
+
+	default:
+		return false;
+	}
+}
+
+static bool hdmi_bus_fmt_is_yuv422(unsigned int bus_format)
+{
+	switch (bus_format) {
+	case MEDIA_BUS_FMT_UYVY8_1X16:
+	case MEDIA_BUS_FMT_UYVY10_1X20:
+	case MEDIA_BUS_FMT_UYVY12_1X24:
+	case MEDIA_BUS_FMT_YUYV8_1X16:
+	case MEDIA_BUS_FMT_YUYV10_1X20:
+	case MEDIA_BUS_FMT_YUYV12_1X24:
+		return true;
+
+	default:
+		return false;
+	}
+}
+
+static bool hdmi_bus_fmt_is_yuv420(unsigned int bus_format)
+{
+	switch (bus_format) {
+	case MEDIA_BUS_FMT_UYYVYY8_0_5X24:
+	case MEDIA_BUS_FMT_UYYVYY10_0_5X30:
+	case MEDIA_BUS_FMT_UYYVYY12_0_5X36:
+	case MEDIA_BUS_FMT_UYYVYY16_0_5X48:
+		return true;
+
+	default:
+		return false;
+	}
+}
+
+static int hdmi_bus_fmt_color_depth(unsigned int bus_format)
+{
+	switch (bus_format) {
+	case MEDIA_BUS_FMT_RGB888_1X24:
+	case MEDIA_BUS_FMT_YUV8_1X24:
+	case MEDIA_BUS_FMT_UYVY8_1X16:
+	case MEDIA_BUS_FMT_UYYVYY8_0_5X24:
+		return 8;
+
+	case MEDIA_BUS_FMT_RGB101010_1X30:
+	case MEDIA_BUS_FMT_YUV10_1X30:
+	case MEDIA_BUS_FMT_UYVY10_1X20:
+	case MEDIA_BUS_FMT_UYYVYY10_0_5X30:
+		return 10;
+
+	case MEDIA_BUS_FMT_RGB121212_1X36:
+	case MEDIA_BUS_FMT_YUV12_1X36:
+	case MEDIA_BUS_FMT_UYVY12_1X24:
+	case MEDIA_BUS_FMT_UYYVYY12_0_5X36:
+		return 12;
+
+	case MEDIA_BUS_FMT_RGB161616_1X48:
+	case MEDIA_BUS_FMT_YUV16_1X48:
+	case MEDIA_BUS_FMT_UYYVYY16_0_5X48:
+		return 16;
+
+	default:
+		return 0;
+	}
+}
+
+static bool drm_scdc_set_scrambling(struct ddc_adapter *adapter, bool enable)
+{
+	u8 config;
+	int ret;
+
+	ret = drm_scdc_readb(adapter, SCDC_TMDS_CONFIG, &config);
+	if (ret < 0) {
+		debug("Failed to read TMDS config: %d\n", ret);
+		return false;
+	}
+
+	if (enable)
+		config |= SCDC_SCRAMBLING_ENABLE;
+	else
+		config &= ~SCDC_SCRAMBLING_ENABLE;
+
+	ret = drm_scdc_writeb(adapter, SCDC_TMDS_CONFIG, config);
+	if (ret < 0) {
+		debug("Failed to enable scrambling: %d\n", ret);
+		return false;
+	}
+
+	return true;
+}
+
+static bool
+drm_scdc_set_high_tmds_clock_ratio(struct ddc_adapter *adapter, bool set)
+{
+	u8 config;
+	int ret;
+
+	ret = drm_scdc_readb(adapter, SCDC_TMDS_CONFIG, &config);
+	if (ret < 0) {
+		debug("Failed to read TMDS config: %d\n", ret);
+		return false;
+	}
+
+	if (set)
+		config |= SCDC_TMDS_BIT_CLOCK_RATIO_BY_40;
+	else
+		config &= ~SCDC_TMDS_BIT_CLOCK_RATIO_BY_40;
+
+	ret = drm_scdc_writeb(adapter, SCDC_TMDS_CONFIG, config);
+	if (ret < 0) {
+		debug("Failed to set TMDS clock ratio: %d\n", ret);
+		return false;
+	}
+
+	/*
+	 * The spec says that a source should wait minimum 1ms and maximum
+	 * 100ms after writing the TMDS config for clock ratio. Lets allow a
+	 * wait of up to 2ms here.
+	 */
+	udelay(2000);
+	return true;
+}
+
+static void dw_hdmi_i2c_init(struct dw_hdmi_qp *hdmi)
+{
+	/* Software reset */
+	hdmi_writel(hdmi, 0x01, I2CM_CONTROL0);
+
+	hdmi_writel(hdmi, 0x085c085c, I2CM_FM_SCL_CONFIG0);
+
+	hdmi_modb(hdmi, 0, I2CM_FM_EN, I2CM_INTERFACE_CONTROL0);
+
+	/* Clear DONE and ERROR interrupts */
+	hdmi_writel(hdmi, I2CM_OP_DONE_CLEAR | I2CM_NACK_RCVD_CLEAR,
+		    MAINUNIT_1_INT_CLEAR);
+}
+
+static int dw_hdmi_i2c_read(struct dw_hdmi_qp *hdmi,
+			    unsigned char *buf, unsigned int length)
+{
+	struct dw_hdmi_i2c *i2c = hdmi->i2c;
+	int i = 20;
+	u32 intr = 0;
+
+	if (!i2c->is_regaddr) {
+		printf("set read register address to 0\n");
+		i2c->slave_reg = 0x00;
+		i2c->is_regaddr = true;
+	}
+
+	while (length--) {
+		hdmi_modb(hdmi, i2c->slave_reg++ << 12, I2CM_ADDR,
+			  I2CM_INTERFACE_CONTROL0);
+
+		hdmi_modb(hdmi, I2CM_FM_READ, I2CM_WR_MASK,
+			  I2CM_INTERFACE_CONTROL0);
+
+		while (i--) {
+			udelay(1000);
+			intr = hdmi_readl(hdmi, MAINUNIT_1_INT_STATUS) &
+				(I2CM_OP_DONE_IRQ | I2CM_READ_REQUEST_IRQ |
+				 I2CM_NACK_RCVD_IRQ);
+			if (intr) {
+				hdmi_writel(hdmi, intr, MAINUNIT_1_INT_CLEAR);
+				break;
+			}
+		}
+
+		if (!i) {
+			printf("i2c read time out!\n");
+			hdmi_writel(hdmi, 0x01, I2CM_CONTROL0);
+			return -EAGAIN;
+		}
+
+		/* Check for error condition on the bus */
+		if (intr & I2CM_NACK_RCVD_IRQ) {
+			printf("i2c read err!\n");
+			hdmi_writel(hdmi, 0x01, I2CM_CONTROL0);
+			return -EIO;
+		}
+
+		*buf++ = hdmi_readl(hdmi, I2CM_INTERFACE_RDDATA_0_3) & 0xff;
+		hdmi_modb(hdmi, 0, I2CM_WR_MASK, I2CM_INTERFACE_CONTROL0);
+		i = 20;
+	}
+	i2c->is_segment = false;
+
+	return 0;
+}
+
+static int dw_hdmi_i2c_write(struct dw_hdmi_qp *hdmi,
+			     unsigned char *buf, unsigned int length)
+{
+	struct dw_hdmi_i2c *i2c = hdmi->i2c;
+	int i = 20;
+	u32 intr = 0;
+
+	if (!i2c->is_regaddr) {
+		/* Use the first write byte as register address */
+		i2c->slave_reg = buf[0];
+		length--;
+		buf++;
+		i2c->is_regaddr = true;
+	}
+
+	while (length--) {
+		hdmi_writel(hdmi, *buf++, I2CM_INTERFACE_WRDATA_0_3);
+		hdmi_modb(hdmi, i2c->slave_reg++ << 12, I2CM_ADDR,
+			  I2CM_INTERFACE_CONTROL0);
+		hdmi_modb(hdmi, I2CM_FM_WRITE, I2CM_WR_MASK,
+			  I2CM_INTERFACE_CONTROL0);
+
+		while (i--) {
+			udelay(1000);
+			intr = hdmi_readl(hdmi, MAINUNIT_1_INT_STATUS) &
+				(I2CM_OP_DONE_IRQ | I2CM_READ_REQUEST_IRQ |
+				 I2CM_NACK_RCVD_IRQ);
+			if (intr) {
+				hdmi_writel(hdmi, intr, MAINUNIT_1_INT_CLEAR);
+				break;
+			}
+		}
+
+		if (!i) {
+			printf("i2c write time out!\n");
+			hdmi_writel(hdmi, 0x01, I2CM_CONTROL0);
+			return -EAGAIN;
+		}
+
+		/* Check for error condition on the bus */
+		if (intr & I2CM_NACK_RCVD_IRQ) {
+			printf("i2c write nack!\n");
+			hdmi_writel(hdmi, 0x01, I2CM_CONTROL0);
+			return -EIO;
+		}
+		hdmi_modb(hdmi, 0, I2CM_WR_MASK, I2CM_INTERFACE_CONTROL0);
+		i = 20;
+	}
+
+	return 0;
+}
+
+static int dw_hdmi_i2c_xfer(struct ddc_adapter *adap,
+			    struct i2c_msg *msgs, int num)
+{
+	struct dw_hdmi_qp *hdmi = container_of(adap, struct dw_hdmi_qp, adap);
+	struct dw_hdmi_i2c *i2c = hdmi->i2c;
+	u8 addr = msgs[0].addr;
+	int i, ret = 0;
+
+	debug("i2c xfer: num: %d, addr: %#x\n", num, addr);
+
+	for (i = 0; i < num; i++) {
+		if (msgs[i].len == 0) {
+			printf("unsupported transfer %d/%d, no data\n",
+			       i + 1, num);
+			return -EOPNOTSUPP;
+		}
+	}
+
+	/* Unmute DONE and ERROR interrupts */
+	hdmi_modb(hdmi, I2CM_NACK_RCVD_MASK_N | I2CM_OP_DONE_MASK_N,
+		  I2CM_NACK_RCVD_MASK_N | I2CM_OP_DONE_MASK_N,
+		  MAINUNIT_1_INT_MASK_N);
+
+	/* Set slave device address taken from the first I2C message */
+	if (addr == DDC_SEGMENT_ADDR && msgs[0].len == 1)
+		addr = DDC_ADDR;
+
+	hdmi_modb(hdmi, addr << 5, I2CM_SLVADDR, I2CM_INTERFACE_CONTROL0);
+
+	/* Set slave device register address on transfer */
+	i2c->is_regaddr = false;
+
+	/* Set segment pointer for I2C extended read mode operation */
+	i2c->is_segment = false;
+
+	for (i = 0; i < num; i++) {
+		debug("xfer: num: %d/%d, len: %d, flags: %#x\n",
+		      i + 1, num, msgs[i].len, msgs[i].flags);
+
+		if (msgs[i].addr == DDC_SEGMENT_ADDR && msgs[i].len == 1) {
+			i2c->is_segment = true;
+			hdmi_modb(hdmi, DDC_SEGMENT_ADDR, I2CM_SEG_ADDR,
+				  I2CM_INTERFACE_CONTROL1);
+			hdmi_modb(hdmi, *msgs[i].buf, I2CM_SEG_PTR,
+				  I2CM_INTERFACE_CONTROL1);
+		} else {
+			if (msgs[i].flags & I2C_M_RD)
+				ret = dw_hdmi_i2c_read(hdmi, msgs[i].buf,
+						       msgs[i].len);
+			else
+				ret = dw_hdmi_i2c_write(hdmi, msgs[i].buf,
+							msgs[i].len);
+		}
+		if (ret < 0)
+			break;
+	}
+
+	if (!ret)
+		ret = num;
+
+	/* Mute DONE and ERROR interrupts */
+	hdmi_modb(hdmi, 0, I2CM_OP_DONE_MASK_N | I2CM_NACK_RCVD_MASK_N,
+		  MAINUNIT_1_INT_MASK_N);
+
+	return ret;
+}
+
+static int dw_hdmi_detect_phy(struct dw_hdmi_qp *hdmi)
+{
+	/* Vendor PHYs require support from the glue layer. */
+	if (!hdmi->plat_data->qp_phy_ops || !hdmi->plat_data->phy_name) {
+		dev_err(hdmi->dev,
+			"Vendor HDMI PHY not supported by glue layer\n");
+		return -ENODEV;
+	}
+
+	hdmi->phy.ops = hdmi->plat_data->qp_phy_ops;
+	hdmi->phy.data = hdmi->plat_data->phy_data;
+	hdmi->phy.name = hdmi->plat_data->phy_name;
+
+	return 0;
+}
+
+static unsigned int
+hdmi_get_tmdsclock(struct dw_hdmi_qp *hdmi, unsigned long mpixelclock)
+{
+	unsigned int tmdsclock = mpixelclock;
+	unsigned int depth =
+		hdmi_bus_fmt_color_depth(hdmi->hdmi_data.enc_out_bus_format);
+
+	if (!hdmi_bus_fmt_is_yuv422(hdmi->hdmi_data.enc_out_bus_format)) {
+		switch (depth) {
+		case 16:
+			tmdsclock = mpixelclock * 2;
+			break;
+		case 12:
+			tmdsclock = mpixelclock * 3 / 2;
+			break;
+		case 10:
+			tmdsclock = mpixelclock * 5 / 4;
+			break;
+		default:
+			break;
+		}
+	}
+
+	return tmdsclock;
+}
+
+static void hdmi_infoframe_set_checksum(u8 *ptr, int size)
+{
+	u8 csum = 0;
+	int i;
+
+	ptr[3] = 0;
+	/* compute checksum */
+	for (i = 0; i < size; i++)
+		csum += ptr[i];
+
+	ptr[3] = 256 - csum;
+}
+
+static bool is_hdmi2_sink(struct dw_hdmi_qp *hdmi)
+{
+	return hdmi->edid_data.display_info.hdmi.scdc.supported ||
+		hdmi->edid_data.display_info.color_formats & DRM_COLOR_FORMAT_YCRCB420;
+}
+
+static void hdmi_config_AVI(struct dw_hdmi_qp *hdmi, struct drm_display_mode *mode)
+{
+	struct hdmi_avi_infoframe frame;
+	u32 val, i, j;
+	u8 buff[17];
+	bool is_hdmi2 = false;
+	enum hdmi_quantization_range rgb_quant_range =
+		hdmi->hdmi_data.quant_range;
+
+	if (hdmi_bus_fmt_is_yuv420(hdmi->hdmi_data.enc_out_bus_format) ||
+	    hdmi->edid_data.display_info.hdmi.scdc.supported)
+		is_hdmi2 = true;
+	/* Initialise info frame from DRM mode */
+	drm_hdmi_avi_infoframe_from_display_mode(&frame, mode, is_hdmi2);
+
+	/*
+	 * Ignore monitor selectable quantization, use quantization set
+	 * by the user
+	 */
+	drm_hdmi_avi_infoframe_quant_range(&frame, mode, rgb_quant_range,
+					   true);
+	if (hdmi_bus_fmt_is_yuv444(hdmi->hdmi_data.enc_out_bus_format))
+		frame.colorspace = HDMI_COLORSPACE_YUV444;
+	else if (hdmi_bus_fmt_is_yuv422(hdmi->hdmi_data.enc_out_bus_format))
+		frame.colorspace = HDMI_COLORSPACE_YUV422;
+	else if (hdmi_bus_fmt_is_yuv420(hdmi->hdmi_data.enc_out_bus_format))
+		frame.colorspace = HDMI_COLORSPACE_YUV420;
+	else
+		frame.colorspace = HDMI_COLORSPACE_RGB;
+
+	/* Set up colorimetry and quant range */
+	if (!hdmi_bus_fmt_is_rgb(hdmi->hdmi_data.enc_out_bus_format)) {
+		switch (hdmi->hdmi_data.enc_out_encoding) {
+		case V4L2_YCBCR_ENC_601:
+			if (hdmi->hdmi_data.enc_in_encoding == V4L2_YCBCR_ENC_XV601)
+				frame.colorimetry = HDMI_COLORIMETRY_EXTENDED;
+			else
+				frame.colorimetry = HDMI_COLORIMETRY_ITU_601;
+			frame.extended_colorimetry =
+					HDMI_EXTENDED_COLORIMETRY_XV_YCC_601;
+			break;
+		case V4L2_YCBCR_ENC_709:
+			if (hdmi->hdmi_data.enc_in_encoding == V4L2_YCBCR_ENC_XV709)
+				frame.colorimetry = HDMI_COLORIMETRY_EXTENDED;
+			else
+				frame.colorimetry = HDMI_COLORIMETRY_ITU_709;
+			frame.extended_colorimetry =
+					HDMI_EXTENDED_COLORIMETRY_XV_YCC_709;
+			break;
+		case V4L2_YCBCR_ENC_BT2020:
+			if (hdmi->hdmi_data.enc_in_encoding == V4L2_YCBCR_ENC_BT2020)
+				frame.colorimetry = HDMI_COLORIMETRY_EXTENDED;
+			else
+				frame.colorimetry = HDMI_COLORIMETRY_ITU_709;
+			frame.extended_colorimetry =
+					HDMI_EXTENDED_COLORIMETRY_BT2020;
+			break;
+		default: /* Carries no data */
+			frame.colorimetry = HDMI_COLORIMETRY_ITU_601;
+			frame.extended_colorimetry =
+					HDMI_EXTENDED_COLORIMETRY_XV_YCC_601;
+			break;
+		}
+
+		frame.ycc_quantization_range = HDMI_YCC_QUANTIZATION_RANGE_LIMITED;
+	} else {
+		if (hdmi->hdmi_data.enc_out_encoding == V4L2_YCBCR_ENC_BT2020) {
+			frame.colorimetry = HDMI_COLORIMETRY_EXTENDED;
+			frame.extended_colorimetry =
+				HDMI_EXTENDED_COLORIMETRY_BT2020;
+		} else {
+			frame.colorimetry = HDMI_COLORIMETRY_NONE;
+			frame.extended_colorimetry =
+				HDMI_EXTENDED_COLORIMETRY_XV_YCC_601;
+		}
+
+		if (is_hdmi2_sink(hdmi) &&
+		    frame.quantization_range == HDMI_QUANTIZATION_RANGE_FULL)
+			frame.ycc_quantization_range = HDMI_YCC_QUANTIZATION_RANGE_FULL;
+		else
+			frame.ycc_quantization_range = HDMI_YCC_QUANTIZATION_RANGE_LIMITED;
+	}
+
+	frame.scan_mode = HDMI_SCAN_MODE_NONE;
+
+	hdmi_avi_infoframe_pack_only(&frame, buff, 17);
+
+	/* mode which vic >= 128 must use avi version 3 */
+	if (hdmi->vic >= 128) {
+		frame.version = 3;
+		buff[1] = frame.version;
+		buff[4] &= 0x1f;
+		buff[4] |= ((frame.colorspace & 0x7) << 5);
+		buff[7] = hdmi->vic;
+		hdmi_infoframe_set_checksum(buff, 17);
+	}
+
+	/*
+	 * The Designware IP uses a different byte format from standard
+	 * AVI info frames, though generally the bits are in the correct
+	 * bytes.
+	 */
+
+	val = (frame.version << 8) | (frame.length << 16);
+	hdmi_writel(hdmi, val, PKT_AVI_CONTENTS0);
+
+	for (i = 0; i < 4; i++) {
+		for (j = 0; j < 4; j++) {
+			if (i * 4 + j >= 14)
+				break;
+			if (!j)
+				val = buff[i * 4 + j + 3];
+			val |= buff[i * 4 + j + 3] << (8 * j);
+		}
+
+		hdmi_writel(hdmi, val, PKT_AVI_CONTENTS1 + i * 4);
+	}
+
+	hdmi_modb(hdmi, 0, PKTSCHED_AVI_FIELDRATE, PKTSCHED_PKT_CONFIG1);
+
+	hdmi_modb(hdmi, PKTSCHED_AVI_TX_EN, PKTSCHED_AVI_TX_EN,
+		  PKTSCHED_PKT_EN);
+}
+
+#define VSI_PKT_TYPE		0x81
+#define VSI_PKT_VERSION		1
+#define HDMI_FORUM_OUI		0xc45dd8
+#define ALLM_MODE		BIT(1)
+#define HDMI_FORUM_LEN		9
+
+static void hdmi_config_vendor_specific_infoframe(struct dw_hdmi_qp *hdmi,
+						  struct drm_display_mode *mode)
+{
+	struct hdmi_vendor_infoframe frame;
+	struct dw_hdmi_link_config *link_cfg = NULL;
+	u8 buffer[10];
+	u32 val;
+	ssize_t err;
+	int i, reg;
+
+	link_cfg = dw_hdmi_rockchip_get_link_cfg(hdmi->rk_hdmi);
+
+	hdmi_modb(hdmi, 0, PKTSCHED_VSI_TX_EN, PKTSCHED_PKT_EN);
+
+	for (i = 0; i <= 7; i++)
+		hdmi_writel(hdmi, 0, PKT_VSI_CONTENTS0 + i * 4);
+
+	if (link_cfg->allm_en) {
+		buffer[0] = VSI_PKT_TYPE;
+		buffer[1] = VSI_PKT_VERSION;
+		buffer[2] = 5;
+		buffer[4] = HDMI_FORUM_OUI & 0xff;
+		buffer[5] = (HDMI_FORUM_OUI >> 8) & 0xff;
+		buffer[6] = (HDMI_FORUM_OUI >> 16) & 0xff;
+		buffer[7] = VSI_PKT_VERSION;
+		buffer[8] = ALLM_MODE;
+
+		hdmi_infoframe_set_checksum(buffer, HDMI_FORUM_LEN);
+
+		err = 9;
+	} else {
+		err = drm_hdmi_vendor_infoframe_from_display_mode(&frame, mode);
+		if (err < 0)
+			/*
+			 * Going into that statement does not means vendor infoframe
+			 * fails. It just informed us that vendor infoframe is not
+			 * needed for the selected mode. Only 4k or stereoscopic 3D
+			 * mode requires vendor infoframe. So just simply return.
+			 */
+			return;
+
+		err = hdmi_vendor_infoframe_pack(&frame, buffer, sizeof(buffer));
+		if (err < 0) {
+			dev_err(hdmi->dev, "Failed to pack vendor infoframe: %zd\n",
+				err);
+			return;
+		}
+	}
+
+	/* vsi header */
+	val = (buffer[2] << 16) | (buffer[1] << 8) | buffer[0];
+	hdmi_writel(hdmi, val, PKT_VSI_CONTENTS0);
+
+	reg = PKT_VSI_CONTENTS1;
+	for (i = 3; i < err; i++) {
+		if (i % 4 == 3)
+			val = buffer[i];
+		if (i % 4 == 0)
+			val |= buffer[i] << 8;
+		if (i % 4 == 1)
+			val |= buffer[i] << 16;
+		if (i % 4 == 2)
+			val |= buffer[i] << 24;
+
+		if ((i % 4 == 2) || (i == (err - 1))) {
+			hdmi_writel(hdmi, val, reg);
+			reg += 4;
+		}
+	}
+
+	hdmi_writel(hdmi, 0, PKT_VSI_CONTENTS7);
+
+	hdmi_modb(hdmi, 0, PKTSCHED_VSI_FIELDRATE, PKTSCHED_PKT_CONFIG1);
+	hdmi_modb(hdmi, PKTSCHED_VSI_TX_EN, PKTSCHED_VSI_TX_EN,
+		  PKTSCHED_PKT_EN);
+}
+
+static void hdmi_config_CVTEM(struct dw_hdmi_qp *hdmi,
+			      struct dw_hdmi_link_config *link_cfg)
+{
+	u8 ds_type = 0;
+	u8 sync = 1;
+	u8 vfr = 1;
+	u8 afr = 0;
+	u8 new = 1;
+	u8 end = 0;
+	u8 data_set_length = 136;
+	u8 hb1[6] = { 0x80, 0, 0, 0, 0, 0x40 };
+	u8 *pps_body;
+	u32 val, i, reg;
+	struct drm_display_mode *mode = &hdmi->previous_mode;
+	int hsync, hfront, hback;
+
+	hdmi_modb(hdmi, 0, PKTSCHED_EMP_CVTEM_TX_EN, PKTSCHED_PKT_EN);
+
+	if (!link_cfg->dsc_mode) {
+		printf("don't use dsc mode\n");
+		return;
+	}
+
+	pps_body = link_cfg->pps_payload;
+
+	hsync = mode->hsync_end - mode->hsync_start;
+	hback = mode->htotal - mode->hsync_end;
+	hfront = mode->hsync_start - mode->hdisplay;
+
+	for (i = 0; i < 6; i++) {
+		val = i << 16 | hb1[i] << 8;
+		hdmi_writel(hdmi, val, PKT0_EMP_CVTEM_CONTENTS0 + i * 0x20);
+	}
+
+	val = new << 7 | end << 6 | ds_type << 4 | afr << 3 |
+	      vfr << 2 | sync << 1;
+	hdmi_writel(hdmi, val, PKT0_EMP_CVTEM_CONTENTS1);
+
+	val = data_set_length << 16 | pps_body[0] << 24;
+	hdmi_writel(hdmi, val, PKT0_EMP_CVTEM_CONTENTS2);
+
+	reg = PKT0_EMP_CVTEM_CONTENTS3;
+	for (i = 1; i < 125; i++) {
+		if (reg == PKT1_EMP_CVTEM_CONTENTS0 ||
+		    reg == PKT2_EMP_CVTEM_CONTENTS0 ||
+		    reg == PKT3_EMP_CVTEM_CONTENTS0 ||
+		    reg == PKT4_EMP_CVTEM_CONTENTS0 ||
+		    reg == PKT5_EMP_CVTEM_CONTENTS0) {
+			reg += 4;
+			i--;
+			continue;
+		}
+		if (i % 4 == 1)
+			val = pps_body[i];
+		if (i % 4 == 2)
+			val |= pps_body[i] << 8;
+		if (i % 4 == 3)
+			val |= pps_body[i] << 16;
+		if (!(i % 4)) {
+			val |= pps_body[i] << 24;
+			hdmi_writel(hdmi, val, reg);
+			reg += 4;
+		}
+	}
+
+	val = (hfront & 0xff) << 24 | pps_body[127] << 16 |
+	      pps_body[126] << 8 | pps_body[125];
+	hdmi_writel(hdmi, val, PKT4_EMP_CVTEM_CONTENTS6);
+
+	val = (hback & 0xff) << 24 | ((hsync >> 8) & 0xff) << 16 |
+	      (hsync & 0xff) << 8 | ((hfront >> 8) & 0xff);
+	hdmi_writel(hdmi, val, PKT4_EMP_CVTEM_CONTENTS7);
+
+	val = link_cfg->hcactive << 8 | ((hback >> 8) & 0xff);
+	hdmi_writel(hdmi, val, PKT5_EMP_CVTEM_CONTENTS1);
+
+	for (i = PKT5_EMP_CVTEM_CONTENTS2; i <= PKT5_EMP_CVTEM_CONTENTS7; i += 4)
+		hdmi_writel(hdmi, 0, i);
+
+	hdmi_modb(hdmi, PKTSCHED_EMP_CVTEM_TX_EN, PKTSCHED_EMP_CVTEM_TX_EN,
+		  PKTSCHED_PKT_EN);
+}
+
+static int hdmi_set_frl_mask(int frl_rate)
+{
+	switch (frl_rate) {
+	case 48:
+		return FRL_12GBPS_4LANE;
+	case 40:
+		return FRL_10GBPS_4LANE;
+	case 32:
+		return FRL_8GBPS_4LANE;
+	case 24:
+		return FRL_6GBPS_4LANE;
+	case 18:
+		return FRL_6GBPS_3LANE;
+	case 9:
+		return FRL_3GBPS_3LANE;
+	}
+
+	return 0;
+}
+
+static int hdmi_start_flt(struct dw_hdmi_qp *hdmi, u8 rate)
+{
+	u8 val;
+	u32 value;
+	u8 ffe_lv = 0;
+	int i = 0;
+	bool ltsp = false;
+
+	hdmi_modb(hdmi, AVP_DATAPATH_VIDEO_SWDISABLE,
+		  AVP_DATAPATH_VIDEO_SWDISABLE, GLOBAL_SWDISABLE);
+
+	hdmi_writel(hdmi, AVP_DATAPATH_SWINIT_P, GLOBAL_SWRESET_REQUEST);
+
+	/* clear flt flags */
+	drm_scdc_writeb(&hdmi->adap, 0x10, 0xff);
+
+	/* FLT_READY & FFE_LEVELS read */
+	for (i = 0; i < 20; i++) {
+		drm_scdc_readb(&hdmi->adap, SCDC_STATUS_FLAGS_0, &val);
+		if (val & BIT(6))
+			break;
+		mdelay(20);
+	}
+
+	if (i == 20) {
+		printf("sink flt isn't ready\n");
+		return -EINVAL;
+	}
+
+	/* max ffe level 3 */
+	val = 0 << 4 | hdmi_set_frl_mask(rate);
+	drm_scdc_writeb(&hdmi->adap, 0x31, val);
+	/* select FRL_RATE & FFE_LEVELS */
+	hdmi_writel(hdmi, ffe_lv, FLT_CONFIG0);
+
+	i = 500;
+	while (i--) {
+		mdelay(4);
+		drm_scdc_readb(&hdmi->adap, 0x10, &val);
+
+		if (!(val & 0x30))
+			continue;
+
+		if (val & BIT(5)) {
+			u8 reg_val, ln0, ln1, ln2, ln3;
+
+			drm_scdc_readb(&hdmi->adap, 0x41, &reg_val);
+			ln0 = reg_val & 0xf;
+			ln1 = (reg_val >> 4) & 0xf;
+
+			drm_scdc_readb(&hdmi->adap, 0x42, &reg_val);
+			ln2 = reg_val & 0xf;
+			ln3 = (reg_val >> 4) & 0xf;
+
+			if (!ln0 && !ln1 && !ln2 && !ln3) {
+				printf("goto ltsp\n");
+				ltsp = true;
+				hdmi_writel(hdmi, 0, FLT_CONFIG1);
+			} else if ((ln0 == 0xf) | (ln1 == 0xf) | (ln2 == 0xf) | (ln3 == 0xf)) {
+				printf("goto lts4\n");
+				break;
+			} else if ((ln0 == 0xe) | (ln1 == 0xe) | (ln2 == 0xe) | (ln3 == 0xe)) {
+				printf("goto ffe\n");
+				break;
+			} else {
+				value = (ln3 << 16) | (ln2 << 12) | (ln1 << 8) | (ln0 << 4) | 0xf;
+				hdmi_writel(hdmi, value, FLT_CONFIG1);
+			}
+		}
+
+		drm_scdc_writeb(&hdmi->adap, 0x10, val);
+
+		if ((val & BIT(4)) && ltsp) {
+			hdmi_modb(hdmi, 0, AVP_DATAPATH_VIDEO_SWDISABLE, GLOBAL_SWDISABLE);
+			printf("flt success\n");
+			break;
+		}
+	}
+
+	if (i < 0) {
+		printf("flt time out\n");
+		return -ETIMEDOUT;
+	}
+
+	return 0;
+}
+
+#define HDMI_MODE_FRL_MASK     BIT(30)
+
+static void hdmi_set_op_mode(struct dw_hdmi_qp *hdmi,
+			     struct dw_hdmi_link_config *link_cfg,
+			     struct display_state *state,
+			     struct rockchip_connector *conn)
+{
+	int frl_rate;
+	int i, ret;
+
+	if (!link_cfg->frl_mode) {
+		printf("dw hdmi qp use tmds mode\n");
+		hdmi_modb(hdmi, 0, OPMODE_FRL, LINK_CONFIG0);
+		hdmi_modb(hdmi, 0, OPMODE_FRL_4LANES, LINK_CONFIG0);
+		hdmi->phy.ops->init(conn, hdmi->rk_hdmi, state);
+		hdmi->phy.enabled = true;
+		return;
+	}
+
+	if (link_cfg->frl_lanes == 4)
+		hdmi_modb(hdmi, OPMODE_FRL_4LANES, OPMODE_FRL_4LANES,
+			  LINK_CONFIG0);
+	else
+		hdmi_modb(hdmi, 0, OPMODE_FRL_4LANES, LINK_CONFIG0);
+
+	hdmi_modb(hdmi, 1, OPMODE_FRL, LINK_CONFIG0);
+
+	frl_rate = link_cfg->frl_lanes * link_cfg->rate_per_lane;
+	hdmi->phy.ops->init(conn, hdmi->rk_hdmi, state);
+	hdmi->phy.enabled = true;
+
+	mdelay(200);
+	ret = hdmi_start_flt(hdmi, frl_rate);
+	if (ret) {
+		hdmi_writel(hdmi, 0, FLT_CONFIG0);
+		drm_scdc_writeb(&hdmi->adap, 0x31, 0);
+		hdmi_modb(hdmi, 0, AVP_DATAPATH_VIDEO_SWDISABLE, GLOBAL_SWDISABLE);
+		return;
+	}
+
+	for (i = 0; i < 200; i++) {
+		hdmi_modb(hdmi, PKTSCHED_NULL_TX_EN, PKTSCHED_NULL_TX_EN, PKTSCHED_PKT_EN);
+		udelay(50);
+		hdmi_modb(hdmi, 0, PKTSCHED_NULL_TX_EN, PKTSCHED_PKT_EN);
+		udelay(50);
+	}
+}
+
+static int dw_hdmi_setup(struct dw_hdmi_qp *hdmi,
+			 struct rockchip_connector *conn,
+			 struct drm_display_mode *mode,
+			 struct display_state *state)
+{
+	int ret;
+	void *data = hdmi->plat_data->phy_data;
+	struct dw_hdmi_link_config *link_cfg;
+	struct drm_hdmi_info *hdmi_info = &hdmi->edid_data.display_info.hdmi;
+	struct hdmi_vmode *vmode = &hdmi->hdmi_data.video_mode;
+	u8 bytes = 0;
+
+	if (!hdmi->vic)
+		printf("Non-CEA mode used in HDMI\n");
+	else
+		printf("CEA mode used vic=%d\n", hdmi->vic);
+
+	vmode->mpixelclock = mode->clock * 1000;
+	vmode->mtmdsclock = hdmi_get_tmdsclock(hdmi, vmode->mpixelclock);
+	if (hdmi_bus_fmt_is_yuv420(hdmi->hdmi_data.enc_out_bus_format))
+		vmode->mtmdsclock /= 2;
+	printf("mtmdsclock:%d\n", vmode->mtmdsclock);
+
+	if (hdmi->plat_data->get_enc_out_encoding)
+		hdmi->hdmi_data.enc_out_encoding =
+			hdmi->plat_data->get_enc_out_encoding(data);
+	else if (hdmi->vic == 6 || hdmi->vic == 7 ||
+		 hdmi->vic == 21 || hdmi->vic == 22 ||
+		 hdmi->vic == 2 || hdmi->vic == 3 ||
+		 hdmi->vic == 17 || hdmi->vic == 18)
+		hdmi->hdmi_data.enc_out_encoding = V4L2_YCBCR_ENC_601;
+	else
+		hdmi->hdmi_data.enc_out_encoding = V4L2_YCBCR_ENC_709;
+
+	if (mode->flags & DRM_MODE_FLAG_DBLCLK) {
+		hdmi->hdmi_data.video_mode.mpixelrepetitionoutput = 1;
+		hdmi->hdmi_data.video_mode.mpixelrepetitioninput = 1;
+	} else {
+		hdmi->hdmi_data.video_mode.mpixelrepetitionoutput = 0;
+		hdmi->hdmi_data.video_mode.mpixelrepetitioninput = 0;
+	}
+
+	/* TOFIX: Get input encoding from plat data or fallback to none */
+	if (hdmi->plat_data->get_enc_in_encoding)
+		hdmi->hdmi_data.enc_in_encoding =
+			hdmi->plat_data->get_enc_in_encoding(data);
+	else if (hdmi->plat_data->input_bus_encoding)
+		hdmi->hdmi_data.enc_in_encoding =
+			hdmi->plat_data->input_bus_encoding;
+	else
+		hdmi->hdmi_data.enc_in_encoding = V4L2_YCBCR_ENC_DEFAULT;
+
+	if (hdmi->plat_data->get_quant_range)
+		hdmi->hdmi_data.quant_range =
+			hdmi->plat_data->get_quant_range(data);
+	else
+		hdmi->hdmi_data.quant_range = HDMI_QUANTIZATION_RANGE_DEFAULT;
+
+	/*
+	 * According to the dw-hdmi specification 6.4.2
+	 * vp_pr_cd[3:0]:
+	 * 0000b: No pixel repetition (pixel sent only once)
+	 * 0001b: Pixel sent two times (pixel repeated once)
+	 */
+	hdmi->hdmi_data.pix_repet_factor =
+		(mode->flags & DRM_MODE_FLAG_DBLCLK) ? 1 : 0;
+	hdmi->hdmi_data.video_mode.mdataenablepolarity = true;
+
+	/* HDMI Initialization Step B.2 */
+	hdmi->phy.ops->set_pll(conn, hdmi->rk_hdmi, state);
+
+	/* Mark yuv422 10bit */
+	if (hdmi->hdmi_data.enc_out_bus_format == MEDIA_BUS_FMT_YUYV10_1X20)
+		hdmi_writel(hdmi, BIT(20), VIDEO_INTERFACE_CONFIG0);
+	rk3588_set_grf_cfg(hdmi->rk_hdmi);
+	link_cfg = dw_hdmi_rockchip_get_link_cfg(hdmi->rk_hdmi);
+
+	/* not for DVI mode */
+	if (hdmi->sink_is_hdmi) {
+	// if (true) {
+		printf("%s HDMI mode\n", __func__);
+		hdmi_modb(hdmi, 0, OPMODE_DVI, LINK_CONFIG0);
+		hdmi_modb(hdmi, HDCP2_BYPASS, HDCP2_BYPASS, HDCP2LOGIC_CONFIG0);
+		hdmi_modb(hdmi, KEEPOUT_REKEY_ALWAYS, KEEPOUT_REKEY_CFG, FRAME_COMPOSER_CONFIG9);
+		hdmi_writel(hdmi, 0, FLT_CONFIG0);
+		if (hdmi_info->scdc.supported)
+			drm_scdc_writeb(&hdmi->adap, 0x31, 0);
+		if (!link_cfg->frl_mode) {
+			if (vmode->mtmdsclock > HDMI14_MAX_TMDSCLK) {
+				drm_scdc_readb(&hdmi->adap, SCDC_SINK_VERSION, &bytes);
+				drm_scdc_writeb(&hdmi->adap, SCDC_SOURCE_VERSION,
+						min_t(u8, bytes, SCDC_MIN_SOURCE_VERSION));
+				drm_scdc_set_high_tmds_clock_ratio(&hdmi->adap, 1);
+				drm_scdc_set_scrambling(&hdmi->adap, 1);
+				hdmi_writel(hdmi, 1, SCRAMB_CONFIG0);
+				mdelay(100);
+			} else {
+				if (hdmi_info->scdc.supported) {
+					drm_scdc_set_high_tmds_clock_ratio(&hdmi->adap, 0);
+					drm_scdc_set_scrambling(&hdmi->adap, 0);
+				}
+				hdmi_writel(hdmi, 0, SCRAMB_CONFIG0);
+			}
+		}
+		/* HDMI Initialization Step F - Configure AVI InfoFrame */
+		hdmi_config_AVI(hdmi, mode);
+		hdmi_config_vendor_specific_infoframe(hdmi, mode);
+		hdmi_config_CVTEM(hdmi, link_cfg);
+		hdmi_set_op_mode(hdmi, link_cfg, state, conn);
+		/* clear avmute */
+		mdelay(50);
+		hdmi_writel(hdmi, 2, PKTSCHED_PKT_CONTROL0);
+		hdmi_modb(hdmi, PKTSCHED_GCP_TX_EN, PKTSCHED_GCP_TX_EN,
+			  PKTSCHED_PKT_EN);
+	} else {
+		hdmi_modb(hdmi, HDCP2_BYPASS, HDCP2_BYPASS, HDCP2LOGIC_CONFIG0);
+		hdmi_modb(hdmi, OPMODE_DVI, OPMODE_DVI, LINK_CONFIG0);
+		hdmi_writel(hdmi, 2, PKTSCHED_PKT_CONTROL0);
+		hdmi_modb(hdmi, PKTSCHED_GCP_TX_EN, PKTSCHED_GCP_TX_EN, PKTSCHED_PKT_EN);
+		ret = hdmi->phy.ops->init(conn, hdmi->rk_hdmi, state);
+		if (ret)
+			return ret;
+		hdmi->phy.enabled = true;
+		printf("%s DVI mode\n", __func__);
+	}
+
+	/* Mark uboot hdmi is enabled */
+	hdmi_writel(hdmi, BIT(21), VIDEO_INTERFACE_CONFIG0);
+
+	return 0;
+}
+
+int dw_hdmi_detect_hotplug(struct dw_hdmi_qp *hdmi,
+			   struct display_state *state)
+{
+	struct connector_state *conn_state = &state->conn_state;
+	struct rockchip_connector *conn = conn_state->connector;
+	int ret;
+
+	ret = hdmi->phy.ops->read_hpd(hdmi->rk_hdmi);
+	if (!ret) {
+		if (conn->bridge)
+			ret = rockchip_bridge_detect(conn->bridge);
+	}
+
+	if (ret || state->force_output) {
+		if (!hdmi->id)
+			conn_state->output_if |= VOP_OUTPUT_IF_HDMI0;
+		else
+			conn_state->output_if |= VOP_OUTPUT_IF_HDMI1;
+	}
+
+	return ret;
+}
+
+int rockchip_dw_hdmi_qp_init(struct rockchip_connector *conn, struct display_state *state)
+{
+	struct connector_state *conn_state = &state->conn_state;
+	const struct dw_hdmi_plat_data *pdata =
+		(const struct dw_hdmi_plat_data *)dev_get_driver_data(conn->dev);
+	void *rk_hdmi = dev_get_priv(conn->dev);
+	struct dw_hdmi_qp *hdmi;
+	struct drm_display_mode *mode_buf;
+	ofnode hdmi_node = conn->dev->node_;
+	struct device_node *ddc_node;
+
+	hdmi = malloc(sizeof(struct dw_hdmi_qp));
+	if (!hdmi)
+		return -ENOMEM;
+
+	memset(hdmi, 0, sizeof(struct dw_hdmi_qp));
+	mode_buf = malloc(MODE_LEN * sizeof(struct drm_display_mode));
+	if (!mode_buf)
+		return -ENOMEM;
+
+	hdmi->rk_hdmi = rk_hdmi;
+	hdmi->id = of_alias_get_id(ofnode_to_np(hdmi_node), "hdmi");
+	if (hdmi->id < 0)
+		hdmi->id = 0;
+	conn_state->disp_info = rockchip_get_disp_info(conn_state->type, hdmi->id);
+
+	memset(mode_buf, 0, MODE_LEN * sizeof(struct drm_display_mode));
+
+	hdmi->regs = dev_read_addr_ptr(conn->dev);
+
+	ddc_node = of_parse_phandle(ofnode_to_np(hdmi_node), "ddc-i2c-bus", 0);
+	if (ddc_node) {
+		uclass_get_device_by_ofnode(UCLASS_I2C, np_to_ofnode(ddc_node),
+					    &hdmi->adap.i2c_bus);
+		if (hdmi->adap.i2c_bus)
+			hdmi->adap.ops = i2c_get_ops(hdmi->adap.i2c_bus);
+	}
+
+	hdmi->i2c = malloc(sizeof(struct dw_hdmi_i2c));
+	if (!hdmi->i2c)
+		return -ENOMEM;
+	hdmi->adap.ddc_xfer = dw_hdmi_i2c_xfer;
+
+	/*
+	 * Read high and low time from device tree. If not available use
+	 * the default timing scl clock rate is about 99.6KHz.
+	 */
+	hdmi->i2c->scl_high_ns =
+		ofnode_read_s32_default(hdmi_node,
+					"ddc-i2c-scl-high-time-ns", 4708);
+	hdmi->i2c->scl_low_ns =
+		ofnode_read_s32_default(hdmi_node,
+					"ddc-i2c-scl-low-time-ns", 4916);
+
+	dw_hdmi_i2c_init(hdmi);
+	conn_state->output_mode = ROCKCHIP_OUT_MODE_AAAA;
+
+	hdmi->dev_type = pdata->dev_type;
+	hdmi->plat_data = pdata;
+	hdmi->edid_data.mode_buf = mode_buf;
+
+	conn->data = hdmi;
+
+	dw_hdmi_detect_phy(hdmi);
+	hdmi_writel(hdmi, 0, MAINUNIT_0_INT_MASK_N);
+	hdmi_writel(hdmi, 0, MAINUNIT_1_INT_MASK_N);
+	hdmi_writel(hdmi, 428571429, TIMER_BASE_CONFIG0);
+
+	dw_hdmi_qp_set_iomux(hdmi->rk_hdmi);
+
+	return 0;
+}
+
+void rockchip_dw_hdmi_qp_deinit(struct rockchip_connector *conn, struct display_state *state)
+{
+	struct dw_hdmi_qp *hdmi = conn->data;
+
+	if (hdmi->i2c)
+		free(hdmi->i2c);
+	if (hdmi->edid_data.mode_buf)
+		free(hdmi->edid_data.mode_buf);
+	if (hdmi)
+		free(hdmi);
+}
+
+static void rockchip_dw_hdmi_qp_config_output(struct rockchip_connector *conn,
+					      struct display_state *state)
+{
+	struct connector_state *conn_state = &state->conn_state;
+	struct drm_display_mode *mode = &conn_state->mode;
+	struct dw_hdmi_qp *hdmi = conn->data;
+	unsigned int bus_format;
+	unsigned long enc_out_encoding;
+	struct overscan *overscan = &conn_state->overscan;
+
+	dw_hdmi_qp_selete_output(&hdmi->edid_data, conn, &bus_format,
+				 overscan, hdmi->dev_type,
+				 hdmi->output_bus_format_rgb, hdmi->rk_hdmi,
+				 state);
+
+	*mode = *hdmi->edid_data.preferred_mode;
+	hdmi->vic = drm_match_cea_mode(mode);
+
+	printf("mode:%dx%d bus_format:0x%x\n", mode->hdisplay, mode->vdisplay, bus_format);
+	conn_state->bus_format = bus_format;
+	hdmi->hdmi_data.enc_in_bus_format = bus_format;
+	hdmi->hdmi_data.enc_out_bus_format = bus_format;
+
+	switch (bus_format) {
+	case MEDIA_BUS_FMT_YUYV10_1X20:
+		conn_state->bus_format = MEDIA_BUS_FMT_YUYV10_1X20;
+		hdmi->hdmi_data.enc_in_bus_format =
+			MEDIA_BUS_FMT_YUYV10_1X20;
+		conn_state->output_mode = ROCKCHIP_OUT_MODE_YUV422;
+		break;
+	case MEDIA_BUS_FMT_YUYV8_1X16:
+		conn_state->bus_format = MEDIA_BUS_FMT_YUYV8_1X16;
+		hdmi->hdmi_data.enc_in_bus_format =
+			MEDIA_BUS_FMT_YUYV8_1X16;
+		conn_state->output_mode = ROCKCHIP_OUT_MODE_YUV422;
+		break;
+	case MEDIA_BUS_FMT_UYYVYY8_0_5X24:
+	case MEDIA_BUS_FMT_UYYVYY10_0_5X30:
+		conn_state->output_mode = ROCKCHIP_OUT_MODE_YUV420;
+		break;
+	}
+
+	if (hdmi->vic == 6 || hdmi->vic == 7 || hdmi->vic == 21 ||
+	    hdmi->vic == 22 || hdmi->vic == 2 || hdmi->vic == 3 ||
+	    hdmi->vic == 17 || hdmi->vic == 18)
+		enc_out_encoding = V4L2_YCBCR_ENC_601;
+	else
+		enc_out_encoding = V4L2_YCBCR_ENC_709;
+
+	if (enc_out_encoding == V4L2_YCBCR_ENC_BT2020)
+		conn_state->color_space = V4L2_COLORSPACE_BT2020;
+	else if (bus_format == MEDIA_BUS_FMT_RGB888_1X24 ||
+		 bus_format == MEDIA_BUS_FMT_RGB101010_1X30)
+		conn_state->color_space = V4L2_COLORSPACE_DEFAULT;
+	else if (enc_out_encoding == V4L2_YCBCR_ENC_709)
+		conn_state->color_space = V4L2_COLORSPACE_REC709;
+	else
+		conn_state->color_space = V4L2_COLORSPACE_SMPTE170M;
+}
+
+int rockchip_dw_hdmi_qp_prepare(struct rockchip_connector *conn, struct display_state *state)
+{
+	struct connector_state *conn_state = &state->conn_state;
+	struct drm_display_mode *mode = &conn_state->mode;
+	struct dw_hdmi_qp *hdmi = conn->data;
+
+	if (!hdmi->edid_data.preferred_mode && conn->bridge) {
+		drm_add_hdmi_modes(&hdmi->edid_data, mode);
+		drm_mode_sort(&hdmi->edid_data);
+		hdmi->sink_is_hdmi = true;
+		hdmi->sink_has_audio = true;
+		rockchip_dw_hdmi_qp_config_output(conn, state);
+	}
+
+	return 0;
+}
+
+int rockchip_dw_hdmi_qp_check(struct rockchip_connector *conn, struct display_state *state)
+{
+	struct crtc_state *cstate = &state->crtc_state;
+	struct rockchip_crtc *crtc = cstate->crtc;
+	struct dw_hdmi_qp *hdmi = conn->data;
+
+	/* clear hdmi uboot logo on flag */
+	if (crtc->splice_mode && cstate->crtc_id == 1)
+		hdmi_writel(hdmi, 0, I2CM_INTERFACE_CONTROL0);
+
+	return 0;
+}
+
+static void dw_hdmi_disable(struct rockchip_connector *conn, struct dw_hdmi_qp *hdmi,
+			    struct display_state *state)
+{
+	if (hdmi->phy.enabled) {
+		hdmi->phy.ops->disable(conn, hdmi->rk_hdmi, state);
+		hdmi->phy.enabled = false;
+	}
+}
+
+int rockchip_dw_hdmi_qp_enable(struct rockchip_connector *conn, struct display_state *state)
+{
+	struct connector_state *conn_state = &state->conn_state;
+	struct drm_display_mode *mode = &conn_state->mode;
+	struct dw_hdmi_qp *hdmi = conn->data;
+
+	if (!hdmi)
+		return -EFAULT;
+
+	/* Store the display mode for plugin/DKMS poweron events */
+	memcpy(&hdmi->previous_mode, mode, sizeof(hdmi->previous_mode));
+
+	dw_hdmi_setup(hdmi, conn, mode, state);
+
+	return 0;
+}
+
+int rockchip_dw_hdmi_qp_disable(struct rockchip_connector *conn, struct display_state *state)
+{
+	struct dw_hdmi_qp *hdmi = conn->data;
+
+	dw_hdmi_disable(conn, hdmi, state);
+	return 0;
+}
+
+static void rockchip_dw_hdmi_qp_mode_valid(struct dw_hdmi_qp *hdmi)
+{
+	struct hdmi_edid_data *edid_data = &hdmi->edid_data;
+	int i;
+	bool enable_gpio = dw_hdmi_qp_check_enable_gpio(hdmi->rk_hdmi);
+
+	for (i = 0; i < edid_data->modes; i++) {
+		if (edid_data->mode_buf[i].invalid)
+			continue;
+
+		if (edid_data->mode_buf[i].clock <= 25000)
+			edid_data->mode_buf[i].invalid = true;
+
+		if (edid_data->mode_buf[i].clock > 600000 && !enable_gpio)
+			edid_data->mode_buf[i].invalid = true;
+	}
+}
+
+static int _rockchip_dw_hdmi_qp_get_timing(struct rockchip_connector *conn,
+					   struct display_state *state, int edid_status)
+{
+	int i;
+	struct connector_state *conn_state = &state->conn_state;
+	struct dw_hdmi_qp *hdmi = conn->data;
+	struct edid *edid = (struct edid *)conn_state->edid;
+	const u8 def_modes_vic[6] = {4, 16, 2, 17, 31, 19};
+
+	if (!hdmi)
+		return -EFAULT;
+
+	if (!edid_status) {
+		hdmi->sink_is_hdmi =
+			drm_detect_hdmi_monitor(edid);
+		hdmi->sink_has_audio = drm_detect_monitor_audio(edid);
+		edid_status = drm_add_edid_modes(&hdmi->edid_data, conn_state->edid);
+	}
+	if (edid_status < 0) {
+		hdmi->sink_is_hdmi = true;
+		hdmi->sink_has_audio = true;
+		do_cea_modes(&hdmi->edid_data, def_modes_vic,
+			     sizeof(def_modes_vic));
+		hdmi->edid_data.preferred_mode = &hdmi->edid_data.mode_buf[0];
+		printf("failed to get edid\n");
+	}
+	drm_rk_filter_whitelist(&hdmi->edid_data);
+	rockchip_dw_hdmi_qp_mode_valid(hdmi);
+	drm_mode_max_resolution_filter(&hdmi->edid_data,
+				       &state->crtc_state.max_output);
+	if (!drm_mode_prune_invalid(&hdmi->edid_data)) {
+		printf("can't find valid hdmi mode\n");
+		return -EINVAL;
+	}
+
+	for (i = 0; i < hdmi->edid_data.modes; i++)
+		hdmi->edid_data.mode_buf[i].vrefresh =
+			drm_mode_vrefresh(&hdmi->edid_data.mode_buf[i]);
+
+	drm_mode_sort(&hdmi->edid_data);
+
+	rockchip_dw_hdmi_qp_config_output(conn, state);
+
+	return 0;
+}
+
+int rockchip_dw_hdmi_qp_get_timing(struct rockchip_connector *conn, struct display_state *state)
+{
+	struct connector_state *conn_state = &state->conn_state;
+	struct dw_hdmi_qp *hdmi = conn->data;
+	int ret;
+
+	ret = drm_do_get_edid(&hdmi->adap, conn_state->edid);
+
+	if (conn_state->secondary)
+		_rockchip_dw_hdmi_qp_get_timing(conn_state->secondary, state, ret);
+
+	return _rockchip_dw_hdmi_qp_get_timing(conn, state, ret);
+}
+
+
+int rockchip_dw_hdmi_qp_detect(struct rockchip_connector *conn, struct display_state *state)
+{
+	int ret;
+	struct dw_hdmi_qp *hdmi = conn->data;
+
+	if (!hdmi)
+		return -EFAULT;
+
+	ret = dw_hdmi_detect_hotplug(hdmi, state);
+
+	return ret;
+}
+
+int rockchip_dw_hdmi_qp_get_edid(struct rockchip_connector *conn, struct display_state *state)
+{
+	int ret;
+	struct connector_state *conn_state = &state->conn_state;
+	struct dw_hdmi_qp *hdmi = conn->data;
+
+	ret = drm_do_get_edid(&hdmi->adap, conn_state->edid);
+
+	return ret;
+}
diff --git a/drivers/video/drm/dw_hdmi_qp.h b/drivers/video/drm/dw_hdmi_qp.h
new file mode 100644
index 0000000000..00f30621f5
--- /dev/null
+++ b/drivers/video/drm/dw_hdmi_qp.h
@@ -0,0 +1,944 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * (C) Copyright 2022 Fuzhou Rockchip Electronics Co., Ltd
+ */
+#ifndef __DW_HDMI_QP_H__
+#define __DW_HDMI_QP_H__
+/* Main Unit Registers */
+#define CORE_ID						0x0
+#define VER_NUMBER					0x4
+#define VER_TYPE					0x8
+#define CONFIG_REG					0xc
+#define CONFIG_CEC					BIT(28)
+#define CONFIG_AUD_UD					BIT(23)
+#define CORE_TIMESTAMP_HHMM				0x14
+#define CORE_TIMESTAMP_MMDD				0x18
+#define CORE_TIMESTAMP_YYYY				0x1c
+/* Reset Manager Registers */
+#define GLOBAL_SWRESET_REQUEST				0x40
+#define EARCRX_CMDC_SWINIT_P				BIT(27)
+#define AVP_DATAPATH_PACKET_AUDIO_SWINIT_P		BIT(10)
+#define AVP_DATAPATH_SWINIT_P				BIT(6)
+#define GLOBAL_SWDISABLE				0x44
+#define CEC_SWDISABLE					BIT(17)
+#define AVP_DATAPATH_PACKET_AUDIO_SWDISABLE		BIT(10)
+#define AVP_DATAPATH_VIDEO_SWDISABLE			BIT(6)
+#define RESET_MANAGER_CONFIG0				0x48
+#define RESET_MANAGER_STATUS0				0x50
+#define RESET_MANAGER_STATUS1				0x54
+#define RESET_MANAGER_STATUS2				0x58
+/* Timer Base Registers */
+#define TIMER_BASE_CONFIG0				0x80
+#define TIMER_BASE_STATUS0				0x84
+/* CMU Registers */
+#define CMU_CONFIG0					0xa0
+#define CMU_CONFIG1					0xa4
+#define CMU_CONFIG2					0xa8
+#define CMU_CONFIG3					0xac
+#define CMU_STATUS					0xb0
+#define EARC_BPCLK_OFF					BIT(9)
+#define AUDCLK_OFF					BIT(7)
+#define LINKQPCLK_OFF					BIT(5)
+#define VIDQPCLK_OFF					BIT(3)
+#define IPI_CLK_OFF					BIT(1)
+#define CMU_IPI_CLK_FREQ				0xb4
+#define CMU_VIDQPCLK_FREQ				0xb8
+#define CMU_LINKQPCLK_FREQ				0xbc
+#define CMU_AUDQPCLK_FREQ				0xc0
+#define CMU_EARC_BPCLK_FREQ				0xc4
+/* I2CM Registers */
+#define I2CM_SM_SCL_CONFIG0				0xe0
+#define I2CM_FM_SCL_CONFIG0				0xe4
+#define I2CM_CONFIG0					0xe8
+#define I2CM_CONTROL0					0xec
+#define I2CM_STATUS0					0xf0
+#define I2CM_INTERFACE_CONTROL0				0xf4
+#define I2CM_ADDR					0xff000
+#define I2CM_SLVADDR					0xfe0
+#define I2CM_WR_MASK					0x1e
+#define I2CM_EXT_READ					BIT(4)
+#define I2CM_SHORT_READ					BIT(3)
+#define I2CM_FM_READ					BIT(2)
+#define I2CM_FM_WRITE					BIT(1)
+#define I2CM_FM_EN					BIT(0)
+#define I2CM_INTERFACE_CONTROL1				0xf8
+#define I2CM_SEG_PTR					0x7f80
+#define I2CM_SEG_ADDR					0x7f
+#define I2CM_INTERFACE_WRDATA_0_3			0xfc
+#define I2CM_INTERFACE_WRDATA_4_7			0x100
+#define I2CM_INTERFACE_WRDATA_8_11			0x104
+#define I2CM_INTERFACE_WRDATA_12_15			0x108
+#define I2CM_INTERFACE_RDDATA_0_3			0x10c
+#define I2CM_INTERFACE_RDDATA_4_7			0x110
+#define I2CM_INTERFACE_RDDATA_8_11			0x114
+#define I2CM_INTERFACE_RDDATA_12_15			0x118
+/* SCDC Registers */
+#define SCDC_CONFIG0					0x140
+#define SCDC_I2C_FM_EN					BIT(12)
+#define SCDC_UPD_FLAGS_AUTO_CLR				BIT(6)
+#define SCDC_UPD_FLAGS_POLL_EN				BIT(4)
+#define SCDC_CONTROL0					0x148
+#define SCDC_STATUS0					0x150
+#define STATUS_UPDATE					BIT(0)
+#define FRL_START					BIT(4)
+#define FLT_UPDATE					BIT(5)
+/* FLT Registers */
+#define FLT_CONFIG0					0x160
+#define FLT_CONFIG1					0x164
+#define FLT_CONFIG2					0x168
+#define FLT_CONTROL0					0x170
+/*  Main Unit 2 Registers */
+#define MAINUNIT_STATUS0				0x180
+/* Video Interface Registers */
+#define VIDEO_INTERFACE_CONFIG0				0x800
+#define VIDEO_INTERFACE_CONFIG1				0x804
+#define VIDEO_INTERFACE_CONFIG2				0x808
+#define VIDEO_INTERFACE_CONTROL0			0x80c
+#define VIDEO_INTERFACE_STATUS0				0x814
+/* Video Packing Registers */
+#define VIDEO_PACKING_CONFIG0				0x81c
+/* Audio Interface Registers */
+#define AUDIO_INTERFACE_CONFIG0				0x820
+#define AUD_IF_SEL_MSK					0x3
+#define AUD_IF_SPDIF					0x2
+#define AUD_IF_I2S					0x1
+#define AUD_IF_PAI					0x0
+#define AUD_FIFO_INIT_ON_OVF_MSK			BIT(2)
+#define AUD_FIFO_INIT_ON_OVF_EN				BIT(2)
+#define I2S_LINES_EN_MSK				GENMASK(7, 4)
+#define I2S_LINES_EN(x)					BIT((x) + 4)
+#define I2S_BPCUV_RCV_MSK				BIT(12)
+#define I2S_BPCUV_RCV_EN				BIT(12)
+#define I2S_BPCUV_RCV_DIS				0
+#define SPDIF_LINES_EN					GENMASK(19, 16)
+#define AUD_FORMAT_MSK					GENMASK(26, 24)
+#define AUD_3DOBA					(0x7 << 24)
+#define AUD_3DASP					(0x6 << 24)
+#define AUD_MSOBA					(0x5 << 24)
+#define AUD_MSASP					(0x4 << 24)
+#define AUD_HBR						(0x3 << 24)
+#define AUD_DST						(0x2 << 24)
+#define AUD_OBA						(0x1 << 24)
+#define AUD_ASP						(0x0 << 24)
+#define AUDIO_INTERFACE_CONFIG1				0x824
+#define AUDIO_INTERFACE_CONTROL0			0x82c
+#define AUDIO_FIFO_CLR_P				BIT(0)
+#define AUDIO_INTERFACE_STATUS0				0x834
+/* Frame Composer Registers */
+#define FRAME_COMPOSER_CONFIG0				0x840
+#define FRAME_COMPOSER_CONFIG1				0x844
+#define FRAME_COMPOSER_CONFIG2				0x848
+#define FRAME_COMPOSER_CONFIG3				0x84c
+#define FRAME_COMPOSER_CONFIG4				0x850
+#define FRAME_COMPOSER_CONFIG5				0x854
+#define FRAME_COMPOSER_CONFIG6				0x858
+#define FRAME_COMPOSER_CONFIG7				0x85c
+#define FRAME_COMPOSER_CONFIG8				0x860
+#define FRAME_COMPOSER_CONFIG9				0x864
+#define KEEPOUT_REKEY_CFG				GENMASK(9, 8)
+#define KEEPOUT_REKEY_ALWAYS				(0x2 << 8)
+#define FRAME_COMPOSER_CONTROL0				0x86c
+/* Video Monitor Registers */
+#define VIDEO_MONITOR_CONFIG0				0x880
+#define VIDEO_MONITOR_STATUS0				0x884
+#define VIDEO_MONITOR_STATUS1				0x888
+#define VIDEO_MONITOR_STATUS2				0x88c
+#define VIDEO_MONITOR_STATUS3				0x890
+#define VIDEO_MONITOR_STATUS4				0x894
+#define VIDEO_MONITOR_STATUS5				0x898
+#define VIDEO_MONITOR_STATUS6				0x89c
+/* HDCP2 Logic Registers */
+#define HDCP2LOGIC_CONFIG0				0x8e0
+#define HDCP2_BYPASS					BIT(0)
+#define HDCP2LOGIC_ESM_GPIO_IN				0x8e4
+#define HDCP2LOGIC_ESM_GPIO_OUT				0x8e8
+/* HDCP14 Registers */
+#define HDCP14_CONFIG0					0x900
+#define HDCP14_CONFIG1					0x904
+#define HDCP14_CONFIG2					0x908
+#define HDCP14_CONFIG3					0x90c
+#define HDCP14_KEY_SEED					0x914
+#define HDCP14_KEY_H					0x918
+#define HDCP14_KEY_L					0x91c
+#define HDCP14_KEY_STATUS				0x920
+#define HDCP14_AKSV_H					0x924
+#define HDCP14_AKSV_L					0x928
+#define HDCP14_AN_H					0x92c
+#define HDCP14_AN_L					0x930
+#define HDCP14_STATUS0					0x934
+#define HDCP14_STATUS1					0x938
+/* Scrambler Registers */
+#define SCRAMB_CONFIG0					0x960
+/* Video Configuration Registers */
+#define LINK_CONFIG0					0x968
+#define OPMODE_FRL_4LANES				BIT(8)
+#define OPMODE_DVI					BIT(4)
+#define OPMODE_FRL					BIT(0)
+/* TMDS FIFO Registers */
+#define TMDS_FIFO_CONFIG0				0x970
+#define TMDS_FIFO_CONTROL0				0x974
+/* FRL RSFEC Registers */
+#define FRL_RSFEC_CONFIG0				0xa20
+#define FRL_RSFEC_STATUS0				0xa30
+/* FRL Packetizer Registers */
+#define FRL_PKTZ_CONFIG0				0xa40
+#define FRL_PKTZ_CONTROL0				0xa44
+#define FRL_PKTZ_CONTROL1				0xa50
+#define FRL_PKTZ_STATUS1				0xa54
+/* Packet Scheduler Registers */
+#define PKTSCHED_CONFIG0				0xa80
+#define PKTSCHED_PRQUEUE0_CONFIG0			0xa84
+#define PKTSCHED_PRQUEUE1_CONFIG0			0xa88
+#define PKTSCHED_PRQUEUE2_CONFIG0			0xa8c
+#define PKTSCHED_PRQUEUE2_CONFIG1			0xa90
+#define PKTSCHED_PRQUEUE2_CONFIG2			0xa94
+#define PKTSCHED_PKT_CONFIG0				0xa98
+#define PKTSCHED_PKT_CONFIG1				0xa9c
+#define PKTSCHED_VSI_FIELDRATE				BIT(14)
+#define PKTSCHED_AVI_FIELDRATE				BIT(12)
+#define PKTSCHED_PKT_CONFIG2				0xaa0
+#define PKTSCHED_PKT_CONFIG3				0xaa4
+#define PKTSCHED_PKT_EN					0xaa8
+#define PKTSCHED_DRMI_TX_EN				BIT(17)
+#define PKTSCHED_AUDI_TX_EN				BIT(15)
+#define PKTSCHED_AVI_TX_EN				BIT(13)
+#define PKTSCHED_VSI_TX_EN				BIT(12)
+#define PKTSCHED_EMP_CVTEM_TX_EN			BIT(10)
+#define PKTSCHED_AMD_TX_EN				BIT(8)
+#define PKTSCHED_GCP_TX_EN				BIT(3)
+#define PKTSCHED_AUDS_TX_EN				BIT(2)
+#define PKTSCHED_ACR_TX_EN				BIT(1)
+#define PKTSCHED_NULL_TX_EN				BIT(0)
+#define PKTSCHED_PKT_CONTROL0				0xaac
+#define PKTSCHED_PKT_SEND				0xab0
+#define PKTSCHED_PKT_STATUS0				0xab4
+#define PKTSCHED_PKT_STATUS1				0xab8
+#define PKT_NULL_CONTENTS0				0xb00
+#define PKT_NULL_CONTENTS1				0xb04
+#define PKT_NULL_CONTENTS2				0xb08
+#define PKT_NULL_CONTENTS3				0xb0c
+#define PKT_NULL_CONTENTS4				0xb10
+#define PKT_NULL_CONTENTS5				0xb14
+#define PKT_NULL_CONTENTS6				0xb18
+#define PKT_NULL_CONTENTS7				0xb1c
+#define PKT_ACP_CONTENTS0				0xb20
+#define PKT_ACP_CONTENTS1				0xb24
+#define PKT_ACP_CONTENTS2				0xb28
+#define PKT_ACP_CONTENTS3				0xb2c
+#define PKT_ACP_CONTENTS4				0xb30
+#define PKT_ACP_CONTENTS5				0xb34
+#define PKT_ACP_CONTENTS6				0xb38
+#define PKT_ACP_CONTENTS7				0xb3c
+#define PKT_ISRC1_CONTENTS0				0xb40
+#define PKT_ISRC1_CONTENTS1				0xb44
+#define PKT_ISRC1_CONTENTS2				0xb48
+#define PKT_ISRC1_CONTENTS3				0xb4c
+#define PKT_ISRC1_CONTENTS4				0xb50
+#define PKT_ISRC1_CONTENTS5				0xb54
+#define PKT_ISRC1_CONTENTS6				0xb58
+#define PKT_ISRC1_CONTENTS7				0xb5c
+#define PKT_ISRC2_CONTENTS0				0xb60
+#define PKT_ISRC2_CONTENTS1				0xb64
+#define PKT_ISRC2_CONTENTS2				0xb68
+#define PKT_ISRC2_CONTENTS3				0xb6c
+#define PKT_ISRC2_CONTENTS4				0xb70
+#define PKT_ISRC2_CONTENTS5				0xb74
+#define PKT_ISRC2_CONTENTS6				0xb78
+#define PKT_ISRC2_CONTENTS7				0xb7c
+#define PKT_GMD_CONTENTS0				0xb80
+#define PKT_GMD_CONTENTS1				0xb84
+#define PKT_GMD_CONTENTS2				0xb88
+#define PKT_GMD_CONTENTS3				0xb8c
+#define PKT_GMD_CONTENTS4				0xb90
+#define PKT_GMD_CONTENTS5				0xb94
+#define PKT_GMD_CONTENTS6				0xb98
+#define PKT_GMD_CONTENTS7				0xb9c
+#define PKT_AMD_CONTENTS0				0xba0
+#define PKT_AMD_CONTENTS1				0xba4
+#define PKT_AMD_CONTENTS2				0xba8
+#define PKT_AMD_CONTENTS3				0xbac
+#define PKT_AMD_CONTENTS4				0xbb0
+#define PKT_AMD_CONTENTS5				0xbb4
+#define PKT_AMD_CONTENTS6				0xbb8
+#define PKT_AMD_CONTENTS7				0xbbc
+#define PKT_VSI_CONTENTS0				0xbc0
+#define PKT_VSI_CONTENTS1				0xbc4
+#define PKT_VSI_CONTENTS2				0xbc8
+#define PKT_VSI_CONTENTS3				0xbcc
+#define PKT_VSI_CONTENTS4				0xbd0
+#define PKT_VSI_CONTENTS5				0xbd4
+#define PKT_VSI_CONTENTS6				0xbd8
+#define PKT_VSI_CONTENTS7				0xbdc
+#define PKT_AVI_CONTENTS0				0xbe0
+#define HDMI_FC_AVICONF0_ACTIVE_FMT_INFO_PRESENT	BIT(4)
+#define HDMI_FC_AVICONF0_BAR_DATA_VERT_BAR		0x04
+#define HDMI_FC_AVICONF0_BAR_DATA_HORIZ_BAR		0x08
+#define HDMI_FC_AVICONF2_IT_CONTENT_VALID		0x80
+#define PKT_AVI_CONTENTS1				0xbe4
+#define PKT_AVI_CONTENTS2				0xbe8
+#define PKT_AVI_CONTENTS3				0xbec
+#define PKT_AVI_CONTENTS4				0xbf0
+#define PKT_AVI_CONTENTS5				0xbf4
+#define PKT_AVI_CONTENTS6				0xbf8
+#define PKT_AVI_CONTENTS7				0xbfc
+#define PKT_SPDI_CONTENTS0				0xc00
+#define PKT_SPDI_CONTENTS1				0xc04
+#define PKT_SPDI_CONTENTS2				0xc08
+#define PKT_SPDI_CONTENTS3				0xc0c
+#define PKT_SPDI_CONTENTS4				0xc10
+#define PKT_SPDI_CONTENTS5				0xc14
+#define PKT_SPDI_CONTENTS6				0xc18
+#define PKT_SPDI_CONTENTS7				0xc1c
+#define PKT_AUDI_CONTENTS0				0xc20
+#define PKT_AUDI_CONTENTS1				0xc24
+#define PKT_AUDI_CONTENTS2				0xc28
+#define PKT_AUDI_CONTENTS3				0xc2c
+#define PKT_AUDI_CONTENTS4				0xc30
+#define PKT_AUDI_CONTENTS5				0xc34
+#define PKT_AUDI_CONTENTS6				0xc38
+#define PKT_AUDI_CONTENTS7				0xc3c
+#define PKT_NVI_CONTENTS0				0xc40
+#define PKT_NVI_CONTENTS1				0xc44
+#define PKT_NVI_CONTENTS2				0xc48
+#define PKT_NVI_CONTENTS3				0xc4c
+#define PKT_NVI_CONTENTS4				0xc50
+#define PKT_NVI_CONTENTS5				0xc54
+#define PKT_NVI_CONTENTS6				0xc58
+#define PKT_NVI_CONTENTS7				0xc5c
+#define PKT_DRMI_CONTENTS0				0xc60
+#define PKT_DRMI_CONTENTS1				0xc64
+#define PKT_DRMI_CONTENTS2				0xc68
+#define PKT_DRMI_CONTENTS3				0xc6c
+#define PKT_DRMI_CONTENTS4				0xc70
+#define PKT_DRMI_CONTENTS5				0xc74
+#define PKT_DRMI_CONTENTS6				0xc78
+#define PKT_DRMI_CONTENTS7				0xc7c
+#define PKT_GHDMI1_CONTENTS0				0xc80
+#define PKT_GHDMI1_CONTENTS1				0xc84
+#define PKT_GHDMI1_CONTENTS2				0xc88
+#define PKT_GHDMI1_CONTENTS3				0xc8c
+#define PKT_GHDMI1_CONTENTS4				0xc90
+#define PKT_GHDMI1_CONTENTS5				0xc94
+#define PKT_GHDMI1_CONTENTS6				0xc98
+#define PKT_GHDMI1_CONTENTS7				0xc9c
+#define PKT_GHDMI2_CONTENTS0				0xca0
+#define PKT_GHDMI2_CONTENTS1				0xca4
+#define PKT_GHDMI2_CONTENTS2				0xca8
+#define PKT_GHDMI2_CONTENTS3				0xcac
+#define PKT_GHDMI2_CONTENTS4				0xcb0
+#define PKT_GHDMI2_CONTENTS5				0xcb4
+#define PKT_GHDMI2_CONTENTS6				0xcb8
+#define PKT_GHDMI2_CONTENTS7				0xcbc
+/* EMP Packetizer Registers */
+#define PKT_EMP_CONFIG0					0xce0
+#define PKT_EMP_CONTROL0				0xcec
+#define PKT_EMP_CONTROL1				0xcf0
+#define PKT_EMP_CONTROL2				0xcf4
+#define PKT_EMP_VTEM_CONTENTS0				0xd00
+#define PKT_EMP_VTEM_CONTENTS1				0xd04
+#define PKT_EMP_VTEM_CONTENTS2				0xd08
+#define PKT_EMP_VTEM_CONTENTS3				0xd0c
+#define PKT_EMP_VTEM_CONTENTS4				0xd10
+#define PKT_EMP_VTEM_CONTENTS5				0xd14
+#define PKT_EMP_VTEM_CONTENTS6				0xd18
+#define PKT_EMP_VTEM_CONTENTS7				0xd1c
+#define PKT0_EMP_CVTEM_CONTENTS0			0xd20
+#define PKT0_EMP_CVTEM_CONTENTS1			0xd24
+#define PKT0_EMP_CVTEM_CONTENTS2			0xd28
+#define PKT0_EMP_CVTEM_CONTENTS3			0xd2c
+#define PKT0_EMP_CVTEM_CONTENTS4			0xd30
+#define PKT0_EMP_CVTEM_CONTENTS5			0xd34
+#define PKT0_EMP_CVTEM_CONTENTS6			0xd38
+#define PKT0_EMP_CVTEM_CONTENTS7			0xd3c
+#define PKT1_EMP_CVTEM_CONTENTS0			0xd40
+#define PKT1_EMP_CVTEM_CONTENTS1			0xd44
+#define PKT1_EMP_CVTEM_CONTENTS2			0xd48
+#define PKT1_EMP_CVTEM_CONTENTS3			0xd4c
+#define PKT1_EMP_CVTEM_CONTENTS4			0xd50
+#define PKT1_EMP_CVTEM_CONTENTS5			0xd54
+#define PKT1_EMP_CVTEM_CONTENTS6			0xd58
+#define PKT1_EMP_CVTEM_CONTENTS7			0xd5c
+#define PKT2_EMP_CVTEM_CONTENTS0			0xd60
+#define PKT2_EMP_CVTEM_CONTENTS1			0xd64
+#define PKT2_EMP_CVTEM_CONTENTS2			0xd68
+#define PKT2_EMP_CVTEM_CONTENTS3			0xd6c
+#define PKT2_EMP_CVTEM_CONTENTS4			0xd70
+#define PKT2_EMP_CVTEM_CONTENTS5			0xd74
+#define PKT2_EMP_CVTEM_CONTENTS6			0xd78
+#define PKT2_EMP_CVTEM_CONTENTS7			0xd7c
+#define PKT3_EMP_CVTEM_CONTENTS0			0xd80
+#define PKT3_EMP_CVTEM_CONTENTS1			0xd84
+#define PKT3_EMP_CVTEM_CONTENTS2			0xd88
+#define PKT3_EMP_CVTEM_CONTENTS3			0xd8c
+#define PKT3_EMP_CVTEM_CONTENTS4			0xd90
+#define PKT3_EMP_CVTEM_CONTENTS5			0xd94
+#define PKT3_EMP_CVTEM_CONTENTS6			0xd98
+#define PKT3_EMP_CVTEM_CONTENTS7			0xd9c
+#define PKT4_EMP_CVTEM_CONTENTS0			0xda0
+#define PKT4_EMP_CVTEM_CONTENTS1			0xda4
+#define PKT4_EMP_CVTEM_CONTENTS2			0xda8
+#define PKT4_EMP_CVTEM_CONTENTS3			0xdac
+#define PKT4_EMP_CVTEM_CONTENTS4			0xdb0
+#define PKT4_EMP_CVTEM_CONTENTS5			0xdb4
+#define PKT4_EMP_CVTEM_CONTENTS6			0xdb8
+#define PKT4_EMP_CVTEM_CONTENTS7			0xdbc
+#define PKT5_EMP_CVTEM_CONTENTS0			0xdc0
+#define PKT5_EMP_CVTEM_CONTENTS1			0xdc4
+#define PKT5_EMP_CVTEM_CONTENTS2			0xdc8
+#define PKT5_EMP_CVTEM_CONTENTS3			0xdcc
+#define PKT5_EMP_CVTEM_CONTENTS4			0xdd0
+#define PKT5_EMP_CVTEM_CONTENTS5			0xdd4
+#define PKT5_EMP_CVTEM_CONTENTS6			0xdd8
+#define PKT5_EMP_CVTEM_CONTENTS7			0xddc
+/* Audio Packetizer Registers */
+#define AUDPKT_CONTROL0					0xe20
+#define AUDPKT_CHSTATUS_OVR_EN_MASK			BIT(0)
+#define AUDPKT_CHSTATUS_OVR_EN				BIT(0)
+#define AUDPKT_CONTROL1					0xe24
+#define AUDPKT_ACR_CONTROL0				0xe40
+#define AUDPKT_ACR_N_VALUE				0xfffff
+#define AUDPKT_ACR_CONTROL1				0xe44
+#define AUDPKT_ACR_CTS_OVR_VAL_MSK			GENMASK(23, 4)
+#define AUDPKT_ACR_CTS_OVR_VAL(x)			((x) << 4)
+#define AUDPKT_ACR_CTS_OVR_EN_MSK			BIT(1)
+#define AUDPKT_ACR_CTS_OVR_EN				BIT(1)
+#define AUDPKT_ACR_STATUS0				0xe4c
+#define AUDPKT_CHSTATUS_OVR0				0xe60
+#define AUDPKT_CHSTATUS_OVR1				0xe64
+/* IEC60958 Byte 3: Sampleing frenuency Bits 24 to 27 */
+#define AUDPKT_CHSTATUS_SR_MASK				GENMASK(3, 0)
+#define AUDPKT_CHSTATUS_SR_22050			0x4
+#define AUDPKT_CHSTATUS_SR_24000			0x6
+#define AUDPKT_CHSTATUS_SR_32000			0x3
+#define AUDPKT_CHSTATUS_SR_44100			0x0
+#define AUDPKT_CHSTATUS_SR_48000			0x2
+#define AUDPKT_CHSTATUS_SR_88200			0x8
+#define AUDPKT_CHSTATUS_SR_96000			0xa
+#define AUDPKT_CHSTATUS_SR_176400			0xc
+#define AUDPKT_CHSTATUS_SR_192000			0xe
+#define AUDPKT_CHSTATUS_SR_768000			0x9
+#define AUDPKT_CHSTATUS_SR_NOT_INDICATED		0x1
+/* IEC60958 Byte 4: Original Sampleing frenuency Bits 36 to 39 */
+#define AUDPKT_CHSTATUS_0SR_MASK			GENMASK(15, 12)
+#define AUDPKT_CHSTATUS_OSR_8000			0x6
+#define AUDPKT_CHSTATUS_OSR_11025			0xa
+#define AUDPKT_CHSTATUS_OSR_12000			0x2
+#define AUDPKT_CHSTATUS_OSR_16000			0x8
+#define AUDPKT_CHSTATUS_OSR_22050			0xb
+#define AUDPKT_CHSTATUS_OSR_24000			0x9
+#define AUDPKT_CHSTATUS_OSR_32000			0xc
+#define AUDPKT_CHSTATUS_OSR_44100			0xf
+#define AUDPKT_CHSTATUS_OSR_48000			0xd
+#define AUDPKT_CHSTATUS_OSR_88200			0x7
+#define AUDPKT_CHSTATUS_OSR_96000			0x5
+#define AUDPKT_CHSTATUS_OSR_176400			0x3
+#define AUDPKT_CHSTATUS_OSR_192000			0x1
+#define AUDPKT_CHSTATUS_OSR_NOT_INDICATED		0x0
+#define AUDPKT_CHSTATUS_OVR2				0xe68
+#define AUDPKT_CHSTATUS_OVR3				0xe6c
+#define AUDPKT_CHSTATUS_OVR4				0xe70
+#define AUDPKT_CHSTATUS_OVR5				0xe74
+#define AUDPKT_CHSTATUS_OVR6				0xe78
+#define AUDPKT_CHSTATUS_OVR7				0xe7c
+#define AUDPKT_CHSTATUS_OVR8				0xe80
+#define AUDPKT_CHSTATUS_OVR9				0xe84
+#define AUDPKT_CHSTATUS_OVR10				0xe88
+#define AUDPKT_CHSTATUS_OVR11				0xe8c
+#define AUDPKT_CHSTATUS_OVR12				0xe90
+#define AUDPKT_CHSTATUS_OVR13				0xe94
+#define AUDPKT_CHSTATUS_OVR14				0xe98
+#define AUDPKT_USRDATA_OVR_MSG_GENERIC0			0xea0
+#define AUDPKT_USRDATA_OVR_MSG_GENERIC1			0xea4
+#define AUDPKT_USRDATA_OVR_MSG_GENERIC2			0xea8
+#define AUDPKT_USRDATA_OVR_MSG_GENERIC3			0xeac
+#define AUDPKT_USRDATA_OVR_MSG_GENERIC4			0xeb0
+#define AUDPKT_USRDATA_OVR_MSG_GENERIC5			0xeb4
+#define AUDPKT_USRDATA_OVR_MSG_GENERIC6			0xeb8
+#define AUDPKT_USRDATA_OVR_MSG_GENERIC7			0xebc
+#define AUDPKT_USRDATA_OVR_MSG_GENERIC8			0xec0
+#define AUDPKT_USRDATA_OVR_MSG_GENERIC9			0xec4
+#define AUDPKT_USRDATA_OVR_MSG_GENERIC10		0xec8
+#define AUDPKT_USRDATA_OVR_MSG_GENERIC11		0xecc
+#define AUDPKT_USRDATA_OVR_MSG_GENERIC12		0xed0
+#define AUDPKT_USRDATA_OVR_MSG_GENERIC13		0xed4
+#define AUDPKT_USRDATA_OVR_MSG_GENERIC14		0xed8
+#define AUDPKT_USRDATA_OVR_MSG_GENERIC15		0xedc
+#define AUDPKT_USRDATA_OVR_MSG_GENERIC16		0xee0
+#define AUDPKT_USRDATA_OVR_MSG_GENERIC17		0xee4
+#define AUDPKT_USRDATA_OVR_MSG_GENERIC18		0xee8
+#define AUDPKT_USRDATA_OVR_MSG_GENERIC19		0xeec
+#define AUDPKT_USRDATA_OVR_MSG_GENERIC20		0xef0
+#define AUDPKT_USRDATA_OVR_MSG_GENERIC21		0xef4
+#define AUDPKT_USRDATA_OVR_MSG_GENERIC22		0xef8
+#define AUDPKT_USRDATA_OVR_MSG_GENERIC23		0xefc
+#define AUDPKT_USRDATA_OVR_MSG_GENERIC24		0xf00
+#define AUDPKT_USRDATA_OVR_MSG_GENERIC25		0xf04
+#define AUDPKT_USRDATA_OVR_MSG_GENERIC26		0xf08
+#define AUDPKT_USRDATA_OVR_MSG_GENERIC27		0xf0c
+#define AUDPKT_USRDATA_OVR_MSG_GENERIC28		0xf10
+#define AUDPKT_USRDATA_OVR_MSG_GENERIC29		0xf14
+#define AUDPKT_USRDATA_OVR_MSG_GENERIC30		0xf18
+#define AUDPKT_USRDATA_OVR_MSG_GENERIC31		0xf1c
+#define AUDPKT_USRDATA_OVR_MSG_GENERIC32		0xf20
+#define AUDPKT_VBIT_OVR0				0xf24
+/* CEC Registers */
+#define CEC_TX_CONTROL					0x1000
+#define CEC_STATUS					0x1004
+#define CEC_CONFIG					0x1008
+#define CEC_ADDR					0x100c
+#define CEC_TX_COUNT					0x1020
+#define CEC_TX_DATA3_0					0x1024
+#define CEC_TX_DATA7_4					0x1028
+#define CEC_TX_DATA11_8					0x102c
+#define CEC_TX_DATA15_12				0x1030
+#define CEC_RX_COUNT_STATUS				0x1040
+#define CEC_RX_DATA3_0					0x1044
+#define CEC_RX_DATA7_4					0x1048
+#define CEC_RX_DATA11_8					0x104c
+#define CEC_RX_DATA15_12				0x1050
+#define CEC_LOCK_CONTROL				0x1054
+#define CEC_RXQUAL_BITTIME_CONFIG			0x1060
+#define CEC_RX_BITTIME_CONFIG				0x1064
+#define CEC_TX_BITTIME_CONFIG				0x1068
+/* eARC RX CMDC Registers */
+#define EARCRX_CMDC_CONFIG0				0x1800
+#define EARCRX_XACTREAD_STOP_CFG			BIT(26)
+#define EARCRX_XACTREAD_RETRY_CFG			BIT(25)
+#define EARCRX_CMDC_DSCVR_EARCVALID0_TO_DISC1		BIT(24)
+#define EARCRX_CMDC_XACT_RESTART_EN			BIT(18)
+#define EARCRX_CMDC_CONFIG1				0x1804
+#define EARCRX_CMDC_CONTROL				0x1808
+#define EARCRX_CMDC_HEARTBEAT_LOSS_EN			BIT(4)
+#define EARCRX_CMDC_DISCOVERY_EN			BIT(3)
+#define EARCRX_CONNECTOR_HPD				BIT(1)
+#define EARCRX_CMDC_WHITELIST0_CONFIG			0x180c
+#define EARCRX_CMDC_WHITELIST1_CONFIG			0x1810
+#define EARCRX_CMDC_WHITELIST2_CONFIG			0x1814
+#define EARCRX_CMDC_WHITELIST3_CONFIG			0x1818
+#define EARCRX_CMDC_STATUS				0x181c
+#define EARCRX_CMDC_XACT_INFO				0x1820
+#define EARCRX_CMDC_XACT_ACTION				0x1824
+#define EARCRX_CMDC_HEARTBEAT_RXSTAT_SE			0x1828
+#define EARCRX_CMDC_HEARTBEAT_STATUS			0x182c
+#define EARCRX_CMDC_XACT_WR0				0x1840
+#define EARCRX_CMDC_XACT_WR1				0x1844
+#define EARCRX_CMDC_XACT_WR2				0x1848
+#define EARCRX_CMDC_XACT_WR3				0x184c
+#define EARCRX_CMDC_XACT_WR4				0x1850
+#define EARCRX_CMDC_XACT_WR5				0x1854
+#define EARCRX_CMDC_XACT_WR6				0x1858
+#define EARCRX_CMDC_XACT_WR7				0x185c
+#define EARCRX_CMDC_XACT_WR8				0x1860
+#define EARCRX_CMDC_XACT_WR9				0x1864
+#define EARCRX_CMDC_XACT_WR10				0x1868
+#define EARCRX_CMDC_XACT_WR11				0x186c
+#define EARCRX_CMDC_XACT_WR12				0x1870
+#define EARCRX_CMDC_XACT_WR13				0x1874
+#define EARCRX_CMDC_XACT_WR14				0x1878
+#define EARCRX_CMDC_XACT_WR15				0x187c
+#define EARCRX_CMDC_XACT_WR16				0x1880
+#define EARCRX_CMDC_XACT_WR17				0x1884
+#define EARCRX_CMDC_XACT_WR18				0x1888
+#define EARCRX_CMDC_XACT_WR19				0x188c
+#define EARCRX_CMDC_XACT_WR20				0x1890
+#define EARCRX_CMDC_XACT_WR21				0x1894
+#define EARCRX_CMDC_XACT_WR22				0x1898
+#define EARCRX_CMDC_XACT_WR23				0x189c
+#define EARCRX_CMDC_XACT_WR24				0x18a0
+#define EARCRX_CMDC_XACT_WR25				0x18a4
+#define EARCRX_CMDC_XACT_WR26				0x18a8
+#define EARCRX_CMDC_XACT_WR27				0x18ac
+#define EARCRX_CMDC_XACT_WR28				0x18b0
+#define EARCRX_CMDC_XACT_WR29				0x18b4
+#define EARCRX_CMDC_XACT_WR30				0x18b8
+#define EARCRX_CMDC_XACT_WR31				0x18bc
+#define EARCRX_CMDC_XACT_WR32				0x18c0
+#define EARCRX_CMDC_XACT_WR33				0x18c4
+#define EARCRX_CMDC_XACT_WR34				0x18c8
+#define EARCRX_CMDC_XACT_WR35				0x18cc
+#define EARCRX_CMDC_XACT_WR36				0x18d0
+#define EARCRX_CMDC_XACT_WR37				0x18d4
+#define EARCRX_CMDC_XACT_WR38				0x18d8
+#define EARCRX_CMDC_XACT_WR39				0x18dc
+#define EARCRX_CMDC_XACT_WR40				0x18e0
+#define EARCRX_CMDC_XACT_WR41				0x18e4
+#define EARCRX_CMDC_XACT_WR42				0x18e8
+#define EARCRX_CMDC_XACT_WR43				0x18ec
+#define EARCRX_CMDC_XACT_WR44				0x18f0
+#define EARCRX_CMDC_XACT_WR45				0x18f4
+#define EARCRX_CMDC_XACT_WR46				0x18f8
+#define EARCRX_CMDC_XACT_WR47				0x18fc
+#define EARCRX_CMDC_XACT_WR48				0x1900
+#define EARCRX_CMDC_XACT_WR49				0x1904
+#define EARCRX_CMDC_XACT_WR50				0x1908
+#define EARCRX_CMDC_XACT_WR51				0x190c
+#define EARCRX_CMDC_XACT_WR52				0x1910
+#define EARCRX_CMDC_XACT_WR53				0x1914
+#define EARCRX_CMDC_XACT_WR54				0x1918
+#define EARCRX_CMDC_XACT_WR55				0x191c
+#define EARCRX_CMDC_XACT_WR56				0x1920
+#define EARCRX_CMDC_XACT_WR57				0x1924
+#define EARCRX_CMDC_XACT_WR58				0x1928
+#define EARCRX_CMDC_XACT_WR59				0x192c
+#define EARCRX_CMDC_XACT_WR60				0x1930
+#define EARCRX_CMDC_XACT_WR61				0x1934
+#define EARCRX_CMDC_XACT_WR62				0x1938
+#define EARCRX_CMDC_XACT_WR63				0x193c
+#define EARCRX_CMDC_XACT_WR64				0x1940
+#define EARCRX_CMDC_XACT_RD0				0x1960
+#define EARCRX_CMDC_XACT_RD1				0x1964
+#define EARCRX_CMDC_XACT_RD2				0x1968
+#define EARCRX_CMDC_XACT_RD3				0x196c
+#define EARCRX_CMDC_XACT_RD4				0x1970
+#define EARCRX_CMDC_XACT_RD5				0x1974
+#define EARCRX_CMDC_XACT_RD6				0x1978
+#define EARCRX_CMDC_XACT_RD7				0x197c
+#define EARCRX_CMDC_XACT_RD8				0x1980
+#define EARCRX_CMDC_XACT_RD9				0x1984
+#define EARCRX_CMDC_XACT_RD10				0x1988
+#define EARCRX_CMDC_XACT_RD11				0x198c
+#define EARCRX_CMDC_XACT_RD12				0x1990
+#define EARCRX_CMDC_XACT_RD13				0x1994
+#define EARCRX_CMDC_XACT_RD14				0x1998
+#define EARCRX_CMDC_XACT_RD15				0x199c
+#define EARCRX_CMDC_XACT_RD16				0x19a0
+#define EARCRX_CMDC_XACT_RD17				0x19a4
+#define EARCRX_CMDC_XACT_RD18				0x19a8
+#define EARCRX_CMDC_XACT_RD19				0x19ac
+#define EARCRX_CMDC_XACT_RD20				0x19b0
+#define EARCRX_CMDC_XACT_RD21				0x19b4
+#define EARCRX_CMDC_XACT_RD22				0x19b8
+#define EARCRX_CMDC_XACT_RD23				0x19bc
+#define EARCRX_CMDC_XACT_RD24				0x19c0
+#define EARCRX_CMDC_XACT_RD25				0x19c4
+#define EARCRX_CMDC_XACT_RD26				0x19c8
+#define EARCRX_CMDC_XACT_RD27				0x19cc
+#define EARCRX_CMDC_XACT_RD28				0x19d0
+#define EARCRX_CMDC_XACT_RD29				0x19d4
+#define EARCRX_CMDC_XACT_RD30				0x19d8
+#define EARCRX_CMDC_XACT_RD31				0x19dc
+#define EARCRX_CMDC_XACT_RD32				0x19e0
+#define EARCRX_CMDC_XACT_RD33				0x19e4
+#define EARCRX_CMDC_XACT_RD34				0x19e8
+#define EARCRX_CMDC_XACT_RD35				0x19ec
+#define EARCRX_CMDC_XACT_RD36				0x19f0
+#define EARCRX_CMDC_XACT_RD37				0x19f4
+#define EARCRX_CMDC_XACT_RD38				0x19f8
+#define EARCRX_CMDC_XACT_RD39				0x19fc
+#define EARCRX_CMDC_XACT_RD40				0x1a00
+#define EARCRX_CMDC_XACT_RD41				0x1a04
+#define EARCRX_CMDC_XACT_RD42				0x1a08
+#define EARCRX_CMDC_XACT_RD43				0x1a0c
+#define EARCRX_CMDC_XACT_RD44				0x1a10
+#define EARCRX_CMDC_XACT_RD45				0x1a14
+#define EARCRX_CMDC_XACT_RD46				0x1a18
+#define EARCRX_CMDC_XACT_RD47				0x1a1c
+#define EARCRX_CMDC_XACT_RD48				0x1a20
+#define EARCRX_CMDC_XACT_RD49				0x1a24
+#define EARCRX_CMDC_XACT_RD50				0x1a28
+#define EARCRX_CMDC_XACT_RD51				0x1a2c
+#define EARCRX_CMDC_XACT_RD52				0x1a30
+#define EARCRX_CMDC_XACT_RD53				0x1a34
+#define EARCRX_CMDC_XACT_RD54				0x1a38
+#define EARCRX_CMDC_XACT_RD55				0x1a3c
+#define EARCRX_CMDC_XACT_RD56				0x1a40
+#define EARCRX_CMDC_XACT_RD57				0x1a44
+#define EARCRX_CMDC_XACT_RD58				0x1a48
+#define EARCRX_CMDC_XACT_RD59				0x1a4c
+#define EARCRX_CMDC_XACT_RD60				0x1a50
+#define EARCRX_CMDC_XACT_RD61				0x1a54
+#define EARCRX_CMDC_XACT_RD62				0x1a58
+#define EARCRX_CMDC_XACT_RD63				0x1a5c
+#define EARCRX_CMDC_XACT_RD64				0x1a60
+#define EARCRX_CMDC_SYNC_CONFIG				0x1b00
+/* eARC RX DMAC Registers */
+#define EARCRX_DMAC_PHY_CONTROL				0x1c00
+#define EARCRX_DMAC_CONFIG				0x1c08
+#define EARCRX_DMAC_CONTROL0				0x1c0c
+#define EARCRX_DMAC_AUDIO_EN				BIT(1)
+#define EARCRX_DMAC_EN					BIT(0)
+#define EARCRX_DMAC_CONTROL1				0x1c10
+#define EARCRX_DMAC_STATUS				0x1c14
+#define EARCRX_DMAC_CHSTATUS0				0x1c18
+#define EARCRX_DMAC_CHSTATUS1				0x1c1c
+#define EARCRX_DMAC_CHSTATUS2				0x1c20
+#define EARCRX_DMAC_CHSTATUS3				0x1c24
+#define EARCRX_DMAC_CHSTATUS4				0x1c28
+#define EARCRX_DMAC_CHSTATUS5				0x1c2c
+#define EARCRX_DMAC_USRDATA_MSG_HDMI_AC0		0x1c30
+#define EARCRX_DMAC_USRDATA_MSG_HDMI_AC1		0x1c34
+#define EARCRX_DMAC_USRDATA_MSG_HDMI_AC2		0x1c38
+#define EARCRX_DMAC_USRDATA_MSG_HDMI_AC3		0x1c3c
+#define EARCRX_DMAC_USRDATA_MSG_HDMI_AC4		0x1c40
+#define EARCRX_DMAC_USRDATA_MSG_HDMI_AC5		0x1c44
+#define EARCRX_DMAC_USRDATA_MSG_HDMI_AC6		0x1c48
+#define EARCRX_DMAC_USRDATA_MSG_HDMI_AC7		0x1c4c
+#define EARCRX_DMAC_USRDATA_MSG_HDMI_AC8		0x1c50
+#define EARCRX_DMAC_USRDATA_MSG_HDMI_AC9		0x1c54
+#define EARCRX_DMAC_USRDATA_MSG_HDMI_AC10		0x1c58
+#define EARCRX_DMAC_USRDATA_MSG_HDMI_AC11		0x1c5c
+#define EARCRX_DMAC_USRDATA_MSG_HDMI_ISRC1_PKT0		0x1c60
+#define EARCRX_DMAC_USRDATA_MSG_HDMI_ISRC1_PKT1		0x1c64
+#define EARCRX_DMAC_USRDATA_MSG_HDMI_ISRC1_PKT2		0x1c68
+#define EARCRX_DMAC_USRDATA_MSG_HDMI_ISRC1_PKT3		0x1c6c
+#define EARCRX_DMAC_USRDATA_MSG_HDMI_ISRC1_PKT4		0x1c70
+#define EARCRX_DMAC_USRDATA_MSG_HDMI_ISRC1_PKT5		0x1c74
+#define EARCRX_DMAC_USRDATA_MSG_HDMI_ISRC1_PKT6		0x1c78
+#define EARCRX_DMAC_USRDATA_MSG_HDMI_ISRC1_PKT7		0x1c7c
+#define EARCRX_DMAC_USRDATA_MSG_HDMI_ISRC1_PKT8		0x1c80
+#define EARCRX_DMAC_USRDATA_MSG_HDMI_ISRC1_PKT9		0x1c84
+#define EARCRX_DMAC_USRDATA_MSG_HDMI_ISRC1_PKT10	0x1c88
+#define EARCRX_DMAC_USRDATA_MSG_HDMI_ISRC1_PKT11	0x1c8c
+#define EARCRX_DMAC_USRDATA_MSG_HDMI_ISRC2_PKT0		0x1c90
+#define EARCRX_DMAC_USRDATA_MSG_HDMI_ISRC2_PKT1		0x1c94
+#define EARCRX_DMAC_USRDATA_MSG_HDMI_ISRC2_PKT2		0x1c98
+#define EARCRX_DMAC_USRDATA_MSG_HDMI_ISRC2_PKT3		0x1c9c
+#define EARCRX_DMAC_USRDATA_MSG_HDMI_ISRC2_PKT4		0x1ca0
+#define EARCRX_DMAC_USRDATA_MSG_HDMI_ISRC2_PKT5		0x1ca4
+#define EARCRX_DMAC_USRDATA_MSG_HDMI_ISRC2_PKT6		0x1ca8
+#define EARCRX_DMAC_USRDATA_MSG_HDMI_ISRC2_PKT7		0x1cac
+#define EARCRX_DMAC_USRDATA_MSG_HDMI_ISRC2_PKT8		0x1cb0
+#define EARCRX_DMAC_USRDATA_MSG_HDMI_ISRC2_PKT9		0x1cb4
+#define EARCRX_DMAC_USRDATA_MSG_HDMI_ISRC2_PKT10	0x1cb8
+#define EARCRX_DMAC_USRDATA_MSG_HDMI_ISRC2_PKT11	0x1cbc
+#define EARCRX_DMAC_USRDATA_MSG_GENERIC0		0x1cc0
+#define EARCRX_DMAC_USRDATA_MSG_GENERIC1		0x1cc4
+#define EARCRX_DMAC_USRDATA_MSG_GENERIC2		0x1cc8
+#define EARCRX_DMAC_USRDATA_MSG_GENERIC3		0x1ccc
+#define EARCRX_DMAC_USRDATA_MSG_GENERIC4		0x1cd0
+#define EARCRX_DMAC_USRDATA_MSG_GENERIC5		0x1cd4
+#define EARCRX_DMAC_USRDATA_MSG_GENERIC6		0x1cd8
+#define EARCRX_DMAC_USRDATA_MSG_GENERIC7		0x1cdc
+#define EARCRX_DMAC_USRDATA_MSG_GENERIC8		0x1ce0
+#define EARCRX_DMAC_USRDATA_MSG_GENERIC9		0x1ce4
+#define EARCRX_DMAC_USRDATA_MSG_GENERIC10		0x1ce8
+#define EARCRX_DMAC_USRDATA_MSG_GENERIC11		0x1cec
+#define EARCRX_DMAC_USRDATA_MSG_GENERIC12		0x1cf0
+#define EARCRX_DMAC_USRDATA_MSG_GENERIC13		0x1cf4
+#define EARCRX_DMAC_USRDATA_MSG_GENERIC14		0x1cf8
+#define EARCRX_DMAC_USRDATA_MSG_GENERIC15		0x1cfc
+#define EARCRX_DMAC_USRDATA_MSG_GENERIC16		0x1d00
+#define EARCRX_DMAC_USRDATA_MSG_GENERIC17		0x1d04
+#define EARCRX_DMAC_USRDATA_MSG_GENERIC18		0x1d08
+#define EARCRX_DMAC_USRDATA_MSG_GENERIC19		0x1d0c
+#define EARCRX_DMAC_USRDATA_MSG_GENERIC20		0x1d10
+#define EARCRX_DMAC_USRDATA_MSG_GENERIC21		0x1d14
+#define EARCRX_DMAC_USRDATA_MSG_GENERIC22		0x1d18
+#define EARCRX_DMAC_USRDATA_MSG_GENERIC23		0x1d1c
+#define EARCRX_DMAC_USRDATA_MSG_GENERIC24		0x1d20
+#define EARCRX_DMAC_USRDATA_MSG_GENERIC25		0x1d24
+#define EARCRX_DMAC_USRDATA_MSG_GENERIC26		0x1d28
+#define EARCRX_DMAC_USRDATA_MSG_GENERIC27		0x1d2c
+#define EARCRX_DMAC_USRDATA_MSG_GENERIC28		0x1d30
+#define EARCRX_DMAC_USRDATA_MSG_GENERIC29		0x1d34
+#define EARCRX_DMAC_USRDATA_MSG_GENERIC30		0x1d38
+#define EARCRX_DMAC_USRDATA_MSG_GENERIC31		0x1d3c
+#define EARCRX_DMAC_USRDATA_MSG_GENERIC32		0x1d40
+#define EARCRX_DMAC_CHSTATUS_STREAMER0			0x1d44
+#define EARCRX_DMAC_CHSTATUS_STREAMER1			0x1d48
+#define EARCRX_DMAC_CHSTATUS_STREAMER2			0x1d4c
+#define EARCRX_DMAC_CHSTATUS_STREAMER3			0x1d50
+#define EARCRX_DMAC_CHSTATUS_STREAMER4			0x1d54
+#define EARCRX_DMAC_CHSTATUS_STREAMER5			0x1d58
+#define EARCRX_DMAC_CHSTATUS_STREAMER6			0x1d5c
+#define EARCRX_DMAC_CHSTATUS_STREAMER7			0x1d60
+#define EARCRX_DMAC_CHSTATUS_STREAMER8			0x1d64
+#define EARCRX_DMAC_CHSTATUS_STREAMER9			0x1d68
+#define EARCRX_DMAC_CHSTATUS_STREAMER10			0x1d6c
+#define EARCRX_DMAC_CHSTATUS_STREAMER11			0x1d70
+#define EARCRX_DMAC_CHSTATUS_STREAMER12			0x1d74
+#define EARCRX_DMAC_CHSTATUS_STREAMER13			0x1d78
+#define EARCRX_DMAC_CHSTATUS_STREAMER14			0x1d7c
+#define EARCRX_DMAC_USRDATA_STREAMER0			0x1d80
+/* Main Unit Interrupt Registers */
+#define MAIN_INTVEC_INDEX				0x3000
+#define MAINUNIT_0_INT_STATUS				0x3010
+#define MAINUNIT_0_INT_MASK_N				0x3014
+#define MAINUNIT_0_INT_CLEAR				0x3018
+#define MAINUNIT_0_INT_FORCE				0x301c
+#define MAINUNIT_1_INT_STATUS				0x3020
+#define FLT_EXIT_TO_LTSL_IRQ				BIT(22)
+#define FLT_EXIT_TO_LTS4_IRQ				BIT(21)
+#define FLT_EXIT_TO_LTSP_IRQ				BIT(20)
+#define SCDC_NACK_RCVD_IRQ				BIT(12)
+#define SCDC_RR_REPLY_STOP_IRQ				BIT(11)
+#define SCDC_UPD_FLAGS_CLR_IRQ				BIT(10)
+#define SCDC_UPD_FLAGS_CHG_IRQ				BIT(9)
+#define SCDC_UPD_FLAGS_RD_IRQ				BIT(8)
+#define I2CM_NACK_RCVD_IRQ				BIT(2)
+#define I2CM_READ_REQUEST_IRQ				BIT(1)
+#define I2CM_OP_DONE_IRQ				BIT(0)
+#define MAINUNIT_1_INT_MASK_N				0x3024
+#define I2CM_NACK_RCVD_MASK_N				BIT(2)
+#define I2CM_READ_REQUEST_MASK_N			BIT(1)
+#define I2CM_OP_DONE_MASK_N				BIT(0)
+#define MAINUNIT_1_INT_CLEAR				0x3028
+#define I2CM_NACK_RCVD_CLEAR				BIT(2)
+#define I2CM_READ_REQUEST_CLEAR				BIT(1)
+#define I2CM_OP_DONE_CLEAR				BIT(0)
+#define MAINUNIT_1_INT_FORCE				0x302c
+/* AVPUNIT Interrupt Registers */
+#define AVP_INTVEC_INDEX				0x3800
+#define AVP_0_INT_STATUS				0x3810
+#define AVP_0_INT_MASK_N				0x3814
+#define AVP_0_INT_CLEAR					0x3818
+#define AVP_0_INT_FORCE					0x381c
+#define AVP_1_INT_STATUS				0x3820
+#define AVP_1_INT_MASK_N				0x3824
+#define HDCP14_AUTH_CHG_MASK_N				BIT(6)
+#define AVP_1_INT_CLEAR					0x3828
+#define AVP_1_INT_FORCE					0x382c
+#define AVP_2_INT_STATUS				0x3830
+#define AVP_2_INT_MASK_N				0x3834
+#define AVP_2_INT_CLEAR					0x3838
+#define AVP_2_INT_FORCE					0x383c
+#define AVP_3_INT_STATUS				0x3840
+#define AVP_3_INT_MASK_N				0x3844
+#define AVP_3_INT_CLEAR					0x3848
+#define AVP_3_INT_FORCE					0x384c
+#define AVP_4_INT_STATUS				0x3850
+#define AVP_4_INT_MASK_N				0x3854
+#define AVP_4_INT_CLEAR					0x3858
+#define AVP_4_INT_FORCE					0x385c
+#define AVP_5_INT_STATUS				0x3860
+#define AVP_5_INT_MASK_N				0x3864
+#define AVP_5_INT_CLEAR					0x3868
+#define AVP_5_INT_FORCE					0x386c
+#define AVP_6_INT_STATUS				0x3870
+#define AVP_6_INT_MASK_N				0x3874
+#define AVP_6_INT_CLEAR					0x3878
+#define AVP_6_INT_FORCE					0x387c
+/* CEC Interrupt Registers */
+#define CEC_INT_STATUS					0x4000
+#define CEC_INT_MASK_N					0x4004
+#define CEC_INT_CLEAR					0x4008
+#define CEC_INT_FORCE					0x400c
+/* eARC RX Interrupt Registers  */
+#define EARCRX_INTVEC_INDEX				0x4800
+#define EARCRX_0_INT_STATUS				0x4810
+#define EARCRX_CMDC_DISCOVERY_TIMEOUT_IRQ		BIT(9)
+#define EARCRX_CMDC_DISCOVERY_DONE_IRQ			BIT(8)
+#define EARCRX_0_INT_MASK_N				0x4814
+#define EARCRX_0_INT_CLEAR				0x4818
+#define EARCRX_0_INT_FORCE				0x481c
+#define EARCRX_1_INT_STATUS				0x4820
+#define EARCRX_1_INT_MASK_N				0x4824
+#define EARCRX_1_INT_CLEAR				0x4828
+#define EARCRX_1_INT_FORCE				0x482c
+
+/* SCDC Registers */
+#define SCDC_SINK_VERSION 0x01
+#define SCDC_SOURCE_VERSION 0x02
+
+#define SCDC_UPDATE_0 0x10
+#define SCDC_READ_REQUEST_TEST BIT(2)
+#define SCDC_CED_UPDATE BIT(1)
+#define SCDC_STATUS_UPDATE BIT(0)
+#define SCDC_UPDATE_1 0x11
+
+#define SCDC_TMDS_CONFIG 0x20
+#define SCDC_TMDS_BIT_CLOCK_RATIO_BY_40 BIT(1)
+#define SCDC_TMDS_BIT_CLOCK_RATIO_BY_10 (0 << 1)
+#define SCDC_SCRAMBLING_ENABLE BIT(0)
+#define SCDC_SCRAMBLER_STATUS 0x21
+#define SCDC_SCRAMBLING_STATUS BIT(0)
+
+#define SCDC_CONFIG_0 0x30
+#define SCDC_READ_REQUEST_ENABLE BIT(0)
+
+#define SCDC_STATUS_FLAGS_0 0x40
+#define SCDC_CH2_LOCK BIT(3)
+#define SCDC_CH1_LOCK BIT(2)
+#define SCDC_CH0_LOCK BIT(1)
+#define SCDC_CH_LOCK_MASK (SCDC_CH2_LOCK | SCDC_CH1_LOCK | SCDC_CH0_LOCK)
+#define SCDC_CLOCK_DETECT BIT(0)
+#define SCDC_STATUS_FLAGS_1 0x41
+
+#define SCDC_ERR_DET_0_L 0x50
+#define SCDC_ERR_DET_0_H 0x51
+#define SCDC_ERR_DET_1_L 0x52
+#define SCDC_ERR_DET_1_H 0x53
+#define SCDC_ERR_DET_2_L 0x54
+#define SCDC_ERR_DET_2_H 0x55
+#define SCDC_CHANNEL_VALID BIT(7)
+#define SCDC_ERR_DET_CHECKSUM 0x56
+
+#define SCDC_TEST_CONFIG_0 0xc0
+#define SCDC_TEST_READ_REQUEST BIT(7)
+#define SCDC_TEST_READ_REQUEST_DELAY(x) ((x) & 0x7f)
+
+#define SCDC_MANUFACTURER_IEEE_OUI 0xd0
+#define SCDC_MANUFACTURER_IEEE_OUI_SIZE 3
+#define SCDC_DEVICE_ID 0xd3
+#define SCDC_DEVICE_ID_SIZE 8
+#define SCDC_DEVICE_HARDWARE_REVISION 0xdb
+#define SCDC_DEVICE_HARDWARE_REVISION_MAJOR(x) (((x) >> 4) & 0xf)
+#define SCDC_DEVICE_HARDWARE_REVISION_MINOR(x) (((x) >> 0) & 0xf)
+#define SCDC_DEVICE_SOFTWARE_MAJOR_REVISION 0xdc
+#define SCDC_DEVICE_SOFTWARE_MINOR_REVISION 0xdd
+
+#define SCDC_MANUFACTURER_SPECIFIC 0xde
+#define SCDC_MANUFACTURER_SPECIFIC_SIZE 34
+
+enum v4l2_ycbcr_encoding {
+	/*
+	 * Mapping of V4L2_YCBCR_ENC_DEFAULT to actual encodings for the
+	 * various colorspaces:
+	 *
+	 * V4L2_COLORSPACE_SMPTE170M, V4L2_COLORSPACE_470_SYSTEM_M,
+	 * V4L2_COLORSPACE_470_SYSTEM_BG, V4L2_COLORSPACE_ADOBERGB and
+	 * V4L2_COLORSPACE_JPEG: V4L2_YCBCR_ENC_601
+	 *
+	 * V4L2_COLORSPACE_REC709 and V4L2_COLORSPACE_DCI_P3: V4L2_YCBCR_ENC_709
+	 *
+	 * V4L2_COLORSPACE_SRGB: V4L2_YCBCR_ENC_SYCC
+	 *
+	 * V4L2_COLORSPACE_BT2020: V4L2_YCBCR_ENC_BT2020
+	 *
+	 * V4L2_COLORSPACE_SMPTE240M: V4L2_YCBCR_ENC_SMPTE240M
+	 */
+	V4L2_YCBCR_ENC_DEFAULT        = 0,
+
+	/* ITU-R 601 -- SDTV */
+	V4L2_YCBCR_ENC_601            = 1,
+
+	/* Rec. 709 -- HDTV */
+	V4L2_YCBCR_ENC_709            = 2,
+
+	/* ITU-R 601/EN 61966-2-4 Extended Gamut -- SDTV */
+	V4L2_YCBCR_ENC_XV601          = 3,
+
+	/* Rec. 709/EN 61966-2-4 Extended Gamut -- HDTV */
+	V4L2_YCBCR_ENC_XV709          = 4,
+
+	/* sYCC (Y'CbCr encoding of sRGB) */
+	V4L2_YCBCR_ENC_SYCC           = 5,
+
+	/* BT.2020 Non-constant Luminance Y'CbCr */
+	V4L2_YCBCR_ENC_BT2020         = 6,
+
+	/* BT.2020 Constant Luminance Y'CbcCrc */
+	V4L2_YCBCR_ENC_BT2020_CONST_LUM = 7,
+
+	/* SMPTE 240M -- Obsolete HDTV */
+	V4L2_YCBCR_ENC_SMPTE240M      = 8,
+};
+
+enum drm_connector_status {
+	connector_status_disconnected = 0,
+	connector_status_connected = 1,
+};
+
+void rk3588_set_grf_cfg(void *data);
+void dw_hdmi_qp_set_iomux(void *data);
+struct dw_hdmi_link_config *dw_hdmi_rockchip_get_link_cfg(void *data);
+void dw_hdmi_qp_selete_output(struct hdmi_edid_data *edid_data,
+			      struct rockchip_connector *conn,
+			      unsigned int *bus_format,
+			      struct overscan *overscan,
+			      enum dw_hdmi_devtype dev_type,
+			      bool output_bus_format_rgb,
+			      void *data, struct display_state *state);
+bool dw_hdmi_qp_check_enable_gpio(void *data);
+
+#endif /* __DW_HDMI_QP_H__ */
diff --git a/drivers/video/drm/dw_mipi_dsi.c b/drivers/video/drm/dw_mipi_dsi.c
new file mode 100644
index 0000000000..bf337f7bfa
--- /dev/null
+++ b/drivers/video/drm/dw_mipi_dsi.c
@@ -0,0 +1,1698 @@
+/*
+ * (C) Copyright 2008-2017 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <drm/drm_mipi_dsi.h>
+
+#include <config.h>
+#include <common.h>
+#include <errno.h>
+#include <asm/unaligned.h>
+#include <asm/io.h>
+#include <asm/hardware.h>
+#include <dm/device.h>
+#include <dm/read.h>
+#include <dm/of_access.h>
+#include <syscon.h>
+#include <asm/arch-rockchip/clock.h>
+#include <linux/iopoll.h>
+
+#include "rockchip_display.h"
+#include "rockchip_crtc.h"
+#include "rockchip_connector.h"
+#include "rockchip_panel.h"
+#include "rockchip_phy.h"
+
+#define UPDATE(v, h, l)		(((v) << (l)) & GENMASK((h), (l)))
+
+#define DSI_VERSION			0x00
+#define DSI_PWR_UP			0x04
+#define RESET				0
+#define POWERUP				BIT(0)
+
+#define DSI_CLKMGR_CFG			0x08
+#define TO_CLK_DIVIDSION(div)		(((div) & 0xff) << 8)
+#define TX_ESC_CLK_DIVIDSION(div)	(((div) & 0xff) << 0)
+
+#define DSI_DPI_VCID			0x0c
+#define DPI_VID(vid)			(((vid) & 0x3) << 0)
+
+#define DSI_DPI_COLOR_CODING		0x10
+#define EN18_LOOSELY			BIT(8)
+#define DPI_COLOR_CODING_16BIT_1	0x0
+#define DPI_COLOR_CODING_16BIT_2	0x1
+#define DPI_COLOR_CODING_16BIT_3	0x2
+#define DPI_COLOR_CODING_18BIT_1	0x3
+#define DPI_COLOR_CODING_18BIT_2	0x4
+#define DPI_COLOR_CODING_24BIT		0x5
+
+#define DSI_DPI_CFG_POL			0x14
+#define COLORM_ACTIVE_LOW		BIT(4)
+#define SHUTD_ACTIVE_LOW		BIT(3)
+#define HSYNC_ACTIVE_LOW		BIT(2)
+#define VSYNC_ACTIVE_LOW		BIT(1)
+#define DATAEN_ACTIVE_LOW		BIT(0)
+
+#define DSI_DPI_LP_CMD_TIM		0x18
+#define OUTVACT_LPCMD_TIME(p)		(((p) & 0xff) << 16)
+#define INVACT_LPCMD_TIME(p)		((p) & 0xff)
+
+#define DSI_DBI_VCID			0x1c
+#define DBI_VCID(x)			UPDATE(x, 1, 0)
+#define DSI_DBI_CFG			0x20
+#define DSI_DBI_CMDSIZE			0x28
+
+#define DSI_PCKHDL_CFG			0x2c
+#define CRC_RX_EN			BIT(4)
+#define ECC_RX_EN			BIT(3)
+#define BTA_EN				BIT(2)
+#define EOTP_RX_EN			BIT(1)
+#define EOTP_TX_EN			BIT(0)
+#define DSI_MODE_CFG			0x34
+#define CMD_VIDEO_MODE			BIT(0)
+#define COMMAND_MODE			BIT(0)
+#define VIDEO_MODE			0
+#define DSI_VID_MODE_CFG		0x38
+#define VPG_EN				BIT(16)
+#define LP_CMD_EN			BIT(15)
+#define FRAME_BTA_ACK			BIT(14)
+#define LP_HFP_EN			BIT(13)
+#define LP_HBP_EN			BIT(12)
+#define LP_VACT_EN			BIT(11)
+#define LP_VFP_EN			BIT(10)
+#define LP_VBP_EN			BIT(9)
+#define LP_VSA_EN			BIT(8)
+#define VID_MODE_TYPE_BURST_SYNC_PULSES	0x0
+#define VID_MODE_TYPE_BURST_SYNC_EVENTS	0x1
+#define VID_MODE_TYPE_BURST		0x2
+
+#define DSI_VID_PKT_SIZE		0x3c
+#define VID_PKT_SIZE(p)			(((p) & 0x3fff) << 0)
+#define VID_PKT_MAX_SIZE		0x3fff
+
+#define DSI_VID_NUM_CHUMKS		0x40
+#define DSI_VID_NULL_PKT_SIZE		0x44
+#define DSI_VID_HSA_TIME		0x48
+#define DSI_VID_HBP_TIME		0x4c
+#define DSI_VID_HLINE_TIME		0x50
+#define DSI_VID_VSA_LINES		0x54
+#define DSI_VID_VBP_LINES		0x58
+#define DSI_VID_VFP_LINES		0x5c
+#define DSI_VID_VACTIVE_LINES		0x60
+#define DSI_EDPI_CMD_SIZE		0x64
+#define DSI_CMD_MODE_CFG		0x68
+#define MAX_RD_PKT_SIZE			BIT(24)
+#define DCS_LW_TX			BIT(19)
+#define DCS_SR_0P_TX			BIT(18)
+#define DCS_SW_1P_TX			BIT(17)
+#define DCS_SW_0P_TX			BIT(16)
+#define GEN_LW_TX			BIT(14)
+#define GEN_SR_2P_TX			BIT(13)
+#define GEN_SR_1P_TX			BIT(12)
+#define GEN_SR_0P_TX			BIT(11)
+#define GEN_SW_2P_TX			BIT(10)
+#define GEN_SW_1P_TX			BIT(9)
+#define GEN_SW_0P_TX			BIT(8)
+#define ACK_RQST_EN			BIT(1)
+#define TEAR_FX_EN			BIT(0)
+
+#define DSI_GEN_HDR			0x6c
+#define GEN_HDATA(data)			(((data) & 0xffff) << 8)
+#define GEN_HDATA_MASK			(0xffff << 8)
+#define GEN_HTYPE(type)			(((type) & 0xff) << 0)
+#define GEN_HTYPE_MASK			0xff
+
+#define DSI_GEN_PLD_DATA		0x70
+
+#define DSI_CMD_PKT_STATUS		0x74
+#define GEN_CMD_EMPTY			BIT(0)
+#define GEN_CMD_FULL			BIT(1)
+#define GEN_PLD_W_EMPTY			BIT(2)
+#define GEN_PLD_W_FULL			BIT(3)
+#define GEN_PLD_R_EMPTY			BIT(4)
+#define GEN_PLD_R_FULL			BIT(5)
+#define GEN_RD_CMD_BUSY			BIT(6)
+
+#define DSI_TO_CNT_CFG			0x78
+#define HSTX_TO_CNT(p)			(((p) & 0xffff) << 16)
+#define LPRX_TO_CNT(p)			((p) & 0xffff)
+
+#define DSI_BTA_TO_CNT			0x8c
+#define DSI_LPCLK_CTRL			0x94
+#define AUTO_CLKLANE_CTRL		BIT(1)
+#define PHY_TXREQUESTCLKHS		BIT(0)
+
+#define DSI_PHY_TMR_LPCLK_CFG		0x98
+#define PHY_CLKHS2LP_TIME(lbcc)		(((lbcc) & 0x3ff) << 16)
+#define PHY_CLKLP2HS_TIME(lbcc)		((lbcc) & 0x3ff)
+
+#define DSI_PHY_TMR_CFG			0x9c
+#define PHY_HS2LP_TIME(lbcc)		(((lbcc) & 0xff) << 24)
+#define PHY_LP2HS_TIME(lbcc)		(((lbcc) & 0xff) << 16)
+#define MAX_RD_TIME(lbcc)		((lbcc) & 0x7fff)
+
+#define DSI_PHY_RSTZ			0xa0
+#define PHY_ENFORCEPLL			BIT(3)
+#define PHY_ENABLECLK			BIT(2)
+#define PHY_RSTZ			BIT(1)
+#define PHY_SHUTDOWNZ			BIT(0)
+
+#define DSI_PHY_IF_CFG			0xa4
+#define N_LANES(n)			((((n) - 1) & 0x3) << 0)
+#define PHY_STOP_WAIT_TIME(cycle)	(((cycle) & 0xff) << 8)
+
+#define DSI_PHY_STATUS			0xb0
+#define PHY_STOPSTATE0LANE		BIT(4)
+#define PHY_STOPSTATECLKLANE		BIT(2)
+#define PHY_LOCK			BIT(0)
+#define PHY_STOPSTATELANE		(PHY_STOPSTATE0LANE | \
+					 PHY_STOPSTATECLKLANE)
+
+#define DSI_PHY_TST_CTRL0		0xb4
+#define PHY_TESTCLK			BIT(1)
+#define PHY_TESTCLR			BIT(0)
+
+#define DSI_PHY_TST_CTRL1		0xb8
+#define PHY_TESTEN			BIT(16)
+#define PHY_TESTDOUT_SHIFT		8
+#define PHY_TESTDIN_MASK		GENMASK(7, 0)
+#define PHY_TESTDIN(x)			UPDATE(x, 7, 0)
+
+#define DSI_INT_ST0			0xbc
+#define DSI_INT_ST1			0xc0
+#define DSI_INT_MSK0			0xc4
+#define DSI_INT_MSK1			0xc8
+
+#define PHY_STATUS_TIMEOUT_US		10000
+#define CMD_PKT_STATUS_TIMEOUT_US	20000
+
+/* Test Code: 0x44 (HS RX Control of Lane 0) */
+#define HSFREQRANGE(x)			UPDATE(x, 6, 1)
+/* Test Code: 0x17 (PLL Input Divider Ratio) */
+#define INPUT_DIV(x)			UPDATE(x, 6, 0)
+/* Test Code: 0x18 (PLL Loop Divider Ratio) */
+#define FEEDBACK_DIV_LO(x)		UPDATE(x, 4, 0)
+#define FEEDBACK_DIV_HI(x)		(BIT(7) | UPDATE(x, 3, 0))
+
+#define GRF_REG_FIELD(reg, lsb, msb)	(((reg) << 10) | ((lsb) << 5) | (msb))
+
+enum grf_reg_fields {
+	DPIUPDATECFG,
+	DPISHUTDN,
+	DPICOLORM,
+	VOPSEL,
+	TURNREQUEST,
+	TURNDISABLE,
+	SKEWCALHS,
+	FORCETXSTOPMODE,
+	FORCERXMODE,
+	ENABLE_N,
+	MASTERSLAVEZ,
+	ENABLECLK,
+	BASEDIR,
+	MAX_FIELDS,
+};
+
+struct dw_mipi_dsi_plat_data {
+	const u32 *dsi0_grf_reg_fields;
+	const u32 *dsi1_grf_reg_fields;
+	unsigned long max_bit_rate_per_lane;
+};
+
+struct mipi_dphy {
+	/* Non-SNPS PHY */
+	struct rockchip_phy *phy;
+
+	u16 input_div;
+	u16 feedback_div;
+};
+
+struct dw_mipi_dsi {
+	struct rockchip_connector connector;
+	struct udevice *dev;
+	void *base;
+	void *grf;
+	int id;
+	struct dw_mipi_dsi *master;
+	struct dw_mipi_dsi *slave;
+	bool prepared;
+
+	unsigned int lane_mbps; /* per lane */
+	u32 channel;
+	u32 lanes;
+	u32 format;
+	u32 mode_flags;
+	struct mipi_dphy dphy;
+	struct drm_display_mode mode;
+	bool data_swap;
+
+	const struct dw_mipi_dsi_plat_data *pdata;
+};
+
+static inline void dsi_write(struct dw_mipi_dsi *dsi, u32 reg, u32 val)
+{
+	writel(val, dsi->base + reg);
+}
+
+static inline u32 dsi_read(struct dw_mipi_dsi *dsi, u32 reg)
+{
+	return readl(dsi->base + reg);
+}
+
+static inline void dsi_update_bits(struct dw_mipi_dsi *dsi,
+				   u32 reg, u32 mask, u32 val)
+{
+	u32 orig, tmp;
+
+	orig = dsi_read(dsi, reg);
+	tmp = orig & ~mask;
+	tmp |= val & mask;
+	dsi_write(dsi, reg, tmp);
+}
+
+static void grf_field_write(struct dw_mipi_dsi *dsi, enum grf_reg_fields index,
+			    unsigned int val)
+{
+	const u32 field = dsi->id ? dsi->pdata->dsi1_grf_reg_fields[index] :
+			  dsi->pdata->dsi0_grf_reg_fields[index];
+	u16 reg;
+	u8 msb, lsb;
+
+	if (!field)
+		return;
+
+	reg = (field >> 10) & 0x3ffff;
+	lsb = (field >>  5) & 0x1f;
+	msb = (field >>  0) & 0x1f;
+
+	rk_clrsetreg(dsi->grf + reg, GENMASK(msb, lsb), val << lsb);
+}
+
+static inline void dpishutdn_assert(struct dw_mipi_dsi *dsi)
+{
+	grf_field_write(dsi, DPISHUTDN, 1);
+}
+
+static inline void dpishutdn_deassert(struct dw_mipi_dsi *dsi)
+{
+	grf_field_write(dsi, DPISHUTDN, 0);
+}
+
+static int genif_wait_w_pld_fifo_not_full(struct dw_mipi_dsi *dsi)
+{
+	u32 sts;
+	int ret;
+
+	ret = readl_poll_timeout(dsi->base + DSI_CMD_PKT_STATUS,
+				 sts, !(sts & GEN_PLD_W_FULL),
+				 CMD_PKT_STATUS_TIMEOUT_US);
+	if (ret < 0) {
+		printf("generic write payload fifo is full\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int genif_wait_cmd_fifo_not_full(struct dw_mipi_dsi *dsi)
+{
+	u32 sts;
+	int ret;
+
+	ret = readl_poll_timeout(dsi->base + DSI_CMD_PKT_STATUS,
+				 sts, !(sts & GEN_CMD_FULL),
+				 CMD_PKT_STATUS_TIMEOUT_US);
+	if (ret < 0) {
+		printf("generic write cmd fifo is full\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int genif_wait_write_fifo_empty(struct dw_mipi_dsi *dsi)
+{
+	u32 sts;
+	u32 mask;
+	int ret;
+
+	mask = GEN_CMD_EMPTY | GEN_PLD_W_EMPTY;
+	ret = readl_poll_timeout(dsi->base + DSI_CMD_PKT_STATUS,
+				 sts, (sts & mask) == mask,
+				 CMD_PKT_STATUS_TIMEOUT_US);
+	if (ret < 0) {
+		printf("generic write fifo is full\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static inline void mipi_dphy_enableclk_assert(struct dw_mipi_dsi *dsi)
+{
+	dsi_update_bits(dsi, DSI_PHY_RSTZ, PHY_ENABLECLK, PHY_ENABLECLK);
+	udelay(1);
+}
+
+static inline void mipi_dphy_enableclk_deassert(struct dw_mipi_dsi *dsi)
+{
+	dsi_update_bits(dsi, DSI_PHY_RSTZ, PHY_ENABLECLK, 0);
+	udelay(1);
+}
+
+static inline void mipi_dphy_shutdownz_assert(struct dw_mipi_dsi *dsi)
+{
+	dsi_update_bits(dsi, DSI_PHY_RSTZ, PHY_SHUTDOWNZ, 0);
+	udelay(1);
+}
+
+static inline void mipi_dphy_shutdownz_deassert(struct dw_mipi_dsi *dsi)
+{
+	dsi_update_bits(dsi, DSI_PHY_RSTZ, PHY_SHUTDOWNZ, PHY_SHUTDOWNZ);
+	udelay(1);
+}
+
+static inline void mipi_dphy_rstz_assert(struct dw_mipi_dsi *dsi)
+{
+	dsi_update_bits(dsi, DSI_PHY_RSTZ, PHY_RSTZ, 0);
+	udelay(1);
+}
+
+static inline void mipi_dphy_rstz_deassert(struct dw_mipi_dsi *dsi)
+{
+	dsi_update_bits(dsi, DSI_PHY_RSTZ, PHY_RSTZ, PHY_RSTZ);
+	udelay(1);
+}
+
+static inline void testif_testclk_assert(struct dw_mipi_dsi *dsi)
+{
+	dsi_update_bits(dsi, DSI_PHY_TST_CTRL0, PHY_TESTCLK, PHY_TESTCLK);
+	udelay(1);
+}
+
+static inline void testif_testclk_deassert(struct dw_mipi_dsi *dsi)
+{
+	dsi_update_bits(dsi, DSI_PHY_TST_CTRL0, PHY_TESTCLK, 0);
+	udelay(1);
+}
+
+static inline void testif_testclr_assert(struct dw_mipi_dsi *dsi)
+{
+	dsi_update_bits(dsi, DSI_PHY_TST_CTRL0, PHY_TESTCLR, PHY_TESTCLR);
+	udelay(1);
+}
+
+static inline void testif_testclr_deassert(struct dw_mipi_dsi *dsi)
+{
+	dsi_update_bits(dsi, DSI_PHY_TST_CTRL0, PHY_TESTCLR, 0);
+	udelay(1);
+}
+
+static inline void testif_testen_assert(struct dw_mipi_dsi *dsi)
+{
+	dsi_update_bits(dsi, DSI_PHY_TST_CTRL1, PHY_TESTEN, PHY_TESTEN);
+	udelay(1);
+}
+
+static inline void testif_testen_deassert(struct dw_mipi_dsi *dsi)
+{
+	dsi_update_bits(dsi, DSI_PHY_TST_CTRL1, PHY_TESTEN, 0);
+	udelay(1);
+}
+
+static inline void testif_set_data(struct dw_mipi_dsi *dsi, u8 data)
+{
+	dsi_update_bits(dsi, DSI_PHY_TST_CTRL1,
+			PHY_TESTDIN_MASK, PHY_TESTDIN(data));
+	udelay(1);
+}
+
+static inline u8 testif_get_data(struct dw_mipi_dsi *dsi)
+{
+	return dsi_read(dsi, DSI_PHY_TST_CTRL1) >> PHY_TESTDOUT_SHIFT;
+}
+
+static void testif_test_code_write(struct dw_mipi_dsi *dsi, u8 test_code)
+{
+	testif_testclk_assert(dsi);
+	testif_set_data(dsi, test_code);
+	testif_testen_assert(dsi);
+	testif_testclk_deassert(dsi);
+	testif_testen_deassert(dsi);
+}
+
+static void testif_test_data_write(struct dw_mipi_dsi *dsi, u8 test_data)
+{
+	testif_testclk_deassert(dsi);
+	testif_set_data(dsi, test_data);
+	testif_testclk_assert(dsi);
+}
+
+static void testif_write(struct dw_mipi_dsi *dsi, u8 test_code, u8 test_data)
+{
+	testif_test_code_write(dsi, test_code);
+	testif_test_data_write(dsi, test_data);
+
+	dev_dbg(dsi->dev,
+		"test_code=0x%02x, test_data=0x%02x, monitor_data=0x%02x\n",
+		test_code, test_data, testif_get_data(dsi));
+}
+
+static int mipi_dphy_power_on(struct dw_mipi_dsi *dsi)
+{
+	u32 mask, val;
+	int ret;
+
+	mipi_dphy_shutdownz_deassert(dsi);
+	mipi_dphy_rstz_deassert(dsi);
+	mdelay(2);
+
+	if (dsi->dphy.phy) {
+		rockchip_phy_set_mode(dsi->dphy.phy, PHY_MODE_MIPI_DPHY);
+		rockchip_phy_power_on(dsi->dphy.phy);
+	}
+
+	ret = readl_poll_timeout(dsi->base + DSI_PHY_STATUS,
+				 val, val & PHY_LOCK, PHY_STATUS_TIMEOUT_US);
+	if (ret < 0) {
+		dev_err(dsi->dev, "PHY is not locked\n");
+		return ret;
+	}
+
+	udelay(200);
+
+	mask = PHY_STOPSTATELANE;
+	ret = readl_poll_timeout(dsi->base + DSI_PHY_STATUS,
+				 val, (val & mask) == mask,
+				 PHY_STATUS_TIMEOUT_US);
+	if (ret < 0) {
+		dev_err(dsi->dev, "lane module is not in stop state\n");
+		return ret;
+	}
+
+	udelay(10);
+
+	return 0;
+}
+
+static void dw_mipi_dsi_phy_init(struct dw_mipi_dsi *dsi)
+{
+	/* Table 5-1 Frequency Ranges */
+	const struct {
+		unsigned long max_lane_mbps;
+		u8 hsfreqrange;
+	} hsfreqrange_table[] = {
+		{  90, 0x00}, { 100, 0x10}, { 110, 0x20}, { 130, 0x01},
+		{ 140, 0x11}, { 150, 0x21}, { 170, 0x02}, { 180, 0x12},
+		{ 200, 0x22}, { 220, 0x03}, { 240, 0x13}, { 250, 0x23},
+		{ 270, 0x04}, { 300, 0x14}, { 330, 0x05}, { 360, 0x15},
+		{ 400, 0x25}, { 450, 0x06}, { 500, 0x16}, { 550, 0x07},
+		{ 600, 0x17}, { 650, 0x08}, { 700, 0x18}, { 750, 0x09},
+		{ 800, 0x19}, { 850, 0x29}, { 900, 0x39}, { 950, 0x0a},
+		{1000, 0x1a}, {1050, 0x2a}, {1100, 0x3a}, {1150, 0x0b},
+		{1200, 0x1b}, {1250, 0x2b}, {1300, 0x3b}, {1350, 0x0c},
+		{1400, 0x1c}, {1450, 0x2c}, {1500, 0x3c}
+	};
+	u8 hsfreqrange, counter;
+	unsigned int index, txbyteclkhs;
+	u16 n, m;
+
+	for (index = 0; index < ARRAY_SIZE(hsfreqrange_table); index++)
+		if (dsi->lane_mbps <= hsfreqrange_table[index].max_lane_mbps)
+			break;
+
+	if (index == ARRAY_SIZE(hsfreqrange_table))
+		--index;
+
+	hsfreqrange = hsfreqrange_table[index].hsfreqrange;
+	testif_write(dsi, 0x44, HSFREQRANGE(hsfreqrange));
+
+	txbyteclkhs = dsi->lane_mbps >> 3;
+	counter = txbyteclkhs * 60 / 1000;
+	testif_write(dsi, 0x60, 0x80 | counter);
+	testif_write(dsi, 0x70, 0x80 | counter);
+
+	n = dsi->dphy.input_div - 1;
+	m = dsi->dphy.feedback_div - 1;
+	testif_write(dsi, 0x19, 0x30);
+	testif_write(dsi, 0x17, INPUT_DIV(n));
+	testif_write(dsi, 0x18, FEEDBACK_DIV_LO(m));
+	testif_write(dsi, 0x18, FEEDBACK_DIV_HI(m >> 5));
+}
+
+static unsigned long dw_mipi_dsi_get_lane_rate(struct dw_mipi_dsi *dsi)
+{
+	const struct drm_display_mode *mode = &dsi->mode;
+	unsigned long max_lane_rate = dsi->pdata->max_bit_rate_per_lane;
+	unsigned long lane_rate;
+	unsigned int value;
+	int bpp, lanes;
+	u64 tmp;
+
+	/* optional override of the desired bandwidth */
+	value = dev_read_u32_default(dsi->dev, "rockchip,lane-rate", 0);
+	if (value > 0)
+		return value * 1000 * 1000;
+
+	bpp = mipi_dsi_pixel_format_to_bpp(dsi->format);
+	if (bpp < 0)
+		bpp = 24;
+
+	lanes = dsi->slave ? dsi->lanes * 2 : dsi->lanes;
+	tmp = (u64)mode->clock * 1000 * bpp;
+	do_div(tmp, lanes);
+
+	/* take 1 / 0.9, since mbps must big than bandwidth of RGB */
+	tmp *= 10;
+	do_div(tmp, 9);
+
+	if (tmp > max_lane_rate)
+		lane_rate = max_lane_rate;
+	else
+		lane_rate = tmp;
+
+	return lane_rate;
+}
+
+static void dw_mipi_dsi_set_pll(struct dw_mipi_dsi *dsi, unsigned long rate)
+{
+	unsigned long fin, fout;
+	unsigned long fvco_min, fvco_max, best_freq = 984000000;
+	u8 min_prediv, max_prediv;
+	u8 _prediv, best_prediv = 2;
+	u16 _fbdiv, best_fbdiv = 82;
+	u32 min_delta = ~0U;
+
+	fin = 24000000;
+	fout = rate;
+
+	/* 5Mhz < Fref / N < 40MHz, 80MHz < Fvco < 1500Mhz */
+	min_prediv = DIV_ROUND_UP(fin, 40000000);
+	max_prediv = fin / 5000000;
+	fvco_min = 80000000;
+	fvco_max = 1500000000;
+
+	for (_prediv = min_prediv; _prediv <= max_prediv; _prediv++) {
+		u64 tmp, _fout;
+		u32 delta;
+
+		/* Fvco = Fref * M / N */
+		tmp = (u64)fout * _prediv;
+		do_div(tmp, fin);
+		_fbdiv = tmp;
+
+		/*
+		 * Due to the use of a "by 2 pre-scaler," the range of the
+		 * feedback multiplication value M is limited to even division
+		 * numbers, and m must be greater than 12, less than 1000.
+		 */
+		if (_fbdiv <= 12 || _fbdiv >= 1000)
+			continue;
+
+		if (_fbdiv % 2)
+			++_fbdiv;
+
+		_fout = (u64)_fbdiv * fin;
+		do_div(_fout, _prediv);
+
+		if (_fout < fvco_min || _fout > fvco_max)
+			continue;
+
+		delta = abs(fout - _fout);
+		if (!delta) {
+			best_prediv = _prediv;
+			best_fbdiv = _fbdiv;
+			best_freq = _fout;
+			break;
+		} else if (delta < min_delta) {
+			best_prediv = _prediv;
+			best_fbdiv = _fbdiv;
+			best_freq = _fout;
+			min_delta = delta;
+		}
+	}
+
+	dsi->lane_mbps = best_freq / 1000 / 1000;
+	dsi->dphy.input_div = best_prediv;
+	dsi->dphy.feedback_div = best_fbdiv;
+	if (dsi->slave) {
+		dsi->slave->lane_mbps = dsi->lane_mbps;
+		dsi->slave->dphy.input_div = dsi->dphy.input_div;
+		dsi->slave->dphy.feedback_div = dsi->dphy.feedback_div;
+	}
+	if (dsi->master) {
+		dsi->master->lane_mbps = dsi->lane_mbps;
+		dsi->master->dphy.input_div = dsi->dphy.input_div;
+		dsi->master->dphy.feedback_div = dsi->dphy.feedback_div;
+	}
+}
+
+static int dw_mipi_dsi_read_from_fifo(struct dw_mipi_dsi *dsi,
+				      const struct mipi_dsi_msg *msg)
+{
+	u8 *payload = msg->rx_buf;
+	u16 length;
+	u32 val;
+	int ret;
+
+	ret = readl_poll_timeout(dsi->base + DSI_CMD_PKT_STATUS,
+				 val, !(val & GEN_RD_CMD_BUSY), 5000);
+	if (ret) {
+		printf("entire response isn't stored in the FIFO\n");
+		return ret;
+	}
+
+	/* Receive payload */
+	for (length = msg->rx_len; length; length -= 4) {
+		ret = readl_poll_timeout(dsi->base + DSI_CMD_PKT_STATUS,
+					 val, !(val & GEN_PLD_R_EMPTY), 5000);
+		if (ret) {
+			printf("Read payload FIFO is empty\n");
+			return ret;
+		}
+
+		val = dsi_read(dsi, DSI_GEN_PLD_DATA);
+
+		switch (length) {
+		case 3:
+			payload[2] = (val >> 16) & 0xff;
+			/* Fall through */
+		case 2:
+			payload[1] = (val >> 8) & 0xff;
+			/* Fall through */
+		case 1:
+			payload[0] = val & 0xff;
+			return 0;
+		}
+
+		payload[0] = (val >>  0) & 0xff;
+		payload[1] = (val >>  8) & 0xff;
+		payload[2] = (val >> 16) & 0xff;
+		payload[3] = (val >> 24) & 0xff;
+		payload += 4;
+	}
+
+	return 0;
+}
+
+static int dw_mipi_dsi_turn_on_peripheral(struct dw_mipi_dsi *dsi)
+{
+	dpishutdn_assert(dsi);
+	udelay(20);
+	dpishutdn_deassert(dsi);
+
+	return 0;
+}
+
+static int dw_mipi_dsi_shutdown_peripheral(struct dw_mipi_dsi *dsi)
+{
+	dpishutdn_deassert(dsi);
+	udelay(20);
+	dpishutdn_assert(dsi);
+
+	return 0;
+}
+
+static ssize_t dw_mipi_dsi_transfer(struct dw_mipi_dsi *dsi,
+				    const struct mipi_dsi_msg *msg)
+{
+	struct mipi_dsi_packet packet;
+	int ret;
+	int val;
+
+	if (msg->flags & MIPI_DSI_MSG_USE_LPM) {
+		dsi_update_bits(dsi, DSI_VID_MODE_CFG, LP_CMD_EN, LP_CMD_EN);
+		dsi_update_bits(dsi, DSI_LPCLK_CTRL, PHY_TXREQUESTCLKHS, 0);
+	} else {
+		dsi_update_bits(dsi, DSI_VID_MODE_CFG, LP_CMD_EN, 0);
+		dsi_update_bits(dsi, DSI_LPCLK_CTRL,
+				PHY_TXREQUESTCLKHS, PHY_TXREQUESTCLKHS);
+	}
+
+	switch (msg->type) {
+	case MIPI_DSI_SHUTDOWN_PERIPHERAL:
+		return dw_mipi_dsi_shutdown_peripheral(dsi);
+	case MIPI_DSI_TURN_ON_PERIPHERAL:
+		return dw_mipi_dsi_turn_on_peripheral(dsi);
+	case MIPI_DSI_DCS_SHORT_WRITE:
+		dsi_update_bits(dsi, DSI_CMD_MODE_CFG, DCS_SW_0P_TX,
+				dsi->mode_flags & MIPI_DSI_MODE_LPM ?
+				DCS_SW_0P_TX : 0);
+		break;
+	case MIPI_DSI_DCS_SHORT_WRITE_PARAM:
+		dsi_update_bits(dsi, DSI_CMD_MODE_CFG, DCS_SW_1P_TX,
+				dsi->mode_flags & MIPI_DSI_MODE_LPM ?
+				DCS_SW_1P_TX : 0);
+		break;
+	case MIPI_DSI_DCS_LONG_WRITE:
+		dsi_update_bits(dsi, DSI_CMD_MODE_CFG, DCS_LW_TX,
+				dsi->mode_flags & MIPI_DSI_MODE_LPM ?
+				DCS_LW_TX : 0);
+		break;
+	case MIPI_DSI_DCS_READ:
+		dsi_update_bits(dsi, DSI_CMD_MODE_CFG, DCS_SR_0P_TX,
+				dsi->mode_flags & MIPI_DSI_MODE_LPM ?
+				DCS_SR_0P_TX : 0);
+		break;
+	case MIPI_DSI_SET_MAXIMUM_RETURN_PACKET_SIZE:
+		dsi_update_bits(dsi, DSI_CMD_MODE_CFG, MAX_RD_PKT_SIZE,
+				dsi->mode_flags & MIPI_DSI_MODE_LPM ?
+				MAX_RD_PKT_SIZE : 0);
+		break;
+	case MIPI_DSI_GENERIC_SHORT_WRITE_0_PARAM:
+		dsi_update_bits(dsi, DSI_CMD_MODE_CFG, GEN_SW_0P_TX,
+				dsi->mode_flags & MIPI_DSI_MODE_LPM ?
+				GEN_SW_0P_TX : 0);
+		break;
+	case MIPI_DSI_GENERIC_SHORT_WRITE_1_PARAM:
+		dsi_update_bits(dsi, DSI_CMD_MODE_CFG, GEN_SW_1P_TX,
+				dsi->mode_flags & MIPI_DSI_MODE_LPM ?
+				GEN_SW_1P_TX : 0);
+		break;
+	case MIPI_DSI_GENERIC_SHORT_WRITE_2_PARAM:
+		dsi_update_bits(dsi, DSI_CMD_MODE_CFG, GEN_SW_2P_TX,
+				dsi->mode_flags & MIPI_DSI_MODE_LPM ?
+				GEN_SW_2P_TX : 0);
+		break;
+	case MIPI_DSI_GENERIC_LONG_WRITE:
+		dsi_update_bits(dsi, DSI_CMD_MODE_CFG, GEN_LW_TX,
+				dsi->mode_flags & MIPI_DSI_MODE_LPM ?
+				GEN_LW_TX : 0);
+		break;
+	case MIPI_DSI_GENERIC_READ_REQUEST_0_PARAM:
+		dsi_update_bits(dsi, DSI_CMD_MODE_CFG, GEN_SR_0P_TX,
+				dsi->mode_flags & MIPI_DSI_MODE_LPM ?
+				GEN_SR_0P_TX : 0);
+		break;
+	case MIPI_DSI_GENERIC_READ_REQUEST_1_PARAM:
+		dsi_update_bits(dsi, DSI_CMD_MODE_CFG, GEN_SR_1P_TX,
+				dsi->mode_flags & MIPI_DSI_MODE_LPM ?
+				GEN_SR_1P_TX : 0);
+		break;
+	case MIPI_DSI_GENERIC_READ_REQUEST_2_PARAM:
+		dsi_update_bits(dsi, DSI_CMD_MODE_CFG, GEN_SR_2P_TX,
+				dsi->mode_flags & MIPI_DSI_MODE_LPM ?
+				GEN_SR_2P_TX : 0);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (msg->flags & MIPI_DSI_MSG_REQ_ACK)
+		dsi_update_bits(dsi, DSI_CMD_MODE_CFG,
+				ACK_RQST_EN, ACK_RQST_EN);
+
+	/* create a packet to the DSI protocol */
+	ret = mipi_dsi_create_packet(&packet, msg);
+	if (ret) {
+		printf("failed to create packet: %d\n", ret);
+		return ret;
+	}
+
+	/* Send payload */
+	while (DIV_ROUND_UP(packet.payload_length, 4)) {
+		/*
+		 * Alternatively, you can always keep the FIFO
+		 * nearly full by monitoring the FIFO state until
+		 * it is not full, and then writea single word of data.
+		 * This solution is more resource consuming
+		 * but it simultaneously avoids FIFO starvation,
+		 * making it possible to use FIFO sizes smaller than
+		 * the amount of data of the longest packet to be written.
+		 */
+		ret = genif_wait_w_pld_fifo_not_full(dsi);
+		if (ret)
+			return ret;
+
+		if (packet.payload_length < 4) {
+			/* send residu payload */
+			val = 0;
+			memcpy(&val, packet.payload, packet.payload_length);
+			dsi_write(dsi, DSI_GEN_PLD_DATA, val);
+			packet.payload_length = 0;
+		} else {
+			val = get_unaligned_le32(packet.payload);
+			dsi_write(dsi, DSI_GEN_PLD_DATA, val);
+			packet.payload += 4;
+			packet.payload_length -= 4;
+		}
+	}
+
+	ret = genif_wait_cmd_fifo_not_full(dsi);
+	if (ret)
+		return ret;
+
+	/* Send packet header */
+	val = get_unaligned_le32(packet.header);
+	dsi_write(dsi, DSI_GEN_HDR, val);
+
+	ret = genif_wait_write_fifo_empty(dsi);
+	if (ret)
+		return ret;
+
+	if (msg->rx_len) {
+		ret = dw_mipi_dsi_read_from_fifo(dsi, msg);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (dsi->slave) {
+		ret = dw_mipi_dsi_transfer(dsi->slave, msg);
+		if (ret < 0)
+			return ret;
+	}
+
+	return msg->rx_len ? msg->rx_len : msg->tx_len;
+}
+
+static void dw_mipi_dsi_video_mode_config(struct dw_mipi_dsi *dsi)
+{
+	u32 val = LP_VACT_EN | LP_VFP_EN | LP_VBP_EN | LP_VSA_EN |
+		  LP_HFP_EN | LP_HBP_EN;
+
+	if (dsi->mode_flags & MIPI_DSI_MODE_VIDEO_HFP)
+		val &= ~LP_HFP_EN;
+
+	if (dsi->mode_flags & MIPI_DSI_MODE_VIDEO_HBP)
+		val &= ~LP_HBP_EN;
+
+	if (dsi->mode_flags & MIPI_DSI_MODE_VIDEO_BURST)
+		val |= VID_MODE_TYPE_BURST;
+	else if (dsi->mode_flags & MIPI_DSI_MODE_VIDEO_SYNC_PULSE)
+		val |= VID_MODE_TYPE_BURST_SYNC_PULSES;
+	else
+		val |= VID_MODE_TYPE_BURST_SYNC_EVENTS;
+
+	dsi_write(dsi, DSI_VID_MODE_CFG, val);
+
+	if (dsi->mode_flags & MIPI_DSI_CLOCK_NON_CONTINUOUS)
+		dsi_update_bits(dsi, DSI_LPCLK_CTRL,
+				AUTO_CLKLANE_CTRL, AUTO_CLKLANE_CTRL);
+}
+
+static void dw_mipi_dsi_enable(struct dw_mipi_dsi *dsi)
+{
+	const struct drm_display_mode *mode = &dsi->mode;
+
+	dsi_update_bits(dsi, DSI_LPCLK_CTRL,
+			PHY_TXREQUESTCLKHS, PHY_TXREQUESTCLKHS);
+
+	dsi_write(dsi, DSI_PWR_UP, RESET);
+
+	if (dsi->mode_flags & MIPI_DSI_MODE_VIDEO) {
+		dsi_update_bits(dsi, DSI_MODE_CFG, CMD_VIDEO_MODE, VIDEO_MODE);
+	} else {
+		dsi_write(dsi, DSI_DBI_VCID, DBI_VCID(dsi->channel));
+		dsi_update_bits(dsi, DSI_CMD_MODE_CFG, DCS_LW_TX, 0);
+		dsi_write(dsi, DSI_EDPI_CMD_SIZE, mode->hdisplay);
+		dsi_update_bits(dsi, DSI_MODE_CFG,
+				CMD_VIDEO_MODE, COMMAND_MODE);
+	}
+
+	dsi_write(dsi, DSI_PWR_UP, POWERUP);
+
+	if (dsi->slave)
+		dw_mipi_dsi_enable(dsi->slave);
+}
+
+static void dw_mipi_dsi_disable(struct dw_mipi_dsi *dsi)
+{
+	dsi_write(dsi, DSI_PWR_UP, RESET);
+	dsi_write(dsi, DSI_LPCLK_CTRL, 0);
+	dsi_write(dsi, DSI_EDPI_CMD_SIZE, 0);
+	dsi_update_bits(dsi, DSI_MODE_CFG, CMD_VIDEO_MODE, COMMAND_MODE);
+	dsi_write(dsi, DSI_PWR_UP, POWERUP);
+
+	if (dsi->slave)
+		dw_mipi_dsi_disable(dsi->slave);
+}
+
+static void dw_mipi_dsi_post_disable(struct dw_mipi_dsi *dsi)
+{
+	if (!dsi->prepared)
+		return;
+
+	if (dsi->master)
+		dw_mipi_dsi_post_disable(dsi->master);
+
+	dsi_write(dsi, DSI_PWR_UP, RESET);
+	dsi_write(dsi, DSI_PHY_RSTZ, 0);
+
+	if (dsi->dphy.phy)
+		rockchip_phy_power_off(dsi->dphy.phy);
+
+	dsi->prepared = false;
+
+	if (dsi->slave)
+		dw_mipi_dsi_post_disable(dsi->slave);
+}
+
+static void dw_mipi_dsi_init(struct dw_mipi_dsi *dsi)
+{
+	u32 esc_clk_div;
+
+	dsi_write(dsi, DSI_PWR_UP, RESET);
+
+	/* The maximum value of the escape clock frequency is 20MHz */
+	esc_clk_div = DIV_ROUND_UP(dsi->lane_mbps >> 3, 20);
+	dsi_write(dsi, DSI_CLKMGR_CFG, TO_CLK_DIVIDSION(10) |
+		  TX_ESC_CLK_DIVIDSION(esc_clk_div));
+}
+
+static void dw_mipi_dsi_dpi_config(struct dw_mipi_dsi *dsi,
+				   struct drm_display_mode *mode)
+{
+	u32 val = 0, color = 0;
+
+	switch (dsi->format) {
+	case MIPI_DSI_FMT_RGB888:
+		color = DPI_COLOR_CODING_24BIT;
+		break;
+	case MIPI_DSI_FMT_RGB666:
+		color = DPI_COLOR_CODING_18BIT_2 | EN18_LOOSELY;
+		break;
+	case MIPI_DSI_FMT_RGB666_PACKED:
+		color = DPI_COLOR_CODING_18BIT_1;
+		break;
+	case MIPI_DSI_FMT_RGB565:
+		color = DPI_COLOR_CODING_16BIT_1;
+		break;
+	}
+
+	if (mode->flags & DRM_MODE_FLAG_NVSYNC)
+		val |= VSYNC_ACTIVE_LOW;
+	if (mode->flags & DRM_MODE_FLAG_NHSYNC)
+		val |= HSYNC_ACTIVE_LOW;
+
+	dsi_write(dsi, DSI_DPI_VCID, DPI_VID(dsi->channel));
+	dsi_write(dsi, DSI_DPI_COLOR_CODING, color);
+	dsi_write(dsi, DSI_DPI_CFG_POL, val);
+	dsi_write(dsi, DSI_DPI_LP_CMD_TIM, OUTVACT_LPCMD_TIME(4)
+		  | INVACT_LPCMD_TIME(4));
+}
+
+static void dw_mipi_dsi_packet_handler_config(struct dw_mipi_dsi *dsi)
+{
+	u32 val = CRC_RX_EN | ECC_RX_EN | BTA_EN | EOTP_TX_EN;
+
+	if (dsi->mode_flags & MIPI_DSI_MODE_EOT_PACKET)
+		val &= ~EOTP_TX_EN;
+
+	dsi_write(dsi, DSI_PCKHDL_CFG, val);
+}
+
+static void dw_mipi_dsi_video_packet_config(struct dw_mipi_dsi *dsi,
+					    struct drm_display_mode *mode)
+{
+	dsi_write(dsi, DSI_VID_PKT_SIZE, VID_PKT_SIZE(mode->hdisplay));
+}
+
+static void dw_mipi_dsi_command_mode_config(struct dw_mipi_dsi *dsi)
+{
+	dsi_write(dsi, DSI_TO_CNT_CFG, HSTX_TO_CNT(1000) | LPRX_TO_CNT(1000));
+	dsi_write(dsi, DSI_BTA_TO_CNT, 0xd00);
+}
+
+/* Get lane byte clock cycles. */
+static int dw_mipi_dsi_get_hcomponent_lbcc(struct dw_mipi_dsi *dsi,
+					   u32 hcomponent)
+{
+	u32 lbcc;
+
+	lbcc = hcomponent * dsi->lane_mbps * 1000 / 8;
+
+	if (!dsi->mode.clock)
+		return 0;
+
+	return DIV_ROUND_CLOSEST(lbcc, dsi->mode.clock);
+}
+
+static void dw_mipi_dsi_line_timer_config(struct dw_mipi_dsi *dsi)
+{
+	int htotal, hsa, hbp, lbcc;
+	struct drm_display_mode *mode = &dsi->mode;
+
+	htotal = mode->htotal;
+	hsa = mode->hsync_end - mode->hsync_start;
+	hbp = mode->htotal - mode->hsync_end;
+
+	lbcc = dw_mipi_dsi_get_hcomponent_lbcc(dsi, htotal);
+	dsi_write(dsi, DSI_VID_HLINE_TIME, lbcc);
+
+	lbcc = dw_mipi_dsi_get_hcomponent_lbcc(dsi, hsa);
+	dsi_write(dsi, DSI_VID_HSA_TIME, lbcc);
+
+	lbcc = dw_mipi_dsi_get_hcomponent_lbcc(dsi, hbp);
+	dsi_write(dsi, DSI_VID_HBP_TIME, lbcc);
+}
+
+static void dw_mipi_dsi_vertical_timing_config(struct dw_mipi_dsi *dsi)
+{
+	u32 vactive, vsa, vfp, vbp;
+	struct drm_display_mode *mode = &dsi->mode;
+
+	vactive = mode->vdisplay;
+	vsa = mode->vsync_end - mode->vsync_start;
+	vfp = mode->vsync_start - mode->vdisplay;
+	vbp = mode->vtotal - mode->vsync_end;
+
+	dsi_write(dsi, DSI_VID_VACTIVE_LINES, vactive);
+	dsi_write(dsi, DSI_VID_VSA_LINES, vsa);
+	dsi_write(dsi, DSI_VID_VFP_LINES, vfp);
+	dsi_write(dsi, DSI_VID_VBP_LINES, vbp);
+}
+
+static void dw_mipi_dsi_dphy_timing_config(struct dw_mipi_dsi *dsi)
+{
+	dsi_write(dsi, DSI_PHY_TMR_CFG, PHY_HS2LP_TIME(0x14)
+		  | PHY_LP2HS_TIME(0x10) | MAX_RD_TIME(10000));
+
+	dsi_write(dsi, DSI_PHY_TMR_LPCLK_CFG, PHY_CLKHS2LP_TIME(0x40)
+		  | PHY_CLKLP2HS_TIME(0x40));
+}
+
+static void dw_mipi_dsi_dphy_interface_config(struct dw_mipi_dsi *dsi)
+{
+	dsi_write(dsi, DSI_PHY_IF_CFG, PHY_STOP_WAIT_TIME(0x20) |
+		  N_LANES(dsi->lanes));
+}
+
+static void dw_mipi_dsi_clear_err(struct dw_mipi_dsi *dsi)
+{
+	dsi_read(dsi, DSI_INT_ST0);
+	dsi_read(dsi, DSI_INT_ST1);
+	dsi_write(dsi, DSI_INT_MSK0, 0);
+	dsi_write(dsi, DSI_INT_MSK1, 0);
+}
+
+static int dw_mipi_dsi_connector_init(struct rockchip_connector *conn, struct display_state *state)
+{
+	struct connector_state *conn_state = &state->conn_state;
+	struct dw_mipi_dsi *dsi = dev_get_priv(conn->dev);
+
+	conn_state->disp_info  = rockchip_get_disp_info(conn_state->type, dsi->id);
+	dsi->dphy.phy = conn->phy;
+
+	conn_state->output_mode = ROCKCHIP_OUT_MODE_P888;
+	conn_state->color_space = V4L2_COLORSPACE_DEFAULT;
+	conn_state->output_if |=
+		dsi->id ? VOP_OUTPUT_IF_MIPI1 : VOP_OUTPUT_IF_MIPI0;
+
+#ifndef CONFIG_ROCKCHIP_RK3568
+	if (dsi->id) {
+		struct udevice *dev;
+		int ret;
+
+		ret = uclass_get_device_by_name(UCLASS_DISPLAY, "dsi@ff960000",
+						&dev);
+		if (ret)
+			return ret;
+
+		dsi->master = dev_get_priv(dev);
+		if (!dsi->master)
+			return -ENODEV;
+
+		conn_state->output_flags = ROCKCHIP_OUTPUT_DATA_SWAP;
+	}
+#endif
+
+	if (dsi->lanes > 4) {
+		struct udevice *dev;
+		int ret;
+
+		ret = uclass_get_device_by_name(UCLASS_DISPLAY,
+#if defined(CONFIG_ROCKCHIP_RK3288)
+						"dsi@ff964000",
+#elif defined(CONFIG_ROCKCHIP_RK3399)
+						"dsi@ff968000",
+#else
+						"dsi@fe070000",
+#endif
+						&dev);
+		if (ret)
+			return ret;
+
+		dsi->slave = dev_get_priv(dev);
+		if (!dsi->slave)
+			return -ENODEV;
+
+		dsi->lanes /= 2;
+		dsi->slave->lanes = dsi->lanes;
+		dsi->slave->format = dsi->format;
+		dsi->slave->mode_flags = dsi->mode_flags;
+		dsi->slave->channel = dsi->channel;
+		conn_state->output_flags =
+				ROCKCHIP_OUTPUT_DUAL_CHANNEL_LEFT_RIGHT_MODE;
+		if (dsi->data_swap)
+			conn_state->output_flags |= ROCKCHIP_OUTPUT_DATA_SWAP;
+
+		conn_state->output_if |= VOP_OUTPUT_IF_MIPI1;
+
+#if defined(CONFIG_ROCKCHIP_RK3568)
+		struct rockchip_phy *phy = NULL;
+		struct udevice *phy_dev;
+
+		ret = uclass_get_device_by_phandle(UCLASS_PHY, dev,
+						   "phys", &phy_dev);
+		if (ret)
+			return -ENODEV;
+
+		phy = (struct rockchip_phy *)dev_get_driver_data(phy_dev);
+		if (!phy)
+			return -ENODEV;
+
+		dsi->slave->dphy.phy = phy;
+		if (phy->funcs && phy->funcs->init)
+			return phy->funcs->init(phy);
+#endif
+
+	}
+
+	return 0;
+}
+
+static void dw_mipi_dsi_set_hs_clk(struct dw_mipi_dsi *dsi, unsigned long rate)
+{
+	rate = rockchip_phy_set_pll(dsi->dphy.phy, rate);
+	dsi->lane_mbps = rate / 1000 / 1000;
+}
+
+static void dw_mipi_dsi_host_init(struct dw_mipi_dsi *dsi)
+{
+	dw_mipi_dsi_init(dsi);
+	dw_mipi_dsi_dpi_config(dsi, &dsi->mode);
+	dw_mipi_dsi_packet_handler_config(dsi);
+	dw_mipi_dsi_video_mode_config(dsi);
+	dw_mipi_dsi_video_packet_config(dsi, &dsi->mode);
+	dw_mipi_dsi_command_mode_config(dsi);
+	dsi_update_bits(dsi, DSI_MODE_CFG, CMD_VIDEO_MODE, COMMAND_MODE);
+	dw_mipi_dsi_line_timer_config(dsi);
+	dw_mipi_dsi_vertical_timing_config(dsi);
+	dw_mipi_dsi_dphy_timing_config(dsi);
+	dw_mipi_dsi_dphy_interface_config(dsi);
+	dw_mipi_dsi_clear_err(dsi);
+}
+
+static void dw_mipi_dsi_vop_routing(struct dw_mipi_dsi *dsi, int vop_id)
+{
+	grf_field_write(dsi, VOPSEL, vop_id);
+
+	if (dsi->slave)
+		grf_field_write(dsi->slave, VOPSEL, vop_id);
+}
+
+static void mipi_dphy_init(struct dw_mipi_dsi *dsi)
+{
+	u32 map[] = {0x0, 0x1, 0x3, 0x7, 0xf};
+
+	mipi_dphy_enableclk_deassert(dsi);
+	mipi_dphy_shutdownz_assert(dsi);
+	mipi_dphy_rstz_assert(dsi);
+	testif_testclr_assert(dsi);
+
+	/* Configures DPHY to work as a Master */
+	grf_field_write(dsi, MASTERSLAVEZ, 1);
+
+	/* Configures lane as TX */
+	grf_field_write(dsi, BASEDIR, 0);
+
+	/* Set all REQUEST inputs to zero */
+	grf_field_write(dsi, TURNREQUEST, 0);
+	grf_field_write(dsi, TURNDISABLE, 0);
+	grf_field_write(dsi, FORCETXSTOPMODE, 0);
+	grf_field_write(dsi, FORCERXMODE, 0);
+	udelay(1);
+
+	testif_testclr_deassert(dsi);
+
+	if (!dsi->dphy.phy)
+		dw_mipi_dsi_phy_init(dsi);
+
+	/* Enable Data Lane Module */
+	grf_field_write(dsi, ENABLE_N, map[dsi->lanes]);
+
+	/* Enable Clock Lane Module */
+	grf_field_write(dsi, ENABLECLK, 1);
+
+	mipi_dphy_enableclk_assert(dsi);
+}
+
+static void dw_mipi_dsi_pre_enable(struct dw_mipi_dsi *dsi)
+{
+	if (dsi->prepared)
+		return;
+
+	if (dsi->master)
+		dw_mipi_dsi_pre_enable(dsi->master);
+
+	dw_mipi_dsi_host_init(dsi);
+	mipi_dphy_init(dsi);
+	mipi_dphy_power_on(dsi);
+	dsi_write(dsi, DSI_PWR_UP, POWERUP);
+
+	dsi->prepared = true;
+
+	if (dsi->slave)
+		dw_mipi_dsi_pre_enable(dsi->slave);
+}
+
+static int dw_mipi_dsi_connector_prepare(struct rockchip_connector *conn,
+					 struct display_state *state)
+{
+	struct connector_state *conn_state = &state->conn_state;
+	struct crtc_state *crtc_state = &state->crtc_state;
+	struct dw_mipi_dsi *dsi = dev_get_priv(conn->dev);
+	unsigned long lane_rate;
+
+	memcpy(&dsi->mode, &conn_state->mode, sizeof(struct drm_display_mode));
+	if (dsi->slave) {
+		dsi->mode.hdisplay /= 2;
+		memcpy(&dsi->slave->mode, &dsi->mode,
+		       sizeof(struct drm_display_mode));
+	}
+
+	lane_rate = dw_mipi_dsi_get_lane_rate(dsi);
+	if (dsi->dphy.phy)
+		dw_mipi_dsi_set_hs_clk(dsi, lane_rate);
+	else
+		dw_mipi_dsi_set_pll(dsi, lane_rate);
+
+	if (dsi->slave && dsi->slave->dphy.phy)
+		dw_mipi_dsi_set_hs_clk(dsi->slave, lane_rate);
+
+	printf("final DSI-Link bandwidth: %u Mbps x %d\n",
+	       dsi->lane_mbps, dsi->slave ? dsi->lanes * 2 : dsi->lanes);
+
+	dw_mipi_dsi_vop_routing(dsi, crtc_state->crtc_id);
+	dw_mipi_dsi_pre_enable(dsi);
+
+	return 0;
+}
+
+static void dw_mipi_dsi_connector_unprepare(struct rockchip_connector *conn,
+					    struct display_state *state)
+{
+	struct dw_mipi_dsi *dsi = dev_get_priv(conn->dev);
+
+	dw_mipi_dsi_post_disable(dsi);
+}
+
+static int dw_mipi_dsi_connector_enable(struct rockchip_connector *conn,
+					struct display_state *state)
+{
+	struct dw_mipi_dsi *dsi = dev_get_priv(conn->dev);
+
+	dw_mipi_dsi_enable(dsi);
+
+	return 0;
+}
+
+static int dw_mipi_dsi_connector_disable(struct rockchip_connector *conn,
+					 struct display_state *state)
+{
+	struct dw_mipi_dsi *dsi = dev_get_priv(conn->dev);
+
+	dw_mipi_dsi_disable(dsi);
+
+	return 0;
+}
+
+static const struct rockchip_connector_funcs dw_mipi_dsi_connector_funcs = {
+	.init = dw_mipi_dsi_connector_init,
+	.prepare = dw_mipi_dsi_connector_prepare,
+	.unprepare = dw_mipi_dsi_connector_unprepare,
+	.enable = dw_mipi_dsi_connector_enable,
+	.disable = dw_mipi_dsi_connector_disable,
+};
+
+static int dw_mipi_dsi_probe(struct udevice *dev)
+{
+	struct dw_mipi_dsi *dsi = dev_get_priv(dev);
+	const struct dw_mipi_dsi_plat_data *pdata =
+		(const struct dw_mipi_dsi_plat_data *)dev_get_driver_data(dev);
+	int id;
+
+	dsi->base = dev_read_addr_ptr(dev);
+	dsi->grf = syscon_get_first_range(ROCKCHIP_SYSCON_GRF);
+	if (IS_ERR(dsi->grf))
+		return PTR_ERR(dsi->grf);
+
+	id = of_alias_get_id(ofnode_to_np(dev->node), "dsi");
+	if (id < 0)
+		id = 0;
+
+	dsi->dev = dev;
+	dsi->pdata = pdata;
+	dsi->id = id;
+	dsi->data_swap = dev_read_bool(dsi->dev, "rockchip,data-swap");
+
+	rockchip_connector_bind(&dsi->connector, dev, dsi->id, &dw_mipi_dsi_connector_funcs, NULL,
+				DRM_MODE_CONNECTOR_DSI);
+
+	return 0;
+}
+
+static const u32 px30_dsi_grf_reg_fields[MAX_FIELDS] = {
+	[DPIUPDATECFG]		= GRF_REG_FIELD(0x0434,  7,  7),
+	[DPICOLORM]		= GRF_REG_FIELD(0x0434,  3,  3),
+	[DPISHUTDN]		= GRF_REG_FIELD(0x0434,  2,  2),
+	[FORCETXSTOPMODE]	= GRF_REG_FIELD(0x0438,  7, 10),
+	[TURNDISABLE]		= GRF_REG_FIELD(0x0438,  5,  5),
+	[VOPSEL]		= GRF_REG_FIELD(0x0438,  0,  0),
+};
+
+static const struct dw_mipi_dsi_plat_data px30_mipi_dsi_plat_data = {
+	.dsi0_grf_reg_fields = px30_dsi_grf_reg_fields,
+	.max_bit_rate_per_lane = 1000000000UL,
+};
+
+static const u32 rk1808_dsi_grf_reg_fields[MAX_FIELDS] = {
+	[MASTERSLAVEZ]          = GRF_REG_FIELD(0x0440,  8,  8),
+	[DPIUPDATECFG]          = GRF_REG_FIELD(0x0440,  7,  7),
+	[DPICOLORM]             = GRF_REG_FIELD(0x0440,  3,  3),
+	[DPISHUTDN]             = GRF_REG_FIELD(0x0440,  2,  2),
+	[FORCETXSTOPMODE]       = GRF_REG_FIELD(0x0444,  7, 10),
+	[FORCERXMODE]           = GRF_REG_FIELD(0x0444,  6,  6),
+	[TURNDISABLE]           = GRF_REG_FIELD(0x0444,  5,  5),
+};
+
+static const struct dw_mipi_dsi_plat_data rk1808_mipi_dsi_plat_data = {
+	.dsi0_grf_reg_fields = rk1808_dsi_grf_reg_fields,
+	.max_bit_rate_per_lane = 2000000000UL,
+};
+
+static const u32 rk3128_dsi_grf_reg_fields[MAX_FIELDS] = {
+	[FORCETXSTOPMODE]	= GRF_REG_FIELD(0x0150, 10, 13),
+	[FORCERXMODE]		= GRF_REG_FIELD(0x0150,  9,  9),
+	[TURNDISABLE]		= GRF_REG_FIELD(0x0150,  8,  8),
+	[DPICOLORM]		= GRF_REG_FIELD(0x0150,  5,  5),
+	[DPISHUTDN]		= GRF_REG_FIELD(0x0150,  4,  4),
+};
+
+static const struct dw_mipi_dsi_plat_data rk3128_mipi_dsi_plat_data = {
+	.dsi0_grf_reg_fields = rk3128_dsi_grf_reg_fields,
+	.max_bit_rate_per_lane = 1000000000UL,
+};
+
+static const u32 rk3288_dsi0_grf_reg_fields[MAX_FIELDS] = {
+	[DPICOLORM]		= GRF_REG_FIELD(0x025c,  8,  8),
+	[DPISHUTDN]		= GRF_REG_FIELD(0x025c,  7,  7),
+	[VOPSEL]		= GRF_REG_FIELD(0x025c,  6,  6),
+	[FORCETXSTOPMODE]	= GRF_REG_FIELD(0x0264,  8, 11),
+	[FORCERXMODE]		= GRF_REG_FIELD(0x0264,  4,  7),
+	[TURNDISABLE]		= GRF_REG_FIELD(0x0264,  0,  3),
+	[TURNREQUEST]		= GRF_REG_FIELD(0x03a4,  8, 10),
+	[DPIUPDATECFG]		= GRF_REG_FIELD(0x03a8,  0,  0),
+};
+
+static const u32 rk3288_dsi1_grf_reg_fields[MAX_FIELDS] = {
+	[DPICOLORM]		= GRF_REG_FIELD(0x025c, 11, 11),
+	[DPISHUTDN]		= GRF_REG_FIELD(0x025c, 10, 10),
+	[VOPSEL]		= GRF_REG_FIELD(0x025c,  9,  9),
+	[ENABLE_N]		= GRF_REG_FIELD(0x0268, 12, 15),
+	[FORCETXSTOPMODE]	= GRF_REG_FIELD(0x0268,  8, 11),
+	[FORCERXMODE]		= GRF_REG_FIELD(0x0268,  4,  7),
+	[TURNDISABLE]		= GRF_REG_FIELD(0x0268,  0,  3),
+	[BASEDIR]		= GRF_REG_FIELD(0x027c, 15, 15),
+	[MASTERSLAVEZ]		= GRF_REG_FIELD(0x027c, 14, 14),
+	[ENABLECLK]		= GRF_REG_FIELD(0x027c, 12, 12),
+	[TURNREQUEST]		= GRF_REG_FIELD(0x03a4,  4,  7),
+	[DPIUPDATECFG]		= GRF_REG_FIELD(0x03a8,  1,  1),
+};
+
+static const struct dw_mipi_dsi_plat_data rk3288_mipi_dsi_plat_data = {
+	.dsi0_grf_reg_fields = rk3288_dsi0_grf_reg_fields,
+	.dsi1_grf_reg_fields = rk3288_dsi1_grf_reg_fields,
+	.max_bit_rate_per_lane = 1500000000UL,
+};
+
+static const u32 rk3366_dsi_grf_reg_fields[MAX_FIELDS] = {
+	[VOPSEL]		= GRF_REG_FIELD(0x0400,  2,  2),
+	[DPIUPDATECFG]		= GRF_REG_FIELD(0x0410,  9,  9),
+	[DPICOLORM]		= GRF_REG_FIELD(0x0410,  3,  3),
+	[DPISHUTDN]		= GRF_REG_FIELD(0x0410,  2,  2),
+	[FORCETXSTOPMODE]	= GRF_REG_FIELD(0x0414,  7, 10),
+	[FORCERXMODE]		= GRF_REG_FIELD(0x0414,  6,  6),
+	[TURNDISABLE]		= GRF_REG_FIELD(0x0414,  5,  5),
+};
+
+static const struct dw_mipi_dsi_plat_data rk3366_mipi_dsi_plat_data = {
+	.dsi0_grf_reg_fields = rk3366_dsi_grf_reg_fields,
+	.max_bit_rate_per_lane = 1000000000UL,
+};
+
+static const u32 rk3368_dsi_grf_reg_fields[MAX_FIELDS] = {
+	[DPIUPDATECFG]		= GRF_REG_FIELD(0x0418,  7,  7),
+	[DPICOLORM]		= GRF_REG_FIELD(0x0418,  3,  3),
+	[DPISHUTDN]		= GRF_REG_FIELD(0x0418,  2,  2),
+	[FORCETXSTOPMODE]	= GRF_REG_FIELD(0x041c,  7, 10),
+	[FORCERXMODE]		= GRF_REG_FIELD(0x041c,  6,  6),
+	[TURNDISABLE]		= GRF_REG_FIELD(0x041c,  5,  5),
+};
+
+static const struct dw_mipi_dsi_plat_data rk3368_mipi_dsi_plat_data = {
+	.dsi0_grf_reg_fields = rk3368_dsi_grf_reg_fields,
+	.max_bit_rate_per_lane = 1000000000UL,
+};
+
+static const u32 rk3399_dsi0_grf_reg_fields[MAX_FIELDS] = {
+	[DPIUPDATECFG]		= GRF_REG_FIELD(0x6224, 15, 15),
+	[DPISHUTDN]		= GRF_REG_FIELD(0x6224, 14, 14),
+	[DPICOLORM]		= GRF_REG_FIELD(0x6224, 13, 13),
+	[VOPSEL]		= GRF_REG_FIELD(0x6250,  0,  0),
+	[TURNREQUEST]		= GRF_REG_FIELD(0x6258, 12, 15),
+	[TURNDISABLE]		= GRF_REG_FIELD(0x6258,  8, 11),
+	[FORCETXSTOPMODE]	= GRF_REG_FIELD(0x6258,  4,  7),
+	[FORCERXMODE]		= GRF_REG_FIELD(0x6258,  0,  3),
+};
+
+static const u32 rk3399_dsi1_grf_reg_fields[MAX_FIELDS] = {
+	[VOPSEL]		= GRF_REG_FIELD(0x6250,  4,  4),
+	[DPIUPDATECFG]		= GRF_REG_FIELD(0x6250,  3,  3),
+	[DPISHUTDN]		= GRF_REG_FIELD(0x6250,  2,  2),
+	[DPICOLORM]		= GRF_REG_FIELD(0x6250,  1,  1),
+	[TURNDISABLE]		= GRF_REG_FIELD(0x625c, 12, 15),
+	[FORCETXSTOPMODE]	= GRF_REG_FIELD(0x625c,  8, 11),
+	[FORCERXMODE]           = GRF_REG_FIELD(0x625c,  4,  7),
+	[ENABLE_N]		= GRF_REG_FIELD(0x625c,  0,  3),
+	[MASTERSLAVEZ]		= GRF_REG_FIELD(0x6260,  7,  7),
+	[ENABLECLK]		= GRF_REG_FIELD(0x6260,  6,  6),
+	[BASEDIR]		= GRF_REG_FIELD(0x6260,  5,  5),
+	[TURNREQUEST]		= GRF_REG_FIELD(0x6260,  0,  3),
+};
+
+static const struct dw_mipi_dsi_plat_data rk3399_mipi_dsi_plat_data = {
+	.dsi0_grf_reg_fields = rk3399_dsi0_grf_reg_fields,
+	.dsi1_grf_reg_fields = rk3399_dsi1_grf_reg_fields,
+	.max_bit_rate_per_lane = 1500000000UL,
+};
+
+static const u32 rk3562_dsi_grf_reg_fields[MAX_FIELDS] = {
+	[DPIUPDATECFG]		= GRF_REG_FIELD(0x05d0,  2,  2),
+	[DPICOLORM]		= GRF_REG_FIELD(0x05d0,  1,  1),
+	[DPISHUTDN]		= GRF_REG_FIELD(0x05d0,  0,  0),
+	[SKEWCALHS]		= GRF_REG_FIELD(0x05d4, 11, 15),
+	[FORCETXSTOPMODE]	= GRF_REG_FIELD(0x05d4,  4,  7),
+	[TURNDISABLE]		= GRF_REG_FIELD(0x05d4,  2,  2),
+	[FORCERXMODE]		= GRF_REG_FIELD(0x05d4,  0,  0),
+};
+
+static const struct dw_mipi_dsi_plat_data rk3562_mipi_dsi_plat_data = {
+	.dsi0_grf_reg_fields = rk3562_dsi_grf_reg_fields,
+	.max_bit_rate_per_lane = 1200000000UL,
+};
+
+static const u32 rk3568_dsi0_grf_reg_fields[MAX_FIELDS] = {
+	[DPIUPDATECFG]		= GRF_REG_FIELD(0x0360,  2,  2),
+	[DPICOLORM]		= GRF_REG_FIELD(0x0360,  1,  1),
+	[DPISHUTDN]		= GRF_REG_FIELD(0x0360,  0,  0),
+	[SKEWCALHS]		= GRF_REG_FIELD(0x0368, 11, 15),
+	[FORCETXSTOPMODE]	= GRF_REG_FIELD(0x0368,  4,  7),
+	[TURNDISABLE]		= GRF_REG_FIELD(0x0368,  2,  2),
+	[FORCERXMODE]		= GRF_REG_FIELD(0x0368,  0,  0),
+};
+
+static const u32 rk3568_dsi1_grf_reg_fields[MAX_FIELDS] = {
+	[DPIUPDATECFG]		= GRF_REG_FIELD(0x0360, 10, 10),
+	[DPICOLORM]		= GRF_REG_FIELD(0x0360,  9,  9),
+	[DPISHUTDN]		= GRF_REG_FIELD(0x0360,  8,  8),
+	[SKEWCALHS]             = GRF_REG_FIELD(0x036c, 11, 15),
+	[FORCETXSTOPMODE]	= GRF_REG_FIELD(0x036c,  4,  7),
+	[TURNDISABLE]		= GRF_REG_FIELD(0x036c,  2,  2),
+	[FORCERXMODE]		= GRF_REG_FIELD(0x036c,  0,  0),
+};
+
+static const struct dw_mipi_dsi_plat_data rk3568_mipi_dsi_plat_data = {
+	.dsi0_grf_reg_fields = rk3568_dsi0_grf_reg_fields,
+	.dsi1_grf_reg_fields = rk3568_dsi1_grf_reg_fields,
+	.max_bit_rate_per_lane = 1200000000UL,
+};
+
+static const u32 rv1108_dsi_grf_reg_fields[MAX_FIELDS] = {
+	[DPICOLORM]		= GRF_REG_FIELD(0x0410,  7,  7),
+	[DPISHUTDN]		= GRF_REG_FIELD(0x0410,  6,  6),
+	[DPIUPDATECFG]		= GRF_REG_FIELD(0x0410,  8,  8),
+	[FORCERXMODE]		= GRF_REG_FIELD(0x0414,  5,  5),
+	[FORCETXSTOPMODE]	= GRF_REG_FIELD(0x0414,  6,  9),
+	[TURNDISABLE]		= GRF_REG_FIELD(0x0414,  4,  4),
+};
+
+static const struct dw_mipi_dsi_plat_data rv1108_mipi_dsi_plat_data = {
+	.dsi0_grf_reg_fields = rv1108_dsi_grf_reg_fields,
+	.max_bit_rate_per_lane = 1000000000UL,
+};
+
+static const u32 rv1126_dsi_grf_reg_fields[MAX_FIELDS] = {
+	[DPIUPDATECFG]		= GRF_REG_FIELD(0x0008,  5,  5),
+	[DPISHUTDN]		= GRF_REG_FIELD(0x0008,  4,  4),
+	[DPICOLORM]		= GRF_REG_FIELD(0x0008,  3,  3),
+	[FORCETXSTOPMODE]	= GRF_REG_FIELD(0x10220,  4,  7),
+	[TURNDISABLE]		= GRF_REG_FIELD(0x10220,  2,  2),
+	[FORCERXMODE]		= GRF_REG_FIELD(0x10220,  0,  0),
+};
+
+static const struct dw_mipi_dsi_plat_data rv1126_mipi_dsi_plat_data = {
+	.dsi0_grf_reg_fields = rv1126_dsi_grf_reg_fields,
+	.max_bit_rate_per_lane = 1000000000UL,
+};
+
+static const struct udevice_id dw_mipi_dsi_ids[] = {
+	{
+		.compatible = "rockchip,px30-mipi-dsi",
+		.data = (ulong)&px30_mipi_dsi_plat_data,
+	},
+	{
+		.compatible = "rockchip,rk1808-mipi-dsi",
+		.data = (ulong)&rk1808_mipi_dsi_plat_data,
+	},
+	{
+		.compatible = "rockchip,rk3128-mipi-dsi",
+		.data = (ulong)&rk3128_mipi_dsi_plat_data,
+	},
+	{
+		.compatible = "rockchip,rk3288-mipi-dsi",
+		.data = (ulong)&rk3288_mipi_dsi_plat_data,
+	},
+	{
+		.compatible = "rockchip,rk3366-mipi-dsi",
+		.data = (ulong)&rk3366_mipi_dsi_plat_data,
+	},
+	{
+		.compatible = "rockchip,rk3368-mipi-dsi",
+		.data = (ulong)&rk3368_mipi_dsi_plat_data,
+	},
+	{
+		.compatible = "rockchip,rk3399-mipi-dsi",
+		.data = (ulong)&rk3399_mipi_dsi_plat_data,
+	},
+	{
+		.compatible = "rockchip,rk3562-mipi-dsi",
+		.data = (ulong)&rk3562_mipi_dsi_plat_data,
+	},
+	{
+		.compatible = "rockchip,rk3568-mipi-dsi",
+		.data = (ulong)&rk3568_mipi_dsi_plat_data,
+	},
+	{
+		.compatible = "rockchip,rv1108-mipi-dsi",
+		.data = (ulong)&rv1108_mipi_dsi_plat_data,
+	},
+	{
+		.compatible = "rockchip,rv1126-mipi-dsi",
+		.data = (ulong)&rv1126_mipi_dsi_plat_data,
+	},
+	{}
+};
+
+static ssize_t dw_mipi_dsi_host_transfer(struct mipi_dsi_host *host,
+					 const struct mipi_dsi_msg *msg)
+{
+	struct dw_mipi_dsi *dsi = dev_get_priv(host->dev);
+
+	return dw_mipi_dsi_transfer(dsi, msg);
+}
+
+static int dw_mipi_dsi_host_attach(struct mipi_dsi_host *host,
+				   struct mipi_dsi_device *device)
+{
+	struct dw_mipi_dsi *dsi = dev_get_priv(host->dev);
+
+	if (device->lanes < 1 || device->lanes > 8)
+		return -EINVAL;
+
+	dsi->lanes = device->lanes;
+	dsi->channel = device->channel;
+	dsi->format = device->format;
+	dsi->mode_flags = device->mode_flags;
+
+	return 0;
+}
+
+static const struct mipi_dsi_host_ops dw_mipi_dsi_host_ops = {
+	.attach = dw_mipi_dsi_host_attach,
+	.transfer = dw_mipi_dsi_host_transfer,
+};
+
+static int dw_mipi_dsi_bind(struct udevice *dev)
+{
+	struct mipi_dsi_host *host = dev_get_platdata(dev);
+
+	host->dev = dev;
+	host->ops = &dw_mipi_dsi_host_ops;
+
+	return dm_scan_fdt_dev(dev);
+}
+
+static int dw_mipi_dsi_child_post_bind(struct udevice *dev)
+{
+	struct mipi_dsi_host *host = dev_get_platdata(dev->parent);
+	struct mipi_dsi_device *device = dev_get_parent_platdata(dev);
+	char name[20];
+
+	sprintf(name, "%s.%d", host->dev->name, device->channel);
+	device_set_name(dev, name);
+
+	device->dev = dev;
+	device->host = host;
+	device->lanes = dev_read_u32_default(dev, "dsi,lanes", 4);
+	device->format = dev_read_u32_default(dev, "dsi,format",
+					      MIPI_DSI_FMT_RGB888);
+	device->mode_flags = dev_read_u32_default(dev, "dsi,flags",
+						  MIPI_DSI_MODE_VIDEO |
+						  MIPI_DSI_MODE_VIDEO_BURST |
+						  MIPI_DSI_MODE_VIDEO_HBP |
+						  MIPI_DSI_MODE_LPM |
+						  MIPI_DSI_MODE_EOT_PACKET);
+	device->channel = dev_read_u32_default(dev, "reg", 0);
+
+	return 0;
+}
+
+static int dw_mipi_dsi_child_pre_probe(struct udevice *dev)
+{
+	struct mipi_dsi_device *device = dev_get_parent_platdata(dev);
+	int ret;
+
+	ret = mipi_dsi_attach(device);
+	if (ret) {
+		dev_err(dev, "mipi_dsi_attach() failed: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+U_BOOT_DRIVER(dw_mipi_dsi) = {
+	.name = "dw_mipi_dsi",
+	.id = UCLASS_DISPLAY,
+	.of_match = dw_mipi_dsi_ids,
+	.probe = dw_mipi_dsi_probe,
+	.bind = dw_mipi_dsi_bind,
+	.priv_auto_alloc_size = sizeof(struct dw_mipi_dsi),
+	.per_child_platdata_auto_alloc_size = sizeof(struct mipi_dsi_device),
+	.platdata_auto_alloc_size = sizeof(struct mipi_dsi_host),
+	.child_post_bind = dw_mipi_dsi_child_post_bind,
+	.child_pre_probe = dw_mipi_dsi_child_pre_probe,
+};
diff --git a/drivers/video/drm/dw_mipi_dsi2.c b/drivers/video/drm/dw_mipi_dsi2.c
new file mode 100644
index 0000000000..5882026c3c
--- /dev/null
+++ b/drivers/video/drm/dw_mipi_dsi2.c
@@ -0,0 +1,1425 @@
+/*
+ * (C) Copyright 2008-2017 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Author: Guochun Huang <hero.huang@rock-chips.com>
+ */
+
+#include <drm/drm_mipi_dsi.h>
+
+#include <config.h>
+#include <common.h>
+#include <errno.h>
+#include <asm/unaligned.h>
+#include <asm/gpio.h>
+#include <asm/io.h>
+#include <asm/hardware.h>
+#include <dm/device.h>
+#include <dm/read.h>
+#include <dm/of_access.h>
+#include <regmap.h>
+#include <syscon.h>
+#include <asm/arch-rockchip/clock.h>
+#include <linux/iopoll.h>
+
+#include "rockchip_display.h"
+#include "rockchip_crtc.h"
+#include "rockchip_connector.h"
+#include "rockchip_panel.h"
+#include "rockchip_phy.h"
+
+#define UPDATE(v, h, l)		(((v) << (l)) & GENMASK((h), (l)))
+
+#define DSI2_PWR_UP			0x000c
+#define RESET				0
+#define POWER_UP			BIT(0)
+#define CMD_TX_MODE(x)			UPDATE(x,  24,  24)
+#define DSI2_SOFT_RESET			0x0010
+#define SYS_RSTN			BIT(2)
+#define PHY_RSTN			BIT(1)
+#define IPI_RSTN			BIT(0)
+#define INT_ST_MAIN			0x0014
+#define DSI2_MODE_CTRL			0x0018
+#define DSI2_MODE_STATUS		0x001c
+#define DSI2_CORE_STATUS		0x0020
+#define PRI_RD_DATA_AVAIL		BIT(26)
+#define PRI_FIFOS_NOT_EMPTY		BIT(25)
+#define PRI_BUSY			BIT(24)
+#define CRI_RD_DATA_AVAIL		BIT(18)
+#define CRT_FIFOS_NOT_EMPTY		BIT(17)
+#define CRI_BUSY			BIT(16)
+#define IPI_FIFOS_NOT_EMPTY		BIT(9)
+#define IPI_BUSY			BIT(8)
+#define CORE_FIFOS_NOT_EMPTY		BIT(1)
+#define CORE_BUSY			BIT(0)
+#define MANUAL_MODE_CFG			0x0024
+#define MANUAL_MODE_EN			BIT(0)
+#define DSI2_TIMEOUT_HSTX_CFG		0x0048
+#define TO_HSTX(x)			UPDATE(x, 15, 0)
+#define DSI2_TIMEOUT_HSTXRDY_CFG	0x004c
+#define TO_HSTXRDY(x)			UPDATE(x, 15, 0)
+#define DSI2_TIMEOUT_LPRX_CFG		0x0050
+#define TO_LPRXRDY(x)			UPDATE(x, 15, 0)
+#define DSI2_TIMEOUT_LPTXRDY_CFG	0x0054
+#define TO_LPTXRDY(x)			UPDATE(x, 15, 0)
+#define DSI2_TIMEOUT_LPTXTRIG_CFG	0x0058
+#define TO_LPTXTRIG(x)			UPDATE(x, 15, 0)
+#define DSI2_TIMEOUT_LPTXULPS_CFG	0x005c
+#define TO_LPTXULPS(x)			UPDATE(x, 15, 0)
+#define DSI2_TIMEOUT_BTA_CFG		0x60
+#define TO_BTA(x)			UPDATE(x, 15, 0)
+
+#define DSI2_PHY_MODE_CFG		0x0100
+#define PPI_WIDTH(x)			UPDATE(x, 9, 8)
+#define PHY_LANES(x)			UPDATE(x - 1, 5, 4)
+#define PHY_TYPE(x)			UPDATE(x, 0, 0)
+#define DSI2_PHY_CLK_CFG		0X0104
+#define PHY_LPTX_CLK_DIV(x)		UPDATE(x, 12, 8)
+#define NON_CONTINUOUS_CLK		BIT(0)
+#define DSI2_PHY_LP2HS_MAN_CFG		0x010c
+#define PHY_LP2HS_TIME(x)		UPDATE(x, 28, 0)
+#define DSI2_PHY_HS2LP_MAN_CFG		0x0114
+#define PHY_HS2LP_TIME(x)		UPDATE(x, 28, 0)
+#define DSI2_PHY_MAX_RD_T_MAN_CFG	0x011c
+#define PHY_MAX_RD_TIME(x)		UPDATE(x, 26, 0)
+#define DSI2_PHY_ESC_CMD_T_MAN_CFG	0x0124
+#define PHY_ESC_CMD_TIME(x)		UPDATE(x, 28, 0)
+#define DSI2_PHY_ESC_BYTE_T_MAN_CFG	0x012c
+#define PHY_ESC_BYTE_TIME(x)		UPDATE(x, 28, 0)
+
+#define DSI2_PHY_IPI_RATIO_MAN_CFG	0x0134
+#define PHY_IPI_RATIO(x)		UPDATE(x, 21, 0)
+#define DSI2_PHY_SYS_RATIO_MAN_CFG	0x013C
+#define PHY_SYS_RATIO(x)		UPDATE(x, 16, 0)
+
+#define DSI2_DSI_GENERAL_CFG		0x0200
+#define BTA_EN				BIT(1)
+#define EOTP_TX_EN			BIT(0)
+#define DSI2_DSI_VCID_CFG		0x0204
+#define TX_VCID(x)			UPDATE(x, 1, 0)
+#define DSI2_DSI_SCRAMBLING_CFG		0x0208
+#define SCRAMBLING_SEED(x)		UPDATE(x, 31, 16)
+#define SCRAMBLING_EN			BIT(0)
+#define DSI2_DSI_VID_TX_CFG		0x020c
+#define LPDT_DISPLAY_CMD_EN		BIT(20)
+#define BLK_VFP_HS_EN			BIT(14)
+#define BLK_VBP_HS_EN			BIT(13)
+#define BLK_VSA_HS_EN			BIT(12)
+#define BLK_HFP_HS_EN			BIT(6)
+#define BLK_HBP_HS_EN			BIT(5)
+#define BLK_HSA_HS_EN			BIT(4)
+#define VID_MODE_TYPE(x)		UPDATE(x, 1, 0)
+#define DSI2_CRI_TX_HDR			0x02c0
+#define CMD_TX_MODE(x)			UPDATE(x, 24, 24)
+#define DSI2_CRI_TX_PLD			0x02c4
+#define DSI2_CRI_RX_HDR			0x02c8
+#define DSI2_CRI_RX_PLD			0x02cc
+
+#define DSI2_IPI_COLOR_MAN_CFG		0x0300
+#define IPI_DEPTH(x)			UPDATE(x, 7, 4)
+#define IPI_DEPTH_5_6_5_BITS		0x02
+#define IPI_DEPTH_6_BITS		0x03
+#define IPI_DEPTH_8_BITS		0x05
+#define IPI_DEPTH_10_BITS		0x06
+#define IPI_FORMAT(x)			UPDATE(x, 3, 0)
+#define IPI_FORMAT_RGB			0x0
+#define IPI_FORMAT_DSC			0x0b
+#define DSI2_IPI_VID_HSA_MAN_CFG	0x0304
+#define VID_HSA_TIME(x)			UPDATE(x, 29, 0)
+#define DSI2_IPI_VID_HBP_MAN_CFG	0x030c
+#define VID_HBP_TIME(x)			UPDATE(x, 29, 0)
+#define DSI2_IPI_VID_HACT_MAN_CFG	0x0314
+#define VID_HACT_TIME(x)		UPDATE(x, 29, 0)
+#define DSI2_IPI_VID_HLINE_MAN_CFG	0x031c
+#define VID_HLINE_TIME(x)		UPDATE(x, 29, 0)
+#define DSI2_IPI_VID_VSA_MAN_CFG	0x0324
+#define VID_VSA_LINES(x)		UPDATE(x, 9, 0)
+#define DSI2_IPI_VID_VBP_MAN_CFG	0X032C
+#define VID_VBP_LINES(x)		UPDATE(x, 9, 0)
+#define DSI2_IPI_VID_VACT_MAN_CFG	0X0334
+#define VID_VACT_LINES(x)		UPDATE(x, 13, 0)
+#define DSI2_IPI_VID_VFP_MAN_CFG	0X033C
+#define VID_VFP_LINES(x)		UPDATE(x, 9, 0)
+#define DSI2_IPI_PIX_PKT_CFG		0x0344
+#define MAX_PIX_PKT(x)			UPDATE(x, 15, 0)
+
+#define DSI2_INT_ST_PHY			0x0400
+#define DSI2_INT_MASK_PHY		0x0404
+#define DSI2_INT_ST_TO			0x0410
+#define DSI2_INT_MASK_TO		0x0414
+#define DSI2_INT_ST_ACK			0x0420
+#define DSI2_INT_MASK_ACK		0x0424
+#define DSI2_INT_ST_IPI			0x0430
+#define DSI2_INT_MASK_IPI		0x0434
+#define DSI2_INT_ST_FIFO		0x0440
+#define DSI2_INT_MASK_FIFO		0x0444
+#define DSI2_INT_ST_PRI			0x0450
+#define DSI2_INT_MASK_PRI		0x0454
+#define DSI2_INT_ST_CRI			0x0460
+#define DSI2_INT_MASK_CRI		0x0464
+#define DSI2_INT_FORCE_CRI		0x0468
+#define DSI2_MAX_REGISGER		DSI2_INT_FORCE_CRI
+
+#define CMD_PKT_STATUS_TIMEOUT_US	1000
+#define MODE_STATUS_TIMEOUT_US		20000
+#define SYS_CLK				351000000LL
+#define PSEC_PER_SEC			1000000000000LL
+#define USEC_PER_SEC			1000000L
+#define MSEC_PER_SEC			1000L
+
+#define GRF_REG_FIELD(reg, lsb, msb)	(((reg) << 16) | ((lsb) << 8) | (msb))
+
+enum vid_mode_type {
+	VID_MODE_TYPE_NON_BURST_SYNC_PULSES,
+	VID_MODE_TYPE_NON_BURST_SYNC_EVENTS,
+	VID_MODE_TYPE_BURST,
+};
+
+enum mode_ctrl {
+	IDLE_MODE,
+	AUTOCALC_MODE,
+	COMMAND_MODE,
+	VIDEO_MODE,
+	DATA_STREAM_MODE,
+	VIDE_TEST_MODE,
+	DATA_STREAM_TEST_MODE,
+};
+
+enum grf_reg_fields {
+	TXREQCLKHS_EN,
+	GATING_EN,
+	IPI_SHUTDN,
+	IPI_COLORM,
+	IPI_COLOR_DEPTH,
+	IPI_FORMAT,
+	MAX_FIELDS,
+};
+
+enum phy_type {
+	DPHY,
+	CPHY,
+};
+
+enum ppi_width {
+	PPI_WIDTH_8_BITS,
+	PPI_WIDTH_16_BITS,
+	PPI_WIDTH_32_BITS,
+};
+
+struct rockchip_cmd_header {
+	u8 data_type;
+	u8 delay_ms;
+	u8 payload_length;
+};
+
+struct dw_mipi_dsi2_plat_data {
+	const u32 *dsi0_grf_reg_fields;
+	const u32 *dsi1_grf_reg_fields;
+	unsigned long long dphy_max_bit_rate_per_lane;
+	unsigned long long cphy_max_symbol_rate_per_lane;
+};
+
+struct mipi_dcphy {
+	/* Non-SNPS PHY */
+	struct rockchip_phy *phy;
+
+	u16 input_div;
+	u16 feedback_div;
+};
+
+/**
+ * struct mipi_dphy_configure - MIPI D-PHY configuration set
+ *
+ * This structure is used to represent the configuration state of a
+ * MIPI D-PHY phy.
+ */
+struct mipi_dphy_configure {
+	unsigned int		clk_miss;
+	unsigned int		clk_post;
+	unsigned int		clk_pre;
+	unsigned int		clk_prepare;
+	unsigned int		clk_settle;
+	unsigned int		clk_term_en;
+	unsigned int		clk_trail;
+	unsigned int		clk_zero;
+	unsigned int		d_term_en;
+	unsigned int		eot;
+	unsigned int		hs_exit;
+	unsigned int		hs_prepare;
+	unsigned int		hs_settle;
+	unsigned int		hs_skip;
+	unsigned int		hs_trail;
+	unsigned int		hs_zero;
+	unsigned int		init;
+	unsigned int		lpx;
+	unsigned int		ta_get;
+	unsigned int		ta_go;
+	unsigned int		ta_sure;
+	unsigned int		wakeup;
+	unsigned long		hs_clk_rate;
+	unsigned long		lp_clk_rate;
+	unsigned char		lanes;
+};
+
+struct dw_mipi_dsi2 {
+	struct rockchip_connector connector;
+	struct udevice *dev;
+	void *base;
+	void *grf;
+	int id;
+	struct dw_mipi_dsi2 *master;
+	struct dw_mipi_dsi2 *slave;
+	bool prepared;
+
+	bool auto_calc_mode;
+	bool c_option;
+	bool dsc_enable;
+	bool scrambling_en;
+	unsigned int slice_width;
+	unsigned int slice_height;
+	u32 version_major;
+	u32 version_minor;
+
+	unsigned int lane_hs_rate; /* Kbps/Ksps per lane */
+	u32 channel;
+	u32 lanes;
+	u32 format;
+	u32 mode_flags;
+	u64 mipi_pixel_rate;
+	struct mipi_dcphy dcphy;
+	struct drm_display_mode mode;
+	bool data_swap;
+
+	struct gpio_desc te_gpio;
+	struct mipi_dsi_device *device;
+	struct mipi_dphy_configure mipi_dphy_cfg;
+	const struct dw_mipi_dsi2_plat_data *pdata;
+	struct drm_dsc_picture_parameter_set *pps;
+};
+
+static inline void dsi_write(struct dw_mipi_dsi2 *dsi2, u32 reg, u32 val)
+{
+	writel(val, dsi2->base + reg);
+}
+
+static inline u32 dsi_read(struct dw_mipi_dsi2 *dsi2, u32 reg)
+{
+	return readl(dsi2->base + reg);
+}
+
+static inline void dsi_update_bits(struct dw_mipi_dsi2 *dsi2,
+				   u32 reg, u32 mask, u32 val)
+{
+	u32 orig, tmp;
+
+	orig = dsi_read(dsi2, reg);
+	tmp = orig & ~mask;
+	tmp |= val & mask;
+	dsi_write(dsi2, reg, tmp);
+}
+
+static void grf_field_write(struct dw_mipi_dsi2 *dsi2, enum grf_reg_fields index,
+			    unsigned int val)
+{
+	const u32 field = dsi2->id ? dsi2->pdata->dsi1_grf_reg_fields[index] :
+			  dsi2->pdata->dsi0_grf_reg_fields[index];
+	u16 reg;
+	u8 msb, lsb;
+
+	if (!field)
+		return;
+
+	reg = (field >> 16) & 0xffff;
+	lsb = (field >>  8) & 0xff;
+	msb = (field >>  0) & 0xff;
+
+	regmap_write(dsi2->grf, reg, GENMASK(msb, lsb) << 16 | val << lsb);
+}
+
+static unsigned long dw_mipi_dsi2_get_lane_rate(struct dw_mipi_dsi2 *dsi2)
+{
+	const struct drm_display_mode *mode = &dsi2->mode;
+	u64 max_lane_rate, lane_rate;
+	unsigned int value;
+	int bpp, lanes;
+	u64 tmp;
+
+	max_lane_rate = (dsi2->c_option) ?
+			dsi2->pdata->cphy_max_symbol_rate_per_lane :
+			dsi2->pdata->dphy_max_bit_rate_per_lane;
+
+	/*
+	 * optional override of the desired bandwidth
+	 * High-Speed mode: Differential and terminated: 80Mbps ~ 4500 Mbps
+	 */
+	value = dev_read_u32_default(dsi2->dev, "rockchip,lane-rate", 0);
+	if (value >= 80000 && value <= 4500000)
+		return value * MSEC_PER_SEC;
+	else if (value >= 80 && value <= 4500)
+		return value * USEC_PER_SEC;
+
+	bpp = mipi_dsi_pixel_format_to_bpp(dsi2->format);
+	if (bpp < 0)
+		bpp = 24;
+
+	lanes = dsi2->slave ? dsi2->lanes * 2 : dsi2->lanes;
+	tmp = (u64)mode->crtc_clock * 1000 * bpp;
+	do_div(tmp, lanes);
+
+	if (dsi2->c_option)
+		tmp = DIV_ROUND_CLOSEST(tmp * 100, 228);
+
+	/* set BW a little larger only in video burst mode in
+	 * consideration of the protocol overhead and HS mode
+	 * switching to BLLP mode, take 1 / 0.9, since Mbps must
+	 * big than bandwidth of RGB
+	 */
+	if (dsi2->mode_flags & MIPI_DSI_MODE_VIDEO_BURST) {
+		tmp *= 10;
+		do_div(tmp, 9);
+	}
+
+	if (tmp > max_lane_rate)
+		lane_rate = max_lane_rate;
+	else
+		lane_rate = tmp;
+
+	return lane_rate;
+}
+
+static int cri_fifos_wait_avail(struct dw_mipi_dsi2 *dsi2)
+{
+	u32 sts, mask;
+	int ret;
+
+	mask = CRI_BUSY | CRT_FIFOS_NOT_EMPTY;
+	ret = readl_poll_timeout(dsi2->base + DSI2_CORE_STATUS,
+				 sts, !(sts & mask),
+				 CMD_PKT_STATUS_TIMEOUT_US);
+	if (ret < 0) {
+		printf("command interface is busy: 0x%x\n", sts);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int dw_mipi_dsi2_read_from_fifo(struct dw_mipi_dsi2 *dsi2,
+				      const struct mipi_dsi_msg *msg)
+{
+	u8 *payload = msg->rx_buf;
+	u8 data_type;
+	u16 wc;
+	int i, j, ret, len = msg->rx_len;
+	unsigned int vrefresh = drm_mode_vrefresh(&dsi2->mode);
+	u32 val;
+
+	ret = readl_poll_timeout(dsi2->base + DSI2_CORE_STATUS,
+				 val, val & CRI_RD_DATA_AVAIL,
+				 DIV_ROUND_UP(1000000, vrefresh));
+	if (ret) {
+		printf("CRI has no available read data\n");
+		return ret;
+	}
+
+	val = dsi_read(dsi2, DSI2_CRI_RX_HDR);
+	data_type = val & 0x3f;
+
+	if (mipi_dsi_packet_format_is_short(data_type)) {
+		for (i = 0; i < len && i < 2; i++)
+			payload[i] = (val >> (8 * (i + 1))) & 0xff;
+
+		return 0;
+	}
+
+	wc = (val >> 8) & 0xffff;
+	/* Receive payload */
+	for (i = 0; i < len && i < wc; i += 4) {
+		val = dsi_read(dsi2, DSI2_CRI_RX_PLD);
+		for (j = 0; j < 4 && j + i < len && j + i < wc; j++)
+			payload[i + j] = val >> (8 * j);
+	}
+
+	return 0;
+}
+
+static ssize_t dw_mipi_dsi2_transfer(struct dw_mipi_dsi2 *dsi2,
+				    const struct mipi_dsi_msg *msg)
+{
+	struct mipi_dsi_packet packet;
+	int ret;
+	int val;
+	u32 mode;
+
+	dsi_update_bits(dsi2, DSI2_DSI_VID_TX_CFG, LPDT_DISPLAY_CMD_EN,
+			msg->flags & MIPI_DSI_MSG_USE_LPM ?
+			LPDT_DISPLAY_CMD_EN : 0);
+
+	/* create a packet to the DSI protocol */
+	ret = mipi_dsi_create_packet(&packet, msg);
+	if (ret) {
+		printf("failed to create packet: %d\n", ret);
+		return ret;
+	}
+
+	/* check cri interface is not busy */
+	ret = cri_fifos_wait_avail(dsi2);
+	if (ret)
+		return ret;
+
+	/* Send payload */
+	while (DIV_ROUND_UP(packet.payload_length, 4)) {
+		if (packet.payload_length < 4) {
+			/* send residu payload */
+			val = 0;
+			memcpy(&val, packet.payload, packet.payload_length);
+			dsi_write(dsi2, DSI2_CRI_TX_PLD, val);
+			packet.payload_length = 0;
+		} else {
+			val = get_unaligned_le32(packet.payload);
+			dsi_write(dsi2, DSI2_CRI_TX_PLD, val);
+			packet.payload += 4;
+			packet.payload_length -= 4;
+		}
+	}
+
+	/* Send packet header */
+	mode = CMD_TX_MODE(msg->flags & MIPI_DSI_MSG_USE_LPM ? 1 : 0);
+	val = get_unaligned_le32(packet.header);
+	dsi_write(dsi2, DSI2_CRI_TX_HDR, mode | val);
+
+	ret = cri_fifos_wait_avail(dsi2);
+	if (ret)
+		return ret;
+
+	if (msg->rx_len) {
+		ret = dw_mipi_dsi2_read_from_fifo(dsi2, msg);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (dsi2->slave) {
+		ret = dw_mipi_dsi2_transfer(dsi2->slave, msg);
+		if (ret < 0)
+			return ret;
+	}
+
+	return msg->rx_len ? msg->rx_len : msg->tx_len;
+}
+
+static void dw_mipi_dsi2_ipi_color_coding_cfg(struct dw_mipi_dsi2 *dsi2)
+{
+	u32 val, color_depth;
+
+	switch (dsi2->format) {
+	case MIPI_DSI_FMT_RGB666:
+	case MIPI_DSI_FMT_RGB666_PACKED:
+		color_depth = IPI_DEPTH_6_BITS;
+		break;
+	case MIPI_DSI_FMT_RGB565:
+		color_depth = IPI_DEPTH_5_6_5_BITS;
+		break;
+	case MIPI_DSI_FMT_RGB888:
+	default:
+		color_depth = IPI_DEPTH_8_BITS;
+		break;
+	}
+
+	val = IPI_DEPTH(color_depth) |
+	      IPI_FORMAT(dsi2->dsc_enable ? IPI_FORMAT_DSC : IPI_FORMAT_RGB);
+	dsi_write(dsi2, DSI2_IPI_COLOR_MAN_CFG, val);
+	grf_field_write(dsi2, IPI_COLOR_DEPTH, color_depth);
+
+	if (dsi2->dsc_enable)
+		grf_field_write(dsi2, IPI_FORMAT, IPI_FORMAT_DSC);
+}
+
+static void dw_mipi_dsi2_ipi_set(struct dw_mipi_dsi2 *dsi2)
+{
+	struct drm_display_mode *mode = &dsi2->mode;
+	u32 hline, hsa, hbp, hact;
+	u64 hline_time, hsa_time, hbp_time, hact_time, tmp;
+	u64 pixel_clk, phy_hs_clk;
+	u32 vact, vsa, vfp, vbp;
+	u16 val;
+
+	if (dsi2->slave || dsi2->master)
+		val = mode->hdisplay / 2;
+	else
+		val = mode->hdisplay;
+
+	dsi_write(dsi2, DSI2_IPI_PIX_PKT_CFG, MAX_PIX_PKT(val));
+
+	dw_mipi_dsi2_ipi_color_coding_cfg(dsi2);
+
+	if (dsi2->auto_calc_mode)
+		return;
+
+	/*
+	 * if the controller is intended to operate in data stream mode,
+	 * no more steps are required.
+	 */
+	if (!(dsi2->mode_flags & MIPI_DSI_MODE_VIDEO))
+		return;
+
+	vact = mode->vdisplay;
+	vsa = mode->vsync_end - mode->vsync_start;
+	vfp = mode->vsync_start - mode->vdisplay;
+	vbp = mode->vtotal - mode->vsync_end;
+	hact = mode->hdisplay;
+	hsa = mode->hsync_end - mode->hsync_start;
+	hbp = mode->htotal - mode->hsync_end;
+	hline = mode->htotal;
+
+	pixel_clk = mode->crtc_clock * MSEC_PER_SEC;
+
+	if (dsi2->c_option)
+		phy_hs_clk = DIV_ROUND_CLOSEST(dsi2->lane_hs_rate * MSEC_PER_SEC, 7);
+	else
+		phy_hs_clk = DIV_ROUND_CLOSEST(dsi2->lane_hs_rate * MSEC_PER_SEC, 16);
+
+	tmp = hsa * phy_hs_clk;
+	hsa_time = DIV_ROUND_CLOSEST(tmp << 16, pixel_clk);
+	dsi_write(dsi2, DSI2_IPI_VID_HSA_MAN_CFG, VID_HSA_TIME(hsa_time));
+
+	tmp = hbp * phy_hs_clk;
+	hbp_time = DIV_ROUND_CLOSEST(tmp << 16, pixel_clk);
+	dsi_write(dsi2, DSI2_IPI_VID_HBP_MAN_CFG, VID_HBP_TIME(hbp_time));
+
+	tmp = hact * phy_hs_clk;
+	hact_time = DIV_ROUND_CLOSEST(tmp << 16, pixel_clk);
+	dsi_write(dsi2, DSI2_IPI_VID_HACT_MAN_CFG, VID_HACT_TIME(hact_time));
+
+	tmp = hline * phy_hs_clk;
+	hline_time = DIV_ROUND_CLOSEST(tmp << 16, pixel_clk);
+	dsi_write(dsi2, DSI2_IPI_VID_HLINE_MAN_CFG, VID_HLINE_TIME(hline_time));
+
+	dsi_write(dsi2, DSI2_IPI_VID_VSA_MAN_CFG, VID_VSA_LINES(vsa));
+	dsi_write(dsi2, DSI2_IPI_VID_VBP_MAN_CFG, VID_VBP_LINES(vbp));
+	dsi_write(dsi2, DSI2_IPI_VID_VACT_MAN_CFG, VID_VACT_LINES(vact));
+	dsi_write(dsi2, DSI2_IPI_VID_VFP_MAN_CFG, VID_VFP_LINES(vfp));
+}
+
+static void dw_mipi_dsi2_set_vid_mode(struct dw_mipi_dsi2 *dsi2)
+{
+	u32 val = 0, mode;
+	int ret;
+
+	if (dsi2->mode_flags & MIPI_DSI_MODE_VIDEO_HFP)
+		val |= BLK_HFP_HS_EN;
+
+	if (dsi2->mode_flags & MIPI_DSI_MODE_VIDEO_HBP)
+		val |= BLK_HBP_HS_EN;
+
+	if (dsi2->mode_flags & MIPI_DSI_MODE_VIDEO_HSA)
+		val |= BLK_HSA_HS_EN;
+
+	if (dsi2->mode_flags & MIPI_DSI_MODE_VIDEO_BURST)
+		val |= VID_MODE_TYPE_BURST;
+	else if (dsi2->mode_flags & MIPI_DSI_MODE_VIDEO_SYNC_PULSE)
+		val |= VID_MODE_TYPE_NON_BURST_SYNC_PULSES;
+	else
+		val |= VID_MODE_TYPE_NON_BURST_SYNC_EVENTS;
+
+	dsi_write(dsi2, DSI2_DSI_VID_TX_CFG, val);
+
+	dsi_write(dsi2, DSI2_MODE_CTRL, VIDEO_MODE);
+	ret = readl_poll_timeout(dsi2->base + DSI2_MODE_STATUS,
+				 mode, mode & VIDEO_MODE,
+				 MODE_STATUS_TIMEOUT_US);
+	if (ret < 0)
+		printf("failed to enter video mode\n");
+}
+
+static void dw_mipi_dsi2_set_data_stream_mode(struct dw_mipi_dsi2 *dsi2)
+{
+	u32 mode;
+	int ret;
+
+	dsi_write(dsi2, DSI2_MODE_CTRL, DATA_STREAM_MODE);
+	ret = readl_poll_timeout(dsi2->base + DSI2_MODE_STATUS,
+				 mode, mode & DATA_STREAM_MODE,
+				 MODE_STATUS_TIMEOUT_US);
+	if (ret < 0)
+		printf("failed to enter data stream mode\n");
+}
+
+static void dw_mipi_dsi2_set_cmd_mode(struct dw_mipi_dsi2 *dsi2)
+{
+	u32 mode;
+	int ret;
+
+	dsi_write(dsi2, DSI2_MODE_CTRL, COMMAND_MODE);
+	ret = readl_poll_timeout(dsi2->base + DSI2_MODE_STATUS,
+				 mode, mode & COMMAND_MODE,
+				 MODE_STATUS_TIMEOUT_US);
+	if (ret < 0)
+		printf("failed to enter cmd mode\n");
+}
+
+static void dw_mipi_dsi2_enable(struct dw_mipi_dsi2 *dsi2)
+{
+	u32 mode;
+	int ret;
+
+	dw_mipi_dsi2_ipi_set(dsi2);
+
+	if (dsi2->auto_calc_mode) {
+		dsi_write(dsi2, DSI2_MODE_CTRL, AUTOCALC_MODE);
+		ret = readl_poll_timeout(dsi2->base + DSI2_MODE_STATUS,
+					 mode, mode == IDLE_MODE,
+					 MODE_STATUS_TIMEOUT_US);
+		if (ret < 0)
+			printf("auto calculation training failed\n");
+	}
+
+	if (dsi2->mode_flags & MIPI_DSI_MODE_VIDEO)
+		dw_mipi_dsi2_set_vid_mode(dsi2);
+	else
+		dw_mipi_dsi2_set_data_stream_mode(dsi2);
+
+	if (dsi2->slave)
+	    dw_mipi_dsi2_enable(dsi2->slave);
+}
+
+static void dw_mipi_dsi2_disable(struct dw_mipi_dsi2 *dsi2)
+{
+	dsi_write(dsi2, DSI2_IPI_PIX_PKT_CFG, 0);
+	dw_mipi_dsi2_set_cmd_mode(dsi2);
+
+	if (dsi2->slave)
+		dw_mipi_dsi2_disable(dsi2->slave);
+}
+
+static void dw_mipi_dsi2_post_disable(struct dw_mipi_dsi2 *dsi2)
+{
+	if (!dsi2->prepared)
+		return;
+
+	dsi_write(dsi2, DSI2_PWR_UP, RESET);
+
+	if (dsi2->dcphy.phy)
+		rockchip_phy_power_off(dsi2->dcphy.phy);
+
+	dsi2->prepared = false;
+
+	if (dsi2->slave)
+		dw_mipi_dsi2_post_disable(dsi2->slave);
+}
+
+static int dw_mipi_dsi2_connector_pre_init(struct rockchip_connector *conn,
+					   struct display_state *state)
+{
+	struct connector_state *conn_state = &state->conn_state;
+	struct dw_mipi_dsi2 *dsi2 = dev_get_priv(conn->dev);
+	struct mipi_dsi_host *host = dev_get_platdata(dsi2->dev);
+	struct mipi_dsi_device *device;
+	char name[20];
+
+	conn_state->type = DRM_MODE_CONNECTOR_DSI;
+
+	if (conn->bridge) {
+		device = dev_get_platdata(conn->bridge->dev);
+		if (!device)
+			return -ENODEV;
+
+		device->host = host;
+		sprintf(name, "%s.%d", host->dev->name, device->channel);
+		device_set_name(conn->bridge->dev, name);
+		mipi_dsi_attach(device);
+	}
+
+	return 0;
+}
+
+static int dw_mipi_dsi2_get_dsc_params_from_sink(struct dw_mipi_dsi2 *dsi2)
+{
+	struct udevice *dev = dsi2->device->dev;
+	struct rockchip_cmd_header *header;
+	struct drm_dsc_picture_parameter_set *pps = NULL;
+	u8 *dsc_packed_pps;
+	const void *data;
+	int len;
+
+	dsi2->c_option = dev_read_bool(dev, "phy-c-option");
+	dsi2->scrambling_en = dev_read_bool(dev, "scrambling-enable");
+	dsi2->dsc_enable = dev_read_bool(dev, "compressed-data");
+
+	if (dsi2->slave) {
+		dsi2->slave->c_option = dsi2->c_option;
+		dsi2->slave->scrambling_en = dsi2->scrambling_en;
+		dsi2->slave->dsc_enable = dsi2->dsc_enable;
+	}
+
+	if (!dsi2->dsc_enable)
+		return 0;
+
+	dsi2->slice_width = dev_read_u32_default(dev, "slice-width", 0);
+	dsi2->slice_height = dev_read_u32_default(dev, "slice-height", 0);
+	dsi2->version_major = dev_read_u32_default(dev, "version-major", 0);
+	dsi2->version_minor = dev_read_u32_default(dev, "version-minor", 0);
+
+	data = dev_read_prop(dev, "panel-init-sequence", &len);
+	if (!data)
+		return -EINVAL;
+
+	while (len > sizeof(*header)) {
+		header = (struct rockchip_cmd_header *)data;
+		data += sizeof(*header);
+		len -= sizeof(*header);
+
+		if (header->payload_length > len)
+			return -EINVAL;
+
+		if (header->data_type == MIPI_DSI_PICTURE_PARAMETER_SET) {
+			dsc_packed_pps = calloc(1, header->payload_length);
+			if (!dsc_packed_pps)
+				return -ENOMEM;
+
+			memcpy(dsc_packed_pps, data, header->payload_length);
+			pps = (struct drm_dsc_picture_parameter_set *)dsc_packed_pps;
+			break;
+		}
+
+		data += header->payload_length;
+		len -= header->payload_length;
+	}
+
+	if (!pps) {
+		printf("not found dsc pps definition\n");
+		return -EINVAL;
+	}
+
+	dsi2->pps = pps;
+
+	if (dsi2->slave) {
+		u16 pic_width = be16_to_cpu(pps->pic_width) / 2;
+
+		dsi2->pps->pic_width = cpu_to_be16(pic_width);
+		printf("dsc pic_width change from %d to %d\n", pic_width * 2, pic_width);
+	}
+
+	return 0;
+}
+
+static int dw_mipi_dsi2_connector_init(struct rockchip_connector *conn, struct display_state *state)
+{
+	struct connector_state *conn_state = &state->conn_state;
+	struct crtc_state *cstate = &state->crtc_state;
+	struct dw_mipi_dsi2 *dsi2 = dev_get_priv(conn->dev);
+	struct rockchip_phy *phy = NULL;
+	struct udevice *phy_dev;
+	struct udevice *dev;
+	int ret;
+
+	conn_state->disp_info  = rockchip_get_disp_info(conn_state->type, dsi2->id);
+	dsi2->dcphy.phy = conn->phy;
+
+	conn_state->output_mode = ROCKCHIP_OUT_MODE_P888;
+	conn_state->color_space = V4L2_COLORSPACE_DEFAULT;
+	conn_state->output_if |=
+		dsi2->id ? VOP_OUTPUT_IF_MIPI1 : VOP_OUTPUT_IF_MIPI0;
+
+	if (!(dsi2->mode_flags & MIPI_DSI_MODE_VIDEO)) {
+		conn_state->output_flags |= ROCKCHIP_OUTPUT_MIPI_DS_MODE;
+		conn_state->hold_mode = true;
+	}
+
+	if (dsi2->lanes > 4) {
+		ret = uclass_get_device_by_name(UCLASS_DISPLAY,
+						"dsi@fde30000",
+						&dev);
+		if (ret)
+			return ret;
+
+		dsi2->slave = dev_get_priv(dev);
+		if (!dsi2->slave)
+			return -ENODEV;
+
+		dsi2->slave->master = dsi2;
+		dsi2->lanes /= 2;
+
+		dsi2->slave->auto_calc_mode = dsi2->auto_calc_mode;
+		dsi2->slave->lanes = dsi2->lanes;
+		dsi2->slave->format = dsi2->format;
+		dsi2->slave->mode_flags = dsi2->mode_flags;
+		dsi2->slave->channel = dsi2->channel;
+		conn_state->output_flags |=
+				ROCKCHIP_OUTPUT_DUAL_CHANNEL_LEFT_RIGHT_MODE;
+		if (dsi2->data_swap)
+			conn_state->output_flags |= ROCKCHIP_OUTPUT_DATA_SWAP;
+
+		conn_state->output_if |= VOP_OUTPUT_IF_MIPI1;
+
+		ret = uclass_get_device_by_phandle(UCLASS_PHY, dev,
+						   "phys", &phy_dev);
+		if (ret)
+			return -ENODEV;
+
+		phy = (struct rockchip_phy *)dev_get_driver_data(phy_dev);
+		if (!phy)
+			return -ENODEV;
+
+		dsi2->slave->dcphy.phy = phy;
+		if (phy->funcs && phy->funcs->init)
+			return phy->funcs->init(phy);
+	}
+
+	dw_mipi_dsi2_get_dsc_params_from_sink(dsi2);
+
+	if (dm_gpio_is_valid(&dsi2->te_gpio)) {
+		cstate->soft_te = true;
+		conn_state->te_gpio = &dsi2->te_gpio;
+	}
+
+	if (dsi2->dsc_enable) {
+		cstate->dsc_enable = 1;
+		cstate->dsc_sink_cap.version_major = dsi2->version_major;
+		cstate->dsc_sink_cap.version_minor = dsi2->version_minor;
+		cstate->dsc_sink_cap.slice_width = dsi2->slice_width;
+		cstate->dsc_sink_cap.slice_height = dsi2->slice_height;
+		/* only can support rgb888 panel now */
+		cstate->dsc_sink_cap.target_bits_per_pixel_x16 = 8 << 4;
+		cstate->dsc_sink_cap.native_420 = 0;
+		memcpy(&cstate->pps, dsi2->pps, sizeof(struct drm_dsc_picture_parameter_set));
+	}
+
+	return 0;
+}
+
+/*
+ * Minimum D-PHY timings based on MIPI D-PHY specification. Derived
+ * from the valid ranges specified in Section 6.9, Table 14, Page 41
+ * of the D-PHY specification (v2.1).
+ */
+int mipi_dphy_get_default_config(unsigned long long hs_clk_rate,
+				 struct mipi_dphy_configure *cfg)
+{
+	unsigned long long ui;
+
+	if (!cfg)
+		return -EINVAL;
+
+	ui = ALIGN(PSEC_PER_SEC, hs_clk_rate);
+	do_div(ui, hs_clk_rate);
+
+	cfg->clk_miss = 0;
+	cfg->clk_post = 60000 + 52 * ui;
+	cfg->clk_pre = 8000;
+	cfg->clk_prepare = 38000;
+	cfg->clk_settle = 95000;
+	cfg->clk_term_en = 0;
+	cfg->clk_trail = 60000;
+	cfg->clk_zero = 262000;
+	cfg->d_term_en = 0;
+	cfg->eot = 0;
+	cfg->hs_exit = 100000;
+	cfg->hs_prepare = 40000 + 4 * ui;
+	cfg->hs_zero = 105000 + 6 * ui;
+	cfg->hs_settle = 85000 + 6 * ui;
+	cfg->hs_skip = 40000;
+
+	/*
+	 * The MIPI D-PHY specification (Section 6.9, v1.2, Table 14, Page 40)
+	 * contains this formula as:
+	 *
+	 *     T_HS-TRAIL = max(n * 8 * ui, 60 + n * 4 * ui)
+	 *
+	 * where n = 1 for forward-direction HS mode and n = 4 for reverse-
+	 * direction HS mode. There's only one setting and this function does
+	 * not parameterize on anything other that ui, so this code will
+	 * assumes that reverse-direction HS mode is supported and uses n = 4.
+	 */
+	cfg->hs_trail = max(4 * 8 * ui, 60000 + 4 * 4 * ui);
+
+	cfg->init = 100;
+	cfg->lpx = 60000;
+	cfg->ta_get = 5 * cfg->lpx;
+	cfg->ta_go = 4 * cfg->lpx;
+	cfg->ta_sure = 2 * cfg->lpx;
+	cfg->wakeup = 1000;
+
+	return 0;
+}
+
+static void dw_mipi_dsi2_set_hs_clk(struct dw_mipi_dsi2 *dsi2, unsigned long rate)
+{
+	mipi_dphy_get_default_config(rate, &dsi2->mipi_dphy_cfg);
+
+	if (!dsi2->c_option)
+		rockchip_phy_set_mode(dsi2->dcphy.phy, PHY_MODE_MIPI_DPHY);
+
+	rate = rockchip_phy_set_pll(dsi2->dcphy.phy, rate);
+	dsi2->lane_hs_rate = DIV_ROUND_CLOSEST(rate, MSEC_PER_SEC);
+}
+
+static void dw_mipi_dsi2_host_softrst(struct dw_mipi_dsi2 *dsi2)
+{
+	dsi_write(dsi2, DSI2_SOFT_RESET, 0X0);
+	udelay(100);
+	dsi_write(dsi2, DSI2_SOFT_RESET, SYS_RSTN | PHY_RSTN | IPI_RSTN);
+}
+
+static void
+dw_mipi_dsi2_work_mode(struct dw_mipi_dsi2 *dsi2, u32 mode)
+{
+	/*
+	 * select controller work in Manual mode
+	 * Manual: MANUAL_MODE_EN
+	 * Automatic: 0
+	 */
+	dsi_write(dsi2, MANUAL_MODE_CFG, mode);
+}
+
+static void dw_mipi_dsi2_phy_mode_cfg(struct dw_mipi_dsi2 *dsi2)
+{
+	u32 val = 0;
+
+	/* PPI width is fixed to 16 bits in DCPHY */
+	val |= PPI_WIDTH(PPI_WIDTH_16_BITS) | PHY_LANES(dsi2->lanes);
+	val |= PHY_TYPE(dsi2->c_option ? CPHY : DPHY);
+	dsi_write(dsi2, DSI2_PHY_MODE_CFG, val);
+}
+
+static void dw_mipi_dsi2_phy_clk_mode_cfg(struct dw_mipi_dsi2 *dsi2)
+{
+	u32 sys_clk = SYS_CLK / USEC_PER_SEC;
+	u32 esc_clk_div;
+	u32 val = 0;
+
+	if (dsi2->mode_flags & MIPI_DSI_CLOCK_NON_CONTINUOUS)
+		val |= NON_CONTINUOUS_CLK;
+
+	/* The Escape clock ranges from 1MHz to 20MHz. */
+	esc_clk_div = DIV_ROUND_UP(sys_clk, 20 * 2);
+	val |= PHY_LPTX_CLK_DIV(esc_clk_div);
+
+	dsi_write(dsi2, DSI2_PHY_CLK_CFG, val);
+}
+
+static void dw_mipi_dsi2_phy_ratio_cfg(struct dw_mipi_dsi2 *dsi2)
+{
+	u64 ipi_clk, phy_hsclk, tmp;
+
+	/*
+	 * in DPHY mode, the phy_hstx_clk is exactly 1/16 the Lane high-speed
+	 * data rate; In CPHY mode, the phy_hstx_clk is exactly 1/7 the trio
+	 * high speed symbol rate.
+	 */
+	if (dsi2->c_option)
+		phy_hsclk = DIV_ROUND_CLOSEST(dsi2->lane_hs_rate * MSEC_PER_SEC, 7);
+
+	else
+		phy_hsclk = DIV_ROUND_CLOSEST(dsi2->lane_hs_rate * MSEC_PER_SEC, 16);
+
+	/* IPI_RATIO_MAN_CFG = PHY_HSTX_CLK / IPI_CLK */
+	ipi_clk = dsi2->mipi_pixel_rate;
+
+	tmp = DIV_ROUND_CLOSEST(phy_hsclk << 16, ipi_clk);
+	dsi_write(dsi2, DSI2_PHY_IPI_RATIO_MAN_CFG, PHY_IPI_RATIO(tmp));
+
+	/* SYS_RATIO_MAN_CFG = MIPI_DCPHY_HSCLK_Freq / SYS_CLK */
+	tmp = DIV_ROUND_CLOSEST(phy_hsclk << 16, SYS_CLK);
+	dsi_write(dsi2, DSI2_PHY_SYS_RATIO_MAN_CFG, PHY_SYS_RATIO(tmp));
+}
+
+static void dw_mipi_dsi2_lp2hs_or_hs2lp_cfg(struct dw_mipi_dsi2 *dsi2)
+{
+	struct mipi_dphy_configure *cfg = &dsi2->mipi_dphy_cfg;
+	unsigned long long tmp, ui;
+	unsigned long long hstx_clk;
+
+	hstx_clk = DIV_ROUND_CLOSEST(dsi2->lane_hs_rate * MSEC_PER_SEC, 16);
+
+	ui = ALIGN(PSEC_PER_SEC, hstx_clk);
+	do_div(ui, hstx_clk);
+
+	/* PHY_LP2HS_TIME = (TLPX + THS-PREPARE + THS-ZERO) / Tphy_hstx_clk */
+	tmp = cfg->lpx + cfg->hs_prepare + cfg->hs_zero;
+	tmp = DIV_ROUND_CLOSEST(tmp << 16, ui);
+	dsi_write(dsi2, DSI2_PHY_LP2HS_MAN_CFG, PHY_LP2HS_TIME(tmp));
+
+	/* PHY_HS2LP_TIME = (THS-TRAIL + THS-EXIT) / Tphy_hstx_clk */
+	tmp = cfg->hs_trail + cfg->hs_exit;
+	tmp = DIV_ROUND_CLOSEST(tmp << 16, ui);
+	dsi_write(dsi2, DSI2_PHY_HS2LP_MAN_CFG, PHY_HS2LP_TIME(tmp));
+}
+
+static void dw_mipi_dsi2_phy_init(struct dw_mipi_dsi2 *dsi2)
+{
+	dw_mipi_dsi2_phy_mode_cfg(dsi2);
+	dw_mipi_dsi2_phy_clk_mode_cfg(dsi2);
+
+	if (dsi2->auto_calc_mode)
+		return;
+
+	dw_mipi_dsi2_phy_ratio_cfg(dsi2);
+	dw_mipi_dsi2_lp2hs_or_hs2lp_cfg(dsi2);
+
+	/* phy configuration 8 - 10 */
+}
+
+static void dw_mipi_dsi2_tx_option_set(struct dw_mipi_dsi2 *dsi2)
+{
+	u32 val;
+
+	val = BTA_EN | EOTP_TX_EN;
+
+	if (dsi2->mode_flags & MIPI_DSI_MODE_EOT_PACKET)
+		val &= ~EOTP_TX_EN;
+
+	dsi_write(dsi2, DSI2_DSI_GENERAL_CFG, val);
+	dsi_write(dsi2, DSI2_DSI_VCID_CFG, TX_VCID(dsi2->channel));
+
+	if (dsi2->scrambling_en)
+		dsi_write(dsi2, DSI2_DSI_SCRAMBLING_CFG, SCRAMBLING_EN);
+}
+
+static void dw_mipi_dsi2_irq_enable(struct dw_mipi_dsi2 *dsi2, bool enable)
+{
+	if (enable) {
+		dsi_write(dsi2, DSI2_INT_MASK_PHY, 0x1);
+		dsi_write(dsi2, DSI2_INT_MASK_TO, 0xf);
+		dsi_write(dsi2, DSI2_INT_MASK_ACK, 0x1);
+		dsi_write(dsi2, DSI2_INT_MASK_IPI, 0x1);
+		dsi_write(dsi2, DSI2_INT_MASK_FIFO, 0x1);
+		dsi_write(dsi2, DSI2_INT_MASK_PRI, 0x1);
+		dsi_write(dsi2, DSI2_INT_MASK_CRI, 0x1);
+	} else {
+		dsi_write(dsi2, DSI2_INT_MASK_PHY, 0x0);
+		dsi_write(dsi2, DSI2_INT_MASK_TO, 0x0);
+		dsi_write(dsi2, DSI2_INT_MASK_ACK, 0x0);
+		dsi_write(dsi2, DSI2_INT_MASK_IPI, 0x0);
+		dsi_write(dsi2, DSI2_INT_MASK_FIFO, 0x0);
+		dsi_write(dsi2, DSI2_INT_MASK_PRI, 0x0);
+		dsi_write(dsi2, DSI2_INT_MASK_CRI, 0x0);
+	};
+}
+
+static void mipi_dcphy_power_on(struct dw_mipi_dsi2 *dsi2)
+{
+	if (!dsi2->dcphy.phy)
+		return;
+
+	rockchip_phy_power_on(dsi2->dcphy.phy);
+}
+
+static void dw_mipi_dsi2_pre_enable(struct dw_mipi_dsi2 *dsi2)
+{
+	if (dsi2->prepared)
+		return;
+
+	dw_mipi_dsi2_host_softrst(dsi2);
+	dsi_write(dsi2, DSI2_PWR_UP, RESET);
+
+	dw_mipi_dsi2_work_mode(dsi2, dsi2->auto_calc_mode ? 0 : MANUAL_MODE_EN);
+	dw_mipi_dsi2_phy_init(dsi2);
+	dw_mipi_dsi2_tx_option_set(dsi2);
+	dw_mipi_dsi2_irq_enable(dsi2, 0);
+	mipi_dcphy_power_on(dsi2);
+	dsi_write(dsi2, DSI2_PWR_UP, POWER_UP);
+	dw_mipi_dsi2_set_cmd_mode(dsi2);
+
+	dsi2->prepared = true;
+
+	if (dsi2->slave)
+		dw_mipi_dsi2_pre_enable(dsi2->slave);
+}
+
+static void dw_mipi_dsi2_get_mipi_pixel_clk(struct dw_mipi_dsi2 *dsi2,
+					    struct crtc_state *s)
+{
+	struct drm_display_mode *mode = &dsi2->mode;
+	u8 k = dsi2->slave ? 2 : 1;
+
+	/* 1.When MIPI works in uncompressed mode:
+	 * (Video Timing Pixel Rate)/(4)=(MIPI Pixel ClockxK)=(dclk_out×K)=dclk_core
+	 * 2.When MIPI works in compressed mode:
+	 * MIPI Pixel Clock = cds_clk / 2
+	 * MIPI is configured as double channel display mode, K=2, otherwise K=1.
+	 */
+	if (dsi2->dsc_enable) {
+		dsi2->mipi_pixel_rate = s->dsc_cds_clk_rate / 2;
+		if (dsi2->slave)
+			dsi2->slave->mipi_pixel_rate = dsi2->mipi_pixel_rate;
+
+		return;
+	}
+
+	dsi2->mipi_pixel_rate = (mode->crtc_clock * MSEC_PER_SEC) / (4 * k);
+	if (dsi2->slave)
+		dsi2->slave->mipi_pixel_rate = dsi2->mipi_pixel_rate;
+}
+
+static int dw_mipi_dsi2_connector_prepare(struct rockchip_connector *conn,
+					  struct display_state *state)
+{
+	struct dw_mipi_dsi2 *dsi2 = dev_get_priv(conn->dev);
+	struct connector_state *conn_state = &state->conn_state;
+	struct crtc_state *cstate = &state->crtc_state;
+	unsigned long lane_rate;
+
+	memcpy(&dsi2->mode, &conn_state->mode, sizeof(struct drm_display_mode));
+	if (dsi2->slave)
+		memcpy(&dsi2->slave->mode, &dsi2->mode,
+		       sizeof(struct drm_display_mode));
+
+	dw_mipi_dsi2_get_mipi_pixel_clk(dsi2, cstate);
+
+	lane_rate = dw_mipi_dsi2_get_lane_rate(dsi2);
+	if (dsi2->dcphy.phy)
+		dw_mipi_dsi2_set_hs_clk(dsi2, lane_rate);
+
+	if (dsi2->slave && dsi2->slave->dcphy.phy)
+		dw_mipi_dsi2_set_hs_clk(dsi2->slave, lane_rate);
+
+	printf("final DSI-Link bandwidth: %u %s x %d\n",
+	       dsi2->lane_hs_rate, dsi2->c_option ? "Ksps" : "Kbps",
+	       dsi2->slave ? dsi2->lanes * 2 : dsi2->lanes);
+
+	dw_mipi_dsi2_pre_enable(dsi2);
+
+	return 0;
+}
+
+static void dw_mipi_dsi2_connector_unprepare(struct rockchip_connector *conn,
+					     struct display_state *state)
+{
+	struct dw_mipi_dsi2 *dsi2 = dev_get_priv(conn->dev);
+
+	dw_mipi_dsi2_post_disable(dsi2);
+}
+
+static int dw_mipi_dsi2_connector_enable(struct rockchip_connector *conn,
+					 struct display_state *state)
+{
+	struct dw_mipi_dsi2 *dsi2 = dev_get_priv(conn->dev);
+
+	dw_mipi_dsi2_enable(dsi2);
+
+	return 0;
+}
+
+static int dw_mipi_dsi2_connector_disable(struct rockchip_connector *conn,
+					  struct display_state *state)
+{
+	struct dw_mipi_dsi2 *dsi2 = dev_get_priv(conn->dev);
+
+	dw_mipi_dsi2_disable(dsi2);
+
+	return 0;
+}
+
+static int dw_mipi_dsi2_connector_mode_valid(struct rockchip_connector *conn,
+					     struct display_state *state)
+{
+	struct dw_mipi_dsi2 *dsi2 = dev_get_priv(conn->dev);
+	struct connector_state *conn_state = &state->conn_state;
+	u8 min_pixels = dsi2->slave ? 8 : 4;
+	struct videomode vm;
+
+	drm_display_mode_to_videomode(&conn_state->mode, &vm);
+
+	/*
+	 * the minimum region size (HSA,HBP,HACT,HFP) is 4 pixels
+	 * which is the ip known issues and limitations.
+	 */
+	if (!(vm.hsync_len < min_pixels || vm.hback_porch < min_pixels ||
+	    vm.hfront_porch < min_pixels || vm.hactive < min_pixels))
+		return MODE_OK;
+
+	if (vm.hsync_len < min_pixels)
+		vm.hsync_len = min_pixels;
+
+	if (vm.hback_porch < min_pixels)
+		vm.hback_porch = min_pixels;
+
+	if (vm.hfront_porch < min_pixels)
+		vm.hfront_porch = min_pixels;
+
+	if (vm.hactive < min_pixels)
+		vm.hactive = min_pixels;
+
+	memset(&conn_state->mode, 0, sizeof(struct drm_display_mode));
+	drm_display_mode_from_videomode(&vm, &conn_state->mode);
+	conn_state->mode.vrefresh = drm_mode_vrefresh(&conn_state->mode);
+
+	return MODE_OK;
+}
+
+static const struct rockchip_connector_funcs dw_mipi_dsi2_connector_funcs = {
+	.pre_init = dw_mipi_dsi2_connector_pre_init,
+	.init = dw_mipi_dsi2_connector_init,
+	.prepare = dw_mipi_dsi2_connector_prepare,
+	.unprepare = dw_mipi_dsi2_connector_unprepare,
+	.enable = dw_mipi_dsi2_connector_enable,
+	.disable = dw_mipi_dsi2_connector_disable,
+	.mode_valid = dw_mipi_dsi2_connector_mode_valid,
+};
+
+static int dw_mipi_dsi2_probe(struct udevice *dev)
+{
+	struct dw_mipi_dsi2 *dsi2 = dev_get_priv(dev);
+	const struct dw_mipi_dsi2_plat_data *pdata =
+		(const struct dw_mipi_dsi2_plat_data *)dev_get_driver_data(dev);
+	struct udevice *syscon;
+	int id, ret;
+
+	dsi2->base = dev_read_addr_ptr(dev);
+
+	ret = uclass_get_device_by_phandle(UCLASS_SYSCON, dev, "rockchip,grf",
+					   &syscon);
+	if (!ret) {
+		dsi2->grf = syscon_get_regmap(syscon);
+		if (!dsi2->grf)
+			return -ENODEV;
+	}
+
+	id = of_alias_get_id(ofnode_to_np(dev->node), "dsi");
+	if (id < 0)
+		id = 0;
+
+	ret = gpio_request_by_name(dev, "te-gpios", 0,
+				   &dsi2->te_gpio, GPIOD_IS_IN);
+	if (ret && ret != -ENOENT) {
+		printf("%s: Cannot get TE GPIO: %d\n", __func__, ret);
+		return ret;
+	}
+
+	dsi2->dev = dev;
+	dsi2->pdata = pdata;
+	dsi2->id = id;
+	dsi2->data_swap = dev_read_bool(dsi2->dev, "rockchip,data-swap");
+	dsi2->auto_calc_mode = dev_read_bool(dsi2->dev, "auto-calculation-mode");
+
+	rockchip_connector_bind(&dsi2->connector, dev, id, &dw_mipi_dsi2_connector_funcs, NULL,
+				DRM_MODE_CONNECTOR_DSI);
+
+	return 0;
+}
+
+static const u32 rk3588_dsi0_grf_reg_fields[MAX_FIELDS] = {
+	[TXREQCLKHS_EN]		= GRF_REG_FIELD(0x0000, 11, 11),
+	[GATING_EN]		= GRF_REG_FIELD(0x0000, 10, 10),
+	[IPI_SHUTDN]		= GRF_REG_FIELD(0x0000,  9,  9),
+	[IPI_COLORM]		= GRF_REG_FIELD(0x0000,  8,  8),
+	[IPI_COLOR_DEPTH]	= GRF_REG_FIELD(0x0000,  4,  7),
+	[IPI_FORMAT]		= GRF_REG_FIELD(0x0000,  0,  3),
+};
+
+static const u32 rk3588_dsi1_grf_reg_fields[MAX_FIELDS] = {
+	[TXREQCLKHS_EN]		= GRF_REG_FIELD(0x0004, 11, 11),
+	[GATING_EN]		= GRF_REG_FIELD(0x0004, 10, 10),
+	[IPI_SHUTDN]		= GRF_REG_FIELD(0x0004,  9,  9),
+	[IPI_COLORM]		= GRF_REG_FIELD(0x0004,  8,  8),
+	[IPI_COLOR_DEPTH]	= GRF_REG_FIELD(0x0004,  4,  7),
+	[IPI_FORMAT]		= GRF_REG_FIELD(0x0004,  0,  3),
+};
+
+static const struct dw_mipi_dsi2_plat_data rk3588_mipi_dsi2_plat_data = {
+	.dsi0_grf_reg_fields = rk3588_dsi0_grf_reg_fields,
+	.dsi1_grf_reg_fields = rk3588_dsi1_grf_reg_fields,
+	.dphy_max_bit_rate_per_lane = 4500000000ULL,
+	.cphy_max_symbol_rate_per_lane = 2000000000ULL,
+};
+
+static const struct udevice_id dw_mipi_dsi2_ids[] = {
+	{
+		.compatible = "rockchip,rk3588-mipi-dsi2",
+		.data = (ulong)&rk3588_mipi_dsi2_plat_data,
+	},
+	{}
+};
+
+static ssize_t dw_mipi_dsi2_host_transfer(struct mipi_dsi_host *host,
+					 const struct mipi_dsi_msg *msg)
+{
+	struct dw_mipi_dsi2 *dsi2 = dev_get_priv(host->dev);
+
+	return dw_mipi_dsi2_transfer(dsi2, msg);
+}
+
+static int dw_mipi_dsi2_host_attach(struct mipi_dsi_host *host,
+				   struct mipi_dsi_device *device)
+{
+	struct dw_mipi_dsi2 *dsi2 = dev_get_priv(host->dev);
+
+	if (device->lanes < 1 || device->lanes > 8)
+		return -EINVAL;
+
+	dsi2->lanes = device->lanes;
+	dsi2->channel = device->channel;
+	dsi2->format = device->format;
+	dsi2->mode_flags = device->mode_flags;
+	dsi2->device = device;
+
+	return 0;
+}
+
+static const struct mipi_dsi_host_ops dw_mipi_dsi2_host_ops = {
+	.attach = dw_mipi_dsi2_host_attach,
+	.transfer = dw_mipi_dsi2_host_transfer,
+};
+
+static int dw_mipi_dsi2_bind(struct udevice *dev)
+{
+	struct mipi_dsi_host *host = dev_get_platdata(dev);
+
+	host->dev = dev;
+	host->ops = &dw_mipi_dsi2_host_ops;
+
+	return dm_scan_fdt_dev(dev);
+}
+
+static int dw_mipi_dsi2_child_post_bind(struct udevice *dev)
+{
+	struct mipi_dsi_host *host = dev_get_platdata(dev->parent);
+	struct mipi_dsi_device *device = dev_get_parent_platdata(dev);
+	char name[20];
+
+	sprintf(name, "%s.%d", host->dev->name, device->channel);
+	device_set_name(dev, name);
+
+	device->dev = dev;
+	device->host = host;
+	device->lanes = dev_read_u32_default(dev, "dsi,lanes", 4);
+	device->format = dev_read_u32_default(dev, "dsi,format",
+					      MIPI_DSI_FMT_RGB888);
+	device->mode_flags = dev_read_u32_default(dev, "dsi,flags",
+						  MIPI_DSI_MODE_VIDEO |
+						  MIPI_DSI_MODE_VIDEO_BURST |
+						  MIPI_DSI_MODE_VIDEO_HBP |
+						  MIPI_DSI_MODE_LPM |
+						  MIPI_DSI_MODE_EOT_PACKET);
+	device->channel = dev_read_u32_default(dev, "reg", 0);
+
+	return 0;
+}
+
+static int dw_mipi_dsi2_child_pre_probe(struct udevice *dev)
+{
+	struct mipi_dsi_device *device = dev_get_parent_platdata(dev);
+	int ret;
+
+	ret = mipi_dsi_attach(device);
+	if (ret) {
+		dev_err(dev, "mipi_dsi_attach() failed: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+U_BOOT_DRIVER(dw_mipi_dsi2) = {
+	.name = "dw_mipi_dsi2",
+	.id = UCLASS_DISPLAY,
+	.of_match = dw_mipi_dsi2_ids,
+	.probe = dw_mipi_dsi2_probe,
+	.bind = dw_mipi_dsi2_bind,
+	.priv_auto_alloc_size = sizeof(struct dw_mipi_dsi2),
+	.per_child_platdata_auto_alloc_size = sizeof(struct mipi_dsi_device),
+	.platdata_auto_alloc_size = sizeof(struct mipi_dsi_host),
+	.child_post_bind = dw_mipi_dsi2_child_post_bind,
+	.child_pre_probe = dw_mipi_dsi2_child_pre_probe,
+};
diff --git a/drivers/video/drm/inno_hdmi.c b/drivers/video/drm/inno_hdmi.c
new file mode 100644
index 0000000000..8ae9717ed9
--- /dev/null
+++ b/drivers/video/drm/inno_hdmi.c
@@ -0,0 +1,849 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * (C) Copyright 2020 Rockchip Electronics Co., Ltd
+ */
+#include <common.h>
+#include <clk.h>
+#include <syscon.h>
+#include <asm/io.h>
+#include <asm/arch-rockchip/clock.h>
+#include <dm/of_access.h>
+#include <dm/device.h>
+#include <dm/read.h>
+#include <linux/hdmi.h>
+#include <linux/media-bus-format.h>
+
+#include "inno_hdmi.h"
+#include "rockchip_connector.h"
+#include "rockchip_crtc.h"
+#include "rockchip_display.h"
+
+struct inno_hdmi_i2c {
+	u8			slave_reg;
+	u8			ddc_addr;
+	u8			segment_addr;
+	bool			is_regaddr;
+	bool			is_segment;
+
+	unsigned int		scl_high_ns;
+	unsigned int		scl_low_ns;
+};
+
+enum inno_hdmi_dev_type {
+	RK3036_HDMI,
+	RK3128_HDMI,
+};
+
+enum {
+	CSC_ITU601_16_235_TO_RGB_0_255_8BIT,
+	CSC_ITU601_0_255_TO_RGB_0_255_8BIT,
+	CSC_ITU709_16_235_TO_RGB_0_255_8BIT,
+	CSC_RGB_0_255_TO_ITU601_16_235_8BIT,
+	CSC_RGB_0_255_TO_ITU709_16_235_8BIT,
+	CSC_RGB_0_255_TO_RGB_16_235_8BIT,
+};
+
+static const char coeff_csc[][24] = {
+	/*
+	 * YUV2RGB:601 SD mode(Y[16:235], UV[16:240], RGB[0:255]):
+	 *   R = 1.164*Y + 1.596*V - 204
+	 *   G = 1.164*Y - 0.391*U - 0.813*V + 154
+	 *   B = 1.164*Y + 2.018*U - 258
+	 */
+	{
+		0x04, 0xa7, 0x00, 0x00, 0x06, 0x62, 0x02, 0xcc,
+		0x04, 0xa7, 0x11, 0x90, 0x13, 0x40, 0x00, 0x9a,
+		0x04, 0xa7, 0x08, 0x12, 0x00, 0x00, 0x03, 0x02
+	},
+	/*
+	 * YUV2RGB:601 SD mode(YUV[0:255],RGB[0:255]):
+	 *   R = Y + 1.402*V - 248
+	 *   G = Y - 0.344*U - 0.714*V + 135
+	 *   B = Y + 1.772*U - 227
+	 */
+	{
+		0x04, 0x00, 0x00, 0x00, 0x05, 0x9b, 0x02, 0xf8,
+		0x04, 0x00, 0x11, 0x60, 0x12, 0xdb, 0x00, 0x87,
+		0x04, 0x00, 0x07, 0x16, 0x00, 0x00, 0x02, 0xe3
+	},
+	/*
+	 * YUV2RGB:709 HD mode(Y[16:235],UV[16:240],RGB[0:255]):
+	 *   R = 1.164*Y + 1.793*V - 248
+	 *   G = 1.164*Y - 0.213*U - 0.534*V + 77
+	 *   B = 1.164*Y + 2.115*U - 289
+	 */
+	{
+		0x04, 0xa7, 0x00, 0x00, 0x07, 0x2c, 0x02, 0xf8,
+		0x04, 0xa7, 0x10, 0xda, 0x12, 0x22, 0x00, 0x4d,
+		0x04, 0xa7, 0x08, 0x74, 0x00, 0x00, 0x03, 0x21
+	},
+
+	/*
+	 * RGB2YUV:601 SD mode:
+	 *   Cb = -0.291G - 0.148R + 0.439B + 128
+	 *   Y  = 0.504G  + 0.257R + 0.098B + 16
+	 *   Cr = -0.368G + 0.439R - 0.071B + 128
+	 */
+	{
+		0x11, 0x5f, 0x01, 0x82, 0x10, 0x23, 0x00, 0x80,
+		0x02, 0x1c, 0x00, 0xa1, 0x00, 0x36, 0x00, 0x1e,
+		0x11, 0x29, 0x10, 0x59, 0x01, 0x82, 0x00, 0x80
+	},
+	/*
+	 * RGB2YUV:709 HD mode:
+	 *   Cb = - 0.338G - 0.101R + 0.439B + 128
+	 *   Y  = 0.614G   + 0.183R + 0.062B + 16
+	 *   Cr = - 0.399G + 0.439R - 0.040B + 128
+	 */
+	{
+		0x11, 0x98, 0x01, 0xc1, 0x10, 0x28, 0x00, 0x80,
+		0x02, 0x74, 0x00, 0xbb, 0x00, 0x3f, 0x00, 0x10,
+		0x11, 0x5a, 0x10, 0x67, 0x01, 0xc1, 0x00, 0x80
+	},
+	/*
+	 * RGB[0:255]2RGB[16:235]:
+	 *   R' = R x (235-16)/255 + 16;
+	 *   G' = G x (235-16)/255 + 16;
+	 *   B' = B x (235-16)/255 + 16;
+	 */
+	{
+		0x00, 0x00, 0x03, 0x6F, 0x00, 0x00, 0x00, 0x10,
+		0x03, 0x6F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,
+		0x00, 0x00, 0x00, 0x00, 0x03, 0x6F, 0x00, 0x10
+	},
+};
+
+struct hdmi_data_info {
+	int vic;
+	bool sink_is_hdmi;
+	bool sink_has_audio;
+	unsigned int enc_in_format;
+	unsigned int enc_out_format;
+	unsigned int colorimetry;
+};
+
+struct inno_hdmi_phy_config {
+	unsigned long mpixelclock;
+	u8 pre_emphasis;	/* pre-emphasis value */
+	u8 vlev_ctr;		/* voltage level control */
+};
+
+struct inno_hdmi_plat_data {
+	enum inno_hdmi_dev_type dev_type;
+	struct inno_hdmi_phy_config *phy_config;
+};
+
+struct inno_hdmi {
+	struct device *dev;
+	struct drm_device *drm_dev;
+	struct ddc_adapter adap;
+	struct hdmi_edid_data edid_data;
+	struct hdmi_data_info	hdmi_data;
+
+	struct clk pclk;
+	int vic;
+	void *regs;
+	void *grf;
+
+	struct inno_hdmi_i2c *i2c;
+
+	unsigned int tmds_rate;
+	const struct inno_hdmi_plat_data *plat_data;
+
+	unsigned int sample_rate;
+	unsigned int audio_cts;
+	unsigned int audio_n;
+	bool audio_enable;
+
+	struct drm_display_mode previous_mode;
+};
+
+static struct inno_hdmi_phy_config rk3036_hdmi_phy_config[] = {
+	/* pixelclk pre-emp vlev */
+	{ 74250000,  0x3f, 0xbb },
+	{ 165000000, 0x6f, 0xbb },
+	{ ~0UL,	     0x00, 0x00 }
+};
+
+static struct inno_hdmi_phy_config rk3128_hdmi_phy_config[] = {
+	/* pixelclk pre-emp vlev */
+	{ 74250000,  0x3f, 0xaa },
+	{ 165000000, 0x5f, 0xaa },
+	{ ~0UL,	     0x00, 0x00 }
+};
+
+static void hdmi_writeb(struct inno_hdmi *hdmi, u16 offset, u32 val)
+{
+	writel(val, hdmi->regs + (offset << 2));
+}
+
+static u32 hdmi_readb(struct inno_hdmi *hdmi, u16 offset)
+{
+	return readl(hdmi->regs + (offset << 2));
+}
+
+static void hdmi_modb(struct inno_hdmi *hdmi, u16 offset, u32 msk, u32 val)
+{
+	u32 temp = hdmi_readb(hdmi, offset) & ~msk;
+
+	temp |= val & msk;
+	hdmi_writeb(hdmi, offset, temp);
+}
+
+static void inno_hdmi_sys_power(struct inno_hdmi *hdmi, bool enable)
+{
+	if (enable)
+		hdmi_modb(hdmi, HDMI_SYS_CTRL, m_POWER, v_PWR_ON);
+	else
+		hdmi_modb(hdmi, HDMI_SYS_CTRL, m_POWER, v_PWR_OFF);
+}
+
+static void inno_hdmi_set_pwr_mode(struct inno_hdmi *hdmi, int mode)
+{
+	const struct inno_hdmi_phy_config *phy_config =
+						hdmi->plat_data->phy_config;
+
+	switch (mode) {
+	case NORMAL:
+		inno_hdmi_sys_power(hdmi, false);
+		for (; phy_config->mpixelclock != ~0UL; phy_config++)
+			if (hdmi->tmds_rate <= phy_config->mpixelclock)
+				break;
+		if (!phy_config->mpixelclock)
+			return;
+		hdmi_writeb(hdmi, HDMI_PHY_PRE_EMPHASIS,
+			    phy_config->pre_emphasis);
+		hdmi_writeb(hdmi, HDMI_PHY_DRIVER, phy_config->vlev_ctr);
+
+		hdmi_writeb(hdmi, HDMI_PHY_SYS_CTL, 0x15);
+		hdmi_writeb(hdmi, HDMI_PHY_SYS_CTL, 0x14);
+		hdmi_writeb(hdmi, HDMI_PHY_SYS_CTL, 0x10);
+
+		hdmi_writeb(hdmi, HDMI_PHY_CHG_PWR, 0x0f);
+		hdmi_writeb(hdmi, HDMI_PHY_SYNC, 0x00);
+		hdmi_writeb(hdmi, HDMI_PHY_SYNC, 0x01);
+		inno_hdmi_sys_power(hdmi, true);
+
+		break;
+
+	case LOWER_PWR:
+		inno_hdmi_sys_power(hdmi, false);
+		hdmi_writeb(hdmi, HDMI_PHY_DRIVER, 0x00);
+		hdmi_writeb(hdmi, HDMI_PHY_PRE_EMPHASIS, 0x00);
+		hdmi_writeb(hdmi, HDMI_PHY_CHG_PWR, 0x00);
+		hdmi_writeb(hdmi, HDMI_PHY_SYS_CTL, 0x15);
+
+		break;
+
+	default:
+		dev_err(hdmi->dev, "Unknown power mode %d\n", mode);
+	}
+}
+
+static void inno_hdmi_i2c_init(struct inno_hdmi *hdmi)
+{
+	int ddc_bus_freq;
+
+	ddc_bus_freq = (hdmi->tmds_rate >> 2) / HDMI_SCL_RATE;
+	hdmi_writeb(hdmi, DDC_BUS_FREQ_L, ddc_bus_freq & 0xFF);
+	hdmi_writeb(hdmi, DDC_BUS_FREQ_H, (ddc_bus_freq >> 8) & 0xFF);
+
+	/* Clear the EDID interrupt flag and mute the interrupt */
+	hdmi_writeb(hdmi, HDMI_INTERRUPT_MASK1, 0);
+	hdmi_writeb(hdmi, HDMI_INTERRUPT_STATUS1, m_INT_EDID_READY);
+}
+
+static void inno_hdmi_reset(struct inno_hdmi *hdmi)
+{
+	u32 val;
+	u32 msk;
+
+	hdmi_modb(hdmi, HDMI_SYS_CTRL, m_RST_DIGITAL, v_NOT_RST_DIGITAL);
+	udelay(100);
+
+	hdmi_modb(hdmi, HDMI_SYS_CTRL, m_RST_ANALOG, v_NOT_RST_ANALOG);
+	udelay(100);
+
+	msk = m_REG_CLK_INV | m_REG_CLK_SOURCE | m_POWER | m_INT_POL;
+	val = v_REG_CLK_INV | v_REG_CLK_SOURCE_SYS | v_PWR_ON | v_INT_POL_HIGH;
+
+	hdmi_modb(hdmi, HDMI_SYS_CTRL, msk, val);
+
+	inno_hdmi_set_pwr_mode(hdmi, NORMAL);
+}
+
+static int inno_hdmi_upload_frame(struct inno_hdmi *hdmi, int setup_rc,
+				  union hdmi_infoframe *frame, u32 frame_index,
+				  u32 mask, u32 disable, u32 enable)
+{
+	if (mask)
+		hdmi_modb(hdmi, HDMI_PACKET_SEND_AUTO, mask, disable);
+
+	hdmi_writeb(hdmi, HDMI_CONTROL_PACKET_BUF_INDEX, frame_index);
+
+	if (setup_rc >= 0) {
+		u8 packed_frame[HDMI_MAXIMUM_INFO_FRAME_SIZE];
+		ssize_t rc, i;
+
+		rc = hdmi_infoframe_pack(frame, packed_frame,
+					 sizeof(packed_frame));
+		if (rc < 0)
+			return rc;
+
+		for (i = 0; i < rc; i++)
+			hdmi_writeb(hdmi, HDMI_CONTROL_PACKET_ADDR + i,
+				    packed_frame[i]);
+
+		if (mask)
+			hdmi_modb(hdmi, HDMI_PACKET_SEND_AUTO, mask, enable);
+	}
+
+	return setup_rc;
+}
+
+static int inno_hdmi_config_video_vsi(struct inno_hdmi *hdmi,
+				      struct drm_display_mode *mode)
+{
+	union hdmi_infoframe frame;
+	int rc;
+
+	rc = drm_hdmi_vendor_infoframe_from_display_mode(&frame.vendor.hdmi,
+							 mode);
+
+	return inno_hdmi_upload_frame(hdmi, rc, &frame, INFOFRAME_VSI,
+		m_PACKET_VSI_EN, v_PACKET_VSI_EN(0), v_PACKET_VSI_EN(1));
+}
+
+static int inno_hdmi_config_video_avi(struct inno_hdmi *hdmi,
+				      struct drm_display_mode *mode)
+{
+	union hdmi_infoframe frame;
+	int rc;
+
+	rc = drm_hdmi_avi_infoframe_from_display_mode(&frame.avi, mode, false);
+
+	if (hdmi->hdmi_data.enc_out_format == HDMI_COLORSPACE_YUV444)
+		frame.avi.colorspace = HDMI_COLORSPACE_YUV444;
+	else if (hdmi->hdmi_data.enc_out_format == HDMI_COLORSPACE_YUV422)
+		frame.avi.colorspace = HDMI_COLORSPACE_YUV422;
+	else
+		frame.avi.colorspace = HDMI_COLORSPACE_RGB;
+
+	if (frame.avi.colorspace != HDMI_COLORSPACE_RGB)
+		frame.avi.colorimetry = hdmi->hdmi_data.colorimetry;
+
+	frame.avi.scan_mode = HDMI_SCAN_MODE_NONE;
+
+	return inno_hdmi_upload_frame(hdmi, rc, &frame, INFOFRAME_AVI, 0, 0, 0);
+}
+
+static int inno_hdmi_config_video_csc(struct inno_hdmi *hdmi)
+{
+	struct hdmi_data_info *data = &hdmi->hdmi_data;
+	int c0_c2_change = 0;
+	int csc_enable = 0;
+	int csc_mode = 0;
+	int auto_csc = 0;
+	int value;
+	int i;
+
+	/* Input video mode is SDR RGB24bit, data enable signal from external */
+	hdmi_writeb(hdmi, HDMI_VIDEO_CONTRL1, v_DE_EXTERNAL |
+		    v_VIDEO_INPUT_FORMAT(VIDEO_INPUT_SDR_RGB444));
+
+	/* Input color hardcode to RGB, and output color hardcode to RGB888 */
+	value = v_VIDEO_INPUT_BITS(VIDEO_INPUT_8BITS) |
+		v_VIDEO_OUTPUT_COLOR(0) |
+		v_VIDEO_INPUT_CSP(0);
+	hdmi_writeb(hdmi, HDMI_VIDEO_CONTRL2, value);
+
+	if (data->enc_in_format == data->enc_out_format) {
+		if (data->enc_in_format == HDMI_COLORSPACE_RGB ||
+		    data->enc_in_format >= HDMI_COLORSPACE_YUV444) {
+			value = v_SOF_DISABLE | v_COLOR_DEPTH_NOT_INDICATED(1);
+			hdmi_writeb(hdmi, HDMI_VIDEO_CONTRL3, value);
+
+			hdmi_modb(hdmi, HDMI_VIDEO_CONTRL,
+				  m_VIDEO_AUTO_CSC | m_VIDEO_C0_C2_SWAP,
+				  v_VIDEO_AUTO_CSC(AUTO_CSC_DISABLE) |
+				  v_VIDEO_C0_C2_SWAP(C0_C2_CHANGE_DISABLE));
+			return 0;
+		}
+	}
+
+	if (data->colorimetry == HDMI_COLORIMETRY_ITU_601) {
+		if (data->enc_in_format == HDMI_COLORSPACE_RGB &&
+		    data->enc_out_format == HDMI_COLORSPACE_YUV444) {
+			csc_mode = CSC_RGB_0_255_TO_ITU601_16_235_8BIT;
+			auto_csc = AUTO_CSC_DISABLE;
+			c0_c2_change = C0_C2_CHANGE_DISABLE;
+			csc_enable = v_CSC_ENABLE;
+		} else if ((data->enc_in_format == HDMI_COLORSPACE_YUV444) &&
+			   (data->enc_out_format == HDMI_COLORSPACE_RGB)) {
+			csc_mode = CSC_ITU601_16_235_TO_RGB_0_255_8BIT;
+			auto_csc = AUTO_CSC_ENABLE;
+			c0_c2_change = C0_C2_CHANGE_DISABLE;
+			csc_enable = v_CSC_DISABLE;
+		}
+	} else {
+		if (data->enc_in_format == HDMI_COLORSPACE_RGB &&
+		    data->enc_out_format == HDMI_COLORSPACE_YUV444) {
+			csc_mode = CSC_RGB_0_255_TO_ITU709_16_235_8BIT;
+			auto_csc = AUTO_CSC_DISABLE;
+			c0_c2_change = C0_C2_CHANGE_DISABLE;
+			csc_enable = v_CSC_ENABLE;
+		} else if ((data->enc_in_format == HDMI_COLORSPACE_YUV444) &&
+			   (data->enc_out_format == HDMI_COLORSPACE_RGB)) {
+			csc_mode = CSC_ITU709_16_235_TO_RGB_0_255_8BIT;
+			auto_csc = AUTO_CSC_ENABLE;
+			c0_c2_change = C0_C2_CHANGE_DISABLE;
+			csc_enable = v_CSC_DISABLE;
+		}
+	}
+
+	for (i = 0; i < 24; i++)
+		hdmi_writeb(hdmi, HDMI_VIDEO_CSC_COEF + i,
+			    coeff_csc[csc_mode][i]);
+
+	value = v_SOF_DISABLE | csc_enable | v_COLOR_DEPTH_NOT_INDICATED(1);
+	hdmi_writeb(hdmi, HDMI_VIDEO_CONTRL3, value);
+	hdmi_modb(hdmi, HDMI_VIDEO_CONTRL, m_VIDEO_AUTO_CSC |
+		  m_VIDEO_C0_C2_SWAP, v_VIDEO_AUTO_CSC(auto_csc) |
+		  v_VIDEO_C0_C2_SWAP(c0_c2_change));
+
+	return 0;
+}
+
+static int inno_hdmi_config_video_timing(struct inno_hdmi *hdmi,
+					 struct drm_display_mode *mode)
+{
+	int value;
+
+	if (hdmi->plat_data->dev_type == RK3036_HDMI) {
+		value = BIT(20) | BIT(21);
+		value |= mode->flags & DRM_MODE_FLAG_PHSYNC ? BIT(4) : 0;
+		value |= mode->flags & DRM_MODE_FLAG_PVSYNC ? BIT(5) : 0;
+		writel(value, hdmi->grf + 0x148);
+	}
+	/* Set detail external video timing polarity and interlace mode */
+	value = v_EXTERANL_VIDEO(1);
+	value |= mode->flags & DRM_MODE_FLAG_PHSYNC ?
+		 v_HSYNC_POLARITY(1) : v_HSYNC_POLARITY(0);
+	value |= mode->flags & DRM_MODE_FLAG_PVSYNC ?
+		 v_VSYNC_POLARITY(1) : v_VSYNC_POLARITY(0);
+	value |= mode->flags & DRM_MODE_FLAG_INTERLACE ?
+		 v_INETLACE(1) : v_INETLACE(0);
+	hdmi_writeb(hdmi, HDMI_VIDEO_TIMING_CTL, value);
+
+	/* Set detail external video timing */
+	value = mode->htotal;
+	hdmi_writeb(hdmi, HDMI_VIDEO_EXT_HTOTAL_L, value & 0xFF);
+	hdmi_writeb(hdmi, HDMI_VIDEO_EXT_HTOTAL_H, (value >> 8) & 0xFF);
+
+	value = mode->htotal - mode->hdisplay;
+	hdmi_writeb(hdmi, HDMI_VIDEO_EXT_HBLANK_L, value & 0xFF);
+	hdmi_writeb(hdmi, HDMI_VIDEO_EXT_HBLANK_H, (value >> 8) & 0xFF);
+
+	value = mode->htotal - mode->hsync_start;
+	hdmi_writeb(hdmi, HDMI_VIDEO_EXT_HDELAY_L, value & 0xFF);
+	hdmi_writeb(hdmi, HDMI_VIDEO_EXT_HDELAY_H, (value >> 8) & 0xFF);
+
+	value = mode->hsync_end - mode->hsync_start;
+	hdmi_writeb(hdmi, HDMI_VIDEO_EXT_HDURATION_L, value & 0xFF);
+	hdmi_writeb(hdmi, HDMI_VIDEO_EXT_HDURATION_H, (value >> 8) & 0xFF);
+
+	value = mode->vtotal;
+	hdmi_writeb(hdmi, HDMI_VIDEO_EXT_VTOTAL_L, value & 0xFF);
+	hdmi_writeb(hdmi, HDMI_VIDEO_EXT_VTOTAL_H, (value >> 8) & 0xFF);
+
+	value = mode->vtotal - mode->vdisplay;
+	hdmi_writeb(hdmi, HDMI_VIDEO_EXT_VBLANK, value & 0xFF);
+
+	value = mode->vtotal - mode->vsync_start;
+	hdmi_writeb(hdmi, HDMI_VIDEO_EXT_VDELAY, value & 0xFF);
+
+	value = mode->vsync_end - mode->vsync_start;
+	hdmi_writeb(hdmi, HDMI_VIDEO_EXT_VDURATION, value & 0xFF);
+
+	hdmi_writeb(hdmi, HDMI_PHY_PRE_DIV_RATIO, 0x1e);
+	hdmi_writeb(hdmi, HDMI_PHY_FEEDBACK_DIV_RATIO_LOW, 0x2c);
+	hdmi_writeb(hdmi, HDMI_PHY_FEEDBACK_DIV_RATIO_HIGH, 0x01);
+
+	return 0;
+}
+
+static int inno_hdmi_setup(struct inno_hdmi *hdmi,
+			   struct drm_display_mode *mode)
+{
+	hdmi->hdmi_data.vic = drm_match_cea_mode(mode);
+
+	hdmi->hdmi_data.enc_in_format = HDMI_COLORSPACE_RGB;
+	hdmi->hdmi_data.enc_out_format = HDMI_COLORSPACE_RGB;
+
+	if (hdmi->hdmi_data.vic == 6 || hdmi->hdmi_data.vic == 7 ||
+	    hdmi->hdmi_data.vic == 21 || hdmi->hdmi_data.vic == 22 ||
+	    hdmi->hdmi_data.vic == 2 || hdmi->hdmi_data.vic == 3 ||
+	    hdmi->hdmi_data.vic == 17 || hdmi->hdmi_data.vic == 18)
+		hdmi->hdmi_data.colorimetry = HDMI_COLORIMETRY_ITU_601;
+	else
+		hdmi->hdmi_data.colorimetry = HDMI_COLORIMETRY_ITU_709;
+
+	/* Mute video and audio output */
+	hdmi_modb(hdmi, HDMI_AV_MUTE, m_AUDIO_MUTE | m_VIDEO_BLACK,
+		  v_AUDIO_MUTE(1) | v_VIDEO_MUTE(1));
+
+	/* Set HDMI Mode */
+	hdmi_writeb(hdmi, HDMI_HDCP_CTRL,
+		    v_HDMI_DVI(hdmi->hdmi_data.sink_is_hdmi));
+
+	inno_hdmi_config_video_timing(hdmi, mode);
+
+	inno_hdmi_config_video_csc(hdmi);
+
+	if (hdmi->hdmi_data.sink_is_hdmi) {
+		inno_hdmi_config_video_avi(hdmi, mode);
+		inno_hdmi_config_video_vsi(hdmi, mode);
+	}
+
+	/*
+	 * When IP controller have configured to an accurate video
+	 * timing, then the TMDS clock source would be switched to
+	 * DCLK_LCDC, so we need to init the TMDS rate to mode pixel
+	 * clock rate, and reconfigure the DDC clock.
+	 */
+	hdmi->tmds_rate = mode->clock * 1000;
+	inno_hdmi_i2c_init(hdmi);
+	/* Unmute video and audio output */
+	hdmi_modb(hdmi, HDMI_AV_MUTE, m_VIDEO_BLACK, v_VIDEO_MUTE(0));
+	if (hdmi->audio_enable)
+		hdmi_modb(hdmi, HDMI_AV_MUTE, m_AUDIO_MUTE, v_AUDIO_MUTE(0));
+
+	return 0;
+}
+
+static int inno_hdmi_i2c_read(struct inno_hdmi *hdmi,
+			      struct i2c_msg *msgs)
+{
+	struct inno_hdmi_i2c *i2c = hdmi->i2c;
+	unsigned int length = msgs->len;
+	unsigned char *buf = msgs->buf;
+	int interrupt = 0, i = 20;
+
+	while (i--) {
+		mdelay(50);
+		interrupt = 0;
+		interrupt = hdmi_readb(hdmi, HDMI_INTERRUPT_STATUS1);
+
+		if (interrupt & m_INT_EDID_READY)
+			break;
+	}
+
+	if (!interrupt) {
+		printf("[%s] i2c read reg[0x%02x] no interrupt\n",
+		       __func__, i2c->slave_reg);
+		return -EAGAIN;
+	}
+
+	/* Clear HDMI EDID interrupt flag */
+	hdmi_writeb(hdmi, HDMI_INTERRUPT_STATUS1, m_INT_EDID_READY);
+
+	while (length--)
+		*buf++ = hdmi_readb(hdmi, HDMI_EDID_FIFO_ADDR);
+
+	return 0;
+}
+
+static int inno_hdmi_i2c_write(struct inno_hdmi *hdmi,
+			       struct i2c_msg *msgs)
+{
+	unsigned int length = msgs->len;
+
+	hdmi->i2c->segment_addr = 0;
+	hdmi->i2c->ddc_addr = 0;
+
+	/*
+	 * The DDC module only support read EDID message, so
+	 * we assume that each word write to this i2c adapter
+	 * should be the offset of EDID word address.
+	 */
+	if (length != 1 ||
+	    (msgs->addr != DDC_ADDR && msgs->addr != DDC_SEGMENT_ADDR)) {
+		printf("DDC word write to i2c adapter is not EDID address\n");
+		return -EINVAL;
+	}
+
+	if (msgs->addr == DDC_SEGMENT_ADDR)
+		hdmi->i2c->segment_addr = msgs->buf[0];
+	if (msgs->addr == DDC_ADDR)
+		hdmi->i2c->ddc_addr = msgs->buf[0];
+
+	/* Set edid fifo first addr */
+	hdmi_writeb(hdmi, HDMI_EDID_FIFO_OFFSET, 0x00);
+
+	/* Set edid word address 0x00/0x80 */
+	hdmi_writeb(hdmi, HDMI_EDID_WORD_ADDR, hdmi->i2c->ddc_addr);
+
+	/* Set edid segment pointer */
+	hdmi_writeb(hdmi, HDMI_EDID_SEGMENT_POINTER, hdmi->i2c->segment_addr);
+
+	return 0;
+}
+
+static int inno_hdmi_i2c_xfer(struct ddc_adapter *adap,
+			      struct i2c_msg *msgs, int num)
+{
+	struct inno_hdmi *hdmi = container_of(adap, struct inno_hdmi, adap);
+	int i, ret = 0;
+
+	/* Clear the EDID interrupt flag and unmute the interrupt */
+	hdmi_writeb(hdmi, HDMI_INTERRUPT_MASK1, m_INT_EDID_READY);
+	hdmi_writeb(hdmi, HDMI_INTERRUPT_STATUS1, m_INT_EDID_READY);
+
+	for (i = 0; i < num; i++) {
+		dev_dbg(hdmi->dev, "xfer: num: %d/%d, len: %d, flags: %#x\n",
+			i + 1, num, msgs[i].len, msgs[i].flags);
+
+		if (msgs[i].flags & I2C_M_RD)
+			ret = inno_hdmi_i2c_read(hdmi, &msgs[i]);
+		else
+			ret = inno_hdmi_i2c_write(hdmi, &msgs[i]);
+
+		if (ret < 0)
+			break;
+	}
+
+	if (!ret)
+		ret = num;
+
+	/* Mute HDMI EDID interrupt */
+	hdmi_writeb(hdmi, HDMI_INTERRUPT_MASK1, 0);
+
+	return ret;
+}
+
+static int rockchip_inno_hdmi_init(struct rockchip_connector *conn, struct display_state *state)
+{
+	struct connector_state *conn_state = &state->conn_state;
+	struct inno_hdmi *hdmi;
+	struct drm_display_mode *mode_buf;
+	ofnode hdmi_node = conn->dev->node;
+	int ret;
+
+	hdmi = calloc(1, sizeof(struct inno_hdmi));
+	if (!hdmi)
+		return -ENOMEM;
+
+	mode_buf = calloc(1, MODE_LEN * sizeof(struct drm_display_mode));
+	if (!mode_buf)
+		return -ENOMEM;
+
+	hdmi->regs = dev_read_addr_ptr(conn->dev);
+
+	hdmi->grf = syscon_get_first_range(ROCKCHIP_SYSCON_GRF);
+	if (hdmi->grf <= 0) {
+		printf("%s: Get syscon grf failed (ret=%p)\n",
+		       __func__, hdmi->grf);
+		return -ENXIO;
+	}
+
+	hdmi->i2c = malloc(sizeof(struct inno_hdmi_i2c));
+	if (!hdmi->i2c)
+		return -ENOMEM;
+
+	hdmi->adap.ddc_xfer = inno_hdmi_i2c_xfer;
+
+	/*
+	 * Read high and low time from device tree. If not available use
+	 * the default timing scl clock rate is about 99.6KHz.
+	 */
+	hdmi->i2c->scl_high_ns =
+		ofnode_read_s32_default(hdmi_node,
+					"ddc-i2c-scl-high-time-ns", 4708);
+	hdmi->i2c->scl_low_ns =
+		ofnode_read_s32_default(hdmi_node,
+					"ddc-i2c-scl-low-time-ns", 4916);
+
+	conn_state->type = DRM_MODE_CONNECTOR_HDMIA;
+	conn_state->output_mode = ROCKCHIP_OUT_MODE_AAAA;
+
+	hdmi->plat_data = (struct inno_hdmi_plat_data *)dev_get_driver_data(conn->dev);
+	hdmi->edid_data.mode_buf = mode_buf;
+	hdmi->sample_rate = 48000;
+
+	conn->data = hdmi;
+
+	inno_hdmi_reset(hdmi);
+	ret = clk_get_by_name(conn->dev, "pclk", &hdmi->pclk);
+	if (ret < 0) {
+		dev_err(hdmi->dev, "failed to get pclk: %d\n", ret);
+		return ret;
+	}
+	hdmi->tmds_rate = clk_get_rate(&hdmi->pclk);
+	inno_hdmi_i2c_init(hdmi);
+
+	/* Unmute hotplug interrupt */
+	hdmi_modb(hdmi, HDMI_STATUS, m_MASK_INT_HOTPLUG, v_MASK_INT_HOTPLUG(1));
+
+	return 0;
+}
+
+static int rockchip_inno_hdmi_enable(struct rockchip_connector *conn, struct display_state *state)
+{
+	struct connector_state *conn_state = &state->conn_state;
+	struct drm_display_mode *mode = &conn_state->mode;
+	struct inno_hdmi *hdmi = conn->data;
+
+	if (!hdmi)
+		return -EFAULT;
+
+	/* Store the display mode for plugin/DKMS poweron events */
+	memcpy(&hdmi->previous_mode, mode, sizeof(hdmi->previous_mode));
+
+	inno_hdmi_setup(hdmi, mode);
+	inno_hdmi_set_pwr_mode(hdmi, NORMAL);
+
+	return 0;
+}
+
+static void rockchip_inno_hdmi_deinit(struct rockchip_connector *conn, struct display_state *state)
+{
+	struct inno_hdmi *hdmi = conn->data;
+
+	if (hdmi->i2c)
+		free(hdmi->i2c);
+	if (hdmi)
+		free(hdmi);
+}
+
+static int rockchip_inno_hdmi_prepare(struct rockchip_connector *conn, struct display_state *state)
+{
+	return 0;
+}
+
+static int rockchip_inno_hdmi_disable(struct rockchip_connector *conn, struct display_state *state)
+{
+	struct inno_hdmi *hdmi = conn->data;
+
+	inno_hdmi_set_pwr_mode(hdmi, LOWER_PWR);
+	return 0;
+}
+
+static int rockchip_inno_hdmi_detect(struct rockchip_connector *conn, struct display_state *state)
+{
+	struct inno_hdmi *hdmi = conn->data;
+
+	return (hdmi_readb(hdmi, HDMI_STATUS) & m_HOTPLUG) ?
+		connector_status_connected : connector_status_disconnected;
+}
+
+static int rockchip_inno_hdmi_get_timing(struct rockchip_connector *conn,
+					 struct display_state *state)
+{
+	int  i, ret;
+	struct connector_state *conn_state = &state->conn_state;
+	struct drm_display_mode *mode = &conn_state->mode;
+	struct inno_hdmi *hdmi = conn->data;
+	struct edid *edid = (struct edid *)conn_state->edid;
+	const u8 def_modes_vic[6] = {16, 4, 2, 17, 31, 19};
+
+	if (!hdmi)
+		return -EFAULT;
+
+	ret = drm_do_get_edid(&hdmi->adap, conn_state->edid);
+	if (!ret) {
+		hdmi->hdmi_data.sink_is_hdmi =
+			drm_detect_hdmi_monitor(edid);
+		hdmi->hdmi_data.sink_has_audio = drm_detect_monitor_audio(edid);
+		ret = drm_add_edid_modes(&hdmi->edid_data, conn_state->edid);
+	}
+	if (ret <= 0) {
+		hdmi->hdmi_data.sink_is_hdmi = true;
+		hdmi->hdmi_data.sink_has_audio = true;
+		do_cea_modes(&hdmi->edid_data, def_modes_vic,
+			     sizeof(def_modes_vic));
+		hdmi->edid_data.preferred_mode = &hdmi->edid_data.mode_buf[0];
+		printf("failed to get edid\n");
+	}
+	drm_rk_filter_whitelist(&hdmi->edid_data);
+
+	if (!drm_mode_prune_invalid(&hdmi->edid_data)) {
+		printf("can't find valid hdmi mode\n");
+		return -EINVAL;
+	}
+
+	for (i = 0; i < hdmi->edid_data.modes; i++)
+		hdmi->edid_data.mode_buf[i].vrefresh =
+			drm_mode_vrefresh(&hdmi->edid_data.mode_buf[i]);
+
+	drm_mode_sort(&hdmi->edid_data);
+
+	*mode = *hdmi->edid_data.preferred_mode;
+	hdmi->vic = drm_match_cea_mode(mode);
+
+	printf("mode:%dx%d\n", mode->hdisplay, mode->vdisplay);
+
+	conn_state->bus_format = MEDIA_BUS_FMT_RGB888_1X24;
+
+	return 0;
+}
+
+const struct rockchip_connector_funcs rockchip_inno_hdmi_funcs = {
+	.init = rockchip_inno_hdmi_init,
+	.deinit = rockchip_inno_hdmi_deinit,
+	.prepare = rockchip_inno_hdmi_prepare,
+	.enable = rockchip_inno_hdmi_enable,
+	.disable = rockchip_inno_hdmi_disable,
+	.get_timing = rockchip_inno_hdmi_get_timing,
+	.detect = rockchip_inno_hdmi_detect,
+};
+
+static int rockchip_inno_hdmi_probe(struct udevice *dev)
+{
+	int id;
+	struct rockchip_connector *conn = dev_get_priv(dev);
+
+	id = of_alias_get_id(ofnode_to_np(dev->node), "hdmi");
+	if (id < 0)
+		id = 0;
+
+	rockchip_connector_bind(conn, dev, id, &rockchip_inno_hdmi_funcs, NULL,
+				DRM_MODE_CONNECTOR_HDMIA);
+
+	return 0;
+}
+
+static int rockchip_inno_hdmi_bind(struct udevice *dev)
+{
+	return 0;
+}
+
+static const struct inno_hdmi_plat_data rk3036_hdmi_drv_data = {
+	.dev_type   = RK3036_HDMI,
+	.phy_config = rk3036_hdmi_phy_config,
+};
+
+static const struct inno_hdmi_plat_data rk3128_hdmi_drv_data = {
+	.dev_type   = RK3128_HDMI,
+	.phy_config = rk3128_hdmi_phy_config,
+};
+
+static const struct udevice_id rockchip_inno_hdmi_ids[] = {
+	{
+	 .compatible = "rockchip,rk3036-inno-hdmi",
+	 .data = (ulong)&rk3036_hdmi_drv_data,
+	},
+	{
+	 .compatible = "rockchip,rk3128-inno-hdmi",
+	 .data = (ulong)&rk3128_hdmi_drv_data,
+	}, {}
+
+};
+
+U_BOOT_DRIVER(rockchip_inno_hdmi) = {
+	.name = "rockchip_inno_hdmi",
+	.id = UCLASS_DISPLAY,
+	.of_match = rockchip_inno_hdmi_ids,
+	.probe	= rockchip_inno_hdmi_probe,
+	.bind	= rockchip_inno_hdmi_bind,
+	.priv_auto_alloc_size = sizeof(struct rockchip_connector),
+};
diff --git a/drivers/video/drm/inno_hdmi.h b/drivers/video/drm/inno_hdmi.h
new file mode 100644
index 0000000000..1e65bea57c
--- /dev/null
+++ b/drivers/video/drm/inno_hdmi.h
@@ -0,0 +1,381 @@
+/*
+ * SPDX-Licexse-Idextifier: GPL-2.0
+ * Copyright (C) Rockchip Electroxics Co.Ltd
+ *    Zhexg Yaxg <zhexgyaxg@rock-chips.com>
+ *    Yakir Yaxg <ykk@rock-chips.com>
+ *
+ * This software is licexsed uxder the terms of the GNU Gexeral Public
+ * Licexse versiox 2, as published by the Free Software Fouxdatiox, axd
+ * may be copied, distributed, axd modified uxder those terms.
+ *
+ * This program is distributed ix the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without evex the implied warraxty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Gexeral Public Licexse for more details.
+ */
+
+#ifndef __INNO_HDMI_H__
+#define __INNO_HDMI_H__
+
+#define DDC_SEGMENT_ADDR		0x30
+
+enum PWR_MODE {
+	NORMAL,
+	LOWER_PWR,
+};
+
+#define HDMI_SCL_RATE			(100 * 1000)
+#define DDC_BUS_FREQ_L			0x4b
+#define DDC_BUS_FREQ_H			0x4c
+
+#define HDMI_SYS_CTRL			0x00
+#define m_RST_ANALOG			BIT(6)
+#define v_RST_ANALOG			(0 << 6)
+#define v_NOT_RST_ANALOG		BIT(6)
+#define m_RST_DIGITAL			BIT(5)
+#define v_RST_DIGITAL			(0 << 5)
+#define v_NOT_RST_DIGITAL		BIT(5)
+#define m_REG_CLK_INV			BIT(4)
+#define v_REG_CLK_NOT_INV		(0 << 4)
+#define v_REG_CLK_INV			BIT(4)
+#define m_VCLK_INV			BIT(3)
+#define v_VCLK_NOT_INV			(0 << 3)
+#define v_VCLK_INV			BIT(3)
+#define m_REG_CLK_SOURCE		BIT(2)
+#define v_REG_CLK_SOURCE_TMDS		(0 << 2)
+#define v_REG_CLK_SOURCE_SYS		BIT(2)
+#define m_POWER				BIT(1)
+#define v_PWR_ON			(0 << 1)
+#define v_PWR_OFF			BIT(1)
+#define m_INT_POL			BIT(0)
+#define v_INT_POL_HIGH			1
+#define v_INT_POL_LOW			0
+
+#define HDMI_VIDEO_CONTRL1		0x01
+#define m_VIDEO_INPUT_FORMAT		(7 << 1)
+#define m_DE_SOURCE			BIT(0)
+#define v_VIDEO_INPUT_FORMAT(x)		((x) << 1)
+#define v_DE_EXTERNAL			1
+#define v_DE_INTERNAL			0
+enum {
+	VIDEO_INPUT_SDR_RGB444 = 0,
+	VIDEO_INPUT_DDR_RGB444 = 5,
+	VIDEO_INPUT_DDR_YCBCR422 = 6
+};
+
+#define HDMI_VIDEO_CONTRL2		0x02
+#define m_VIDEO_OUTPUT_COLOR		(3 << 6)
+#define m_VIDEO_INPUT_BITS		(3 << 4)
+#define m_VIDEO_INPUT_CSP		BIT(0)
+#define v_VIDEO_OUTPUT_COLOR(x)		(((x) & 0x3) << 6)
+#define v_VIDEO_INPUT_BITS(x)		((x) << 4)
+#define v_VIDEO_INPUT_CSP(x)		((x) << 0)
+enum {
+	VIDEO_INPUT_12BITS = 0,
+	VIDEO_INPUT_10BITS = 1,
+	VIDEO_INPUT_REVERT = 2,
+	VIDEO_INPUT_8BITS = 3,
+};
+
+#define HDMI_VIDEO_CONTRL		0x03
+#define m_VIDEO_AUTO_CSC		BIT(7)
+#define v_VIDEO_AUTO_CSC(x)		((x) << 7)
+#define m_VIDEO_C0_C2_SWAP		BIT(0)
+#define v_VIDEO_C0_C2_SWAP(x)		((x) << 0)
+enum {
+	C0_C2_CHANGE_ENABLE = 0,
+	C0_C2_CHANGE_DISABLE = 1,
+	AUTO_CSC_DISABLE = 0,
+	AUTO_CSC_ENABLE = 1,
+};
+
+#define HDMI_VIDEO_CONTRL3		0x04
+#define m_COLOR_DEPTH_NOT_INDICATED	BIT(4)
+#define m_SOF				BIT(3)
+#define m_COLOR_RANGE			BIT(2)
+#define m_CSC				BIT(0)
+#define v_COLOR_DEPTH_NOT_INDICATED(x)	((x) << 4)
+#define v_SOF_ENABLE			(0 << 3)
+#define v_SOF_DISABLE			BIT(3)
+#define v_COLOR_RANGE_FULL		BIT(2)
+#define v_COLOR_RANGE_LIMITED		(0 << 2)
+#define v_CSC_ENABLE			1
+#define v_CSC_DISABLE			0
+
+#define HDMI_AV_MUTE			0x05
+#define m_AVMUTE_CLEAR			BIT(7)
+#define m_AVMUTE_ENABLE			BIT(6)
+#define m_AUDIO_PD			BIT(2)
+#define m_AUDIO_MUTE			BIT(1)
+#define m_VIDEO_BLACK			BIT(0)
+#define v_AVMUTE_CLEAR(x)		((x) << 7)
+#define v_AVMUTE_ENABLE(x)		((x) << 6)
+#define v_AUDIO_MUTE(x)			((x) << 1)
+#define v_AUDIO_PD(x)			((x) << 2)
+#define v_VIDEO_MUTE(x)			((x) << 0)
+
+#define HDMI_VIDEO_TIMING_CTL		0x08
+#define v_HSYNC_POLARITY(x)		((x) << 3)
+#define v_VSYNC_POLARITY(x)		((x) << 2)
+#define v_INETLACE(x)			((x) << 1)
+#define v_EXTERANL_VIDEO(x)		((x) << 0)
+
+#define HDMI_VIDEO_EXT_HTOTAL_L		0x09
+#define HDMI_VIDEO_EXT_HTOTAL_H		0x0a
+#define HDMI_VIDEO_EXT_HBLANK_L		0x0b
+#define HDMI_VIDEO_EXT_HBLANK_H		0x0c
+#define HDMI_VIDEO_EXT_HDELAY_L		0x0d
+#define HDMI_VIDEO_EXT_HDELAY_H		0x0e
+#define HDMI_VIDEO_EXT_HDURATION_L	0x0f
+#define HDMI_VIDEO_EXT_HDURATION_H	0x10
+#define HDMI_VIDEO_EXT_VTOTAL_L		0x11
+#define HDMI_VIDEO_EXT_VTOTAL_H		0x12
+#define HDMI_VIDEO_EXT_VBLANK		0x13
+#define HDMI_VIDEO_EXT_VDELAY		0x14
+#define HDMI_VIDEO_EXT_VDURATION	0x15
+
+#define HDMI_VIDEO_CSC_COEF		0x18
+
+#define HDMI_AUDIO_CTRL1		0x35
+enum {
+	CTS_SOURCE_INTERNAL = 0,
+	CTS_SOURCE_EXTERNAL = 1,
+};
+
+#define v_CTS_SOURCE(x)			((x) << 7)
+
+enum {
+	DOWNSAMPLE_DISABLE = 0,
+	DOWNSAMPLE_1_2 = 1,
+	DOWNSAMPLE_1_4 = 2,
+};
+
+#define v_DOWN_SAMPLE(x)		((x) << 5)
+
+enum {
+	AUDIO_SOURCE_IIS = 0,
+	AUDIO_SOURCE_SPDIF = 1,
+};
+
+#define v_AUDIO_SOURCE(x)		((x) << 3)
+
+#define v_MCLK_ENABLE(x)		((x) << 2)
+enum {
+	MCLK_128FS = 0,
+	MCLK_256FS = 1,
+	MCLK_384FS = 2,
+	MCLK_512FS = 3,
+};
+
+#define v_MCLK_RATIO(x)			(x)
+
+#define AUDIO_SAMPLE_RATE		0x37
+enum {
+	AUDIO_32K = 0x3,
+	AUDIO_441K = 0x0,
+	AUDIO_48K = 0x2,
+	AUDIO_882K = 0x8,
+	AUDIO_96K = 0xa,
+	AUDIO_1764K = 0xc,
+	AUDIO_192K = 0xe,
+};
+
+#define AUDIO_I2S_MODE			0x38
+enum {
+	I2S_CHANNEL_1_2 = 1,
+	I2S_CHANNEL_3_4 = 3,
+	I2S_CHANNEL_5_6 = 7,
+	I2S_CHANNEL_7_8 = 0xf
+};
+
+#define v_I2S_CHANNEL(x)		((x) << 2)
+enum {
+	I2S_STANDARD = 0,
+	I2S_LEFT_JUSTIFIED = 1,
+	I2S_RIGHT_JUSTIFIED = 2,
+};
+
+#define v_I2S_MODE(x)			(x)
+
+#define AUDIO_I2S_MAP			0x39
+#define AUDIO_I2S_SWAPS_SPDIF		0x3a
+#define v_SPIDF_FREQ(x)			(x)
+
+#define N_32K				0x1000
+#define N_441K				0x1880
+#define N_882K				0x3100
+#define N_1764K				0x6200
+#define N_48K				0x1800
+#define N_96K				0x3000
+#define N_192K				0x6000
+
+#define HDMI_AUDIO_CHANNEL_STATUS	0x3e
+#define m_AUDIO_STATUS_NLPCM		BIT(7)
+#define m_AUDIO_STATUS_USE		BIT(6)
+#define m_AUDIO_STATUS_COPYRIGHT	BIT(5)
+#define m_AUDIO_STATUS_ADDITION		(3 << 2)
+#define m_AUDIO_STATUS_CLK_ACCURACY	(2 << 0)
+#define v_AUDIO_STATUS_NLPCM(x)		(((x) & 1) << 7)
+#define AUDIO_N_H			0x3f
+#define AUDIO_N_M			0x40
+#define AUDIO_N_L			0x41
+
+#define HDMI_AUDIO_CTS_H		0x45
+#define HDMI_AUDIO_CTS_M		0x46
+#define HDMI_AUDIO_CTS_L		0x47
+
+#define HDMI_DDC_CLK_L			0x4b
+#define HDMI_DDC_CLK_H			0x4c
+
+#define HDMI_EDID_SEGMENT_POINTER	0x4d
+#define HDMI_EDID_WORD_ADDR		0x4e
+#define HDMI_EDID_FIFO_OFFSET		0x4f
+#define HDMI_EDID_FIFO_ADDR		0x50
+
+#define HDMI_PACKET_SEND_MANUAL		0x9c
+#define HDMI_PACKET_SEND_AUTO		0x9d
+#define m_PACKET_GCP_EN			BIT(7)
+#define m_PACKET_MSI_EN			BIT(6)
+#define m_PACKET_SDI_EN			BIT(5)
+#define m_PACKET_VSI_EN			BIT(4)
+#define v_PACKET_GCP_EN(x)		(((x) & 1) << 7)
+#define v_PACKET_MSI_EN(x)		(((x) & 1) << 6)
+#define v_PACKET_SDI_EN(x)		(((x) & 1) << 5)
+#define v_PACKET_VSI_EN(x)		(((x) & 1) << 4)
+
+#define HDMI_CONTROL_PACKET_BUF_INDEX	0x9f
+enum {
+	INFOFRAME_VSI = 0x05,
+	INFOFRAME_AVI = 0x06,
+	INFOFRAME_AAI = 0x08,
+};
+
+enum drm_coxxector_status {
+	coxxector_status_discoxxected = 0,
+	coxxector_status_coxxected = 1,
+};
+
+#define HDMI_CONTROL_PACKET_ADDR	0xa0
+#define HDMI_MAXIMUM_INFO_FRAME_SIZE	0x11
+enum {
+	AVI_COLOR_MODE_RGB = 0,
+	AVI_COLOR_MODE_YCBCR422 = 1,
+	AVI_COLOR_MODE_YCBCR444 = 2,
+	AVI_COLORIMETRY_NO_DATA = 0,
+
+	AVI_COLORIMETRY_SMPTE_170M = 1,
+	AVI_COLORIMETRY_ITU709 = 2,
+	AVI_COLORIMETRY_EXTENDED = 3,
+
+	AVI_CODED_FRAME_ASPECT_NO_DATA = 0,
+	AVI_CODED_FRAME_ASPECT_4_3 = 1,
+	AVI_CODED_FRAME_ASPECT_16_9 = 2,
+
+	ACTIVE_ASPECT_RATE_SAME_AS_CODED_FRAME = 0x08,
+	ACTIVE_ASPECT_RATE_4_3 = 0x09,
+	ACTIVE_ASPECT_RATE_16_9 = 0x0A,
+	ACTIVE_ASPECT_RATE_14_9 = 0x0B,
+};
+
+enum drm_connector_status {
+	connector_status_disconnected = 0,
+	connector_status_connected = 1,
+};
+
+#define HDMI_HDCP_CTRL			0x52
+#define m_HDMI_DVI			BIT(1)
+#define v_HDMI_DVI(x)			((x) << 1)
+
+#define HDMI_INTERRUPT_MASK1		0xc0
+#define HDMI_INTERRUPT_STATUS1		0xc1
+#define	m_INT_ACTIVE_VSYNC		BIT(5)
+#define m_INT_EDID_READY		BIT(2)
+
+#define HDMI_INTERRUPT_MASK2		0xc2
+#define HDMI_INTERRUPT_STATUS2		0xc3
+#define m_INT_HDCP_ERR			BIT(7)
+#define m_INT_BKSV_FLAG			BIT(6)
+#define m_INT_HDCP_OK			BIT(4)
+
+#define HDMI_STATUS			0xc8
+#define m_HOTPLUG			BIT(7)
+#define m_MASK_INT_HOTPLUG		BIT(5)
+#define m_INT_HOTPLUG			BIT(1)
+#define v_MASK_INT_HOTPLUG(x)		(((x) & 0x1) << 5)
+
+#define HDMI_COLORBAR                   0xc9
+
+#define HDMI_PHY_SYNC			0xce
+#define HDMI_PHY_SYS_CTL		0xe0
+#define m_TMDS_CLK_SOURCE		BIT(5)
+#define v_TMDS_FROM_PLL			(0 << 5)
+#define v_TMDS_FROM_GEN			BIT(5)
+#define m_PHASE_CLK			BIT(4)
+#define v_DEFAULT_PHASE			(0 << 4)
+#define v_SYNC_PHASE			BIT(4)
+#define m_TMDS_CURRENT_PWR		BIT(3)
+#define v_TURN_ON_CURRENT		(0 << 3)
+#define v_CAT_OFF_CURRENT		BIT(3)
+#define m_BANDGAP_PWR			BIT(2)
+#define v_BANDGAP_PWR_UP		(0 << 2)
+#define v_BANDGAP_PWR_DOWN		BIT(2)
+#define m_PLL_PWR			BIT(1)
+#define v_PLL_PWR_UP			(0 << 1)
+#define v_PLL_PWR_DOWN			BIT(1)
+#define m_TMDS_CHG_PWR			BIT(0)
+#define v_TMDS_CHG_PWR_UP		(0 << 0)
+#define v_TMDS_CHG_PWR_DOWN		BIT(0)
+
+#define HDMI_PHY_CHG_PWR		0xe1
+#define v_CLK_CHG_PWR(x)		(((x) & 1) << 3)
+#define v_DATA_CHG_PWR(x)		(((x) & 7) << 0)
+
+#define HDMI_PHY_DRIVER			0xe2
+#define v_CLK_MAIN_DRIVER(x)		((x) << 4)
+#define v_DATA_MAIN_DRIVER(x)		((x) << 0)
+
+#define HDMI_PHY_PRE_EMPHASIS		0xe3
+#define v_PRE_EMPHASIS(x)		(((x) & 7) << 4)
+#define v_CLK_PRE_DRIVER(x)		(((x) & 3) << 2)
+#define v_DATA_PRE_DRIVER(x)		(((x) & 3) << 0)
+
+#define HDMI_PHY_FEEDBACK_DIV_RATIO_LOW		0xe7
+#define v_FEEDBACK_DIV_LOW(x)			(x) & 0xff
+#define HDMI_PHY_FEEDBACK_DIV_RATIO_HIGH	0xe8
+#define v_FEEDBACK_DIV_HIGH(x)			(x) & 1
+
+#define HDMI_PHY_PRE_DIV_RATIO		0xed
+#define v_PRE_DIV_RATIO(x)		((x) & 0x1f)
+
+#define HDMI_CEC_CTRL			0xd0
+#define m_ADJUST_FOR_HISENSE		BIT(6)
+#define m_REJECT_RX_BROADCAST		BIT(5)
+#define m_BUSFREETIME_ENABLE		BIT(2)
+#define m_REJECT_RX			BIT(1)
+#define m_START_TX			BIT(0)
+
+#define HDMI_CEC_DATA			0xd1
+#define HDMI_CEC_TX_OFFSET		0xd2
+#define HDMI_CEC_RX_OFFSET		0xd3
+#define HDMI_CEC_CLK_H			0xd4
+#define HDMI_CEC_CLK_L			0xd5
+#define HDMI_CEC_TX_LENGTH		0xd6
+#define HDMI_CEC_RX_LENGTH		0xd7
+#define HDMI_CEC_TX_INT_MASK		0xd8
+#define m_TX_DONE			BIT(3)
+#define m_TX_NOACK			BIT(2)
+#define m_TX_BROADCAST_REJ		BIT(1)
+#define m_TX_BUSNOTFREE			BIT(0)
+
+#define HDMI_CEC_RX_INT_MASK		0xd9
+#define m_RX_LA_ERR			BIT(4)
+#define m_RX_GLITCH			BIT(3)
+#define m_RX_DONE			BIT(0)
+
+#define HDMI_CEC_TX_INT			0xda
+#define HDMI_CEC_RX_INT			0xdb
+#define HDMI_CEC_BUSFREETIME_L		0xdc
+#define HDMI_CEC_BUSFREETIME_H		0xdd
+#define HDMI_CEC_LOGICADDR		0xde
+
+#endif /* __INNO_HDMI_H__ */
diff --git a/drivers/video/drm/inno_mipi_phy.c b/drivers/video/drm/inno_mipi_phy.c
new file mode 100644
index 0000000000..8a3741ec3e
--- /dev/null
+++ b/drivers/video/drm/inno_mipi_phy.c
@@ -0,0 +1,753 @@
+/*
+ * (C) Copyright 2008-2017 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <config.h>
+#include <common.h>
+#include <errno.h>
+#include <malloc.h>
+#include <asm/unaligned.h>
+#include <asm/io.h>
+#include <linux/list.h>
+#include <div64.h>
+#include <dm/device.h>
+#include <dm/read.h>
+#include <dm/uclass.h>
+#include <dm/uclass-id.h>
+
+#include "rockchip_phy.h"
+
+#define NSEC_PER_USEC		1000L
+#define USEC_PER_SEC		1000000L
+#define NSEC_PER_SEC		1000000000L
+
+#define UPDATE(v, h, l)		(((v) << (l)) & GENMASK((h), (l)))
+
+/* Innosilicon MIPI D-PHY registers */
+#define INNO_PHY_LANE_CTRL		0x0000
+#define MIPI_BGPD			BIT(7)
+#define CLK_LANE_EN_MASK		BIT(6)
+#define DATA_LANE_3_EN_MASK		BIT(5)
+#define DATA_LANE_2_EN_MASK		BIT(4)
+#define DATA_LANE_1_EN_MASK		BIT(3)
+#define DATA_LANE_0_EN_MASK		BIT(2)
+#define CLK_LANE_EN			BIT(6)
+#define DATA_LANE_3_EN			BIT(5)
+#define DATA_LANE_2_EN			BIT(4)
+#define DATA_LANE_1_EN			BIT(3)
+#define DATA_LANE_0_EN			BIT(2)
+#define PWROK_BP			BIT(1)
+#define PWROK				BIT(0)
+#define INNO_PHY_POWER_CTRL		0x0004
+#define ANALOG_RESET_MASK		BIT(2)
+#define ANALOG_RESET			BIT(2)
+#define ANALOG_NORMAL			0
+#define LDO_POWER_MASK			BIT(1)
+#define LDO_POWER_DOWN			BIT(1)
+#define LDO_POWER_ON			0
+#define PLL_POWER_MASK			BIT(0)
+#define PLL_POWER_DOWN			BIT(0)
+#define PLL_POWER_ON			0
+#define INNO_PHY_PLL_CTRL_0		0x000c
+#define FBDIV_HI_MASK			BIT(5)
+#define FBDIV_HI(x)			UPDATE(x, 5, 5)
+#define PREDIV_MASK			GENMASK(4, 0)
+#define PREDIV(x)			UPDATE(x, 4, 0)
+#define INNO_PHY_PLL_CTRL_1		0x0010
+#define FBDIV_LO_MASK			GENMASK(7, 0)
+#define FBDIV_LO(x)			UPDATE(x, 7, 0)
+#define ANALOG_REG_08			0x0020
+#define PRE_EMPHASIS_ENABLE_MASK	BIT(7)
+#define PRE_EMPHASIS_ENABLE		BIT(7)
+#define PRE_EMPHASIS_DISABLE		0
+#define PLL_POST_DIV_ENABLE_MASK	BIT(5)
+#define PLL_POST_DIV_ENABLE		BIT(5)
+#define PLL_POST_DIV_DISABLE		0
+#define DATA_LANE_VOD_RANGE_SET_MASK	GENMASK(3, 0)
+#define DATA_LANE_VOD_RANGE_SET(x)	UPDATE(x, 3, 0)
+#define ANALOG_REG_0B			0x002c
+#define CLOCK_LANE_VOD_RANGE_SET_MASK	GENMASK(3, 0)
+#define CLOCK_LANE_VOD_RANGE_SET(x)	UPDATE(x, 3, 0)
+#define VOD_MIN_RANGE			0x1
+#define VOD_MID_RANGE			0x3
+#define VOD_BIG_RANGE			0x7
+#define VOD_MAX_RANGE			0xf
+#define INNO_PHY_DIG_CTRL		0x0080
+#define DIGITAL_RESET_MASK		BIT(0)
+#define DIGITAL_NORMAL			BIT(0)
+#define DIGITAL_RESET			0
+#define INNO_PHY_LVDS_CTRL		0x03ac
+#define LVDS_BGPD			BIT(0)
+
+#define INNO_CLOCK_LANE_REG_BASE	0x0100
+#define INNO_DATA_LANE_0_REG_BASE	0x0180
+#define INNO_DATA_LANE_1_REG_BASE	0x0200
+#define INNO_DATA_LANE_2_REG_BASE	0x0280
+#define INNO_DATA_LANE_3_REG_BASE	0x0300
+
+#define T_LPX_OFFSET		0x0014
+#define T_HS_PREPARE_OFFSET	0x0018
+#define T_HS_ZERO_OFFSET	0x001c
+#define T_HS_TRAIL_OFFSET	0x0020
+#define T_HS_EXIT_OFFSET	0x0024
+#define T_CLK_POST_OFFSET	0x0028
+#define T_CLK_POST_OFFSET_H	0x0040
+#define T_WAKUP_H_OFFSET	0x0030
+#define T_WAKUP_L_OFFSET	0x0034
+#define T_CLK_PRE_OFFSET	0x0038
+#define T_TA_GO_OFFSET		0x0040
+#define T_TA_SURE_OFFSET	0x0044
+#define T_TA_WAIT_OFFSET	0x0048
+
+#define T_LPX_MASK		GENMASK(5, 0)
+#define T_LPX(x)		UPDATE(x, 5, 0)
+#define T_HS_PREPARE_MASK	GENMASK(6, 0)
+#define T_HS_PREPARE(x)		UPDATE(x, 6, 0)
+#define T_HS_ZERO_MASK		GENMASK(5, 0)
+#define T_HS_ZERO(x)		UPDATE(x, 5, 0)
+#define T_HS_TRAIL_MASK		GENMASK(6, 0)
+#define T_HS_TRAIL(x)		UPDATE(x, 6, 0)
+#define T_HS_EXIT_MASK		GENMASK(4, 0)
+#define T_HS_EXIT(x)		UPDATE(x, 4, 0)
+#define T_CLK_POST_MASK		GENMASK(3, 0)
+#define T_CLK_POST(x)		UPDATE(x, 3, 0)
+#define T_CLK_POST_HI_MASK	GENMASK(7, 6)
+#define T_CLK_POST_HI(x)	UPDATE(x, 7, 6)
+#define T_WAKUP_H_MASK		GENMASK(1, 0)
+#define T_WAKUP_H(x)		UPDATE(x, 1, 0)
+#define T_WAKUP_L_MASK		GENMASK(7, 0)
+#define T_WAKUP_L(x)		UPDATE(x, 7, 0)
+#define T_CLK_PRE_MASK		GENMASK(3, 0)
+#define T_CLK_PRE(x)		UPDATE(x, 3, 0)
+#define T_TA_GO_MASK		GENMASK(5, 0)
+#define T_TA_GO(x)		UPDATE(x, 5, 0)
+#define T_TA_SURE_MASK		GENMASK(5, 0)
+#define T_TA_SURE(x)		UPDATE(x, 5, 0)
+#define T_TA_WAIT_MASK		GENMASK(5, 0)
+#define T_TA_WAIT(x)		UPDATE(x, 5, 0)
+
+enum soc_type {
+	RV1108_MIPI_DPHY,
+	RK1808_MIPI_DPHY,
+};
+
+enum lane_type {
+	CLOCK_LANE,
+	DATA_LANE_0,
+	DATA_LANE_1,
+	DATA_LANE_2,
+	DATA_LANE_3,
+};
+
+struct mipi_dphy_timing {
+	unsigned int clkmiss;
+	unsigned int clkpost;
+	unsigned int clkpre;
+	unsigned int clkprepare;
+	unsigned int clksettle;
+	unsigned int clktermen;
+	unsigned int clktrail;
+	unsigned int clkzero;
+	unsigned int dtermen;
+	unsigned int eot;
+	unsigned int hsexit;
+	unsigned int hsprepare;
+	unsigned int hszero;
+	unsigned int hssettle;
+	unsigned int hsskip;
+	unsigned int hstrail;
+	unsigned int init;
+	unsigned int lpx;
+	unsigned int taget;
+	unsigned int tago;
+	unsigned int tasure;
+	unsigned int wakeup;
+};
+
+struct inno_mipi_dphy_timing {
+	u8 lpx;
+	u8 hs_prepare;
+	u8 hs_zero;
+	u8 hs_trail;
+	u8 hs_exit;
+	u8 clk_post;
+	u8 wakup_h;
+	u8 wakup_l;
+	u8 clk_pre;
+	u8 ta_go;
+	u8 ta_sure;
+	u8 ta_wait;
+};
+
+struct inno_mipi_dphy {
+	struct udevice *dev;
+	void __iomem *regs;
+	unsigned int lane_mbps;
+	int lanes;
+};
+
+static const u32 lane_reg_offset[] = {
+	[CLOCK_LANE] = INNO_CLOCK_LANE_REG_BASE,
+	[DATA_LANE_0] = INNO_DATA_LANE_0_REG_BASE,
+	[DATA_LANE_1] = INNO_DATA_LANE_1_REG_BASE,
+	[DATA_LANE_2] = INNO_DATA_LANE_2_REG_BASE,
+	[DATA_LANE_3] = INNO_DATA_LANE_3_REG_BASE,
+};
+
+#define FIXED_PARAM(_freq, _lpx, _prepare, _clk_zero, _data_zero, _trail)	\
+{	\
+	.max_freq = _freq,	\
+	.lpx = _lpx,	\
+	.hs_prepare = _prepare,	\
+	.clk_lane = {	\
+		.hs_zero = _clk_zero,	\
+	},	\
+	.data_lane = {	\
+		.hs_zero = _data_zero,	\
+	},	\
+	.hs_trail = _trail,	\
+}
+
+struct fixed_param {
+	unsigned int max_freq;
+	u8 lpx;
+	u8 hs_prepare;
+	struct {
+		u8 hs_zero;
+	} clk_lane;
+	struct {
+		u8 hs_zero;
+	} data_lane;
+	u8 hs_trail;
+};
+
+static const struct fixed_param fixed_param_table[] = {
+	FIXED_PARAM(110, 0x0, 0x20, 0x16, 0x02, 0x22),
+	FIXED_PARAM(150, 0x0, 0x06, 0x16, 0x03, 0x45),
+	FIXED_PARAM(200, 0x0, 0x18, 0x17, 0x04, 0x0b),
+	FIXED_PARAM(250, 0x0, 0x05, 0x17, 0x05, 0x16),
+	FIXED_PARAM(300, 0x0, 0x51, 0x18, 0x06, 0x2c),
+	FIXED_PARAM(400, 0x0, 0x64, 0x19, 0x07, 0x33),
+	FIXED_PARAM(500, 0x0, 0x20, 0x1b, 0x07, 0x4e),
+	FIXED_PARAM(600, 0x0, 0x6a, 0x1d, 0x08, 0x3a),
+	FIXED_PARAM(700, 0x0, 0x3e, 0x1e, 0x08, 0x6a),
+	FIXED_PARAM(800, 0x0, 0x21, 0x1f, 0x09, 0x29),
+	FIXED_PARAM(1000, 0x0, 0x09, 0x20, 0x09, 0x27)
+};
+
+static const struct fixed_param rk1808_fixed_param_table[] = {
+	FIXED_PARAM(110, 0x02, 0x7f, 0x16, 0x02, 0x02),
+	FIXED_PARAM(150, 0x02, 0x7f, 0x16, 0x03, 0x02),
+	FIXED_PARAM(200, 0x02, 0x7f, 0x17, 0x04, 0x02),
+	FIXED_PARAM(250, 0x02, 0x7f, 0x17, 0x05, 0x04),
+	FIXED_PARAM(300, 0x02, 0x7f, 0x18, 0x06, 0x04),
+	FIXED_PARAM(400, 0x03, 0x7e, 0x19, 0x07, 0x04),
+	FIXED_PARAM(500, 0x03, 0x7c, 0x1b, 0x07, 0x08),
+	FIXED_PARAM(600, 0x03, 0x70, 0x1d, 0x08, 0x10),
+	FIXED_PARAM(700, 0x05, 0x40, 0x1e, 0x08, 0x30),
+	FIXED_PARAM(800, 0x05, 0x02, 0x1f, 0x09, 0x30),
+	FIXED_PARAM(1000, 0x05, 0x08, 0x20, 0x09, 0x30),
+	FIXED_PARAM(1400, 0x09, 0x03, 0x32, 0x14, 0x0f),
+	FIXED_PARAM(1600, 0x0d, 0x42, 0x36, 0x0e, 0x0f),
+	FIXED_PARAM(1800, 0x0e, 0x47, 0x7a, 0x0e, 0x0f),
+	FIXED_PARAM(2000, 0x11, 0x64, 0x7a, 0x0e, 0x0b),
+};
+
+static inline void inno_write(struct inno_mipi_dphy *inno, u32 reg, u32 val)
+{
+	writel(val, inno->regs + reg);
+}
+
+static inline u32 inno_read(struct inno_mipi_dphy *inno, u32 reg)
+{
+	return readl(inno->regs + reg);
+}
+
+static inline void inno_update_bits(struct inno_mipi_dphy *inno, u32 reg,
+				    u32 mask, u32 val)
+{
+	u32 tmp, orig;
+
+	orig = inno_read(inno, reg);
+	tmp = orig & ~mask;
+	tmp |= val & mask;
+	inno_write(inno, reg, tmp);
+}
+
+static void mipi_dphy_timing_get_default(struct mipi_dphy_timing *timing,
+					 unsigned long period)
+{
+	/* Global Operation Timing Parameters */
+	timing->clkmiss = 0;
+	timing->clkpost = 70 + 52 * period;
+	timing->clkpre = 8 * period;
+	timing->clkprepare = 65;
+	timing->clksettle = 95;
+	timing->clktermen = 0;
+	timing->clktrail = 80;
+	timing->clkzero = 260;
+	timing->dtermen = 0;
+	timing->eot = 0;
+	timing->hsexit = 120;
+	timing->hsprepare = 65 + 4 * period;
+	timing->hszero = 145 + 6 * period;
+	timing->hssettle = 85 + 6 * period;
+	timing->hsskip = 40;
+	timing->hstrail = max(8 * period, 60 + 4 * period);
+	timing->init = 100000;
+	timing->lpx = 60;
+	timing->taget = 5 * timing->lpx;
+	timing->tago = 4 * timing->lpx;
+	timing->tasure = 2 * timing->lpx;
+	timing->wakeup = 1000000;
+}
+
+static void inno_mipi_dphy_timing_update(struct inno_mipi_dphy *inno,
+					 enum lane_type lane_type,
+					 struct inno_mipi_dphy_timing *t)
+{
+	u32 base = lane_reg_offset[lane_type];
+	u32 m, v;
+
+	m = T_HS_PREPARE_MASK;
+	v = T_HS_PREPARE(t->hs_prepare);
+	inno_update_bits(inno, base + T_HS_PREPARE_OFFSET, m, v);
+
+	m = T_HS_ZERO_MASK;
+	v = T_HS_ZERO(t->hs_zero);
+	inno_update_bits(inno, base + T_HS_ZERO_OFFSET, m, v);
+
+	m = T_HS_TRAIL_MASK;
+	v = T_HS_TRAIL(t->hs_trail);
+	inno_update_bits(inno, base + T_HS_TRAIL_OFFSET, m, v);
+
+	m = T_HS_EXIT_MASK;
+	v = T_HS_EXIT(t->hs_exit);
+	inno_update_bits(inno, base + T_HS_EXIT_OFFSET, m, v);
+
+	if (lane_type == CLOCK_LANE) {
+		m = T_CLK_POST_MASK;
+		v = T_CLK_POST(t->clk_post);
+		inno_update_bits(inno, base + T_CLK_POST_OFFSET, m, v);
+		m = T_CLK_POST_HI_MASK;
+		v = T_CLK_POST_HI(t->clk_post >> 4);
+		inno_update_bits(inno, base + T_CLK_POST_OFFSET_H, m, v);
+		m = T_CLK_PRE_MASK;
+		v = T_CLK_PRE(t->clk_pre);
+		inno_update_bits(inno, base + T_CLK_PRE_OFFSET, m, v);
+	}
+
+	m = T_WAKUP_H_MASK;
+	v = T_WAKUP_H(t->wakup_h);
+	inno_update_bits(inno, base + T_WAKUP_H_OFFSET, m, v);
+
+	m = T_WAKUP_L_MASK;
+	v = T_WAKUP_L(t->wakup_l);
+	inno_update_bits(inno, base + T_WAKUP_L_OFFSET, m, v);
+
+	m = T_LPX_MASK;
+	v = T_LPX(t->lpx);
+	inno_update_bits(inno, base + T_LPX_OFFSET, m, v);
+
+	m = T_TA_GO_MASK;
+	v = T_TA_GO(t->ta_go);
+	inno_update_bits(inno, base + T_TA_GO_OFFSET, m, v);
+
+	m = T_TA_SURE_MASK;
+	v = T_TA_SURE(t->ta_sure);
+	inno_update_bits(inno, base + T_TA_SURE_OFFSET, m, v);
+
+	m = T_TA_WAIT_MASK;
+	v = T_TA_WAIT(t->ta_wait);
+	inno_update_bits(inno, base + T_TA_WAIT_OFFSET, m, v);
+}
+
+static void inno_mipi_dphy_get_fixed_param(struct inno_mipi_dphy_timing *t,
+					   unsigned int freq,
+					   enum soc_type soc_type,
+					   enum lane_type lane_type)
+{
+	const struct fixed_param *param, *param_table;
+	int i, param_num;
+
+	if (soc_type == RK1808_MIPI_DPHY) {
+		param_table = rk1808_fixed_param_table;
+		param_num = ARRAY_SIZE(rk1808_fixed_param_table);
+	} else {
+		param_table = fixed_param_table;
+		param_num = ARRAY_SIZE(fixed_param_table);
+	}
+
+	for (i = 0; i < param_num; i++)
+		if (freq <= param_table[i].max_freq)
+			break;
+
+	if (i == param_num)
+		--i;
+
+	param = &param_table[i];
+
+	if (lane_type == CLOCK_LANE)
+		t->hs_zero = param->clk_lane.hs_zero;
+	else
+		t->hs_zero = param->data_lane.hs_zero;
+
+	t->hs_prepare = param->hs_prepare;
+	t->hs_trail = param->hs_trail;
+
+	if (soc_type == RK1808_MIPI_DPHY)
+		t->lpx = param->lpx;
+}
+
+static void inno_mipi_dphy_lane_timing_init(struct inno_mipi_dphy *inno,
+					    enum lane_type lane_type)
+{
+	struct rockchip_phy *phy =
+		(struct rockchip_phy *)dev_get_driver_data(inno->dev);
+	struct mipi_dphy_timing timing;
+	struct inno_mipi_dphy_timing data;
+	unsigned long txbyteclk, txclkesc, UI;
+	unsigned int esc_clk_div;
+
+	memset(&timing, 0, sizeof(timing));
+	memset(&data, 0, sizeof(data));
+
+	txbyteclk = inno->lane_mbps * USEC_PER_SEC / 8;
+	esc_clk_div = DIV_ROUND_UP(txbyteclk, 20000000);
+	txclkesc = txbyteclk / esc_clk_div;
+	UI = DIV_ROUND_CLOSEST(NSEC_PER_USEC, inno->lane_mbps);
+
+	debug("txbyteclk=%lu, txclkesc=%lu, esc_clk_div=%u, UI=%lu\n",
+	      txbyteclk, txclkesc, esc_clk_div, UI);
+
+	mipi_dphy_timing_get_default(&timing, UI);
+	inno_mipi_dphy_get_fixed_param(&data, inno->lane_mbps,
+				       phy->soc_type, lane_type);
+
+	/*
+	 * Ttxbyteclk * val >= Ths-exit
+	 * Ttxbyteclk * val >= Tclk-post
+	 * Ttxbyteclk * val >= Tclk-pre
+	 * Ttxbyteclk * (2 + val) >= Tlpx
+	 */
+	data.hs_exit = DIV_ROUND_UP(timing.hsexit * txbyteclk, NSEC_PER_SEC);
+	data.clk_post = DIV_ROUND_UP(timing.clkpost * txbyteclk, NSEC_PER_SEC);
+	data.clk_pre = DIV_ROUND_UP(timing.clkpre * txbyteclk, NSEC_PER_SEC);
+	data.wakup_h = 0x3;
+	data.wakup_l = 0xff;
+
+	if (phy->soc_type == RV1108_MIPI_DPHY) {
+		data.lpx = DIV_ROUND_UP(txbyteclk * timing.lpx, NSEC_PER_SEC);
+		if (data.lpx > 2)
+			data.lpx -= 2;
+	}
+
+	/*
+	 * Ttxclkesc * val >= Tta-go
+	 * Ttxclkesc * val >= Tta-sure
+	 * Ttxclkesc * val >= Tta-wait
+	 */
+	data.ta_go = DIV_ROUND_UP(timing.tago * txclkesc, NSEC_PER_SEC);
+	data.ta_sure = DIV_ROUND_UP(timing.tasure * txclkesc, NSEC_PER_SEC);
+	data.ta_wait = DIV_ROUND_UP(timing.taget * txclkesc, NSEC_PER_SEC);
+
+	inno_mipi_dphy_timing_update(inno, lane_type, &data);
+
+#define TIMING_NS(x, freq) (((x) * (DIV_ROUND_CLOSEST(NSEC_PER_SEC, freq))))
+	debug("hs-exit=%lu, clk-post=%lu, clk-pre=%lu, lpx=%lu\n",
+	      TIMING_NS(data.hs_exit, txbyteclk),
+	      TIMING_NS(data.clk_post, txbyteclk),
+	      TIMING_NS(data.clk_pre, txbyteclk),
+	      TIMING_NS(data.lpx + 2, txbyteclk));
+	debug("ta-go=%lu, ta-sure=%lu, ta-wait=%lu\n",
+	      TIMING_NS(data.ta_go, txclkesc),
+	      TIMING_NS(data.ta_sure, txclkesc),
+	      TIMING_NS(data.ta_wait, txclkesc));
+}
+
+static unsigned long inno_mipi_dphy_pll_round_rate(unsigned long fin,
+						   unsigned long fout,
+						   u8 *prediv, u16 *fbdiv)
+{
+	unsigned long best_freq = 0;
+	u8 min_prediv, max_prediv;
+	u8 _prediv, best_prediv = 0;
+	u16 _fbdiv, best_fbdiv = 0;
+	u32 min_delta = 0xffffffff;
+
+	fout *= 2;
+
+	min_prediv = DIV_ROUND_UP(fin, 40000000);
+	max_prediv = fin / 5000000;
+
+	for (_prediv = min_prediv; _prediv <= max_prediv; _prediv++) {
+		u64 tmp;
+		u32 delta;
+		tmp = (u64)fout * _prediv;
+		do_div(tmp, fin);
+		_fbdiv = tmp;
+		if ((_fbdiv == 15) || (_fbdiv < 12) || (_fbdiv > 511))
+			continue;
+		tmp = (u64)_fbdiv * fin;
+		do_div(tmp, _prediv);
+
+		delta = abs(fout - tmp);
+		if (delta < min_delta) {
+			best_prediv = _prediv;
+			best_fbdiv = _fbdiv;
+			min_delta = delta;
+			best_freq = tmp;
+		}
+	}
+
+	if (best_freq) {
+		*prediv = best_prediv;
+		*fbdiv = best_fbdiv;
+	}
+
+	return best_freq / 2;
+}
+
+static inline void inno_mipi_dphy_reset(struct inno_mipi_dphy *inno)
+{
+	/* Reset analog */
+	inno_update_bits(inno, INNO_PHY_POWER_CTRL,
+			 ANALOG_RESET_MASK, ANALOG_RESET);
+	udelay(1);
+	inno_update_bits(inno, INNO_PHY_POWER_CTRL,
+			 ANALOG_RESET_MASK, ANALOG_NORMAL);
+	/* Reset digital */
+	inno_update_bits(inno, INNO_PHY_DIG_CTRL,
+			 DIGITAL_RESET_MASK, DIGITAL_RESET);
+	udelay(1);
+	inno_update_bits(inno, INNO_PHY_DIG_CTRL,
+			 DIGITAL_RESET_MASK, DIGITAL_NORMAL);
+}
+
+static void inno_mipi_dphy_timing_init(struct inno_mipi_dphy *inno)
+{
+	switch (inno->lanes) {
+	case 4:
+		inno_mipi_dphy_lane_timing_init(inno, DATA_LANE_3);
+		/* Fall through */
+	case 3:
+		inno_mipi_dphy_lane_timing_init(inno, DATA_LANE_2);
+		/* Fall through */
+	case 2:
+		inno_mipi_dphy_lane_timing_init(inno, DATA_LANE_1);
+		/* Fall through */
+	case 1:
+	default:
+		inno_mipi_dphy_lane_timing_init(inno, DATA_LANE_0);
+		inno_mipi_dphy_lane_timing_init(inno, CLOCK_LANE);
+		break;
+	}
+}
+
+static inline void inno_mipi_dphy_lane_enable(struct inno_mipi_dphy *inno)
+{
+	u32 m = 0, v = 0;
+
+	switch (inno->lanes) {
+	case 4:
+		m |= DATA_LANE_3_EN_MASK;
+		v |= DATA_LANE_3_EN;
+		/* Fall through */
+	case 3:
+		m |= DATA_LANE_2_EN_MASK;
+		v |= DATA_LANE_2_EN;
+		/* Fall through */
+	case 2:
+		m |= DATA_LANE_1_EN_MASK;
+		v |= DATA_LANE_1_EN;
+		/* Fall through */
+	default:
+	case 1:
+		m |= DATA_LANE_0_EN_MASK | CLK_LANE_EN_MASK;
+		v |= DATA_LANE_0_EN | CLK_LANE_EN;
+		break;
+	}
+
+	inno_update_bits(inno, INNO_PHY_LANE_CTRL, m, v);
+}
+
+static inline void inno_mipi_dphy_pll_ldo_disable(struct inno_mipi_dphy *inno)
+{
+	inno_update_bits(inno, INNO_PHY_POWER_CTRL,
+			 PLL_POWER_MASK | LDO_POWER_MASK,
+			 PLL_POWER_DOWN | LDO_POWER_DOWN);
+}
+
+static inline void inno_mipi_dphy_pll_ldo_enable(struct inno_mipi_dphy *inno)
+{
+	inno_update_bits(inno, INNO_PHY_POWER_CTRL,
+			 PLL_POWER_MASK | LDO_POWER_MASK,
+			 PLL_POWER_ON | LDO_POWER_ON);
+}
+
+static inline void inno_mipi_dphy_da_pwrok_enable(struct inno_mipi_dphy *inno)
+{
+	inno_update_bits(inno, INNO_PHY_LANE_CTRL, PWROK_BP | PWROK, PWROK);
+}
+
+static inline void inno_mipi_dphy_da_pwrok_disable(struct inno_mipi_dphy *inno)
+{
+	inno_update_bits(inno, INNO_PHY_LANE_CTRL, PWROK_BP | PWROK, PWROK_BP);
+}
+
+static inline void inno_mipi_dphy_bgpd_enable(struct inno_mipi_dphy *inno)
+{
+	inno_update_bits(inno, INNO_PHY_LANE_CTRL, MIPI_BGPD, 0);
+}
+
+static inline void inno_mipi_dphy_bgpd_disable(struct inno_mipi_dphy *inno)
+{
+	inno_update_bits(inno, INNO_PHY_LANE_CTRL, MIPI_BGPD, MIPI_BGPD);
+	inno_update_bits(inno, INNO_PHY_LVDS_CTRL, LVDS_BGPD, LVDS_BGPD);
+}
+
+static int inno_mipi_dphy_power_on(struct rockchip_phy *phy)
+{
+	struct inno_mipi_dphy *inno = dev_get_priv(phy->dev);
+
+	inno_mipi_dphy_bgpd_enable(inno);
+	inno_mipi_dphy_da_pwrok_enable(inno);
+	inno_mipi_dphy_pll_ldo_enable(inno);
+	inno_mipi_dphy_lane_enable(inno);
+	inno_mipi_dphy_reset(inno);
+	inno_mipi_dphy_timing_init(inno);
+	udelay(1);
+
+	return 0;
+}
+
+static inline void inno_mipi_dphy_lane_disable(struct inno_mipi_dphy *inno)
+{
+	inno_update_bits(inno, INNO_PHY_LANE_CTRL, 0x7c, 0x00);
+}
+
+static int inno_mipi_dphy_power_off(struct rockchip_phy *phy)
+{
+	struct inno_mipi_dphy *inno = dev_get_priv(phy->dev);
+
+	inno_mipi_dphy_lane_disable(inno);
+	inno_mipi_dphy_pll_ldo_disable(inno);
+	inno_mipi_dphy_da_pwrok_disable(inno);
+	inno_mipi_dphy_bgpd_disable(inno);
+
+	return 0;
+}
+
+static unsigned long inno_mipi_dphy_set_pll(struct rockchip_phy *phy,
+					    unsigned long rate)
+{
+	struct inno_mipi_dphy *inno = dev_get_priv(phy->dev);
+	unsigned long fin, fout;
+	u16 fbdiv = 0;
+	u8 prediv = 0;
+	u32 m, v;
+
+	fin = 24000000;
+	fout = inno_mipi_dphy_pll_round_rate(fin, rate, &prediv, &fbdiv);
+
+	debug("%s: fin=%lu, fout=%lu, prediv=%u, fbdiv=%u\n",
+	       __func__, fin, fout, prediv, fbdiv);
+
+	m = FBDIV_HI_MASK | PREDIV_MASK;
+	v = FBDIV_HI(fbdiv >> 8) | PREDIV(prediv);
+	inno_update_bits(inno, INNO_PHY_PLL_CTRL_0, m, v);
+
+	m = FBDIV_LO_MASK;
+	v = FBDIV_LO(fbdiv);
+	inno_update_bits(inno, INNO_PHY_PLL_CTRL_1, m, v);
+
+	if (phy->soc_type == RK1808_MIPI_DPHY) {
+		inno_update_bits(inno, ANALOG_REG_08,
+				 PLL_POST_DIV_ENABLE_MASK, PLL_POST_DIV_ENABLE);
+		inno_update_bits(inno, ANALOG_REG_0B,
+				 CLOCK_LANE_VOD_RANGE_SET_MASK,
+				 CLOCK_LANE_VOD_RANGE_SET(VOD_MAX_RANGE));
+	}
+
+	inno->lane_mbps = fout / USEC_PER_SEC;
+
+	return fout;
+}
+
+static int inno_mipi_dphy_parse_dt(struct inno_mipi_dphy *inno)
+{
+	struct udevice *dev = inno->dev;
+
+	inno->lanes = ofnode_read_u32_default(dev->node, "inno,lanes", 4);
+
+	return 0;
+}
+
+static int inno_mipi_dphy_init(struct rockchip_phy *phy)
+{
+	struct inno_mipi_dphy *inno = dev_get_priv(phy->dev);
+	int ret;
+
+	ret = inno_mipi_dphy_parse_dt(inno);
+	if (ret) {
+		printf("%s: failed to parse DT\n", __func__);
+		return ret;
+	}
+
+	inno->regs = dev_read_addr_ptr(inno->dev);
+
+	return 0;
+}
+
+static const struct rockchip_phy_funcs inno_mipi_dphy_funcs = {
+	.init = inno_mipi_dphy_init,
+	.power_on = inno_mipi_dphy_power_on,
+	.power_off = inno_mipi_dphy_power_off,
+	.set_pll = inno_mipi_dphy_set_pll,
+};
+
+static const struct udevice_id inno_mipi_dphy_ids[] = {
+	{
+		.compatible = "rockchip,rv1108-mipi-dphy",
+	},
+	{
+		.compatible = "rockchip,rk1808-mipi-dphy",
+	},
+	{
+		.compatible = "rockchip,rv1126-mipi-dphy",
+	},
+	{}
+};
+
+static int inno_mipi_dphy_probe(struct udevice *dev)
+{
+	struct inno_mipi_dphy *inno = dev_get_priv(dev);
+	struct rockchip_phy *phy;
+
+	phy = calloc(1, sizeof(*phy));
+	if (!phy)
+		return -ENOMEM;
+
+	dev->driver_data = (ulong)phy;
+	inno->dev = dev;
+	phy->dev = dev;
+	phy->funcs = &inno_mipi_dphy_funcs;
+
+#if defined(CONFIG_ROCKCHIP_RV1108)
+	phy->soc_type = RV1108_MIPI_DPHY;
+#else
+	phy->soc_type = RK1808_MIPI_DPHY;
+#endif
+
+	return 0;
+}
+
+U_BOOT_DRIVER(inno_mipi_dphy) = {
+	.name = "inno_mipi_dphy",
+	.id = UCLASS_PHY,
+	.of_match = inno_mipi_dphy_ids,
+	.probe = inno_mipi_dphy_probe,
+	.priv_auto_alloc_size = sizeof(struct inno_mipi_dphy),
+};
diff --git a/drivers/video/drm/inno_video_combo_phy.c b/drivers/video/drm/inno_video_combo_phy.c
new file mode 100644
index 0000000000..23718cc32c
--- /dev/null
+++ b/drivers/video/drm/inno_video_combo_phy.c
@@ -0,0 +1,978 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * (C) Copyright 2008-2018 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * Author: Wyon Bi <bivvy.bi@rock-chips.com>
+ */
+
+#include <asm/arch/cpu.h>
+#include <config.h>
+#include <common.h>
+#include <errno.h>
+#include <dm.h>
+#include <div64.h>
+#include <asm/io.h>
+#include <linux/ioport.h>
+#include <linux/iopoll.h>
+#include <linux/math64.h>
+
+#include "rockchip_phy.h"
+
+#define USEC_PER_SEC	1000000LL
+#define PSEC_PER_SEC	1000000000000LL
+
+#define UPDATE(x, h, l)	(((x) << (l)) & GENMASK((h), (l)))
+
+/*
+ * The offset address[7:0] is distributed two parts, one from the bit7 to bit5
+ * is the first address, the other from the bit4 to bit0 is the second address.
+ * when you configure the registers, you must set both of them. The Clock Lane
+ * and Data Lane use the same registers with the same second address, but the
+ * first address is different.
+ */
+#define FIRST_ADDRESS(x)		(((x) & 0x7) << 5)
+#define SECOND_ADDRESS(x)		(((x) & 0x1f) << 0)
+#define PHY_REG(first, second)		(FIRST_ADDRESS(first) | \
+					 SECOND_ADDRESS(second))
+
+/* Analog Register Part: reg00 */
+#define BANDGAP_POWER_MASK			BIT(7)
+#define BANDGAP_POWER_DOWN			BIT(7)
+#define BANDGAP_POWER_ON			0
+#define LANE_EN_MASK				GENMASK(6, 2)
+#define LANE_EN_CK				BIT(6)
+#define LANE_EN_3				BIT(5)
+#define LANE_EN_2				BIT(4)
+#define LANE_EN_1				BIT(3)
+#define LANE_EN_0				BIT(2)
+#define POWER_WORK_MASK				GENMASK(1, 0)
+#define POWER_WORK_ENABLE			UPDATE(1, 1, 0)
+#define POWER_WORK_DISABLE			UPDATE(2, 1, 0)
+/* Analog Register Part: reg01 */
+#define REG_SYNCRST_MASK			BIT(2)
+#define REG_SYNCRST_RESET			BIT(2)
+#define REG_SYNCRST_NORMAL			0
+#define REG_LDOPD_MASK				BIT(1)
+#define REG_LDOPD_POWER_DOWN			BIT(1)
+#define REG_LDOPD_POWER_ON			0
+#define REG_PLLPD_MASK				BIT(0)
+#define REG_PLLPD_POWER_DOWN			BIT(0)
+#define REG_PLLPD_POWER_ON			0
+/* Analog Register Part: reg03 */
+#define REG_FBDIV_HI_MASK			BIT(5)
+#define REG_FBDIV_HI(x)				UPDATE(x, 5, 5)
+#define REG_PREDIV_MASK				GENMASK(4, 0)
+#define REG_PREDIV(x)				UPDATE(x, 4, 0)
+/* Analog Register Part: reg04 */
+#define REG_FBDIV_LO_MASK			GENMASK(7, 0)
+#define REG_FBDIV_LO(x)				UPDATE(x, 7, 0)
+/* Analog Register Part: reg05 */
+#define SAMPLE_CLOCK_PHASE_MASK			GENMASK(6, 4)
+#define SAMPLE_CLOCK_PHASE(x)			UPDATE(x, 6, 4)
+#define CLOCK_LANE_SKEW_PHASE_MASK		GENMASK(2, 0)
+#define CLOCK_LANE_SKEW_PHASE(x)		UPDATE(x, 2, 0)
+/* Analog Register Part: reg06 */
+#define DATA_LANE_3_SKEW_PHASE_MASK		GENMASK(6, 4)
+#define DATA_LANE_3_SKEW_PHASE(x)		UPDATE(x, 6, 4)
+#define DATA_LANE_2_SKEW_PHASE_MASK		GENMASK(2, 0)
+#define DATA_LANE_2_SKEW_PHASE(x)		UPDATE(x, 2, 0)
+/* Analog Register Part: reg07 */
+#define DATA_LANE_1_SKEW_PHASE_MASK		GENMASK(6, 4)
+#define DATA_LANE_1_SKEW_PHASE(x)		UPDATE(x, 6, 4)
+#define DATA_LANE_0_SKEW_PHASE_MASK		GENMASK(2, 0)
+#define DATA_LANE_0_SKEW_PHASE(x)		UPDATE(x, 2, 0)
+/* Analog Register Part: reg08 */
+#define PRE_EMPHASIS_ENABLE_MASK		BIT(7)
+#define PRE_EMPHASIS_ENABLE			BIT(7)
+#define PRE_EMPHASIS_DISABLE			0
+#define PLL_POST_DIV_ENABLE_MASK		BIT(5)
+#define PLL_POST_DIV_ENABLE			BIT(5)
+#define PLL_POST_DIV_DISABLE			0
+#define DATA_LANE_VOD_RANGE_SET_MASK		GENMASK(3, 0)
+#define DATA_LANE_VOD_RANGE_SET(x)		UPDATE(x, 3, 0)
+#define SAMPLE_CLOCK_DIRECTION_MASK		BIT(4)
+#define SAMPLE_CLOCK_DIRECTION_REVERSE		BIT(4)
+#define SAMPLE_CLOCK_DIRECTION_FORWARD		0
+#define LOWFRE_EN_MASK				BIT(5)
+#define PLL_OUTPUT_FREQUENCY_DIV_BY_1		0
+#define PLL_OUTPUT_FREQUENCY_DIV_BY_2		1
+/* Analog Register Part: reg0b */
+#define CLOCK_LANE_VOD_RANGE_SET_MASK	GENMASK(3, 0)
+#define CLOCK_LANE_VOD_RANGE_SET(x)	UPDATE(x, 3, 0)
+#define VOD_MIN_RANGE			0x1
+#define VOD_MID_RANGE			0x3
+#define VOD_BIG_RANGE			0x7
+#define VOD_MAX_RANGE			0xf
+/* Analog Register Part: reg1e */
+#define PLL_MODE_SEL_MASK			GENMASK(6, 5)
+#define PLL_MODE_SEL_LVDS_MODE			0
+#define PLL_MODE_SEL_MIPI_MODE			BIT(5)
+
+/* Digital Register Part: reg00 */
+#define REG_DIG_RSTN_MASK			BIT(0)
+#define REG_DIG_RSTN_NORMAL			BIT(0)
+#define REG_DIG_RSTN_RESET			0
+/* Digital Register Part: reg01	*/
+#define INVERT_TXCLKESC_MASK			BIT(1)
+#define INVERT_TXCLKESC_ENABLE			BIT(1)
+#define INVERT_TXCLKESC_DISABLE			0
+#define INVERT_TXBYTECLKHS_MASK			BIT(0)
+#define INVERT_TXBYTECLKHS_ENABLE		BIT(0)
+#define INVERT_TXBYTECLKHS_DISABLE		0
+/* Clock/Data0/Data1/Data2/Data3 Lane Register Part: reg05 */
+#define T_LPX_CNT_MASK				GENMASK(5, 0)
+#define T_LPX_CNT(x)				UPDATE(x, 5, 0)
+/* Clock/Data0/Data1/Data2/Data3 Lane Register Part: reg06 */
+#define T_HS_ZERO_CNT_HI_MASK			BIT(7)
+#define T_HS_ZERO_CNT_HI(x)			UPDATE(x, 7, 7)
+#define T_HS_PREPARE_CNT_MASK			GENMASK(6, 0)
+#define T_HS_PREPARE_CNT(x)			UPDATE(x, 6, 0)
+/* Clock/Data0/Data1/Data2/Data3 Lane Register Part: reg07 */
+#define T_HS_ZERO_CNT_LO_MASK			GENMASK(5, 0)
+#define T_HS_ZERO_CNT_LO(x)			UPDATE(x, 5, 0)
+/* Clock/Data0/Data1/Data2/Data3 Lane Register Part: reg08 */
+#define T_HS_TRAIL_CNT_MASK			GENMASK(6, 0)
+#define T_HS_TRAIL_CNT(x)			UPDATE(x, 6, 0)
+/* Clock/Data0/Data1/Data2/Data3 Lane Register Part: reg09 */
+#define T_HS_EXIT_CNT_LO_MASK			GENMASK(4, 0)
+#define T_HS_EXIT_CNT_LO(x)			UPDATE(x, 4, 0)
+/* Clock/Data0/Data1/Data2/Data3 Lane Register Part: reg0a */
+#define T_CLK_POST_CNT_LO_MASK			GENMASK(3, 0)
+#define T_CLK_POST_CNT_LO(x)			UPDATE(x, 3, 0)
+/* Clock/Data0/Data1/Data2/Data3 Lane Register Part: reg0c */
+#define LPDT_TX_PPI_SYNC_MASK			BIT(2)
+#define LPDT_TX_PPI_SYNC_ENABLE			BIT(2)
+#define LPDT_TX_PPI_SYNC_DISABLE		0
+#define T_WAKEUP_CNT_HI_MASK			GENMASK(1, 0)
+#define T_WAKEUP_CNT_HI(x)			UPDATE(x, 1, 0)
+/* Clock/Data0/Data1/Data2/Data3 Lane Register Part: reg0d */
+#define T_WAKEUP_CNT_LO_MASK			GENMASK(7, 0)
+#define T_WAKEUP_CNT_LO(x)			UPDATE(x, 7, 0)
+/* Clock/Data0/Data1/Data2/Data3 Lane Register Part: reg0e */
+#define T_CLK_PRE_CNT_MASK			GENMASK(3, 0)
+#define T_CLK_PRE_CNT(x)			UPDATE(x, 3, 0)
+/* Clock/Data0/Data1/Data2/Data3 Lane Register Part: reg10 */
+#define T_CLK_POST_HI_MASK			GENMASK(7, 6)
+#define T_CLK_POST_HI(x)			UPDATE(x, 7, 6)
+#define T_TA_GO_CNT_MASK			GENMASK(5, 0)
+#define T_TA_GO_CNT(x)				UPDATE(x, 5, 0)
+/* Clock/Data0/Data1/Data2/Data3 Lane Register Part: reg11 */
+#define T_HS_EXIT_CNT_HI_MASK			BIT(6)
+#define T_HS_EXIT_CNT_HI(x)			UPDATE(x, 6, 6)
+#define T_TA_SURE_CNT_MASK			GENMASK(5, 0)
+#define T_TA_SURE_CNT(x)			UPDATE(x, 5, 0)
+/* Clock/Data0/Data1/Data2/Data3 Lane Register Part: reg12 */
+#define T_TA_WAIT_CNT_MASK			GENMASK(5, 0)
+#define T_TA_WAIT_CNT(x)			UPDATE(x, 5, 0)
+/* LVDS Register Part: reg00 */
+#define LVDS_DIGITAL_INTERNAL_RESET_MASK	BIT(2)
+#define LVDS_DIGITAL_INTERNAL_RESET_DISABLE	BIT(2)
+#define LVDS_DIGITAL_INTERNAL_RESET_ENABLE	0
+/* LVDS Register Part: reg01 */
+#define LVDS_DIGITAL_INTERNAL_ENABLE_MASK	BIT(7)
+#define LVDS_DIGITAL_INTERNAL_ENABLE		BIT(7)
+#define LVDS_DIGITAL_INTERNAL_DISABLE		0
+/* LVDS Register Part: reg03 */
+#define MODE_ENABLE_MASK			GENMASK(2, 0)
+#define TTL_MODE_ENABLE				BIT(2)
+#define LVDS_MODE_ENABLE			BIT(1)
+#define MIPI_MODE_ENABLE			BIT(0)
+/* LVDS Register Part: reg0b */
+#define LVDS_LANE_EN_MASK			GENMASK(7, 3)
+#define LVDS_DATA_LANE0_EN			BIT(7)
+#define LVDS_DATA_LANE1_EN			BIT(6)
+#define LVDS_DATA_LANE2_EN			BIT(5)
+#define LVDS_DATA_LANE3_EN			BIT(4)
+#define LVDS_CLK_LANE_EN			BIT(3)
+#define LVDS_PLL_POWER_MASK			BIT(2)
+#define LVDS_PLL_POWER_OFF			BIT(2)
+#define LVDS_PLL_POWER_ON			0
+#define LVDS_BANDGAP_POWER_MASK			BIT(0)
+#define LVDS_BANDGAP_POWER_DOWN			BIT(0)
+#define LVDS_BANDGAP_POWER_ON			0
+
+#define DSI_PHY_RSTZ			0xa0
+#define PHY_ENABLECLK			BIT(2)
+#define DSI_PHY_STATUS			0xb0
+#define PHY_LOCK			BIT(0)
+
+enum soc_type {
+	PX30_VIDEO_PHY,
+	PX30S_VIDEO_PHY,
+	RK3128_VIDEO_PHY,
+	RK3368_VIDEO_PHY,
+	RK3568_VIDEO_PHY,
+};
+
+enum phy_max_rate {
+	MAX_1GHZ,
+	MAX_2_5GHZ,
+};
+
+struct inno_video_mipi_dphy_timing {
+	unsigned int max_lane_mbps;
+	u8 lpx;
+	u8 hs_prepare;
+	u8 clk_lane_hs_zero;
+	u8 data_lane_hs_zero;
+	u8 hs_trail;
+};
+
+struct inno_video_mipi_dphy_info {
+	const struct inno_video_mipi_dphy_timing *inno_mipi_dphy_timing_table;
+	const unsigned int num_timings;
+	enum phy_max_rate phy_max_rate;
+};
+
+static const
+struct inno_video_mipi_dphy_timing inno_mipi_dphy_timing_table_max_1GHz[] = {
+	{ 110, 0x0, 0x20, 0x16, 0x02, 0x22},
+	{ 150, 0x0, 0x06, 0x16, 0x03, 0x45},
+	{ 200, 0x0, 0x18, 0x17, 0x04, 0x0b},
+	{ 250, 0x0, 0x05, 0x17, 0x05, 0x16},
+	{ 300, 0x0, 0x51, 0x18, 0x06, 0x2c},
+	{ 400, 0x0, 0x64, 0x19, 0x07, 0x33},
+	{ 500, 0x0, 0x20, 0x1b, 0x07, 0x4e},
+	{ 600, 0x0, 0x6a, 0x1d, 0x08, 0x3a},
+	{ 700, 0x0, 0x3e, 0x1e, 0x08, 0x6a},
+	{ 800, 0x0, 0x21, 0x1f, 0x09, 0x29},
+	{1000, 0x0, 0x09, 0x20, 0x09, 0x27},
+};
+
+static const
+struct inno_video_mipi_dphy_timing inno_mipi_dphy_timing_table_max_2_5GHz[] = {
+	{ 110, 0x02, 0x7f, 0x16, 0x02, 0x02},
+	{ 150, 0x02, 0x7f, 0x16, 0x03, 0x02},
+	{ 200, 0x02, 0x7f, 0x17, 0x04, 0x02},
+	{ 250, 0x02, 0x7f, 0x17, 0x05, 0x04},
+	{ 300, 0x02, 0x7f, 0x18, 0x06, 0x04},
+	{ 400, 0x03, 0x7e, 0x19, 0x07, 0x04},
+	{ 500, 0x03, 0x7c, 0x1b, 0x07, 0x08},
+	{ 600, 0x03, 0x70, 0x1d, 0x08, 0x10},
+	{ 700, 0x05, 0x40, 0x1e, 0x08, 0x30},
+	{ 800, 0x05, 0x02, 0x1f, 0x09, 0x30},
+	{1000, 0x05, 0x08, 0x20, 0x09, 0x30},
+	{1200, 0x06, 0x03, 0x32, 0x14, 0x0f},
+	{1400, 0x09, 0x03, 0x32, 0x14, 0x0f},
+	{1600, 0x0d, 0x42, 0x36, 0x0e, 0x0f},
+	{1800, 0x0e, 0x47, 0x7a, 0x0e, 0x0f},
+	{2000, 0x11, 0x64, 0x7a, 0x0e, 0x0b},
+	{2200, 0x13, 0x64, 0x7e, 0x15, 0x0b},
+	{2400, 0x13, 0x33, 0x7f, 0x15, 0x6a},
+	{2500, 0x15, 0x54, 0x7f, 0x15, 0x6a},
+};
+
+const struct inno_video_mipi_dphy_info inno_video_mipi_dphy_max_1GHz = {
+	.inno_mipi_dphy_timing_table = inno_mipi_dphy_timing_table_max_1GHz,
+	.num_timings = ARRAY_SIZE(inno_mipi_dphy_timing_table_max_1GHz),
+	.phy_max_rate = MAX_1GHZ,
+};
+
+const struct inno_video_mipi_dphy_info inno_video_mipi_dphy_max_2_5GHz = {
+	.inno_mipi_dphy_timing_table = inno_mipi_dphy_timing_table_max_2_5GHz,
+	.num_timings = ARRAY_SIZE(inno_mipi_dphy_timing_table_max_2_5GHz),
+	.phy_max_rate = MAX_2_5GHZ,
+};
+
+struct mipi_dphy_timing {
+	unsigned int clkmiss;
+	unsigned int clkpost;
+	unsigned int clkpre;
+	unsigned int clkprepare;
+	unsigned int clksettle;
+	unsigned int clktermen;
+	unsigned int clktrail;
+	unsigned int clkzero;
+	unsigned int dtermen;
+	unsigned int eot;
+	unsigned int hsexit;
+	unsigned int hsprepare;
+	unsigned int hszero;
+	unsigned int hssettle;
+	unsigned int hsskip;
+	unsigned int hstrail;
+	unsigned int init;
+	unsigned int lpx;
+	unsigned int taget;
+	unsigned int tago;
+	unsigned int tasure;
+	unsigned int wakeup;
+};
+
+struct inno_video_phy {
+	struct udevice *dev;
+	enum phy_mode mode;
+	const struct inno_video_mipi_dphy_info *mipi_dphy_info;
+	struct resource phy;
+	struct resource host;
+	int lanes;
+	struct {
+		u8 prediv;
+		u16 fbdiv;
+		unsigned long rate;
+	} pll;
+};
+
+enum {
+	REGISTER_PART_ANALOG,
+	REGISTER_PART_DIGITAL,
+	REGISTER_PART_CLOCK_LANE,
+	REGISTER_PART_DATA0_LANE,
+	REGISTER_PART_DATA1_LANE,
+	REGISTER_PART_DATA2_LANE,
+	REGISTER_PART_DATA3_LANE,
+	REGISTER_PART_LVDS,
+};
+
+static inline void phy_update_bits(struct inno_video_phy *inno,
+				   u8 first, u8 second, u8 mask, u8 val)
+{
+	u32 reg = PHY_REG(first, second) << 2;
+	u32 tmp, orig;
+
+	orig = readl(inno->phy.start + reg);
+	tmp = orig & ~mask;
+	tmp |= val & mask;
+	writel(tmp, inno->phy.start + reg);
+}
+
+static inline void host_update_bits(struct inno_video_phy *inno,
+				    u32 reg, u32 mask, u32 val)
+{
+	u32 tmp, orig;
+
+	orig = readl(inno->host.start + reg);
+	tmp = orig & ~mask;
+	tmp |= val & mask;
+	writel(tmp, inno->host.start + reg);
+}
+
+static void mipi_dphy_timing_get_default(struct mipi_dphy_timing *timing,
+					 unsigned long period)
+{
+	/* Global Operation Timing Parameters */
+	timing->clkmiss = 0;
+	timing->clkpost = 70000 + 52 * period;
+	timing->clkpre = 8 * period;
+	timing->clkprepare = 65000;
+	timing->clksettle = 95000;
+	timing->clktermen = 0;
+	timing->clktrail = 80000;
+	timing->clkzero = 260000;
+	timing->dtermen = 0;
+	timing->eot = 0;
+	timing->hsexit = 120000;
+	timing->hsprepare = 65000 + 4 * period;
+	timing->hszero = 145000 + 6 * period;
+	timing->hssettle = 85000 + 6 * period;
+	timing->hsskip = 40000;
+	timing->hstrail = max(8 * period, 60000 + 4 * period);
+	timing->init = 100000000;
+	timing->lpx = 60000;
+	timing->taget = 5 * timing->lpx;
+	timing->tago = 4 * timing->lpx;
+	timing->tasure = 2 * timing->lpx;
+	timing->wakeup = 1000000000;
+}
+
+static const struct inno_video_mipi_dphy_timing *
+inno_mipi_dphy_get_timing(struct inno_video_phy *inno)
+{
+	const struct inno_video_mipi_dphy_timing *timings;
+	unsigned int num_timings;
+	unsigned int lane_mbps = inno->pll.rate / USEC_PER_SEC;
+	unsigned int i;
+
+	timings = inno->mipi_dphy_info->inno_mipi_dphy_timing_table;
+	num_timings = inno->mipi_dphy_info->num_timings;
+
+	for (i = 0; i < num_timings; i++)
+		if (lane_mbps <= timings[i].max_lane_mbps)
+			break;
+
+	if (i == num_timings)
+		--i;
+
+	return &timings[i];
+}
+
+static void inno_mipi_dphy_max_2_5GHz_pll_enable(struct inno_video_phy *inno)
+{
+	phy_update_bits(inno, REGISTER_PART_ANALOG, 0x03,
+			REG_PREDIV_MASK, REG_PREDIV(inno->pll.prediv));
+	phy_update_bits(inno, REGISTER_PART_ANALOG, 0x03,
+			REG_FBDIV_HI_MASK, REG_FBDIV_HI(inno->pll.fbdiv >> 8));
+	phy_update_bits(inno, REGISTER_PART_ANALOG, 0x04,
+			REG_FBDIV_LO_MASK, REG_FBDIV_LO(inno->pll.fbdiv));
+	phy_update_bits(inno, REGISTER_PART_ANALOG, 0x08,
+			PLL_POST_DIV_ENABLE_MASK, PLL_POST_DIV_ENABLE);
+	phy_update_bits(inno, REGISTER_PART_ANALOG, 0x0b,
+			CLOCK_LANE_VOD_RANGE_SET_MASK,
+			CLOCK_LANE_VOD_RANGE_SET(VOD_MAX_RANGE));
+	phy_update_bits(inno, REGISTER_PART_ANALOG, 0x01,
+			REG_LDOPD_MASK | REG_PLLPD_MASK,
+			REG_LDOPD_POWER_ON | REG_PLLPD_POWER_ON);
+}
+
+static void inno_mipi_dphy_max_1GHz_pll_enable(struct inno_video_phy *inno)
+{
+	/* Configure PLL */
+	phy_update_bits(inno, REGISTER_PART_ANALOG, 0x03,
+			REG_PREDIV_MASK, REG_PREDIV(inno->pll.prediv));
+	phy_update_bits(inno, REGISTER_PART_ANALOG, 0x03,
+			REG_FBDIV_HI_MASK, REG_FBDIV_HI(inno->pll.fbdiv >> 8));
+	phy_update_bits(inno, REGISTER_PART_ANALOG, 0x04,
+			REG_FBDIV_LO_MASK, REG_FBDIV_LO(inno->pll.fbdiv));
+	/* Enable PLL and LDO */
+	phy_update_bits(inno, REGISTER_PART_ANALOG, 0x01,
+			REG_LDOPD_MASK | REG_PLLPD_MASK,
+			REG_LDOPD_POWER_ON | REG_PLLPD_POWER_ON);
+}
+
+static void inno_mipi_dphy_reset(struct inno_video_phy *inno)
+{
+	/* Reset analog */
+	phy_update_bits(inno, REGISTER_PART_ANALOG, 0x01,
+			 REG_SYNCRST_MASK, REG_SYNCRST_RESET);
+	udelay(1);
+	phy_update_bits(inno, REGISTER_PART_ANALOG, 0x01,
+			 REG_SYNCRST_MASK, REG_SYNCRST_NORMAL);
+	/* Reset digital */
+	phy_update_bits(inno, REGISTER_PART_DIGITAL, 0x00,
+			 REG_DIG_RSTN_MASK, REG_DIG_RSTN_RESET);
+	udelay(1);
+	phy_update_bits(inno, REGISTER_PART_DIGITAL, 0x00,
+			 REG_DIG_RSTN_MASK, REG_DIG_RSTN_NORMAL);
+}
+
+static void inno_mipi_dphy_timing_init(struct inno_video_phy *inno)
+{
+	struct mipi_dphy_timing gotp;
+	u32 t_txbyteclkhs, t_txclkesc, ui;
+	u32 txbyteclkhs, txclkesc, esc_clk_div;
+	u32 hs_exit, clk_post, clk_pre, wakeup, lpx, ta_go, ta_sure, ta_wait;
+	u32 hs_prepare, hs_trail, hs_zero, clk_lane_hs_zero, data_lane_hs_zero;
+	const struct inno_video_mipi_dphy_timing *timing;
+	unsigned int i;
+
+	txbyteclkhs = inno->pll.rate / 8;
+	t_txbyteclkhs = div_u64(PSEC_PER_SEC, txbyteclkhs);
+	esc_clk_div = DIV_ROUND_UP(txbyteclkhs, 20000000);
+	txclkesc = txbyteclkhs / esc_clk_div;
+	t_txclkesc = div_u64(PSEC_PER_SEC, txclkesc);
+
+	ui = div_u64(PSEC_PER_SEC, inno->pll.rate);
+
+	memset(&gotp, 0, sizeof(gotp));
+	mipi_dphy_timing_get_default(&gotp, ui);
+
+	/*
+	 * The value of counter for HS Ths-exit
+	 * Ths-exit = Tpin_txbyteclkhs * value
+	 */
+	hs_exit = DIV_ROUND_UP(gotp.hsexit, t_txbyteclkhs);
+	/*
+	 * The value of counter for HS Tclk-post
+	 * Tclk-post = Tpin_txbyteclkhs * value
+	 */
+	clk_post = DIV_ROUND_UP(gotp.clkpost, t_txbyteclkhs);
+	/*
+	 * The value of counter for HS Tclk-pre
+	 * Tclk-pre = Tpin_txbyteclkhs * value
+	 */
+	clk_pre = DIV_ROUND_UP(gotp.clkpre, t_txbyteclkhs);
+
+	/*
+	 * The value of counter for HS Tlpx Time
+	 * Tlpx = Tpin_txbyteclkhs * (2 + value)
+	 */
+	lpx = DIV_ROUND_UP(gotp.lpx, t_txbyteclkhs);
+	if (lpx >= 2)
+		lpx -= 2;
+
+	/*
+	 * The value of counter for HS Tta-go
+	 * Tta-go for turnaround
+	 * Tta-go = Ttxclkesc * value
+	 */
+	ta_go = DIV_ROUND_UP(gotp.tago, t_txclkesc);
+	/*
+	 * The value of counter for HS Tta-sure
+	 * Tta-sure for turnaround
+	 * Tta-sure = Ttxclkesc * value
+	 */
+	ta_sure = DIV_ROUND_UP(gotp.tasure, t_txclkesc);
+	/*
+	 * The value of counter for HS Tta-wait
+	 * Tta-wait for turnaround
+	 * Tta-wait = Ttxclkesc * value
+	 */
+	ta_wait = DIV_ROUND_UP(gotp.taget, t_txclkesc);
+
+	timing = inno_mipi_dphy_get_timing(inno);
+
+	/*
+	 * The value of counter for HS Tlpx Time
+	 * Tlpx = Tpin_txbyteclkhs * (2 + value)
+	 */
+	if (inno->mipi_dphy_info->phy_max_rate == MAX_1GHZ) {
+		lpx = DIV_ROUND_UP(gotp.lpx, t_txbyteclkhs);
+		if (lpx >= 2)
+			lpx -= 2;
+	} else {
+		lpx = timing->lpx;
+	}
+
+	hs_prepare = timing->hs_prepare;
+	hs_trail = timing->hs_trail;
+	clk_lane_hs_zero = timing->clk_lane_hs_zero;
+	data_lane_hs_zero = timing->data_lane_hs_zero;
+	wakeup = 0x3ff;
+
+	for (i = REGISTER_PART_CLOCK_LANE; i <= REGISTER_PART_DATA3_LANE; i++) {
+		if (i == REGISTER_PART_CLOCK_LANE)
+			hs_zero = clk_lane_hs_zero;
+		else
+			hs_zero = data_lane_hs_zero;
+
+		phy_update_bits(inno, i, 0x05, T_LPX_CNT_MASK,
+				T_LPX_CNT(lpx));
+		phy_update_bits(inno, i, 0x06, T_HS_PREPARE_CNT_MASK,
+				T_HS_PREPARE_CNT(hs_prepare));
+
+		if (inno->mipi_dphy_info->phy_max_rate == MAX_2_5GHZ)
+			phy_update_bits(inno, i, 0x06, T_HS_ZERO_CNT_HI_MASK,
+					T_HS_ZERO_CNT_HI(hs_zero >> 6));
+
+		phy_update_bits(inno, i, 0x07, T_HS_ZERO_CNT_LO_MASK,
+				T_HS_ZERO_CNT_LO(hs_zero));
+		phy_update_bits(inno, i, 0x08, T_HS_TRAIL_CNT_MASK,
+				T_HS_TRAIL_CNT(hs_trail));
+
+		if (inno->mipi_dphy_info->phy_max_rate == MAX_2_5GHZ)
+			phy_update_bits(inno, i, 0x11, T_HS_EXIT_CNT_HI_MASK,
+					T_HS_EXIT_CNT_HI(hs_exit >> 5));
+
+		phy_update_bits(inno, i, 0x09, T_HS_EXIT_CNT_LO_MASK,
+				T_HS_EXIT_CNT_LO(hs_exit));
+
+		if (inno->mipi_dphy_info->phy_max_rate == MAX_2_5GHZ)
+			phy_update_bits(inno, i, 0x10, T_CLK_POST_HI_MASK,
+					T_CLK_POST_HI(clk_post >> 4));
+
+		phy_update_bits(inno, i, 0x0a, T_CLK_POST_CNT_LO_MASK,
+				T_CLK_POST_CNT_LO(clk_post));
+		phy_update_bits(inno, i, 0x0e, T_CLK_PRE_CNT_MASK,
+				T_CLK_PRE_CNT(clk_pre));
+		phy_update_bits(inno, i, 0x0c, T_WAKEUP_CNT_HI_MASK,
+				T_WAKEUP_CNT_HI(wakeup >> 8));
+		phy_update_bits(inno, i, 0x0d, T_WAKEUP_CNT_LO_MASK,
+				T_WAKEUP_CNT_LO(wakeup));
+		phy_update_bits(inno, i, 0x10, T_TA_GO_CNT_MASK,
+				T_TA_GO_CNT(ta_go));
+		phy_update_bits(inno, i, 0x11, T_TA_SURE_CNT_MASK,
+				T_TA_SURE_CNT(ta_sure));
+		phy_update_bits(inno, i, 0x12, T_TA_WAIT_CNT_MASK,
+				T_TA_WAIT_CNT(ta_wait));
+	}
+}
+
+static void inno_mipi_dphy_lane_enable(struct inno_video_phy *inno)
+{
+	u8 val = LANE_EN_CK;
+
+	switch (inno->lanes) {
+	case 1:
+		val |= LANE_EN_0;
+		break;
+	case 2:
+		val |= LANE_EN_1 | LANE_EN_0;
+		break;
+	case 3:
+		val |= LANE_EN_2 | LANE_EN_1 | LANE_EN_0;
+		break;
+	case 4:
+	default:
+		val |= LANE_EN_3 | LANE_EN_2 | LANE_EN_1 | LANE_EN_0;
+		break;
+	}
+
+	phy_update_bits(inno, REGISTER_PART_ANALOG, 0x00, LANE_EN_MASK, val);
+}
+
+static void inno_video_phy_mipi_mode_enable(struct inno_video_phy *inno)
+{
+	struct rockchip_phy *phy =
+		(struct rockchip_phy *)dev_get_driver_data(inno->dev);
+
+	/* Select MIPI mode */
+	phy_update_bits(inno, REGISTER_PART_LVDS, 0x03,
+			MODE_ENABLE_MASK, MIPI_MODE_ENABLE);
+
+	/* set px30 pin_txclkesc_0 invert disable */
+	if (phy->soc_type == PX30_VIDEO_PHY || phy->soc_type == PX30S_VIDEO_PHY)
+		phy_update_bits(inno, REGISTER_PART_DIGITAL, 0x01,
+				INVERT_TXCLKESC_MASK, INVERT_TXCLKESC_DISABLE);
+
+	if (inno->mipi_dphy_info->phy_max_rate == MAX_2_5GHZ)
+		inno_mipi_dphy_max_2_5GHz_pll_enable(inno);
+	else
+		inno_mipi_dphy_max_1GHz_pll_enable(inno);
+
+	inno_mipi_dphy_reset(inno);
+	inno_mipi_dphy_timing_init(inno);
+	inno_mipi_dphy_lane_enable(inno);
+}
+
+static void inno_video_phy_lvds_mode_enable(struct inno_video_phy *inno)
+{
+	u8 prediv = 2;
+	u16 fbdiv = 28;
+	u32 val;
+	int ret;
+
+	/* Sample clock reverse direction */
+	phy_update_bits(inno, REGISTER_PART_ANALOG, 0x08,
+			SAMPLE_CLOCK_DIRECTION_MASK | LOWFRE_EN_MASK,
+			SAMPLE_CLOCK_DIRECTION_REVERSE |
+			PLL_OUTPUT_FREQUENCY_DIV_BY_1);
+
+	/* Reset LVDS digital logic */
+	phy_update_bits(inno, REGISTER_PART_LVDS, 0x00,
+			LVDS_DIGITAL_INTERNAL_RESET_MASK,
+			LVDS_DIGITAL_INTERNAL_RESET_ENABLE);
+	phy_update_bits(inno, REGISTER_PART_LVDS, 0x00,
+			LVDS_DIGITAL_INTERNAL_RESET_MASK,
+			LVDS_DIGITAL_INTERNAL_RESET_DISABLE);
+
+	/* Select LVDS mode */
+	phy_update_bits(inno, REGISTER_PART_LVDS, 0x03,
+			MODE_ENABLE_MASK, LVDS_MODE_ENABLE);
+
+	/* Configure PLL */
+	phy_update_bits(inno, REGISTER_PART_ANALOG, 0x03,
+			REG_PREDIV_MASK, REG_PREDIV(prediv));
+	phy_update_bits(inno, REGISTER_PART_ANALOG, 0x03,
+			REG_FBDIV_HI_MASK, REG_FBDIV_HI(fbdiv >> 8));
+	phy_update_bits(inno, REGISTER_PART_ANALOG, 0x04,
+			REG_FBDIV_LO_MASK, REG_FBDIV_LO(fbdiv));
+	phy_update_bits(inno, REGISTER_PART_LVDS, 0x08, 0xff, 0xfc);
+
+	/* Enable PLL and Bandgap */
+	phy_update_bits(inno, REGISTER_PART_LVDS, 0x0b,
+			LVDS_PLL_POWER_MASK | LVDS_BANDGAP_POWER_MASK,
+			LVDS_PLL_POWER_ON | LVDS_BANDGAP_POWER_ON);
+
+	ret = readl_poll_timeout(inno->host.start + DSI_PHY_STATUS,
+				 val, val & PHY_LOCK, 10000);
+	if (ret)
+		dev_err(phy->dev, "PLL is not lock\n");
+
+	/* Select PLL mode */
+	phy_update_bits(inno, REGISTER_PART_ANALOG, 0x1e,
+			PLL_MODE_SEL_MASK, PLL_MODE_SEL_LVDS_MODE);
+
+	/* Enable LVDS digital logic */
+	phy_update_bits(inno, REGISTER_PART_LVDS, 0x01,
+			LVDS_DIGITAL_INTERNAL_ENABLE_MASK,
+			LVDS_DIGITAL_INTERNAL_ENABLE);
+	/* Enable LVDS analog driver */
+	phy_update_bits(inno, REGISTER_PART_LVDS, 0x0b,
+			LVDS_LANE_EN_MASK, LVDS_CLK_LANE_EN |
+			LVDS_DATA_LANE0_EN | LVDS_DATA_LANE1_EN |
+			LVDS_DATA_LANE2_EN | LVDS_DATA_LANE3_EN);
+}
+
+static void inno_video_phy_ttl_mode_enable(struct inno_video_phy *inno)
+{
+	/* Reset digital logic */
+	phy_update_bits(inno, REGISTER_PART_LVDS, 0x00,
+			LVDS_DIGITAL_INTERNAL_RESET_MASK,
+			LVDS_DIGITAL_INTERNAL_RESET_ENABLE);
+	phy_update_bits(inno, REGISTER_PART_LVDS, 0x00,
+			LVDS_DIGITAL_INTERNAL_RESET_MASK,
+			LVDS_DIGITAL_INTERNAL_RESET_DISABLE);
+
+	/* Select TTL mode */
+	phy_update_bits(inno, REGISTER_PART_LVDS, 0x03,
+			MODE_ENABLE_MASK, TTL_MODE_ENABLE);
+	/* Enable digital logic */
+	phy_update_bits(inno, REGISTER_PART_LVDS, 0x01,
+			LVDS_DIGITAL_INTERNAL_ENABLE_MASK,
+			LVDS_DIGITAL_INTERNAL_ENABLE);
+	/* Enable analog driver */
+	phy_update_bits(inno, REGISTER_PART_LVDS, 0x0b,
+			LVDS_LANE_EN_MASK, LVDS_CLK_LANE_EN |
+			LVDS_DATA_LANE0_EN | LVDS_DATA_LANE1_EN |
+			LVDS_DATA_LANE2_EN | LVDS_DATA_LANE3_EN);
+	/* Enable for clk lane in TTL mode */
+	host_update_bits(inno, DSI_PHY_RSTZ, PHY_ENABLECLK, PHY_ENABLECLK);
+}
+
+static int inno_video_phy_power_on(struct rockchip_phy *phy)
+{
+	struct inno_video_phy *inno = dev_get_priv(phy->dev);
+
+	/* Bandgap power on */
+	phy_update_bits(inno, REGISTER_PART_ANALOG, 0x00,
+			BANDGAP_POWER_MASK, BANDGAP_POWER_ON);
+	/* Enable power work */
+	phy_update_bits(inno, REGISTER_PART_ANALOG, 0x00,
+			POWER_WORK_MASK, POWER_WORK_ENABLE);
+
+	switch (inno->mode) {
+	case PHY_MODE_MIPI_DPHY:
+		inno_video_phy_mipi_mode_enable(inno);
+		break;
+	case PHY_MODE_VIDEO_LVDS:
+		inno_video_phy_lvds_mode_enable(inno);
+		break;
+	case PHY_MODE_VIDEO_TTL:
+		inno_video_phy_ttl_mode_enable(inno);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int inno_video_phy_power_off(struct rockchip_phy *phy)
+{
+	struct inno_video_phy *inno = dev_get_priv(phy->dev);
+
+	phy_update_bits(inno, REGISTER_PART_ANALOG, 0x00, LANE_EN_MASK, 0);
+	phy_update_bits(inno, REGISTER_PART_ANALOG, 0x01,
+			REG_LDOPD_MASK | REG_PLLPD_MASK,
+			REG_LDOPD_POWER_DOWN | REG_PLLPD_POWER_DOWN);
+	phy_update_bits(inno, REGISTER_PART_ANALOG, 0x00,
+			POWER_WORK_MASK, POWER_WORK_DISABLE);
+	phy_update_bits(inno, REGISTER_PART_ANALOG, 0x00,
+			BANDGAP_POWER_MASK, BANDGAP_POWER_DOWN);
+
+	phy_update_bits(inno, REGISTER_PART_LVDS, 0x0b, LVDS_LANE_EN_MASK, 0);
+	phy_update_bits(inno, REGISTER_PART_LVDS, 0x01,
+			LVDS_DIGITAL_INTERNAL_ENABLE_MASK,
+			LVDS_DIGITAL_INTERNAL_DISABLE);
+	phy_update_bits(inno, REGISTER_PART_LVDS, 0x0b,
+			LVDS_PLL_POWER_MASK | LVDS_BANDGAP_POWER_MASK,
+			LVDS_PLL_POWER_OFF | LVDS_BANDGAP_POWER_DOWN);
+
+	return 0;
+}
+
+static unsigned long inno_video_phy_pll_round_rate(unsigned long prate,
+						   unsigned long rate,
+						   u8 *prediv, u16 *fbdiv)
+{
+	unsigned long best_freq = 0;
+	unsigned long fref, fout;
+	u8 min_prediv, max_prediv;
+	u8 _prediv, best_prediv = 1;
+	u16 _fbdiv, best_fbdiv = 1;
+	u32 min_delta = 0xffffffff;
+
+	/*
+	 * The PLL output frequency can be calculated using a simple formula:
+	 * PLL_Output_Frequency = (FREF / PREDIV * FBDIV) / 2
+	 * PLL_Output_Frequency: it is equal to DDR-Clock-Frequency * 2
+	 */
+	fref = prate / 2;
+	if (rate > 1000000000UL)
+		fout = 1000000000UL;
+	else
+		fout = rate;
+
+	/* 5Mhz < Fref / prediv < 40MHz */
+	min_prediv = DIV_ROUND_UP(fref, 40000000);
+	max_prediv = fref / 5000000;
+
+	for (_prediv = min_prediv; _prediv <= max_prediv; _prediv++) {
+		u64 tmp;
+		u32 delta;
+
+		tmp = (u64)fout * _prediv;
+		do_div(tmp, fref);
+		_fbdiv = tmp;
+
+		/*
+		 * The all possible settings of feedback divider are
+		 * 12, 13, 14, 16, ~ 511
+		 */
+		if (_fbdiv == 15)
+			continue;
+
+		if (_fbdiv < 12 || _fbdiv > 511)
+			continue;
+
+		tmp = (u64)_fbdiv * fref;
+		do_div(tmp, _prediv);
+
+		delta = abs(fout - tmp);
+		if (!delta) {
+			best_prediv = _prediv;
+			best_fbdiv = _fbdiv;
+			best_freq = tmp;
+			break;
+		} else if (delta < min_delta) {
+			best_prediv = _prediv;
+			best_fbdiv = _fbdiv;
+			best_freq = tmp;
+			min_delta = delta;
+		}
+	}
+
+	if (best_freq) {
+		*prediv = best_prediv;
+		*fbdiv = best_fbdiv;
+	}
+
+	return best_freq;
+}
+
+static unsigned long inno_video_phy_set_pll(struct rockchip_phy *phy,
+					    unsigned long rate)
+{
+	struct inno_video_phy *inno = dev_get_priv(phy->dev);
+	unsigned long fin, fout;
+	u16 fbdiv = 1;
+	u8 prediv = 1;
+
+	fin = 24000000;
+	fout = inno_video_phy_pll_round_rate(fin, rate, &prediv, &fbdiv);
+
+	dev_dbg(phy->dev, "fin=%lu, fout=%lu, prediv=%u, fbdiv=%u\n",
+		fin, fout, prediv, fbdiv);
+
+	inno->pll.prediv = prediv;
+	inno->pll.fbdiv = fbdiv;
+	inno->pll.rate = fout;
+
+	return fout;
+}
+
+static int inno_video_phy_set_mode(struct rockchip_phy *phy,
+				   enum phy_mode mode)
+{
+	struct inno_video_phy *inno = dev_get_priv(phy->dev);
+
+	switch (mode) {
+	case PHY_MODE_MIPI_DPHY:
+	case PHY_MODE_VIDEO_LVDS:
+	case PHY_MODE_VIDEO_TTL:
+		inno->mode = mode;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int inno_video_phy_probe(struct udevice *dev)
+{
+	struct inno_video_phy *inno = dev_get_priv(dev);
+	struct rockchip_phy *tmp_phy;
+	struct rockchip_phy *phy;
+	int ret;
+
+	phy = calloc(1, sizeof(*phy));
+	if (!phy)
+		return -ENOMEM;
+
+	tmp_phy = (struct rockchip_phy *)dev_get_driver_data(dev);
+	dev->driver_data = (ulong)phy;
+	memcpy(phy, tmp_phy, sizeof(*phy));
+
+	inno->dev = dev;
+	inno->mipi_dphy_info = phy->data;
+	if (soc_is_px30s())
+		inno->mipi_dphy_info = &inno_video_mipi_dphy_max_2_5GHz;
+
+	inno->lanes = ofnode_read_u32_default(dev->node, "inno,lanes", 4);
+
+	ret = dev_read_resource(dev, 0, &inno->phy);
+	if (ret < 0) {
+		dev_err(dev, "resource \"phy\" not found\n");
+		return ret;
+	}
+
+	ret = dev_read_resource(dev, 1, &inno->host);
+	if (ret < 0) {
+		dev_err(dev, "resource \"host\" not found\n");
+		return ret;
+	}
+
+	phy->dev = dev;
+
+	return 0;
+}
+
+static const struct rockchip_phy_funcs inno_video_phy_funcs = {
+	.power_on = inno_video_phy_power_on,
+	.power_off = inno_video_phy_power_off,
+	.set_pll = inno_video_phy_set_pll,
+	.set_mode = inno_video_phy_set_mode,
+};
+
+static struct rockchip_phy px30_inno_video_phy_driver_data = {
+	.soc_type = PX30_VIDEO_PHY,
+	.funcs = &inno_video_phy_funcs,
+	.data = &inno_video_mipi_dphy_max_1GHz,
+};
+
+static struct rockchip_phy px30s_inno_video_phy_driver_data = {
+	.soc_type = PX30S_VIDEO_PHY,
+	.funcs = &inno_video_phy_funcs,
+	.data = &inno_video_mipi_dphy_max_2_5GHz,
+};
+
+static struct rockchip_phy rk3128_inno_video_phy_driver_data = {
+	.soc_type = RK3128_VIDEO_PHY,
+	.funcs = &inno_video_phy_funcs,
+	.data = &inno_video_mipi_dphy_max_1GHz,
+};
+
+static struct rockchip_phy rk3368_inno_video_phy_driver_data = {
+	.soc_type = RK3368_VIDEO_PHY,
+	.funcs = &inno_video_phy_funcs,
+	.data = &inno_video_mipi_dphy_max_1GHz,
+};
+
+static struct rockchip_phy rk3568_inno_video_phy_driver_data = {
+	.soc_type = RK3568_VIDEO_PHY,
+	.funcs = &inno_video_phy_funcs,
+	.data = &inno_video_mipi_dphy_max_2_5GHz,
+};
+
+static const struct udevice_id inno_video_phy_ids[] = {
+	{
+		.compatible = "rockchip,px30-video-phy",
+		.data = (ulong)&px30_inno_video_phy_driver_data,
+	},
+	{
+		.compatible = "rockchip,px30s-video-phy",
+		.data = (ulong)&px30s_inno_video_phy_driver_data,
+	},
+	{
+		.compatible = "rockchip,rk3128-video-phy",
+		.data = (ulong)&rk3128_inno_video_phy_driver_data,
+	},
+	{
+		.compatible = "rockchip,rk3368-video-phy",
+		.data = (ulong)&rk3368_inno_video_phy_driver_data,
+	},
+	{
+		.compatible = "rockchip,rk3568-video-phy",
+		.data = (ulong)&rk3568_inno_video_phy_driver_data,
+	},
+	{}
+};
+
+U_BOOT_DRIVER(inno_video_combo_phy) = {
+	.name = "inno_video_combo_phy",
+	.id = UCLASS_PHY,
+	.of_match = inno_video_phy_ids,
+	.probe = inno_video_phy_probe,
+	.priv_auto_alloc_size = sizeof(struct inno_video_phy),
+};
diff --git a/drivers/video/drm/inno_video_phy.c b/drivers/video/drm/inno_video_phy.c
new file mode 100644
index 0000000000..d2f63da65e
--- /dev/null
+++ b/drivers/video/drm/inno_video_phy.c
@@ -0,0 +1,233 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * (C) Copyright 2008-2018 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * Author: Wyon Bi <bivvy.bi@rock-chips.com>
+ */
+
+#include <config.h>
+#include <common.h>
+#include <errno.h>
+#include <dm.h>
+#include <asm/io.h>
+#include <linux/iopoll.h>
+
+#include "rockchip_phy.h"
+
+/* Register: 0x0030 */
+#define DISABLE_PLL	BIT(3)
+/* Register: 0x003c */
+#define PLL_LOCK	BIT(1)
+/* Register: 0x0084 */
+#define ENABLE_TX	BIT(7)
+
+struct inno_video_phy {
+	void __iomem *base;
+	enum phy_mode mode;
+	bool dual_channel;
+};
+
+struct reg_sequence {
+	unsigned int reg;
+	unsigned int def;
+	unsigned int delay_us;
+};
+
+static const struct reg_sequence ttl_mode[] = {
+	{ 0x0000, 0x7f },
+	{ 0x0004, 0x3f },
+	{ 0x0008, 0x80 },
+	{ 0x0010, 0x3f },
+	{ 0x0014, 0x3f },
+	{ 0x0080, 0x44 },
+
+	{ 0x0100, 0x7f },
+	{ 0x0104, 0x3f },
+	{ 0x0108, 0x80 },
+	{ 0x0110, 0x3f },
+	{ 0x0114, 0x3f },
+	{ 0x0180, 0x44 },
+};
+
+static const struct reg_sequence lvds_mode_single_channel[] = {
+	{ 0x0000, 0xbf },
+	{ 0x0004, 0x3f },
+	{ 0x0008, 0xfe },
+	{ 0x0010, 0x00 },
+	{ 0x0014, 0x00 },
+	{ 0x0080, 0x44 },
+
+	{ 0x0100, 0x00 },
+	{ 0x0104, 0x00 },
+	{ 0x0108, 0x00 },
+	{ 0x0110, 0x00 },
+	{ 0x0114, 0x00 },
+	{ 0x0180, 0x44 },
+};
+
+static const struct reg_sequence lvds_mode_dual_channel[] = {
+	{ 0x0000, 0xbf },
+	{ 0x0004, 0x3f },
+	{ 0x0008, 0xfe },
+	{ 0x0010, 0x00 },
+	{ 0x0014, 0x00 },
+	{ 0x0080, 0x44 },
+
+	{ 0x0100, 0xbf },
+	{ 0x0104, 0x3f },
+	{ 0x0108, 0xfe },
+	{ 0x0110, 0x00 },
+	{ 0x0114, 0x00 },
+	{ 0x0180, 0x44 },
+};
+
+static inline void phy_write(struct inno_video_phy *inno, u32 reg, u32 val)
+{
+	writel(val, inno->base + reg);
+}
+
+static inline u32 phy_read(struct inno_video_phy *inno, u32 reg)
+{
+	return readl(inno->base + reg);
+}
+
+static inline void phy_update_bits(struct inno_video_phy *inno,
+				   u32 reg, u32 mask, u32 val)
+{
+	u32 tmp, orig;
+
+	orig = phy_read(inno, reg);
+	tmp = orig & ~mask;
+	tmp |= val & mask;
+	phy_write(inno, reg, tmp);
+}
+
+static void phy_multi_write(struct inno_video_phy *inno,
+			    const struct reg_sequence *regs, int num_regs)
+{
+	int i;
+
+	for (i = 0; i < num_regs; i++) {
+		phy_write(inno, regs[i].reg, regs[i].def);
+
+		if (regs[i].delay_us)
+			udelay(regs[i].delay_us);
+	}
+}
+
+static int inno_video_phy_power_on(struct rockchip_phy *phy)
+{
+	struct inno_video_phy *inno = dev_get_priv(phy->dev);
+	const struct reg_sequence *wseq;
+	int nregs;
+	u32 status;
+	int ret;
+
+	switch (inno->mode) {
+	case PHY_MODE_VIDEO_LVDS:
+		if (inno->dual_channel) {
+			wseq = lvds_mode_dual_channel;
+			nregs = ARRAY_SIZE(lvds_mode_dual_channel);
+		} else {
+			wseq = lvds_mode_single_channel;
+			nregs = ARRAY_SIZE(lvds_mode_single_channel);
+		}
+		break;
+	case PHY_MODE_VIDEO_TTL:
+		wseq = ttl_mode;
+		nregs = ARRAY_SIZE(ttl_mode);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	phy_multi_write(inno, wseq, nregs);
+
+	phy_update_bits(inno, 0x0030, DISABLE_PLL, 0);
+	ret = readl_poll_timeout(inno->base + 0x003c, status,
+				 status & PLL_LOCK, 100000);
+	if (ret) {
+		dev_err(phy->dev, "PLL is not lock\n");
+		return ret;
+	}
+
+	phy_update_bits(inno, 0x0084, ENABLE_TX, ENABLE_TX);
+
+	return 0;
+}
+
+static int inno_video_phy_power_off(struct rockchip_phy *phy)
+{
+	struct inno_video_phy *inno = dev_get_priv(phy->dev);
+
+	phy_update_bits(inno, 0x0084, ENABLE_TX, 0);
+	phy_update_bits(inno, 0x0030, DISABLE_PLL, DISABLE_PLL);
+
+	return 0;
+}
+
+static int inno_video_phy_set_mode(struct rockchip_phy *phy,
+				   enum phy_mode mode)
+{
+	struct inno_video_phy *inno = dev_get_priv(phy->dev);
+
+	switch (mode) {
+	case PHY_MODE_VIDEO_LVDS:
+	case PHY_MODE_VIDEO_TTL:
+		inno->mode = mode;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int
+inno_video_phy_set_bus_width(struct rockchip_phy *phy, u32 bus_width)
+{
+	struct inno_video_phy *inno = dev_get_priv(phy->dev);
+
+	inno->dual_channel = (bus_width == 2) ? true : false;
+
+	return 0;
+}
+
+static const struct rockchip_phy_funcs inno_video_phy_funcs = {
+	.power_on = inno_video_phy_power_on,
+	.power_off = inno_video_phy_power_off,
+	.set_mode = inno_video_phy_set_mode,
+	.set_bus_width = inno_video_phy_set_bus_width,
+};
+
+static int inno_video_phy_probe(struct udevice *dev)
+{
+	struct inno_video_phy *inno = dev_get_priv(dev);
+	struct rockchip_phy *phy =
+		(struct rockchip_phy *)dev_get_driver_data(dev);
+
+	inno->base = dev_read_addr_ptr(dev);
+	phy->dev = dev;
+
+	return 0;
+}
+
+static struct rockchip_phy inno_video_phy_driver_data = {
+	 .funcs = &inno_video_phy_funcs,
+};
+
+static const struct udevice_id inno_video_phy_ids[] = {
+	{
+		.compatible = "rockchip,rk3288-video-phy",
+		.data = (ulong)&inno_video_phy_driver_data,
+	},
+	{}
+};
+
+U_BOOT_DRIVER(inno_video_phy) = {
+	.name = "inno_video_phy",
+	.id = UCLASS_PHY,
+	.of_match = inno_video_phy_ids,
+	.probe = inno_video_phy_probe,
+	.priv_auto_alloc_size = sizeof(struct inno_video_phy),
+};
diff --git a/drivers/video/drm/libnsbmp.c b/drivers/video/drm/libnsbmp.c
new file mode 100644
index 0000000000..bbefb6707b
--- /dev/null
+++ b/drivers/video/drm/libnsbmp.c
@@ -0,0 +1,1369 @@
+/*
+ * Copyright 2006 Richard Wilson <richard.wilson@netsurf-browser.org>
+ * Copyright 2008 Sean Fox <dyntryx@gmail.com>
+ *
+ * This file is part of NetSurf's libnsbmp, http://www.netsurf-browser.org/
+ * Licenced under the MIT License,
+ *                http://www.opensource.org/licenses/mit-license.php
+ */
+
+/**
+ * \file
+ * BMP decoding implementation
+ *
+ * This library decode windows bitmaps and icons from their disc images.
+ *
+ * The image format is described in several documents:
+ *  https://msdn.microsoft.com/en-us/library/dd183391(v=vs.85).aspx
+ *  http://www.fileformat.info/format/bmp/egff.htm
+ *  https://en.wikipedia.org/wiki/BMP_file_format
+ *
+ * Despite the format being clearly defined many bitmaps found on the web are
+ *  not compliant and this implementation attempts to cope with as many issues
+ *  as possible rather than simply failing.
+ */
+
+#include "libnsbmp.h"
+
+/* squashes unused variable compiler warnings */
+#define UNUSED(x) ((x)=(x))
+
+/* BMP entry sizes */
+#define BMP_FILE_HEADER_SIZE 14
+#define ICO_FILE_HEADER_SIZE 6
+#define ICO_DIR_ENTRY_SIZE 16
+
+/* the bitmap information header types (encoded as lengths) */
+#define BITMAPCOREHEADER 12
+
+#ifdef WE_NEED_INT8_READING_NOW
+static inline int8_t read_int8(uint8_t *data, unsigned int o) {
+        return (int8_t) data[o];
+}
+#endif
+
+static inline uint8_t read_uint8(uint8_t *data, unsigned int o) {
+        return (uint8_t) data[o];
+}
+
+static inline int16_t read_int16(uint8_t *data, unsigned int o) {
+        return (int16_t) (data[o] | (data[o+1] << 8));
+}
+
+static inline uint16_t read_uint16(uint8_t *data, unsigned int o) {
+        return (uint16_t) (data[o] | (data[o+1] << 8));
+}
+
+static inline int32_t read_int32(uint8_t *data, unsigned int o) {
+        return (int32_t) ((unsigned)data[o] |
+			  ((unsigned)data[o+1] << 8) |
+			  ((unsigned)data[o+2] << 16) |
+			  ((unsigned)data[o+3] << 24));
+}
+
+static inline uint32_t read_uint32(uint8_t *data, unsigned int o) {
+        return (uint32_t) ((unsigned)data[o] |
+                           ((unsigned)data[o+1] << 8) |
+                           ((unsigned)data[o+2] << 16) |
+                           ((unsigned)data[o+3] << 24));
+}
+
+
+/**
+ * Parse the bitmap info header
+ */
+static bmp_result bmp_info_header_parse(bmp_image *bmp, uint8_t *data)
+{
+        uint32_t header_size;
+        uint32_t i;
+        uint8_t j;
+        int32_t width, height;
+        uint8_t palette_size;
+        unsigned int flags = 0;
+
+        /* must be at least enough data for a core header */
+        if (bmp->buffer_size < (BMP_FILE_HEADER_SIZE + BITMAPCOREHEADER)) {
+                return BMP_INSUFFICIENT_DATA;
+        }
+
+        header_size = read_uint32(data, 0);
+
+        /* ensure there is enough data for the declared header size*/
+        if ((bmp->buffer_size - BMP_FILE_HEADER_SIZE) < header_size) {
+                return BMP_INSUFFICIENT_DATA;
+        }
+
+        /* a variety of different bitmap headers can follow, depending
+         * on the BMP variant. The header length field determines the type.
+         */
+        if (header_size == BITMAPCOREHEADER) {
+                /* the following header is for os/2 and windows 2.x and consists of:
+                 *
+                 *	+0	UINT32	size of this header (in bytes)
+                 *	+4	INT16	image width (in pixels)
+                 *	+6	INT16	image height (in pixels)
+                 *	+8	UINT16	number of colour planes (always 1)
+                 *	+10	UINT16	number of bits per pixel
+                 */
+                width = read_int16(data, 4);
+                height = read_int16(data, 6);
+                if ((width <= 0) || (height == 0))
+                        return BMP_DATA_ERROR;
+                if (height < 0) {
+                        bmp->reversed = true;
+                        height = -height;
+                }
+                /* ICOs only support 256*256 resolutions
+                 * In the case of the ICO header, the height is actually the added
+                 * height of XOR-Bitmap and AND-Bitmap (double the visible height)
+                 * Technically we could remove this check and ICOs with bitmaps
+                 * of any size could be processed; this is to conform to the spec.
+                 */
+                if (bmp->ico) {
+                        if ((width > 256) || (height > 512)) {
+                                return BMP_DATA_ERROR;
+                        } else {
+                                bmp->width = width;
+                                bmp->height = height / 2;
+                        }
+                } else {
+                        bmp->width = width;
+                        bmp->height = height;
+                }
+                if (read_uint16(data, 8) != 1)
+                        return BMP_DATA_ERROR;
+                bmp->bpp = read_uint16(data, 10);
+                /**
+                 * The bpp value should be in the range 1-32, but the only
+                 * values considered legal are:
+                 * RGB ENCODING: 1, 4, 8, 16, 24 and 32
+                 */
+                if ((bmp->bpp != 1) && (bmp->bpp != 4) &&
+                    (bmp->bpp != 8) &&
+                    (bmp->bpp != 16) &&
+                    (bmp->bpp != 24) &&
+                    (bmp->bpp != 32))
+                        return BMP_DATA_ERROR;
+                if (bmp->bpp < 16)
+                        bmp->colours = (1 << bmp->bpp);
+                palette_size = 3;
+        } else if (header_size < 40) {
+                return BMP_DATA_ERROR;
+        } else {
+                /* the following header is for windows 3.x and onwards. it is a
+                 * minimum of 40 bytes and (as of Windows 95) a maximum of 108 bytes.
+                 *
+                 *	+0	UINT32	size of this header (in bytes)
+                 *	+4	INT32	image width (in pixels)
+                 *	+8	INT32	image height (in pixels)
+                 *	+12	UINT16	number of colour planes (always 1)
+                 *	+14	UINT16	number of bits per pixel
+                 *	+16	UINT32	compression methods used
+                 *	+20	UINT32	size of bitmap (in bytes)
+                 *	+24	UINT32	horizontal resolution (in pixels per meter)
+                 *	+28	UINT32	vertical resolution (in pixels per meter)
+                 *	+32	UINT32	number of colours in the image
+                 *	+36	UINT32	number of important colours
+                 *	+40	UINT32	mask identifying bits of red component
+                 *	+44	UINT32	mask identifying bits of green component
+                 *	+48	UINT32	mask identifying bits of blue component
+                 *	+52	UINT32	mask identifying bits of alpha component
+                 *	+56	UINT32	color space type
+                 *	+60	UINT32	x coordinate of red endpoint
+                 *	+64	UINT32	y coordinate of red endpoint
+                 *	+68	UINT32	z coordinate of red endpoint
+                 *	+72	UINT32	x coordinate of green endpoint
+                 *	+76	UINT32	y coordinate of green endpoint
+                 *	+80	UINT32	z coordinate of green endpoint
+                 *	+84	UINT32	x coordinate of blue endpoint
+                 *	+88	UINT32	y coordinate of blue endpoint
+                 *	+92	UINT32	z coordinate of blue endpoint
+                 *	+96	UINT32	gamma red coordinate scale value
+                 *	+100	UINT32	gamma green coordinate scale value
+                 *	+104	UINT32	gamma blue coordinate scale value
+                 */
+                width = read_int32(data, 4);
+                height = read_int32(data, 8);
+                if ((width <= 0) || (height == 0))
+                        return BMP_DATA_ERROR;
+                if (height < 0) {
+                        bmp->reversed = true;
+                        if (height <= -INT32_MAX) {
+                                height = INT32_MAX;
+                        } else {
+                                height = -height;
+                        }
+                }
+                /* ICOs only support 256*256 resolutions
+                 * In the case of the ICO header, the height is actually the added
+                 * height of XOR-Bitmap and AND-Bitmap (double the visible height)
+                 * Technically we could remove this check and ICOs with bitmaps
+                 * of any size could be processed; this is to conform to the spec.
+                 */
+                if (bmp->ico) {
+                        if ((width > 256) || (height > 512)) {
+                                return BMP_DATA_ERROR;
+                        } else {
+                                bmp->width = width;
+                                bmp->height = height / 2;
+                        }
+                } else {
+                        bmp->width = width;
+                        bmp->height = height;
+                }
+                if (read_uint16(data, 12) != 1)
+                        return BMP_DATA_ERROR;
+                bmp->bpp = read_uint16(data, 14);
+                if (bmp->bpp == 0)
+                        bmp->bpp = 8;
+                bmp->encoding = read_uint32(data, 16);
+                /**
+                 * The bpp value should be in the range 1-32, but the only
+                 * values considered legal are:
+                 * RGB ENCODING: 1, 4, 8, 16, 24 and 32
+                 * RLE4 ENCODING: 4
+                 * RLE8 ENCODING: 8
+                 * BITFIELD ENCODING: 16 and 32
+                 */
+                switch (bmp->encoding) {
+                case BMP_ENCODING_RGB:
+                        if ((bmp->bpp != 1) && (bmp->bpp != 4) &&
+                            (bmp->bpp != 8) &&
+                            (bmp->bpp != 16) &&
+                            (bmp->bpp != 24) &&
+                            (bmp->bpp != 32))
+                                return BMP_DATA_ERROR;
+                        break;
+                case BMP_ENCODING_RLE8:
+                        if (bmp->bpp != 8)
+                                return BMP_DATA_ERROR;
+                        break;
+                case BMP_ENCODING_RLE4:
+                        if (bmp->bpp != 4)
+                                return BMP_DATA_ERROR;
+                        break;
+                case BMP_ENCODING_BITFIELDS:
+                        if ((bmp->bpp != 16) && (bmp->bpp != 32))
+                                return BMP_DATA_ERROR;
+                        break;
+                        /* invalid encoding */
+                default:
+                        return BMP_DATA_ERROR;
+                        break;
+                }
+                /* Bitfield encoding means we have red, green, blue, and alpha masks.
+                 * Here we acquire the masks and determine the required bit shift to
+                 * align them in our 24-bit color 8-bit alpha format.
+                 */
+                if (bmp->encoding == BMP_ENCODING_BITFIELDS) {
+                        if (header_size == 40) {
+                                header_size += 12;
+                                if (bmp->buffer_size < (14 + header_size))
+                                        return BMP_INSUFFICIENT_DATA;
+                                for (i = 0; i < 3; i++)
+                                        bmp->mask[i] = read_uint32(data, 40 + (i << 2));
+                        } else {
+                                if (header_size < 56)
+                                        return BMP_INSUFFICIENT_DATA;
+                                for (i = 0; i < 4; i++)
+                                        bmp->mask[i] = read_uint32(data, 40 + (i << 2));
+                        }
+                        for (i = 0; i < 4; i++) {
+                                if (bmp->mask[i] == 0)
+                                        break;
+                                for (j = 31; j > 0; j--)
+                                        if (bmp->mask[i] & ((unsigned)1 << j)) {
+                                                if ((j - 7) > 0)
+                                                        bmp->mask[i] &= (unsigned)0xff << (j - 7);
+                                                else
+                                                        bmp->mask[i] &= 0xff >> (-(j - 7));
+                                                bmp->shift[i] = (i << 3) - (j - 7);
+                                                break;
+                                        }
+                        }
+                }
+                bmp->colours = read_uint32(data, 32);
+                if (bmp->colours == 0 && bmp->bpp < 16)
+                        bmp->colours = (1 << bmp->bpp);
+                palette_size = 4;
+        }
+        data += header_size;
+
+        /* if there's no alpha mask, flag the bmp opaque */
+        if ((!bmp->ico) && (bmp->mask[3] == 0)) {
+                flags |= BMP_OPAQUE;
+                bmp->opaque = true;
+        }
+
+        /* we only have a palette for <16bpp */
+        if (bmp->bpp < 16) {
+                /* we now have a series of palette entries of the format:
+                 *
+                 *	+0	BYTE	blue
+                 *	+1	BYTE	green
+                 *	+2	BYTE	red
+                 *
+                 * if the palette is from an OS/2 or Win2.x file then the entries
+                 * are padded with an extra byte.
+                 */
+
+                /* boundary checking */
+                if (bmp->buffer_size < (14 + header_size + ((uint64_t)4 * bmp->colours)))
+                        return BMP_INSUFFICIENT_DATA;
+
+                /* create the colour table */
+                bmp->colour_table = (uint32_t *)malloc(bmp->colours * 4);
+                if (!bmp->colour_table)
+                        return BMP_INSUFFICIENT_MEMORY;
+                for (i = 0; i < bmp->colours; i++) {
+                        uint32_t colour = data[2] | (data[1] << 8) | (data[0] << 16);
+                        if (bmp->opaque)
+                                colour |= ((uint32_t)0xff << 24);
+                        data += palette_size;
+                        bmp->colour_table[i] = read_uint32((uint8_t *)&colour,0);
+                }
+
+                /* some bitmaps have a bad offset if there is a pallete, work
+                 * round this by fixing up the data offset to after the palette
+                 * but only if there is data following the palette as some
+                 * bitmaps encode data in the palette!
+                 */
+                if ((bmp->bitmap_offset < (uint32_t)(data - bmp->bmp_data)) &&
+                    ((bmp->buffer_size - (data - bmp->bmp_data)) > 0)) {
+                        bmp->bitmap_offset = data - bmp->bmp_data;
+                }
+        }
+
+        /* create our bitmap */
+        flags |= BMP_NEW | BMP_CLEAR_MEMORY;
+        bmp->bitmap = bmp->bitmap_callbacks.bitmap_create(bmp->width, bmp->height, flags);
+        if (!bmp->bitmap) {
+                if (bmp->colour_table)
+                        free(bmp->colour_table);
+                bmp->colour_table = NULL;
+                return BMP_INSUFFICIENT_MEMORY;
+        }
+        /* BMPs within ICOs don't have BMP file headers, so the image data should
+         * always be right after the colour table.
+         */
+        if (bmp->ico)
+                bmp->bitmap_offset = (uintptr_t)data - (uintptr_t)bmp->bmp_data;
+        return BMP_OK;
+}
+
+
+/**
+ * Parse the bitmap file header
+ *
+ * \param bmp The bitmap.
+ * \param data The data for the file header
+ * \return BMP_OK on success or error code on faliure
+ */
+static bmp_result bmp_file_header_parse(bmp_image *bmp, uint8_t *data)
+{
+        /* standard 14-byte BMP file header is:
+         *
+         *   +0    UINT16   File Type ('BM')
+         *   +2    UINT32   Size of File (in bytes)
+         *   +6    INT16    Reserved Field (1)
+         *   +8    INT16    Reserved Field (2)
+         *   +10   UINT32   Starting Position of Image Data (offset in bytes)
+         */
+        if (bmp->buffer_size < BMP_FILE_HEADER_SIZE)
+                return BMP_INSUFFICIENT_DATA;
+
+        if ((data[0] != (uint8_t)'B') || (data[1] != (uint8_t)'M'))
+                return BMP_DATA_ERROR;
+
+        bmp->bitmap_offset = read_uint32(data, 10);
+
+        /* check the offset to data lies within the file */
+        if (bmp->bitmap_offset >= bmp->buffer_size) {
+                return BMP_INSUFFICIENT_DATA;
+        }
+
+        return BMP_OK;
+}
+
+
+/**
+ * Allocates memory for the next BMP in an ICO collection
+ *
+ * Sets proper structure values
+ *
+ * \param ico the ICO collection to add the image to
+ * \param image a pointer to the ICO image to be initialised
+ */
+static bmp_result next_ico_image(ico_collection *ico, ico_image *image) {
+        bmp_create(&image->bmp, &ico->bitmap_callbacks);
+        image->next = ico->first;
+        ico->first = image;
+        return BMP_OK;
+}
+
+
+/**
+ * Parse the icon file header
+ *
+ * \param ico The icon collection.
+ * \param data The header data to parse.
+ * \return BMP_OK on successful parse else error code
+ */
+static bmp_result ico_header_parse(ico_collection *ico, uint8_t *data)
+{
+        uint16_t count, i;
+        bmp_result result;
+        int area, max_area = 0;
+
+        /* 6-byte ICO file header is:
+         *
+         *	+0	INT16	Reserved (should be 0)
+         *	+2	UINT16	Type (1 for ICO, 2 for CUR)
+         *	+4	UINT16	Number of BMPs to follow
+         */
+        if (ico->buffer_size < ICO_FILE_HEADER_SIZE)
+                return BMP_INSUFFICIENT_DATA;
+        //      if (read_int16(data, 2) != 0x0000)
+        //              return BMP_DATA_ERROR;
+        if (read_uint16(data, 2) != 0x0001)
+                return BMP_DATA_ERROR;
+        count = read_uint16(data, 4);
+        if (count == 0)
+                return BMP_DATA_ERROR;
+        data += ICO_FILE_HEADER_SIZE;
+
+        /* check if we have enough data for the directory */
+        if (ico->buffer_size < (uint32_t)(ICO_FILE_HEADER_SIZE + (ICO_DIR_ENTRY_SIZE * count)))
+                return BMP_INSUFFICIENT_DATA;
+
+        /* Decode the BMP files.
+         *
+         * 16-byte ICO directory entry is:
+         *
+         *	+0	UINT8	Width (0 for 256 pixels)
+         *	+1	UINT8	Height (0 for 256 pixels)
+         *	+2	UINT8	Colour count (0 if more than 256 colours)
+         *	+3	INT8	Reserved (should be 0, but may not be)
+         *	+4	UINT16	Colour Planes (should be 0 or 1)
+         *	+6	UINT16	Bits Per Pixel
+         *	+8	UINT32	Size of BMP info header + bitmap data in bytes
+         *	+12	UINT32	Offset (points to the BMP info header, not the bitmap data)
+         */
+        for (i = 0; i < count; i++) {
+                ico_image *image;
+                image = calloc(1, sizeof(ico_image));
+                if (!image)
+                        return BMP_INSUFFICIENT_MEMORY;
+                result = next_ico_image(ico, image);
+                if (result != BMP_OK)
+                        return result;
+                image->bmp.width = read_uint8(data, 0);
+                if (image->bmp.width == 0)
+                        image->bmp.width = 256;
+                image->bmp.height = read_uint8(data, 1);
+                if (image->bmp.height == 0)
+                        image->bmp.height = 256;
+                image->bmp.buffer_size = read_uint32(data, 8);
+                image->bmp.bmp_data = ico->ico_data + read_uint32(data, 12);
+                if (image->bmp.bmp_data + image->bmp.buffer_size >
+                    ico->ico_data + ico->buffer_size)
+                        return BMP_INSUFFICIENT_DATA;
+                image->bmp.ico = true;
+                data += ICO_DIR_ENTRY_SIZE;
+
+                /* Ensure that the bitmap data resides in the buffer */
+                if (image->bmp.bmp_data - ico->ico_data >= 0 &&
+                    (uint32_t)(image->bmp.bmp_data -
+                               ico->ico_data) >= ico->buffer_size)
+                        return BMP_DATA_ERROR;
+
+                /* Ensure that we have sufficient data to read the bitmap */
+                if (image->bmp.buffer_size - ICO_DIR_ENTRY_SIZE >=
+                    ico->buffer_size - (ico->ico_data - data))
+                        return BMP_INSUFFICIENT_DATA;
+
+                result = bmp_info_header_parse(&image->bmp,
+                                               image->bmp.bmp_data);
+                if (result != BMP_OK)
+                        return result;
+
+                /* adjust the size based on the images available */
+                area = image->bmp.width * image->bmp.height;
+                if (area > max_area) {
+                        ico->width = image->bmp.width;
+                        ico->height = image->bmp.height;
+                        max_area = area;
+                }
+        }
+        return BMP_OK;
+}
+
+
+/**
+ * Decode BMP data stored in 32bpp colour.
+ *
+ * \param bmp	the BMP image to decode
+ * \param start	the data to decode, updated to last byte read on success
+ * \param bytes	the number of bytes of data available
+ * \return	BMP_OK on success
+ *		BMP_INSUFFICIENT_DATA if the bitmap data ends unexpectedly;
+ *			in this case, the image may be partially viewable
+ */
+static bmp_result bmp_decode_rgb32(bmp_image *bmp, uint8_t **start, int bytes)
+{
+        uint8_t *top, *bottom, *end, *data;
+        uint32_t *scanline;
+        uint32_t x, y;
+        uint32_t swidth;
+        uint8_t i;
+        uint32_t word;
+
+        data = *start;
+        swidth = sizeof(uint32_t) * bmp->width;
+        top = bmp->bitmap_callbacks.bitmap_get_buffer(bmp->bitmap);
+        if (!top)
+                return BMP_INSUFFICIENT_MEMORY;
+        bottom = top + (uint64_t)swidth * (bmp->height - 1);
+        end = data + bytes;
+        bmp->decoded = true;
+
+        /* Determine transparent index */
+        if (bmp->limited_trans) {
+                if ((data + 4) > end)
+                        return BMP_INSUFFICIENT_DATA;
+                if (bmp->encoding == BMP_ENCODING_BITFIELDS)
+                        bmp->transparent_index = read_uint32(data, 0);
+                else
+                        bmp->transparent_index = data[2] | (data[1] << 8) | (data[0] << 16);
+        }
+
+        for (y = 0; y < bmp->height; y++) {
+                if ((data + (4 * bmp->width)) > end)
+                        return BMP_INSUFFICIENT_DATA;
+                if (bmp->reversed)
+                        scanline = (void *)(top + (y * swidth));
+                else
+                        scanline = (void *)(bottom - (y * swidth));
+                if (bmp->encoding == BMP_ENCODING_BITFIELDS) {
+                        for (x = 0; x < bmp->width; x++) {
+                                word = read_uint32(data, 0);
+                                for (i = 0; i < 4; i++)
+                                        if (bmp->shift[i] > 0)
+                                                scanline[x] |= ((word & bmp->mask[i]) << bmp->shift[i]);
+                                        else
+                                                scanline[x] |= ((word & bmp->mask[i]) >> (-bmp->shift[i]));
+                                /* 32-bit BMPs have alpha masks, but sometimes they're not utilized */
+                                if (bmp->opaque)
+                                        scanline[x] |= ((unsigned)0xff << 24);
+                                data += 4;
+                                scanline[x] = read_uint32((uint8_t *)&scanline[x],0);
+                        }
+                } else {
+                        for (x = 0; x < bmp->width; x++) {
+                                scanline[x] = data[2] | (data[1] << 8) | (data[0] << 16);
+                                if ((bmp->limited_trans) && (scanline[x] == bmp->transparent_index)) {
+                                        scanline[x] = bmp->trans_colour;
+                                }
+                                if (bmp->opaque) {
+                                        scanline[x] |= ((unsigned)0xff << 24);
+                                } else {
+                                        scanline[x] |= (unsigned)data[3] << 24;
+                                }
+                                data += 4;
+                                scanline[x] = read_uint32((uint8_t *)&scanline[x],0);
+                        }
+                }
+        }
+        *start = data;
+        return BMP_OK;
+}
+
+
+/**
+ * Decode BMP data stored in 24bpp colour.
+ *
+ * \param bmp	the BMP image to decode
+ * \param start	the data to decode, updated to last byte read on success
+ * \param bytes	the number of bytes of data available
+ * \return	BMP_OK on success
+ *		BMP_INSUFFICIENT_DATA if the bitmap data ends unexpectedly;
+ *			in this case, the image may be partially viewable
+ */
+static bmp_result bmp_decode_rgb24(bmp_image *bmp, uint8_t **start, int bytes)
+{
+        uint8_t *top, *bottom, *end, *data;
+        uint32_t *scanline;
+        uint32_t x, y;
+        uint32_t swidth;
+        uintptr_t addr;
+
+        data = *start;
+        swidth = sizeof(uint32_t) * bmp->width;
+        top = bmp->bitmap_callbacks.bitmap_get_buffer(bmp->bitmap);
+        if (!top) {
+                return BMP_INSUFFICIENT_MEMORY;
+        }
+
+        bottom = top + (uint64_t)swidth * (bmp->height - 1);
+        end = data + bytes;
+        addr = ((uintptr_t)data) & 3;
+        bmp->decoded = true;
+
+        /* Determine transparent index */
+        if (bmp->limited_trans) {
+                if ((data + 3) > end) {
+                        return BMP_INSUFFICIENT_DATA;
+                }
+
+                bmp->transparent_index = data[2] | (data[1] << 8) | (data[0] << 16);
+        }
+
+        for (y = 0; y < bmp->height; y++) {
+                if ((data + (3 * bmp->width)) > end) {
+                        return BMP_INSUFFICIENT_DATA;
+                }
+
+                if (bmp->reversed) {
+                        scanline = (void *)(top + (y * swidth));
+                } else {
+                        scanline = (void *)(bottom - (y * swidth));
+                }
+
+                for (x = 0; x < bmp->width; x++) {
+                        scanline[x] = data[2] | (data[1] << 8) | (data[0] << 16);
+                        if ((bmp->limited_trans) && (scanline[x] == bmp->transparent_index)) {
+                                scanline[x] = bmp->trans_colour;
+                        } else {
+                                scanline[x] |= ((uint32_t)0xff << 24);
+                        }
+                        data += 3;
+                        scanline[x] = read_uint32((uint8_t *)&scanline[x],0);
+                }
+
+                while (addr != (((uintptr_t)data) & 3)) {
+                        data++;
+                }
+        }
+        *start = data;
+        return BMP_OK;
+}
+
+
+/**
+ * Decode BMP data stored in 16bpp colour.
+ *
+ * \param bmp	the BMP image to decode
+ * \param start	the data to decode, updated to last byte read on success
+ * \param bytes	the number of bytes of data available
+ * \return	BMP_OK on success
+ *		BMP_INSUFFICIENT_DATA if the bitmap data ends unexpectedly;
+ *			in this case, the image may be partially viewable
+ */
+static bmp_result bmp_decode_rgb16(bmp_image *bmp, uint8_t **start, int bytes)
+{
+        uint8_t *top, *bottom, *end, *data;
+        uint32_t *scanline;
+        uint32_t x, y, swidth;
+        uintptr_t addr;
+        uint8_t i;
+        uint16_t word;
+
+        data = *start;
+        swidth = sizeof(uint32_t) * bmp->width;
+        top = bmp->bitmap_callbacks.bitmap_get_buffer(bmp->bitmap);
+        if (!top)
+                return BMP_INSUFFICIENT_MEMORY;
+        bottom = top + (uint64_t)swidth * (bmp->height - 1);
+        end = data + bytes;
+        addr = ((uintptr_t)data) & 3;
+        bmp->decoded = true;
+
+        /* Determine transparent index */
+        if (bmp->limited_trans) {
+                if ((data + 2) > end)
+                        return BMP_INSUFFICIENT_DATA;
+                bmp->transparent_index = read_uint16(data, 0);
+        }
+
+        for (y = 0; y < bmp->height; y++) {
+                if ((data + (2 * bmp->width)) > end)
+                        return BMP_INSUFFICIENT_DATA;
+                if (bmp->reversed)
+                        scanline = (void *)(top + (y * swidth));
+                else
+                        scanline = (void *)(bottom - (y * swidth));
+                if (bmp->encoding == BMP_ENCODING_BITFIELDS) {
+                        for (x = 0; x < bmp->width; x++) {
+                                word = read_uint16(data, 0);
+                                if ((bmp->limited_trans) && (word == bmp->transparent_index))
+                                        scanline[x] = bmp->trans_colour;
+                                else {
+                                        scanline[x] = 0;
+                                        for (i = 0; i < 4; i++)
+                                                if (bmp->shift[i] > 0)
+                                                        scanline[x] |= ((word & bmp->mask[i]) << bmp->shift[i]);
+                                                else
+                                                        scanline[x] |= ((word & bmp->mask[i]) >> (-bmp->shift[i]));
+                                        if (bmp->opaque)
+                                                scanline[x] |= ((unsigned)0xff << 24);
+                                }
+                                data += 2;
+                                scanline[x] = read_uint32((uint8_t *)&scanline[x],0);
+                        }
+                } else {
+                        for (x = 0; x < bmp->width; x++) {
+                                word = read_uint16(data, 0);
+                                if ((bmp->limited_trans) && (word == bmp->transparent_index))
+                                        scanline[x] = bmp->trans_colour;
+                                else {
+                                        /* 16-bit RGB defaults to RGB555 */
+                                        scanline[x] = ((word & (31 << 0)) << 19) |
+                                                      ((word & (31 << 5)) << 6) |
+                                                      ((word & (31 << 10)) >> 7);
+                                }
+                                if (bmp->opaque)
+                                        scanline[x] |= ((unsigned)0xff << 24);
+                                data += 2;
+                                scanline[x] = read_uint32((uint8_t *)&scanline[x],0);
+                        }
+                }
+                while (addr != (((uintptr_t)data) & 3))
+                        data += 2;
+        }
+        *start = data;
+        return BMP_OK;
+}
+
+
+/**
+ * Decode BMP data stored with a palette and in 8bpp colour or less.
+ *
+ * \param bmp	the BMP image to decode
+ * \param start	the data to decode, updated to last byte read on success
+ * \param bytes	the number of bytes of data available
+ * \return	BMP_OK on success
+ *		BMP_INSUFFICIENT_DATA if the bitmap data ends unexpectedly;
+ *			in this case, the image may be partially viewable
+ */
+static bmp_result bmp_decode_rgb(bmp_image *bmp, uint8_t **start, int bytes)
+{
+        uint8_t *top, *bottom, *end, *data;
+        uint32_t *scanline;
+        uintptr_t addr;
+        uint32_t x, y, swidth;
+        uint8_t bit_shifts[8];
+        uint8_t ppb = 8 / bmp->bpp;
+        uint8_t bit_mask = (1 << bmp->bpp) - 1;
+        uint8_t cur_byte = 0, bit, i;
+
+        for (i = 0; i < ppb; i++)
+                bit_shifts[i] = 8 - ((i + 1) * bmp->bpp);
+
+        data = *start;
+        swidth = sizeof(uint32_t) * bmp->width;
+        top = bmp->bitmap_callbacks.bitmap_get_buffer(bmp->bitmap);
+        if (!top)
+                return BMP_INSUFFICIENT_MEMORY;
+        bottom = top + (uint64_t)swidth * (bmp->height - 1);
+        end = data + bytes;
+        addr = ((uintptr_t)data) & 3;
+        bmp->decoded = true;
+
+        /* Determine transparent index */
+        if (bmp->limited_trans) {
+                uint32_t idx = (*data >> bit_shifts[0]) & bit_mask;
+                if (idx >= bmp->colours)
+                        return BMP_DATA_ERROR;
+                bmp->transparent_index = bmp->colour_table[idx];
+        }
+
+        for (y = 0; y < bmp->height; y++) {
+                bit = 8;
+                if ((data + ((bmp->width + ppb - 1) / ppb)) > end)
+                        return BMP_INSUFFICIENT_DATA;
+                if (bmp->reversed)
+                        scanline = (void *)(top + (y * swidth));
+                else
+                        scanline = (void *)(bottom - (y * swidth));
+                for (x = 0; x < bmp->width; x++) {
+                        uint32_t idx;
+                        if (bit >= ppb) {
+                                bit = 0;
+                                cur_byte = *data++;
+                        }
+                        idx = (cur_byte >> bit_shifts[bit++]) & bit_mask;
+                        if (idx < bmp->colours) {
+                                /* ensure colour table index is in bounds */
+                                scanline[x] = bmp->colour_table[idx];
+                                if ((bmp->limited_trans) &&
+                                    (scanline[x] == bmp->transparent_index)) {
+                                        scanline[x] = bmp->trans_colour;
+                                }
+                        }
+                }
+                while (addr != (((uintptr_t)data) & 3))
+                        data++;
+        }
+        *start = data;
+        return BMP_OK;
+}
+
+
+/**
+ * Decode a 1bpp mask for an ICO
+ *
+ * \param bmp	the BMP image to decode
+ * \param data	the data to decode
+ * \param bytes	the number of bytes of data available
+ * \return BMP_OK on success
+ */
+static bmp_result bmp_decode_mask(bmp_image *bmp, uint8_t *data, int bytes)
+{
+        uint8_t *top, *bottom, *end;
+        uint32_t *scanline;
+        uintptr_t addr;
+        uint32_t x, y, swidth;
+        uint32_t cur_byte = 0;
+
+        swidth = sizeof(uint32_t) * bmp->width;
+        top = bmp->bitmap_callbacks.bitmap_get_buffer(bmp->bitmap);
+        if (!top)
+                return BMP_INSUFFICIENT_MEMORY;
+        bottom = top + (uint64_t)swidth * (bmp->height - 1);
+        end = data + bytes;
+
+        addr = ((uintptr_t)data) & 3;
+
+        for (y = 0; y < bmp->height; y++) {
+                if ((data + (bmp->width >> 3)) > end)
+                        return BMP_INSUFFICIENT_DATA;
+                scanline = (void *)(bottom - (y * swidth));
+                for (x = 0; x < bmp->width; x++) {
+                        if ((x & 7) == 0)
+                                cur_byte = *data++;
+                        scanline[x] = read_uint32((uint8_t *)&scanline[x], 0);
+                        if ((cur_byte & 128) == 0) {
+                                scanline[x] |= ((unsigned)0xff << 24);
+                        } else {
+                                scanline[x] &= 0xffffff;
+                        }
+                        scanline[x] = read_uint32((uint8_t *)&scanline[x], 0);
+                        cur_byte = cur_byte << 1;
+                }
+                while (addr != (((uintptr_t)data) & 3))
+                        data++;
+        }
+        return BMP_OK;
+}
+
+
+/**
+ * Decode BMP data stored encoded in RLE8.
+ *
+ * \param bmp	the BMP image to decode
+ * \param data	the data to decode
+ * \param bytes	the number of bytes of data available
+ * \return	BMP_OK on success
+ *		BMP_INSUFFICIENT_DATA if the bitmap data ends unexpectedly;
+ *			in this case, the image may be partially viewable
+ */
+static bmp_result
+bmp_decode_rle8(bmp_image *bmp, uint8_t *data, int bytes)
+{
+        uint8_t *top, *bottom, *end;
+        uint32_t *scanline;
+        uint32_t swidth;
+        uint32_t i, length, pixels_left;
+        uint32_t x = 0, y = 0, last_y = 0;
+        uint32_t pixel = 0;
+
+        if (bmp->ico)
+                return BMP_DATA_ERROR;
+
+        swidth = sizeof(uint32_t) * bmp->width;
+        top = bmp->bitmap_callbacks.bitmap_get_buffer(bmp->bitmap);
+        if (!top)
+                return BMP_INSUFFICIENT_MEMORY;
+        bottom = top + (uint64_t)swidth * (bmp->height - 1);
+        end = data + bytes;
+        bmp->decoded = true;
+
+        do {
+                if (data + 2 > end)
+                        return BMP_INSUFFICIENT_DATA;
+                length = *data++;
+                if (length == 0) {
+                        length = *data++;
+                        switch (length) {
+                        case 0:
+                                /* 00 - 00 means end of scanline */
+                                x = 0;
+                                if (last_y == y) {
+                                        y++;
+                                        if (y >= bmp->height)
+                                                return BMP_DATA_ERROR;
+                                }
+                                last_y = y;
+                                break;
+
+                        case 1:
+                                /* 00 - 01 means end of RLE data */
+                                return BMP_OK;
+
+                        case 2:
+                                /* 00 - 02 - XX - YY means move cursor */
+                                if (data + 2 > end)
+                                        return BMP_INSUFFICIENT_DATA;
+                                x += *data++;
+                                if (x >= bmp->width)
+                                        return BMP_DATA_ERROR;
+                                y += *data++;
+                                if (y >= bmp->height)
+                                        return BMP_DATA_ERROR;
+                                break;
+
+                        default:
+                                /* 00 - NN means escape NN pixels */
+                                if (bmp->reversed) {
+                                        pixels_left = (bmp->height - y) * bmp->width - x;
+                                        scanline = (void *)(top + (y * swidth));
+                                } else {
+                                        pixels_left = (y + 1) * bmp->width - x;
+                                        scanline = (void *)(bottom - (y * swidth));
+                                }
+                                if (length > pixels_left)
+                                        length = pixels_left;
+                                if (data + length > end)
+                                        return BMP_INSUFFICIENT_DATA;
+
+                                /* the following code could be easily optimised
+                                 * by simply checking the bounds on entry and
+                                 * using some simple copying routines if so
+                                 */
+                                for (i = 0; i < length; i++) {
+                                        uint32_t idx = (uint32_t) *data++;
+                                        if (x >= bmp->width) {
+                                                x = 0;
+                                                y++;
+                                                if (y >= bmp->height)
+                                                        return BMP_DATA_ERROR;
+                                                if (bmp->reversed) {
+                                                        scanline += bmp->width;
+                                                } else {
+                                                        scanline -= bmp->width;
+                                                }
+                                        }
+                                        if (idx >= bmp->colours)
+                                                return BMP_DATA_ERROR;
+                                        scanline[x++] = bmp->colour_table[idx];
+                                }
+
+                                if ((length & 1) && (*data++ != 0x00))
+                                        return BMP_DATA_ERROR;
+
+                                break;
+                        }
+                } else {
+                        uint32_t idx;
+
+                        /* NN means perform RLE for NN pixels */
+                        if (bmp->reversed) {
+                                pixels_left = (bmp->height - y) * bmp->width - x;
+                                scanline = (void *)(top + (y * swidth));
+                        } else {
+                                pixels_left = (y + 1) * bmp->width - x;
+                                scanline = (void *)(bottom - (y * swidth));
+                        }
+                        if (length > pixels_left)
+                                length = pixels_left;
+
+                        /* boundary checking */
+                        if (data + 1 > end)
+                                return BMP_INSUFFICIENT_DATA;
+
+                        /* the following code could be easily optimised by
+                         * simply checking the bounds on entry and using some
+                         * simply copying routines if so
+                         */
+                        idx = (uint32_t) *data++;
+                        if (idx >= bmp->colours)
+                                return BMP_DATA_ERROR;
+
+                        pixel = bmp->colour_table[idx];
+                        for (i = 0; i < length; i++) {
+                                if (x >= bmp->width) {
+                                        x = 0;
+                                        y++;
+                                        if (y >= bmp->height)
+                                                return BMP_DATA_ERROR;
+                                        if (bmp->reversed) {
+                                                scanline += bmp->width;
+                                        } else {
+                                                scanline -= bmp->width;
+                                        }
+                                }
+                                scanline[x++] = pixel;
+                        }
+                }
+        } while (data < end);
+
+        return BMP_OK;
+}
+
+
+/**
+ * Decode BMP data stored encoded in RLE4.
+ *
+ * \param bmp	the BMP image to decode
+ * \param data	the data to decode
+ * \param bytes	the number of bytes of data available
+ * \return	BMP_OK on success
+ *		BMP_INSUFFICIENT_DATA if the bitmap data ends unexpectedly;
+ *			in this case, the image may be partially viewable
+ */
+static bmp_result
+bmp_decode_rle4(bmp_image *bmp, uint8_t *data, int bytes)
+{
+        uint8_t *top, *bottom, *end;
+        uint32_t *scanline;
+        uint32_t swidth;
+        uint32_t i, length, pixels_left;
+        uint32_t x = 0, y = 0, last_y = 0;
+        uint32_t pixel = 0, pixel2;
+
+        if (bmp->ico)
+                return BMP_DATA_ERROR;
+
+        swidth = sizeof(uint32_t) * bmp->width;
+        top = bmp->bitmap_callbacks.bitmap_get_buffer(bmp->bitmap);
+        if (!top)
+                return BMP_INSUFFICIENT_MEMORY;
+        bottom = top + (uint64_t)swidth * (bmp->height - 1);
+        end = data + bytes;
+        bmp->decoded = true;
+
+        do {
+                if (data + 2 > end)
+                        return BMP_INSUFFICIENT_DATA;
+                length = *data++;
+                if (length == 0) {
+                        length = *data++;
+                        switch (length) {
+                        case 0:
+                                /* 00 - 00 means end of scanline */
+                                x = 0;
+                                if (last_y == y) {
+                                        y++;
+                                        if (y >= bmp->height)
+                                                return BMP_DATA_ERROR;
+                                }
+                                last_y = y;
+                                break;
+
+                        case 1:
+                                /* 00 - 01 means end of RLE data */
+                                return BMP_OK;
+
+                        case 2:
+                                /* 00 - 02 - XX - YY means move cursor */
+                                if (data + 2 > end)
+                                        return BMP_INSUFFICIENT_DATA;
+                                x += *data++;
+                                if (x >= bmp->width)
+                                        return BMP_DATA_ERROR;
+                                y += *data++;
+                                if (y >= bmp->height)
+                                        return BMP_DATA_ERROR;
+                                break;
+
+                        default:
+                                /* 00 - NN means escape NN pixels */
+                                if (bmp->reversed) {
+                                        pixels_left = (bmp->height - y) * bmp->width - x;
+                                        scanline = (void *)(top + (y * swidth));
+                                } else {
+                                        pixels_left = (y + 1) * bmp->width - x;
+                                        scanline = (void *)(bottom - (y * swidth));
+                                }
+                                if (length > pixels_left)
+                                        length = pixels_left;
+                                if (data + ((length + 1) / 2) > end)
+                                        return BMP_INSUFFICIENT_DATA;
+
+                                /* the following code could be easily optimised
+                                 * by simply checking the bounds on entry and
+                                 * using some simple copying routines
+                                 */
+
+                                for (i = 0; i < length; i++) {
+                                        if (x >= bmp->width) {
+                                                x = 0;
+                                                y++;
+                                                if (y >= bmp->height)
+                                                        return BMP_DATA_ERROR;
+                                                if (bmp->reversed) {
+                                                        scanline += bmp->width;
+                                                } else {
+                                                        scanline -= bmp->width;
+                                                }
+
+                                        }
+                                        if ((i & 1) == 0) {
+                                                pixel = *data++;
+                                                if ((pixel >> 4) >= bmp->colours)
+                                                        return BMP_DATA_ERROR;
+                                                scanline[x++] = bmp->colour_table
+                                                                [pixel >> 4];
+                                        } else {
+                                                if ((pixel & 0xf) >= bmp->colours)
+                                                        return BMP_DATA_ERROR;
+                                                scanline[x++] = bmp->colour_table
+                                                                [pixel & 0xf];
+                                        }
+                                }
+                                length = (length + 1) >> 1;
+
+                                if ((length & 1) && (*data++ != 0x00))
+                                        return BMP_DATA_ERROR;
+
+                                break;
+                        }
+                } else {
+                        /* NN means perform RLE for NN pixels */
+                        if (bmp->reversed) {
+                                pixels_left = (bmp->height - y) * bmp->width - x;
+                                scanline = (void *)(top + (y * swidth));
+                        } else {
+                                pixels_left = (y + 1) * bmp->width - x;
+                                scanline = (void *)(bottom - (y * swidth));
+                        }
+                        if (length > pixels_left)
+                                length = pixels_left;
+
+                        /* boundary checking */
+                        if (data + 1 > end)
+                                return BMP_INSUFFICIENT_DATA;
+
+                        /* the following code could be easily optimised by
+                         * simply checking the bounds on entry and using some
+                         * simple copying routines
+                         */
+
+                        pixel2 = *data++;
+                        if ((pixel2 >> 4) >= bmp->colours ||
+                            (pixel2 & 0xf) >= bmp->colours)
+                                return BMP_DATA_ERROR;
+                        pixel = bmp->colour_table[pixel2 >> 4];
+                        pixel2 = bmp->colour_table[pixel2 & 0xf];
+                        for (i = 0; i < length; i++) {
+                                if (x >= bmp->width) {
+                                        x = 0;
+                                        y++;
+                                        if (y >= bmp->height)
+                                                return BMP_DATA_ERROR;
+                                        if (bmp->reversed) {
+                                                scanline += bmp->width;
+                                        } else {
+                                                scanline -= bmp->width;
+                                        }
+                                }
+                                if ((i & 1) == 0)
+                                        scanline[x++] = pixel;
+                                else
+                                        scanline[x++] = pixel2;
+                        }
+
+                }
+        } while (data < end);
+
+        return BMP_OK;
+}
+
+
+/* exported interface documented in libnsbmp.h */
+bmp_result
+bmp_create(bmp_image *bmp,
+           bmp_bitmap_callback_vt *bitmap_callbacks)
+{
+        memset(bmp, 0, sizeof(bmp_image));
+        bmp->bitmap_callbacks = *bitmap_callbacks;
+
+        return BMP_OK;
+}
+
+
+/* exported interface documented in libnsbmp.h */
+bmp_result
+ico_collection_create(ico_collection *ico,
+                      bmp_bitmap_callback_vt *bitmap_callbacks)
+{
+
+        memset(ico, 0, sizeof(ico_collection));
+        ico->bitmap_callbacks = *bitmap_callbacks;
+
+        return BMP_OK;
+}
+
+
+/* exported interface documented in libnsbmp.h */
+bmp_result bmp_analyse(bmp_image *bmp, size_t size, uint8_t *data)
+{
+        bmp_result res;
+
+        /* ensure we aren't already initialised */
+        if (bmp->bitmap) {
+                return BMP_OK;
+        }
+
+        /* initialize source data values */
+        bmp->buffer_size = size;
+        bmp->bmp_data = data;
+
+        res = bmp_file_header_parse(bmp, data);
+        if (res == BMP_OK) {
+                res = bmp_info_header_parse(bmp, data + BMP_FILE_HEADER_SIZE);
+        }
+        return res;
+}
+
+
+/* exported interface documented in libnsbmp.h */
+bmp_result ico_analyse(ico_collection *ico, size_t size, uint8_t *data)
+{
+        /* ensure we aren't already initialised */
+        if (ico->first)
+                return BMP_OK;
+
+        /* initialize values */
+        ico->buffer_size = size;
+        ico->ico_data = data;
+
+        return ico_header_parse(ico, data);
+}
+
+
+/* exported interface documented in libnsbmp.h */
+bmp_result bmp_decode(bmp_image *bmp)
+{
+        uint8_t *data;
+        uint32_t bytes;
+        bmp_result result = BMP_OK;
+
+        data = bmp->bmp_data + bmp->bitmap_offset;
+        bytes = bmp->buffer_size - bmp->bitmap_offset;
+
+        switch (bmp->encoding) {
+        case BMP_ENCODING_RGB:
+                switch (bmp->bpp) {
+                case 32:
+                        result = bmp_decode_rgb32(bmp, &data, bytes);
+                        break;
+
+                case 24:
+                        result = bmp_decode_rgb24(bmp, &data, bytes);
+                        break;
+
+                case 16:
+                        result = bmp_decode_rgb16(bmp, &data, bytes);
+                        break;
+
+                default:
+                        result = bmp_decode_rgb(bmp, &data, bytes);
+                        break;
+                }
+                break;
+
+        case BMP_ENCODING_RLE8:
+                result = bmp_decode_rle8(bmp, data, bytes);
+                break;
+
+        case BMP_ENCODING_RLE4:
+                result = bmp_decode_rle4(bmp, data, bytes);
+                break;
+
+        case BMP_ENCODING_BITFIELDS:
+                switch (bmp->bpp) {
+                case 32:
+                        result = bmp_decode_rgb32(bmp, &data, bytes);
+                        break;
+
+                case 16:
+                        result = bmp_decode_rgb16(bmp, &data, bytes);
+                        break;
+
+                default:
+                        result = BMP_DATA_ERROR;
+                        break;
+                }
+                break;
+        }
+
+        /* icons with less than 32bpp have a 1bpp alpha mask */
+        if ((result == BMP_OK) && (bmp->ico) && (bmp->bpp != 32)) {
+                bytes = (uintptr_t)bmp->bmp_data + bmp->buffer_size - (uintptr_t)data;
+                result = bmp_decode_mask(bmp, data, bytes);
+        }
+        return result;
+}
+
+
+/* exported interface documented in libnsbmp.h */
+bmp_result bmp_decode_trans(bmp_image *bmp, uint32_t colour)
+{
+        bmp->limited_trans = true;
+        bmp->trans_colour = colour;
+        return bmp_decode(bmp);
+}
+
+
+/* exported interface documented in libnsbmp.h */
+bmp_image *ico_find(ico_collection *ico, uint16_t width, uint16_t height)
+{
+        bmp_image *bmp = NULL;
+        ico_image *image;
+        int x, y, cur, distance = (1 << 24);
+
+        if (width == 0)
+                width = ico->width;
+        if (height == 0)
+                height = ico->height;
+        for (image = ico->first; image; image = image->next) {
+                if ((image->bmp.width == width) && (image->bmp.height == height))
+                        return &image->bmp;
+                x = image->bmp.width - width;
+                y = image->bmp.height - height;
+                cur = (x * x) + (y * y);
+                if (cur < distance) {
+                        distance = cur;
+                        bmp = &image->bmp;
+                }
+        }
+        return bmp;
+}
+
+
+/* exported interface documented in libnsbmp.h */
+void bmp_finalise(bmp_image *bmp)
+{
+        if (bmp->bitmap)
+                bmp->bitmap_callbacks.bitmap_destroy(bmp->bitmap);
+        bmp->bitmap = NULL;
+        if (bmp->colour_table)
+                free(bmp->colour_table);
+        bmp->colour_table = NULL;
+}
+
+
+/* exported interface documented in libnsbmp.h */
+void ico_finalise(ico_collection *ico)
+{
+        ico_image *image;
+
+        for (image = ico->first; image; image = image->next)
+                bmp_finalise(&image->bmp);
+        while (ico->first) {
+                image = ico->first;
+                ico->first = image->next;
+                free(image);
+        }
+}
diff --git a/drivers/video/drm/libnsbmp.h b/drivers/video/drm/libnsbmp.h
new file mode 100644
index 0000000000..4f750c472c
--- /dev/null
+++ b/drivers/video/drm/libnsbmp.h
@@ -0,0 +1,252 @@
+/*
+ * Copyright 2006 Richard Wilson <richard.wilson@netsurf-browser.org>
+ * Copyright 2008 Sean Fox <dyntryx@gmail.com>
+ *
+ * This file is part of NetSurf's libnsbmp, http://www.netsurf-browser.org/
+ * Licenced under the MIT License,
+ *                http://www.opensource.org/licenses/mit-license.php
+ */
+
+/**
+ * \file
+ * Bitmap file decoding interface.
+ */
+
+#ifndef _LIBNSBMP_H_
+#define _LIBNSBMP_H_
+
+#include <common.h>
+#include <malloc.h>
+#include <linux/types.h>
+
+#ifndef INT32_MAX
+#define INT32_MAX               (2147483647)
+#endif
+
+/* bmp flags */
+#define BMP_NEW			0
+/** image is opaque (as opposed to having an alpha mask) */
+#define BMP_OPAQUE		(1 << 0)
+/** memory should be wiped */
+#define BMP_CLEAR_MEMORY	(1 << 1)
+
+/**
+ * error return values
+ */
+typedef enum {
+        BMP_OK = 0,
+        BMP_INSUFFICIENT_MEMORY = 1,
+        BMP_INSUFFICIENT_DATA = 2,
+        BMP_DATA_ERROR = 3
+} bmp_result;
+
+/**
+ * encoding types
+ */
+typedef enum {
+        BMP_ENCODING_RGB = 0,
+        BMP_ENCODING_RLE8 = 1,
+        BMP_ENCODING_RLE4 = 2,
+        BMP_ENCODING_BITFIELDS = 3
+} bmp_encoding;
+
+/* API for Bitmap callbacks */
+typedef void* (*bmp_bitmap_cb_create)(int width, int height, unsigned int state);
+typedef void (*bmp_bitmap_cb_destroy)(void *bitmap);
+typedef unsigned char* (*bmp_bitmap_cb_get_buffer)(void *bitmap);
+typedef size_t (*bmp_bitmap_cb_get_bpp)(void *bitmap);
+
+/**
+ * The Bitmap callbacks function table
+ */
+typedef struct bmp_bitmap_callback_vt_s {
+        /** Callback to allocate bitmap storage. */
+        bmp_bitmap_cb_create bitmap_create;
+        /** Called to free bitmap storage. */
+        bmp_bitmap_cb_destroy bitmap_destroy;
+        /** Return a pointer to the pixel data in a bitmap. */
+        bmp_bitmap_cb_get_buffer bitmap_get_buffer;
+} bmp_bitmap_callback_vt;
+
+/**
+ * bitmap image
+ */
+typedef struct bmp_img {
+        /** callbacks for bitmap functions */
+        bmp_bitmap_callback_vt bitmap_callbacks;
+        /** pointer to BMP data */
+        uint8_t *bmp_data;
+        /** width of BMP (valid after _analyse) */
+        uint32_t width;
+        /** heigth of BMP (valid after _analyse) */
+        uint32_t height;
+        /** whether the image has been decoded */
+        bool decoded;
+        /** decoded image */
+        void *bitmap;
+
+        /* Internal members are listed below */
+        /** total number of bytes of BMP data available */
+        uint32_t buffer_size;
+        /** pixel encoding type */
+        bmp_encoding encoding;
+        /** offset of bitmap data */
+        uint32_t bitmap_offset;
+        /** bits per pixel */
+        uint16_t bpp;
+        /** number of colours */
+        uint32_t colours;
+        /** colour table */
+        uint32_t *colour_table;
+        /** whether to use bmp's limited transparency */
+        bool limited_trans;
+        /** colour to display for "transparent" pixels when using limited
+         * transparency
+         */
+        uint32_t trans_colour;
+        /** scanlines are top to bottom */
+        bool reversed;
+        /** image is part of an ICO, mask follows */
+        bool ico;
+        /** true if the bitmap does not contain an alpha channel */
+        bool opaque;
+        /** four bitwise mask */
+        uint32_t mask[4];
+        /** four bitwise shifts */
+        int32_t shift[4];
+        /** colour representing "transparency" in the bitmap */
+        uint32_t transparent_index;
+} bmp_image;
+
+typedef struct ico_image {
+        bmp_image bmp;
+        struct ico_image *next;
+} ico_image;
+
+/**
+ * icon image collection
+ */
+typedef struct ico_collection {
+        /** callbacks for bitmap functions */
+        bmp_bitmap_callback_vt bitmap_callbacks;
+        /** width of largest BMP */
+        uint16_t width;
+        /** heigth of largest BMP */
+        uint16_t height;
+
+        /* Internal members are listed below */
+        /** pointer to ICO data */
+        uint8_t *ico_data;
+        /** total number of bytes of ICO data available */
+        uint32_t buffer_size;
+        /** root of linked list of images */
+        ico_image *first;
+} ico_collection;
+
+/**
+ * Initialises bitmap ready for analysing the bitmap.
+ *
+ * \param bmp The Bitmap to initialise
+ * \param callbacks The callbacks the library will call on operations.
+ * \return BMP_OK on success or appropriate error code.
+ */
+bmp_result bmp_create(bmp_image *bmp, bmp_bitmap_callback_vt *callbacks);
+
+/**
+ * Initialises icon ready for analysing the icon
+ *
+ * \param bmp The Bitmap to initialise
+ * \param callbacks The callbacks the library will call on operations.
+ * \return BMP_OK on success or appropriate error code.
+ */
+bmp_result ico_collection_create(ico_collection *ico,
+                                 bmp_bitmap_callback_vt *callbacks);
+
+/**
+ * Analyse a BMP prior to decoding.
+ *
+ * This will scan the data provided and perform checks to ensure the data is a
+ * valid BMP and prepare the bitmap image structure ready for decode.
+ *
+ * This function must be called and resturn BMP_OK before bmp_decode() as it
+ * prepares the bmp internal state for the decode process.
+ *
+ * \param bmp the BMP image to analyse.
+ * \param size The size of data in cdata.
+ * \param data The bitmap source data.
+ * \return BMP_OK on success or error code on faliure.
+ */
+bmp_result bmp_analyse(bmp_image *bmp, size_t size, uint8_t *data);
+
+/**
+ * Analyse an ICO prior to decoding.
+ *
+ * This function will scan the data provided and perform checks to ensure the
+ * data is a valid ICO.
+ *
+ * This function must be called before ico_find().
+ *
+ * \param ico the ICO image to analyse
+ * \param size The size of data in cdata.
+ * \param data The bitmap source data.
+ * \return BMP_OK on success
+ */
+bmp_result ico_analyse(ico_collection *ico, size_t size, uint8_t *data);
+
+/**
+ * Decode a BMP
+ *
+ * This function decodes the BMP data such that bmp->bitmap is a valid
+ * image. The state of bmp->decoded is set to TRUE on exit such that it
+ * can easily be identified which BMPs are in a fully decoded state.
+ *
+ * \param bmp the BMP image to decode
+ * \return BMP_OK on success
+ */
+bmp_result bmp_decode(bmp_image *bmp);
+
+/**
+ * Decode a BMP using "limited transparency"
+ *
+ * Bitmaps do not have native transparency support.  However, there is a
+ * "trick" that is used in some instances in which the first pixel of the
+ * bitmap becomes the "transparency index".  The decoding application can
+ * replace this index with whatever background colour it chooses to
+ * create the illusion of transparency.
+ *
+ * When to use transparency is at the discretion of the decoding
+ * application.
+ *
+ * \param bmp the BMP image to decode
+ * \param colour the colour to use as "transparent"
+ * \return BMP_OK on success
+ */
+bmp_result bmp_decode_trans(bmp_image *bmp, uint32_t transparent_colour);
+
+/**
+ * Finds the closest BMP within an ICO collection
+ *
+ * This function finds the BMP with dimensions as close to a specified set
+ * as possible from the images in the collection.
+ *
+ * \param ico the ICO collection to examine
+ * \param width the preferred width (0 to use ICO header width)
+ * \param height the preferred height (0 to use ICO header height)
+ */
+bmp_image *ico_find(ico_collection *ico, uint16_t width, uint16_t height);
+
+/**
+ * Finalise a BMP prior to destruction.
+ *
+ * \param bmp the BMP image to finalise.
+ */
+void bmp_finalise(bmp_image *bmp);
+
+/**
+ * Finalise an ICO prior to destruction.
+ *
+ * \param ico the ICO image to finalise,
+ */
+void ico_finalise(ico_collection *ico);
+
+#endif
diff --git a/drivers/video/drm/max96745.c b/drivers/video/drm/max96745.c
new file mode 100644
index 0000000000..3750f4d7fe
--- /dev/null
+++ b/drivers/video/drm/max96745.c
@@ -0,0 +1,139 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * (C) Copyright 2022 Rockchip Electronics Co., Ltd
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <errno.h>
+#include <i2c.h>
+#include <max96745.h>
+#include <video_bridge.h>
+#include <linux/iopoll.h>
+
+#include "rockchip_bridge.h"
+#include "rockchip_display.h"
+#include "rockchip_panel.h"
+
+static bool max96745_bridge_link_locked(struct udevice *dev)
+{
+	int ret;
+
+	ret = dm_i2c_reg_read(dev->parent, 0x002a);
+	if (ret < 0)
+		return false;
+
+	if (!FIELD_GET(LINK_LOCKED, ret))
+		return false;
+
+	return true;
+}
+
+static bool max96745_bridge_detect(struct rockchip_bridge *bridge)
+{
+	return max96745_bridge_link_locked(bridge->dev);
+}
+
+static void max96745_bridge_enable(struct rockchip_bridge *bridge)
+{
+	struct udevice *dev = bridge->dev;
+	struct drm_display_mode *mode = &bridge->state->conn_state.mode;
+	u8 cxtp, tx_rate;
+	int ret;
+
+	ret = dm_i2c_reg_read(dev->parent, 0x0011);
+	if (ret < 0)
+		return;
+
+	cxtp = FIELD_GET(CXTP_A, ret);
+
+	ret = dm_i2c_reg_read(dev->parent, 0x0028);
+	if (ret < 0)
+		return;
+
+	tx_rate = FIELD_GET(TX_RATE, ret);
+
+	if (!cxtp && mode->clock > 95000 && tx_rate == 1) {
+		ret = dm_i2c_reg_clrset(dev->parent, 0x0028, TX_RATE,
+					FIELD_PREP(TX_RATE, 2));
+		if (ret < 0)
+			return;
+
+		ret = dm_i2c_reg_clrset(dev->parent, 0x0029, RESET_ONESHOT,
+					FIELD_PREP(RESET_ONESHOT, 1));
+		if (ret < 0)
+			return;
+
+		if (readx_poll_timeout(max96745_bridge_link_locked, dev, ret,
+				       ret, 200000))
+			dev_err(dev, "%s: GMSL link not locked\n", __func__);
+	}
+}
+
+static void max96745_bridge_post_disable(struct rockchip_bridge *bridge)
+{
+	struct udevice *dev = bridge->dev;
+	u8 cxtp, tx_rate;
+	int ret;
+
+	ret = dm_i2c_reg_read(dev->parent, 0x0011);
+	if (ret < 0)
+		return;
+
+	cxtp = FIELD_GET(CXTP_A, ret);
+
+	ret = dm_i2c_reg_read(dev->parent, 0x0028);
+	if (ret < 0)
+		return;
+
+	tx_rate = FIELD_GET(TX_RATE, ret);
+
+	if (!cxtp && tx_rate == 2) {
+		ret = dm_i2c_reg_clrset(dev->parent, 0x0028, TX_RATE,
+					FIELD_PREP(TX_RATE, 1));
+		if (ret < 0)
+			return;
+
+		ret = dm_i2c_reg_clrset(dev->parent, 0x0029, RESET_ONESHOT,
+					FIELD_PREP(RESET_ONESHOT, 1));
+		if (ret < 0)
+			return;
+
+		if (readx_poll_timeout(max96745_bridge_link_locked, dev, ret,
+				       ret, 200000))
+			dev_err(dev, "%s: GMSL link not locked\n", __func__);
+	}
+}
+
+static const struct rockchip_bridge_funcs max96745_bridge_funcs = {
+	.detect		= max96745_bridge_detect,
+	.enable		= max96745_bridge_enable,
+	.post_disable	= max96745_bridge_post_disable,
+};
+
+static int max96745_bridge_probe(struct udevice *dev)
+{
+	struct rockchip_bridge *bridge;
+
+	bridge = calloc(1, sizeof(*bridge));
+	if (!bridge)
+		return -ENOMEM;
+
+	dev->driver_data = (ulong)bridge;
+	bridge->dev = dev;
+	bridge->funcs = &max96745_bridge_funcs;
+
+	return 0;
+}
+
+static const struct udevice_id max96745_bridge_of_match[] = {
+	{ .compatible = "maxim,max96745-bridge", },
+	{ }
+};
+
+U_BOOT_DRIVER(max96745_bridge) = {
+	.name = "max96745_bridge",
+	.id = UCLASS_VIDEO_BRIDGE,
+	.of_match = max96745_bridge_of_match,
+	.probe = max96745_bridge_probe,
+};
diff --git a/drivers/video/drm/max96755f.c b/drivers/video/drm/max96755f.c
new file mode 100644
index 0000000000..1e0ec08f4f
--- /dev/null
+++ b/drivers/video/drm/max96755f.c
@@ -0,0 +1,234 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * (C) Copyright 2022 Rockchip Electronics Co., Ltd
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <errno.h>
+#include <i2c.h>
+#include <max96755f.h>
+#include <video_bridge.h>
+#include <drm/drm_mipi_dsi.h>
+#include <dm/of_access.h>
+#include <linux/media-bus-format.h>
+
+#include "rockchip_bridge.h"
+#include "rockchip_display.h"
+#include "rockchip_panel.h"
+
+static void max96755f_mipi_dsi_rx_config(struct max96755f_priv *priv)
+{
+	struct drm_display_mode *mode = &priv->mode;
+	u32 hfp, hsa, hbp, hact;
+	u32 vact, vsa, vfp, vbp;
+	u8 lane_map;
+
+	dm_i2c_reg_clrset(priv->dev, 0x0331, NUM_LANES,
+			  FIELD_PREP(NUM_LANES, priv->num_lanes - 1));
+
+	lane_map = (priv->dsi_lane_map[0] & 0xff) << 4 |
+		   (priv->dsi_lane_map[1] & 0xff) << 6 |
+		   (priv->dsi_lane_map[2] & 0xff) << 0 |
+		   (priv->dsi_lane_map[3] & 0xff) << 2;
+
+	dm_i2c_reg_write(priv->dev, 0x0332, lane_map);
+
+	if (!priv->dpi_deskew_en)
+		return;
+
+	vact = mode->vdisplay;
+	vsa = mode->vsync_end - mode->vsync_start;
+	vfp = mode->vsync_start - mode->vdisplay;
+	vbp = mode->vtotal - mode->vsync_end;
+	hact = mode->hdisplay;
+	hsa = mode->hsync_end - mode->hsync_start;
+	hfp = mode->hsync_start - mode->hdisplay;
+	hbp = mode->htotal - mode->hsync_end;
+	dm_i2c_reg_write(priv->dev, 0x03A4, 0xc1);
+	dm_i2c_reg_write(priv->dev, 0x0385, FIELD_PREP(DPI_HSYNC_WIDTH_L, hsa));
+	dm_i2c_reg_write(priv->dev, 0x0386, FIELD_PREP(DPI_VYSNC_WIDTH_L, vsa));
+	dm_i2c_reg_write(priv->dev, 0x0387,
+			 FIELD_PREP(DPI_VSYNC_WIDTH_H, (vsa >> 8)) |
+			 FIELD_PREP(DPI_HSYNC_WIDTH_H, (hsa >> 8)));
+	dm_i2c_reg_write(priv->dev, 0x03a5, FIELD_PREP(DPI_VFP_L, vfp));
+	dm_i2c_reg_write(priv->dev, 0x03a6,
+			 FIELD_PREP(DPI_VBP_L, vbp) |
+			 FIELD_PREP(DPI_VFP_H, (vfp >> 8)));
+	dm_i2c_reg_write(priv->dev, 0x03a7, FIELD_PREP(DPI_VBP_H, (vbp >> 4)));
+	dm_i2c_reg_write(priv->dev, 0x03a8, FIELD_PREP(DPI_VACT_L, vact));
+	dm_i2c_reg_write(priv->dev, 0x03a9, FIELD_PREP(DPI_VACT_H, (vact >> 8)));
+	dm_i2c_reg_write(priv->dev, 0x03aa, FIELD_PREP(DPI_HFP_L, hfp));
+	dm_i2c_reg_write(priv->dev, 0x03ab,
+			 FIELD_PREP(DPI_HBP_L, hbp) |
+			 FIELD_PREP(DPI_HFP_H, (hfp >> 7)));
+	dm_i2c_reg_write(priv->dev, 0x03ac, FIELD_PREP(DPI_HBP_H, (hbp >> 4)));
+	dm_i2c_reg_write(priv->dev, 0x03ad, FIELD_PREP(DPI_HACT_L, hact));
+	dm_i2c_reg_write(priv->dev, 0x03ae, FIELD_PREP(DPI_HACT_H, (hact >> 8)));
+}
+
+static void max96755f_bridge_enable(struct rockchip_bridge *bridge)
+{
+	struct udevice *dev = bridge->dev;
+	struct max96755f_priv *priv = dev_get_priv(dev->parent);
+
+	max96755f_mipi_dsi_rx_config(priv);
+	if (priv->split_mode) {
+		dm_i2c_reg_clrset(dev->parent, 0x0010,
+				  RESET_ONESHOT | AUTO_LINK | LINK_CFG,
+				  FIELD_PREP(RESET_ONESHOT, 1) |
+				  FIELD_PREP(AUTO_LINK, 0) |
+				  FIELD_PREP(LINK_CFG, SPLITTER_MODE));
+		mdelay(50);
+		dm_i2c_reg_clrset(dev->parent, 0x0053,
+				  TX_SPLIT_MASK_B | TX_SPLIT_MASK_A | TX_STR_SEL,
+				  FIELD_PREP(TX_SPLIT_MASK_B, 0) |
+				  FIELD_PREP(TX_SPLIT_MASK_A, 1) |
+				  FIELD_PREP(TX_STR_SEL, 0));
+		dm_i2c_reg_clrset(dev->parent, 0x0057,
+				  TX_SPLIT_MASK_B | TX_SPLIT_MASK_A | TX_STR_SEL,
+				  FIELD_PREP(TX_SPLIT_MASK_B, 1) |
+				  FIELD_PREP(TX_SPLIT_MASK_A, 0) |
+				  FIELD_PREP(TX_STR_SEL, 1));
+		dm_i2c_reg_clrset(dev->parent, 0x032a,
+				  DV_SWP_AB | DV_CONV | DV_SPL | DV_EN,
+				  FIELD_PREP(DV_SWP_AB, priv->dv_swp_ab) |
+				  FIELD_PREP(DV_CONV, 1) |
+				  FIELD_PREP(DV_SPL, 1) |
+				  FIELD_PREP(DV_EN, 1));
+		dm_i2c_reg_clrset(dev->parent, 0x0311,
+				  START_PORTAX | START_PORTAY,
+				  FIELD_PREP(START_PORTAX, 1) |
+				  FIELD_PREP(START_PORTAY, 1));
+		dm_i2c_reg_clrset(dev->parent, 0x0002,
+				  VID_TX_EN_X | VID_TX_EN_Y,
+				  FIELD_PREP(VID_TX_EN_X, 1) |
+				  FIELD_PREP(VID_TX_EN_Y, 1));
+
+	} else {
+		dm_i2c_reg_clrset(dev->parent, 0x0002, VID_TX_EN_X,
+				  FIELD_PREP(VID_TX_EN_X, 1));
+		dm_i2c_reg_clrset(dev->parent, 0x0311, START_PORTAX,
+				  FIELD_PREP(START_PORTAX, 1));
+	}
+
+	dm_i2c_reg_clrset(dev->parent, 0x0010, RESET_ONESHOT,
+			  FIELD_PREP(RESET_ONESHOT, 1));
+	mdelay(100);
+}
+
+static void max96755f_bridge_disable(struct rockchip_bridge *bridge)
+{
+	struct udevice *dev = bridge->dev;
+	struct max96755f_priv *priv = dev_get_priv(dev->parent);
+
+	dm_i2c_reg_clrset(dev->parent, 0x0002, VID_TX_EN_X,
+			  FIELD_PREP(VID_TX_EN_X, 0));
+
+	if (priv->split_mode)
+		dm_i2c_reg_clrset(dev->parent, 0x0010,
+				  AUTO_LINK | LINK_CFG,
+				  FIELD_PREP(AUTO_LINK, 0) |
+				  FIELD_PREP(LINK_CFG, LINKA));
+}
+
+static void max96755f_bridge_mode_set(struct rockchip_bridge *bridge,
+				      const struct drm_display_mode *mode)
+{
+	struct udevice *dev = bridge->dev;
+	struct max96755f_priv *priv = dev_get_priv(dev->parent);
+
+	memcpy(&priv->mode, mode, sizeof(struct drm_display_mode));
+}
+
+static bool max96755f_bridge_detect(struct rockchip_bridge *bridge)
+{
+	struct max96755f_priv *priv = dev_get_priv(bridge->dev->parent);
+
+	if (!dm_gpio_get_value(&priv->lock_gpio))
+		return false;
+
+	return true;
+}
+
+static const struct rockchip_bridge_funcs max96755f_bridge_funcs = {
+	.enable = max96755f_bridge_enable,
+	.disable = max96755f_bridge_disable,
+	.mode_set = max96755f_bridge_mode_set,
+	.detect = max96755f_bridge_detect,
+};
+
+static int max96755f_bridge_bind(struct udevice *dev)
+{
+	struct mipi_dsi_device *device = dev_get_platdata(dev);
+
+	device->dev = dev;
+	device->lanes = dev_read_u32_default(dev, "dsi,lanes", 4);
+	device->format = dev_read_u32_default(dev, "dsi,format",
+					      MIPI_DSI_FMT_RGB888);
+	device->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_SYNC_PULSE;
+	device->channel = dev_read_u32_default(dev, "reg", 0);
+
+	return 0;
+}
+
+static int max96755f_bridge_probe(struct udevice *dev)
+{
+	struct rockchip_bridge *bridge;
+	struct max96755f_priv *priv = dev_get_priv(dev->parent);
+	const struct device_node *np = ofnode_to_np(dev->node);
+	int i, len, ret;
+
+	bridge = calloc(1, sizeof(*bridge));
+	if (!bridge)
+		return -ENOMEM;
+
+	dev->driver_data = (ulong)bridge;
+	bridge->dev = dev;
+	bridge->funcs = &max96755f_bridge_funcs;
+
+	priv->num_lanes = dev_read_u32_default(dev, "dsi,lanes", 4);
+	priv->dv_swp_ab = dev_read_bool(dev, "vd-swap-ab");
+	priv->dpi_deskew_en = dev_read_bool(dev, "dpi-deskew-en");
+
+	for ( i = 0; i < priv->num_lanes; i++)
+		priv->dsi_lane_map[i] = i;
+
+	if (of_find_property(np, "maxim,dsi-lane-map", &len)) {
+		len /= sizeof(u32);
+		if (priv->num_lanes != len) {
+			printf("invalid number of lane map\n");
+			return -EINVAL;
+		}
+	}
+
+	ret = of_read_u32_array(np, "maxim,dsi-lane-map",
+				priv->dsi_lane_map, priv->num_lanes);
+	if (ret) {
+		printf("get dsi lane map failed\n");
+		return -EINVAL;
+	}
+
+	ret = gpio_request_by_name(dev, "lock-gpios", 0, &priv->lock_gpio,
+				   GPIOD_IS_IN);
+	if (ret) {
+		dev_err(dev, "failed to get lock GPIO: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static const struct udevice_id max96755f_bridge_of_match[] = {
+	{ .compatible = "maxim,max96755f-bridge", },
+	{ }
+};
+
+U_BOOT_DRIVER(max96755f_bridge) = {
+	.name = "max96755f_bridge",
+	.id = UCLASS_VIDEO_BRIDGE,
+	.of_match = max96755f_bridge_of_match,
+	.probe = max96755f_bridge_probe,
+	.bind = max96755f_bridge_bind,
+	.platdata_auto_alloc_size = sizeof(struct mipi_dsi_device),
+};
diff --git a/drivers/video/drm/panel-maxim-max96752f.c b/drivers/video/drm/panel-maxim-max96752f.c
new file mode 100644
index 0000000000..0c28231ed4
--- /dev/null
+++ b/drivers/video/drm/panel-maxim-max96752f.c
@@ -0,0 +1,303 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Maxim MAX96752F GMSL2 Deserializer
+ *
+ * (C) Copyright 2022 Rockchip Electronics Co., Ltd
+ */
+
+#include <config.h>
+#include <common.h>
+#include <backlight.h>
+#include <errno.h>
+#include <malloc.h>
+#include <video.h>
+
+#include <asm/gpio.h>
+#include <dm/device.h>
+#include <dm/read.h>
+#include <dm/pinctrl.h>
+#include <dm/uclass-id.h>
+#include <linux/media-bus-format.h>
+
+#include "rockchip_display.h"
+#include "rockchip_panel.h"
+
+struct max96752f;
+
+struct panel_desc {
+	const char *name;
+	int (*prepare)(struct max96752f *max96752f);
+	int (*unprepare)(struct max96752f *max96752f);
+	int (*enable)(struct max96752f *max96752f);
+	int (*disable)(struct max96752f *max96752f);
+	int (*backlight_enable)(struct max96752f *max96752f);
+	int (*backlight_disable)(struct max96752f *max96752f);
+};
+
+struct max96752f {
+	struct udevice *dev;
+	struct udevice *serializer;
+	struct udevice *backlight;
+
+	const struct panel_desc *desc;
+};
+
+static void max96752f_panel_prepare(struct rockchip_panel *panel)
+{
+	struct max96752f *max96752f = dev_get_priv(panel->dev);
+	const struct panel_desc *desc = max96752f->desc;
+
+	if (desc->prepare)
+		desc->prepare(max96752f);
+}
+
+static void max96752f_panel_unprepare(struct rockchip_panel *panel)
+{
+	struct max96752f *max96752f = dev_get_priv(panel->dev);
+	const struct panel_desc *desc = max96752f->desc;
+
+	if (desc->unprepare)
+		desc->unprepare(max96752f);
+}
+
+static void max96752f_panel_enable(struct rockchip_panel *panel)
+{
+	struct max96752f *max96752f = dev_get_priv(panel->dev);
+	const struct panel_desc *desc = max96752f->desc;
+
+	if (desc->enable)
+		desc->enable(max96752f);
+
+	if (max96752f->backlight)
+		backlight_enable(max96752f->backlight);
+
+	if (desc->backlight_enable)
+		desc->backlight_enable(max96752f);
+}
+
+static void max96752f_panel_disable(struct rockchip_panel *panel)
+{
+	struct max96752f *max96752f = dev_get_priv(panel->dev);
+	const struct panel_desc *desc = max96752f->desc;
+
+	if (desc->backlight_disable)
+		desc->backlight_disable(max96752f);
+
+	if (max96752f->backlight)
+		backlight_disable(max96752f->backlight);
+
+	if (desc->disable)
+		desc->disable(max96752f);
+}
+
+static const struct rockchip_panel_funcs max96752f_panel_funcs = {
+	.prepare = max96752f_panel_prepare,
+	.unprepare = max96752f_panel_unprepare,
+	.enable = max96752f_panel_enable,
+	.disable = max96752f_panel_disable,
+};
+
+static int max96752f_probe(struct udevice *dev)
+{
+	struct max96752f *max96752f = dev_get_priv(dev);
+	struct rockchip_panel *panel;
+	int ret;
+
+	ret = i2c_set_chip_offset_len(dev, 2);
+	if (ret)
+		return ret;
+
+	max96752f->dev = dev;
+	max96752f->serializer = dev->parent->parent;
+	max96752f->desc = (const struct panel_desc *)dev_get_driver_data(dev);
+
+	ret = uclass_get_device_by_phandle(UCLASS_PANEL_BACKLIGHT, dev,
+					   "backlight", &max96752f->backlight);
+	if (ret && ret != -ENOENT) {
+		dev_err(dev, "%s: Cannot get backlight: %d\n", __func__, ret);
+		return ret;
+	}
+
+	panel = calloc(1, sizeof(*panel));
+	if (!panel)
+		return -ENOMEM;
+
+	dev->driver_data = (ulong)panel;
+	panel->dev = dev;
+	panel->bus_format = MEDIA_BUS_FMT_RGB888_1X24;
+	panel->funcs = &max96752f_panel_funcs;
+
+	return 0;
+}
+
+#define maxim_serializer_write(max96752f, reg, val) do {	\
+		int ret;					\
+		ret = dm_i2c_reg_write(max96752f->serializer,	\
+				       reg, val);		\
+		if (ret)					\
+			return ret;				\
+	} while (0)
+
+#define maxim_deserializer_write(max96752f, reg, val) do {	\
+		int ret;					\
+		ret = dm_i2c_reg_write(max96752f->dev,		\
+				       reg, val);		\
+		if (ret)					\
+			return ret;				\
+	} while (0)
+
+static int boe_av156fht_l83_panel_prepare(struct max96752f *max96752f)
+{
+	maxim_deserializer_write(max96752f, 0x0002, 0x43);
+	maxim_deserializer_write(max96752f, 0x0140, 0x20);
+
+	maxim_deserializer_write(max96752f, 0x01ce, 0x5e);	/* oldi */
+	maxim_deserializer_write(max96752f, 0x020c, 0x84);	/* bl_pwm */
+	maxim_deserializer_write(max96752f, 0x0206, 0x83);	/* tp_int */
+
+	maxim_deserializer_write(max96752f, 0x0215, 0x90);	/* lcd_en */
+	mdelay(20);
+
+	return 0;
+}
+
+static int boe_av156fht_l83_panel_unprepare(struct max96752f *max96752f)
+{
+	maxim_deserializer_write(max96752f, 0x0215, 0x80);	/* lcd_en */
+
+	return 0;
+}
+
+static int boe_av156fht_l83_panel_enable(struct max96752f *max96752f)
+{
+	maxim_deserializer_write(max96752f, 0x0227, 0x90);	/* lcd_rst */
+	mdelay(20);
+	maxim_deserializer_write(max96752f, 0x020f, 0x90);	/* tp_rst */
+	mdelay(100);
+	maxim_deserializer_write(max96752f, 0x0221, 0x90);	/* lcd_stb */
+	mdelay(60);
+	maxim_deserializer_write(max96752f, 0x0212, 0x90);	/* bl_current_ctl */
+	maxim_deserializer_write(max96752f, 0x0209, 0x90);	/* bl_en */
+
+	return 0;
+}
+
+static int boe_av156fht_l83_panel_disable(struct max96752f *max96752f)
+{
+	maxim_deserializer_write(max96752f, 0x0209, 0x80);	/* bl_en */
+	maxim_deserializer_write(max96752f, 0x0212, 0x80);	/* bl_current_ctl */
+	maxim_deserializer_write(max96752f, 0x0221, 0x80);	/* lcd_stb */
+	maxim_deserializer_write(max96752f, 0x020f, 0x80);	/* tp_rst */
+	maxim_deserializer_write(max96752f, 0x0227, 0x80);	/* lcd_rst */
+
+	return 0;
+}
+
+static int boe_av156fht_l83_panel_backlight_enable(struct max96752f *max96752f)
+{
+	maxim_deserializer_write(max96752f, 0x0212, 0x90);	/* bl_current_ctl */
+	maxim_deserializer_write(max96752f, 0x0209, 0x90);	/* bl_en */
+
+	return 0;
+}
+
+static int boe_av156fht_l83_panel_backlight_disable(struct max96752f *max96752f)
+{
+	maxim_deserializer_write(max96752f, 0x0209, 0x80);	/* bl_en */
+	maxim_deserializer_write(max96752f, 0x0212, 0x80);	/* bl_current_ctl */
+
+	return 0;
+}
+
+static const struct panel_desc boe_av156fht_l83 = {
+	.name			= "boe-av156fht-l83",
+	.prepare		= boe_av156fht_l83_panel_prepare,
+	.unprepare		= boe_av156fht_l83_panel_unprepare,
+	.enable			= boe_av156fht_l83_panel_enable,
+	.disable		= boe_av156fht_l83_panel_disable,
+	.backlight_enable	= boe_av156fht_l83_panel_backlight_enable,
+	.backlight_disable	= boe_av156fht_l83_panel_backlight_disable,
+};
+
+static int hannstar_hsd123jpw3_a15_prepare(struct max96752f *max96752f)
+{
+	maxim_deserializer_write(max96752f, 0x0002, 0x43);
+	maxim_deserializer_write(max96752f, 0x0140, 0x20);
+	maxim_deserializer_write(max96752f, 0x01ce, 0x5e);
+
+	maxim_deserializer_write(max96752f, 0x0203, 0x83);	/* GPIO1  <- TP_INT */
+	maxim_deserializer_write(max96752f, 0x0206, 0x84);      /* GPIO2  -> TP_RST */
+	maxim_deserializer_write(max96752f, 0x0224, 0x84);	/* GPIO12 -> LCD_BL_PWM */
+
+	return 0;
+}
+
+static int hannstar_hsd123jpw3_a15_unprepare(struct max96752f *max96752f)
+{
+	return 0;
+}
+
+static int hannstar_hsd123jpw3_a15_enable(struct max96752f *max96752f)
+{
+	maxim_deserializer_write(max96752f, 0x0221, 0x10);	/* GPIO11 -> LCD_RESET */
+	mdelay(20);
+
+	return 0;
+}
+
+static int hannstar_hsd123jpw3_a15_disable(struct max96752f *max96752f)
+{
+	maxim_deserializer_write(max96752f, 0x0221, 0x00);	/* GPIO11 -> LCD_RESET */
+	mdelay(20);
+
+	return 0;
+}
+
+static const struct panel_desc hannstar_hsd123jpw3_a15 = {
+	.name			= "hannstar,hsd123jpw3-a15",
+	.prepare		= hannstar_hsd123jpw3_a15_prepare,
+	.unprepare		= hannstar_hsd123jpw3_a15_unprepare,
+	.enable			= hannstar_hsd123jpw3_a15_enable,
+	.disable		= hannstar_hsd123jpw3_a15_disable,
+};
+
+static int ogm_101fhbllm01_prepare(struct max96752f *max96752f)
+{
+	maxim_deserializer_write(max96752f, 0x01ce, 0x5e);
+
+	maxim_deserializer_write(max96752f, 0x0203, 0x84);	/* GPIO1 -> BL_PWM */
+	maxim_deserializer_write(max96752f, 0x0206, 0x84);	/* GPIO2 -> TP_RST */
+	maxim_deserializer_write(max96752f, 0x0209, 0x83);	/* GPIO3 <- TP_INT */
+
+	maxim_deserializer_write(max96752f, 0x0001, 0x02);
+
+	return 0;
+}
+
+static int ogm_101fhbllm01_unprepare(struct max96752f *max96752f)
+{
+	maxim_deserializer_write(max96752f, 0x0001, 0x01);
+
+	return 0;
+}
+
+static const struct panel_desc ogm_101fhbllm01 = {
+	.name			= "ogm,101fhbllm01",
+	.prepare		= ogm_101fhbllm01_prepare,
+	.unprepare		= ogm_101fhbllm01_unprepare,
+};
+
+static const struct udevice_id max96752f_of_match[] = {
+	{ .compatible = "boe,av156fht-l83", .data = (ulong)&boe_av156fht_l83 },
+	{ .compatible = "hannstar,hsd123jpw3-a15", .data = (ulong)&hannstar_hsd123jpw3_a15 },
+	{ .compatible = "ogm,101fhbllm01", .data = (ulong)&ogm_101fhbllm01 },
+	{}
+};
+
+U_BOOT_DRIVER(max96752f) = {
+	.name = "max96752f",
+	.id = UCLASS_PANEL,
+	.of_match = max96752f_of_match,
+	.probe = max96752f_probe,
+	.priv_auto_alloc_size = sizeof(struct max96752f),
+};
diff --git a/drivers/video/drm/panel-rohm-bu18rl82.c b/drivers/video/drm/panel-rohm-bu18rl82.c
new file mode 100644
index 0000000000..24792ad74e
--- /dev/null
+++ b/drivers/video/drm/panel-rohm-bu18rl82.c
@@ -0,0 +1,349 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Rohm BU18RL82-based panel driver
+ *
+ * (C) Copyright 2022 Rockchip Electronics Co., Ltd
+ */
+
+#include <config.h>
+#include <common.h>
+#include <backlight.h>
+#include <errno.h>
+#include <malloc.h>
+#include <video.h>
+
+#include <asm/gpio.h>
+#include <dm/device.h>
+#include <dm/read.h>
+#include <dm/pinctrl.h>
+#include <dm/uclass-id.h>
+#include <linux/media-bus-format.h>
+
+#include "rockchip_display.h"
+#include "rockchip_panel.h"
+
+struct bu18rl82;
+
+struct panel_desc {
+	const char *name;
+	int (*prepare)(struct bu18rl82 *rl82);
+	int (*unprepare)(struct bu18rl82 *rl82);
+	int (*enable)(struct bu18rl82 *rl82);
+	int (*disable)(struct bu18rl82 *rl82);
+	int (*backlight_enable)(struct bu18rl82 *rl82);
+	int (*backlight_disable)(struct bu18rl82 *rl82);
+};
+
+struct bu18rl82 {
+	struct udevice *dev;
+	struct udevice *backlight;
+	const struct panel_desc *desc;
+};
+
+static void bu18rl82_panel_prepare(struct rockchip_panel *panel)
+{
+	struct bu18rl82 *rl82 = dev_get_priv(panel->dev);
+	const struct panel_desc *desc = rl82->desc;
+
+	if (desc->prepare)
+		desc->prepare(rl82);
+}
+
+static void bu18rl82_panel_unprepare(struct rockchip_panel *panel)
+{
+	struct bu18rl82 *rl82 = dev_get_priv(panel->dev);
+	const struct panel_desc *desc = rl82->desc;
+
+	if (desc->unprepare)
+		desc->unprepare(rl82);
+}
+
+static void bu18rl82_panel_enable(struct rockchip_panel *panel)
+{
+	struct bu18rl82 *rl82 = dev_get_priv(panel->dev);
+	const struct panel_desc *desc = rl82->desc;
+
+	if (desc->enable)
+		desc->enable(rl82);
+
+	if (rl82->backlight)
+		backlight_enable(rl82->backlight);
+
+	if (desc->backlight_enable)
+		desc->backlight_enable(rl82);
+}
+
+static void bu18rl82_panel_disable(struct rockchip_panel *panel)
+{
+	struct bu18rl82 *rl82 = dev_get_priv(panel->dev);
+	const struct panel_desc *desc = rl82->desc;
+
+	if (desc->backlight_disable)
+		desc->backlight_disable(rl82);
+
+	if (rl82->backlight)
+		backlight_disable(rl82->backlight);
+
+	if (desc->disable)
+		desc->disable(rl82);
+}
+
+static const struct rockchip_panel_funcs bu18rl82_panel_funcs = {
+	.prepare = bu18rl82_panel_prepare,
+	.unprepare = bu18rl82_panel_unprepare,
+	.enable = bu18rl82_panel_enable,
+	.disable = bu18rl82_panel_disable,
+};
+
+static int bu18rl82_probe(struct udevice *dev)
+{
+	struct bu18rl82 *rl82 = dev_get_priv(dev);
+	struct rockchip_panel *panel;
+	int ret;
+
+	ret = i2c_set_chip_offset_len(dev, 2);
+	if (ret)
+		return ret;
+
+	rl82->dev = dev;
+	rl82->desc = (const struct panel_desc *)dev_get_driver_data(dev);
+
+	ret = uclass_get_device_by_phandle(UCLASS_PANEL_BACKLIGHT, dev,
+					   "backlight", &rl82->backlight);
+	if (ret && ret != -ENOENT) {
+		dev_err(dev, "%s: Cannot get backlight: %d\n", __func__, ret);
+		return ret;
+	}
+
+	panel = calloc(1, sizeof(*panel));
+	if (!panel)
+		return -ENOMEM;
+
+	dev->driver_data = (ulong)panel;
+	panel->dev = dev;
+	panel->bus_format = MEDIA_BUS_FMT_RGB888_1X24;
+	panel->funcs = &bu18rl82_panel_funcs;
+
+	return 0;
+}
+
+#define rohm_deserializer_write(rl82, reg, val) do {			\
+		int ret;						\
+		ret = dm_i2c_reg_write(rl82->dev, reg, val);		\
+		if (ret) {						\
+			dev_err(rl82->dev,				\
+				"failed to set register 0x%04x\n",	\
+				reg);					\
+			return ret;					\
+		}							\
+	} while (0)
+
+static int csot_mg1561b01_prepare(struct bu18rl82 *rl82)
+{
+	const struct reg_sequence {
+		u16 reg;
+		u8 def;
+	} regs[] = {
+		{ 0x0011, 0x03 }, { 0x0012, 0x03 },
+		{ 0x001f, 0x02 }, { 0x0020, 0x02 },
+		{ 0x0031, 0x41 }, { 0x0032, 0x41 },
+		{ 0x0073, 0x80 }, { 0x0074, 0x07 },
+		{ 0x007b, 0x38 }, { 0x007c, 0x04 },
+		{ 0x0079, 0x0a },
+		{ 0x0429, 0x0a }, { 0x045d, 0x01 },
+		{ 0x0529, 0x0a }, { 0x055d, 0x01 },
+		{ 0x060a, 0xb0 }, { 0x060b, 0xff }, { 0x060c, 0xff },
+		{ 0x0644, 0x18 }, { 0x0645, 0x01 }, { 0x0646, 0x2d },
+	};
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(regs); i++)
+		rohm_deserializer_write(rl82, regs[i].reg, regs[i].def);
+
+	/* BL_PWM - GPIO0 */
+	rohm_deserializer_write(rl82, 0x0057, 0x00);
+	rohm_deserializer_write(rl82, 0x0058, 0x02);
+
+	/* TP_INT - GPIO3 */
+	rohm_deserializer_write(rl82, 0x0060, 0x08);
+	rohm_deserializer_write(rl82, 0x042e, 0x05);
+
+	/* TP_RST - GPIO4 */
+	rohm_deserializer_write(rl82, 0x0063, 0x00);
+	rohm_deserializer_write(rl82, 0x0064, 0x01);
+
+	return 0;
+}
+
+static int csot_mg1561b01_unprepare(struct bu18rl82 *rl82)
+{
+	/* TP_RST - GPIO4 */
+	rohm_deserializer_write(rl82, 0x0064, 0x00);
+
+	return 0;
+}
+
+static int csot_mg1561b01_enable(struct bu18rl82 *rl82)
+{
+	rohm_deserializer_write(rl82, 0x0091, 0x03);
+	rohm_deserializer_write(rl82, 0x0090, 0x01);
+
+	return 0;
+}
+
+static int csot_mg1561b01_disable(struct bu18rl82 *rl82)
+{
+	rohm_deserializer_write(rl82, 0x0090, 0x00);
+	rohm_deserializer_write(rl82, 0x0091, 0x00);
+
+	return 0;
+}
+
+static int csot_mg1561b01_backlight_enable(struct bu18rl82 *rl82)
+{
+	/* BL_EN - GPIO1 */
+	rohm_deserializer_write(rl82, 0x005a, 0x00);
+	rohm_deserializer_write(rl82, 0x005b, 0x01);
+
+	return 0;
+}
+
+static int csot_mg1561b01_backlight_disable(struct bu18rl82 *rl82)
+{
+	/* BL_EN - GPIO1 */
+	rohm_deserializer_write(rl82, 0x005b, 0x00);
+
+	return 0;
+}
+
+static const struct panel_desc csot_mg1561b01 = {
+	.name			= "csot,mg1561b01",
+	.prepare		= csot_mg1561b01_prepare,
+	.unprepare		= csot_mg1561b01_unprepare,
+	.enable			= csot_mg1561b01_enable,
+	.disable		= csot_mg1561b01_disable,
+	.backlight_enable	= csot_mg1561b01_backlight_enable,
+	.backlight_disable	= csot_mg1561b01_backlight_disable,
+};
+
+static int touch_china_v123awf3_r1_prepare(struct bu18rl82 *rl82)
+{
+	const struct reg_sequence {
+		u16 reg;
+		u8 def;
+	} regs[] = {
+		{ 0x0011, 0x03 }, { 0x0012, 0x03 },
+		{ 0x001f, 0x02 }, { 0x0020, 0x02 },
+		{ 0x0031, 0x48 }, { 0x0032, 0x48 },
+		{ 0x0073, 0x80 }, { 0x0074, 0x07 },
+		{ 0x007b, 0xd0 }, { 0x007c, 0x02 },
+		{ 0x0079, 0x0a },
+		{ 0x0429, 0x0a }, { 0x045d, 0x01 },
+		{ 0x0529, 0x0a }, { 0x055d, 0x01 },
+		{ 0x060a, 0xb0 }, { 0x060b, 0xff }, { 0x060c, 0xff },
+		{ 0x0644, 0x90 }, { 0x0646, 0xd2 },
+	};
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(regs); i++)
+		rohm_deserializer_write(rl82, regs[i].reg, regs[i].def);
+
+	/* TP_INT - GPIO4 */
+	rohm_deserializer_write(rl82, 0x0063, 0x08);
+	rohm_deserializer_write(rl82, 0x042f, 0x06);
+
+	/* TP_RST - GPIO3 */
+	rohm_deserializer_write(rl82, 0x0060, 0x00);
+	rohm_deserializer_write(rl82, 0x0061, 0x00);
+
+	/* LCD_BIAS_EN - GPIO2 */
+	rohm_deserializer_write(rl82, 0x005d, 0x00);
+	rohm_deserializer_write(rl82, 0x005e, 0x01);
+	mdelay(6);
+
+	return 0;
+}
+
+static int touch_china_v123awf3_r1_unprepare(struct bu18rl82 *rl82)
+{
+	/* LCD_BIAS_EN - GPIO2 */
+	rohm_deserializer_write(rl82, 0x005e, 0x00);
+
+	return 0;
+}
+
+static int touch_china_v123awf3_r1_enable(struct bu18rl82 *rl82)
+{
+	rohm_deserializer_write(rl82, 0x0091, 0x03);
+	rohm_deserializer_write(rl82, 0x0090, 0x01);
+
+	/* RSEX - GPIO5 */
+	rohm_deserializer_write(rl82, 0x0066, 0x00);
+	rohm_deserializer_write(rl82, 0x0067, 0x01);
+	/* TP_RST - GPIO3 */
+	rohm_deserializer_write(rl82, 0x0060, 0x00);
+	rohm_deserializer_write(rl82, 0x0061, 0x01);
+	mdelay(20);
+	/* LCD_PON - GPIO1 */
+	rohm_deserializer_write(rl82, 0x005a, 0x00);
+	rohm_deserializer_write(rl82, 0x005b, 0x01);
+
+	return 0;
+}
+
+static int touch_china_v123awf3_r1_disable(struct bu18rl82 *rl82)
+{
+	rohm_deserializer_write(rl82, 0x0090, 0x00);
+	rohm_deserializer_write(rl82, 0x0091, 0x00);
+
+	/* LCD_PON - GPIO1 */
+	rohm_deserializer_write(rl82, 0x005b, 0x00);
+	mdelay(100);
+	/* TP_RST - GPIO3 */
+	rohm_deserializer_write(rl82, 0x0061, 0x00);
+	/* RSEX - GPIO5 */
+	rohm_deserializer_write(rl82, 0x0067, 0x00);
+
+	return 0;
+}
+
+static int touch_china_v123awf3_r1_backlight_enable(struct bu18rl82 *rl82)
+{
+	/* BL_PWM - GPIO0 */
+	rohm_deserializer_write(rl82, 0x0057, 0x00);
+	rohm_deserializer_write(rl82, 0x0058, 0x02);
+
+	return 0;
+}
+
+static int touch_china_v123awf3_r1_backlight_disable(struct bu18rl82 *rl82)
+{
+	/* BL_PWM - GPIO0 */
+	rohm_deserializer_write(rl82, 0x0058, 0x00);
+
+	return 0;
+}
+
+static const struct panel_desc touch_china_v123awf3_r1 = {
+	.name			= "touch-china,v123awf3-r1",
+	.prepare		= touch_china_v123awf3_r1_prepare,
+	.unprepare		= touch_china_v123awf3_r1_unprepare,
+	.enable			= touch_china_v123awf3_r1_enable,
+	.disable		= touch_china_v123awf3_r1_disable,
+	.backlight_enable	= touch_china_v123awf3_r1_backlight_enable,
+	.backlight_disable	= touch_china_v123awf3_r1_backlight_disable,
+};
+
+static const struct udevice_id bu18rl82_of_match[] = {
+	{ .compatible = "csot,mg1561b01", .data = (ulong)&csot_mg1561b01 },
+	{ .compatible = "touch-china,v123awf3-r1", .data = (ulong)&touch_china_v123awf3_r1 },
+	{}
+};
+
+U_BOOT_DRIVER(panel_rohm_bu18rl82) = {
+	.name = "panel-rohm-bu18rl82",
+	.id = UCLASS_PANEL,
+	.of_match = bu18rl82_of_match,
+	.probe = bu18rl82_probe,
+	.priv_auto_alloc_size = sizeof(struct bu18rl82),
+};
diff --git a/drivers/video/drm/phy-rockchip-samsung-hdptx-hdmi.c b/drivers/video/drm/phy-rockchip-samsung-hdptx-hdmi.c
new file mode 100644
index 0000000000..b15bfd14ff
--- /dev/null
+++ b/drivers/video/drm/phy-rockchip-samsung-hdptx-hdmi.c
@@ -0,0 +1,2118 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Rockchip HDMI/DP Combo PHY with Samsung IP block
+ *
+ * Copyright (c) 2021 Rockchip Electronics Co. Ltd.
+ */
+
+#include <common.h>
+#include <clk-uclass.h>
+#include <dm.h>
+#include <reset.h>
+#include <regmap.h>
+#include <syscon.h>
+#include <asm/io.h>
+#include <linux/bitfield.h>
+#include <linux/rational.h>
+#include <linux/iopoll.h>
+#include <asm/arch/clock.h>
+#include <dm/lists.h>
+#include <dm/device_compat.h>
+#include <dm/of_access.h>
+
+#include "rockchip_display.h"
+#include "rockchip_crtc.h"
+#include "rockchip_phy.h"
+
+#define UPDATE(x, h, l)		(((x) << (l)) & GENMASK((h), (l)))
+
+#define GRF_HDPTX_CON0			0x00
+#define LC_REF_CLK_SEL			BIT(11)
+#define HDPTX_I_PLL_EN			BIT(7)
+#define HDPTX_I_BIAS_EN			BIT(6)
+#define HDPTX_I_BGR_EN			BIT(5)
+#define GRF_HDPTX_STATUS		0x80
+#define HDPTX_O_PLL_LOCK_DONE		BIT(3)
+#define HDPTX_O_PHY_CLK_RDY		BIT(2)
+#define HDPTX_O_PHY_RDY			BIT(1)
+#define HDPTX_O_SB_RDY			BIT(0)
+
+#define CMN_REG0000			0x0000
+#define CMN_REG0001			0x0004
+#define CMN_REG0002			0x0008
+#define CMN_REG0003			0x000C
+#define CMN_REG0004			0x0010
+#define CMN_REG0005			0x0014
+#define CMN_REG0006			0x0018
+#define CMN_REG0007			0x001C
+#define CMN_REG0008			0x0020
+#define LCPLL_EN_MASK			BIT(6)
+#define LCPLL_EN(x)			UPDATE(x, 4, 4)
+#define LCPLL_LCVCO_MODE_EN_MASK	BIT(4)
+#define LCPLL_LCVCO_MODE_EN(x)		UPDATE(x, 4, 4)
+#define CMN_REG0009			0x0024
+#define CMN_REG000A			0x0028
+#define CMN_REG000B			0x002C
+#define CMN_REG000C			0x0030
+#define CMN_REG000D			0x0034
+#define CMN_REG000E			0x0038
+#define CMN_REG000F			0x003C
+#define CMN_REG0010			0x0040
+#define CMN_REG0011			0x0044
+#define CMN_REG0012			0x0048
+#define CMN_REG0013			0x004C
+#define CMN_REG0014			0x0050
+#define CMN_REG0015			0x0054
+#define CMN_REG0016			0x0058
+#define CMN_REG0017			0x005C
+#define CMN_REG0018			0x0060
+#define CMN_REG0019			0x0064
+#define CMN_REG001A			0x0068
+#define CMN_REG001B			0x006C
+#define CMN_REG001C			0x0070
+#define CMN_REG001D			0x0074
+#define CMN_REG001E			0x0078
+#define LCPLL_PI_EN_MASK		BIT(5)
+#define LCPLL_PI_EN(x)			UPDATE(x, 5, 5)
+#define LCPLL_100M_CLK_EN_MASK		BIT(0)
+#define LCPLL_100M_CLK_EN(x)		UPDATE(x, 0, 0)
+#define CMN_REG001F			0x007C
+#define CMN_REG0020			0x0080
+#define CMN_REG0021			0x0084
+#define CMN_REG0022			0x0088
+#define CMN_REG0023			0x008C
+#define CMN_REG0024			0x0090
+#define CMN_REG0025			0x0094
+#define LCPLL_PMS_IQDIV_RSTN		BIT(4)
+#define CMN_REG0026			0x0098
+#define CMN_REG0027			0x009C
+#define CMN_REG0028			0x00A0
+#define LCPLL_SDC_FRAC_EN		BIT(2)
+#define LCPLL_SDC_FRAC_RSTN		BIT(0)
+#define CMN_REG0029			0x00A4
+#define CMN_REG002A			0x00A8
+#define CMN_REG002B			0x00AC
+#define CMN_REG002C			0x00B0
+#define CMN_REG002D			0x00B4
+#define LCPLL_SDC_N_MASK		GENMASK(3, 1)
+#define LCPLL_SDC_N(x)			UPDATE(x, 3, 1)
+#define CMN_REG002E			0x00B8
+#define LCPLL_SDC_NUMBERATOR_MASK	GENMASK(5, 0)
+#define LCPLL_SDC_NUMBERATOR(x)		UPDATE(x, 5, 0)
+#define CMN_REG002F			0x00BC
+#define LCPLL_SDC_DENOMINATOR_MASK	GENMASK(7, 2)
+#define LCPLL_SDC_DENOMINATOR(x)	UPDATE(x, 7, 2)
+#define LCPLL_SDC_NDIV_RSTN		BIT(0)
+#define CMN_REG0030			0x00C0
+#define CMN_REG0031			0x00C4
+#define CMN_REG0032			0x00C8
+#define CMN_REG0033			0x00CC
+#define CMN_REG0034			0x00D0
+#define CMN_REG0035			0x00D4
+#define CMN_REG0036			0x00D8
+#define CMN_REG0037			0x00DC
+#define CMN_REG0038			0x00E0
+#define CMN_REG0039			0x00E4
+#define CMN_REG003A			0x00E8
+#define CMN_REG003B			0x00EC
+#define CMN_REG003C			0x00F0
+#define CMN_REG003D			0x00F4
+#define ROPLL_LCVCO_EN			BIT(4)
+#define CMN_REG003E			0x00F8
+#define CMN_REG003F			0x00FC
+#define CMN_REG0040			0x0100
+#define CMN_REG0041			0x0104
+#define CMN_REG0042			0x0108
+#define CMN_REG0043			0x010C
+#define CMN_REG0044			0x0110
+#define CMN_REG0045			0x0114
+#define CMN_REG0046			0x0118
+#define CMN_REG0047			0x011C
+#define CMN_REG0048			0x0120
+#define CMN_REG0049			0x0124
+#define CMN_REG004A			0x0128
+#define CMN_REG004B			0x012C
+#define CMN_REG004C			0x0130
+#define CMN_REG004D			0x0134
+#define CMN_REG004E			0x0138
+#define ROPLL_PI_EN			BIT(5)
+#define CMN_REG004F			0x013C
+#define CMN_REG0050			0x0140
+#define CMN_REG0051			0x0144
+#define CMN_REG0052			0x0148
+#define CMN_REG0053			0x014C
+#define CMN_REG0054			0x0150
+#define CMN_REG0055			0x0154
+#define CMN_REG0056			0x0158
+#define CMN_REG0057			0x015C
+#define CMN_REG0058			0x0160
+#define CMN_REG0059			0x0164
+#define CMN_REG005A			0x0168
+#define CMN_REG005B			0x016C
+#define CMN_REG005C			0x0170
+#define ROPLL_PMS_IQDIV_RSTN		BIT(5)
+#define CMN_REG005D			0x0174
+#define CMN_REG005E			0x0178
+#define ROPLL_SDM_EN_MASK		BIT(6)
+#define ROPLL_SDM_EN(x)			UPDATE(x, 6, 6)
+#define ROPLL_SDM_FRAC_EN_RBR		BIT(3)
+#define ROPLL_SDM_FRAC_EN_HBR		BIT(2)
+#define ROPLL_SDM_FRAC_EN_HBR2		BIT(1)
+#define ROPLL_SDM_FRAC_EN_HBR3		BIT(0)
+#define CMN_REG005F			0x017C
+#define CMN_REG0060			0x0180
+#define CMN_REG0061			0x0184
+#define CMN_REG0062			0x0188
+#define CMN_REG0063			0x018C
+#define CMN_REG0064			0x0190
+#define ROPLL_SDM_NUM_SIGN_RBR_MASK	BIT(3)
+#define ROPLL_SDM_NUM_SIGN_RBR(x)	UPDATE(x, 3, 3)
+#define CMN_REG0065			0x0194
+#define CMN_REG0066			0x0198
+#define CMN_REG0067			0x019C
+#define CMN_REG0068			0x01A0
+#define CMN_REG0069			0x01A4
+#define ROPLL_SDC_N_RBR_MASK		GENMASK(2, 0)
+#define ROPLL_SDC_N_RBR(x)		UPDATE(x, 2, 0)
+#define CMN_REG006A			0x01A8
+#define CMN_REG006B			0x01AC
+#define CMN_REG006C			0x01B0
+#define CMN_REG006D			0x01B4
+#define CMN_REG006E			0x01B8
+#define CMN_REG006F			0x01BC
+#define CMN_REG0070			0x01C0
+#define CMN_REG0071			0x01C4
+#define CMN_REG0072			0x01C8
+#define CMN_REG0073			0x01CC
+#define CMN_REG0074			0x01D0
+#define ROPLL_SDC_NDIV_RSTN		BIT(2)
+#define ROPLL_SSC_EN			BIT(0)
+#define CMN_REG0075			0x01D4
+#define CMN_REG0076			0x01D8
+#define CMN_REG0077			0x01DC
+#define CMN_REG0078			0x01E0
+#define CMN_REG0079			0x01E4
+#define CMN_REG007A			0x01E8
+#define CMN_REG007B			0x01EC
+#define CMN_REG007C			0x01F0
+#define CMN_REG007D			0x01F4
+#define CMN_REG007E			0x01F8
+#define CMN_REG007F			0x01FC
+#define CMN_REG0080			0x0200
+#define CMN_REG0081			0x0204
+#define OVRD_PLL_CD_CLK_EN		BIT(8)
+#define PLL_CD_HSCLK_EAST_EN		BIT(0)
+#define CMN_REG0082			0x0208
+#define CMN_REG0083			0x020C
+#define CMN_REG0084			0x0210
+#define CMN_REG0085			0x0214
+#define CMN_REG0086			0x0218
+#define PLL_PCG_POSTDIV_SEL_MASK	GENMASK(7, 4)
+#define PLL_PCG_POSTDIV_SEL(x)		UPDATE(x, 7, 4)
+#define PLL_PCG_CLK_SEL_MASK		GENMASK(3, 1)
+#define PLL_PCG_CLK_SEL(x)		UPDATE(x, 3, 1)
+#define PLL_PCG_CLK_EN			BIT(0)
+#define CMN_REG0087			0x021C
+#define PLL_FRL_MODE_EN			BIT(3)
+#define PLL_TX_HS_CLK_EN		BIT(2)
+#define CMN_REG0088			0x0220
+#define CMN_REG0089			0x0224
+#define LCPLL_ALONE_MODE		BIT(1)
+#define CMN_REG008A			0x0228
+#define CMN_REG008B			0x022C
+#define CMN_REG008C			0x0230
+#define CMN_REG008D			0x0234
+#define CMN_REG008E			0x0238
+#define CMN_REG008F			0x023C
+#define CMN_REG0090			0x0240
+#define CMN_REG0091			0x0244
+#define CMN_REG0092			0x0248
+#define CMN_REG0093			0x024C
+#define CMN_REG0094			0x0250
+#define CMN_REG0095			0x0254
+#define CMN_REG0096			0x0258
+#define CMN_REG0097			0x025C
+#define DIG_CLK_SEL			BIT(1)
+#define ROPLL_REF			BIT(1)
+#define LCPLL_REF			0
+#define CMN_REG0098			0x0260
+#define CMN_REG0099			0x0264
+#define CMN_ROPLL_ALONE_MODE		BIT(2)
+#define ROPLL_ALONE_MODE		BIT(2)
+#define CMN_REG009A			0x0268
+#define HS_SPEED_SEL			BIT(0)
+#define DIV_10_CLOCK			BIT(0)
+#define CMN_REG009B			0x026C
+#define IS_SPEED_SEL			BIT(4)
+#define LINK_SYMBOL_CLOCK		BIT(4)
+#define LINK_SYMBOL_CLOCK1_2		0
+#define CMN_REG009C			0x0270
+#define CMN_REG009D			0x0274
+#define CMN_REG009E			0x0278
+#define CMN_REG009F			0x027C
+#define CMN_REG00A0			0x0280
+#define CMN_REG00A1			0x0284
+#define CMN_REG00A2			0x0288
+#define CMN_REG00A3			0x028C
+#define CMN_REG00AD			0x0290
+#define CMN_REG00A5			0x0294
+#define CMN_REG00A6			0x0298
+#define CMN_REG00A7			0x029C
+#define SB_REG0100			0x0400
+#define SB_REG0101			0x0404
+#define SB_REG0102			0x0408
+#define OVRD_SB_RXTERM_EN_MASK		BIT(5)
+#define OVRD_SB_RXTERM_EN(x)		UPDATE(x, 5, 5)
+#define SB_RXTERM_EN_MASK		BIT(4)
+#define SB_RXTERM_EN(x)			UPDATE(x, 4, 4)
+#define ANA_SB_RXTERM_OFFSP_MASK	GENMASK(3, 0)
+#define ANA_SB_RXTERM_OFFSP(x)		UPDATE(x, 3, 0)
+#define SB_REG0103			0x040C
+#define ANA_SB_RXTERM_OFFSN_MASK	GENMASK(6, 3)
+#define ANA_SB_RXTERM_OFFSN(x)		UPDATE(x, 6, 3)
+#define OVRD_SB_RX_RESCAL_DONE_MASK	BIT(1)
+#define OVRD_SB_RX_RESCAL_DONE(x)	UPDATE(x, 1, 1)
+#define SB_RX_RESCAL_DONE_MASK		BIT(0)
+#define SB_RX_RESCAL_DONE(x)		UPDATE(x, 0, 0)
+#define SB_REG0104			0x0410
+#define OVRD_SB_EN_MASK			BIT(5)
+#define OVRD_SB_EN(x)			UPDATE(x, 5, 5)
+#define SB_EN_MASK			BIT(4)
+#define SB_EN(x)			UPDATE(x, 4, 4)
+#define SB_REG0105			0x0414
+#define OVRD_SB_EARC_CMDC_EN_MASK	BIT(6)
+#define OVRD_SB_EARC_CMDC_EN(x)		UPDATE(x, 6, 6)
+#define SB_EARC_CMDC_EN_MASK		BIT(5)
+#define SB_EARC_CMDC_EN(x)		UPDATE(x, 5, 5)
+#define ANA_SB_TX_HLVL_PROG_MASK	GENMASK(2, 0)
+#define ANA_SB_TX_HLVL_PROG(x)		UPDATE(x, 2, 0)
+#define SB_REG0106			0x0418
+#define ANA_SB_TX_LLVL_PROG_MASK	GENMASK(6, 4)
+#define ANA_SB_TX_LLVL_PROG(x)		UPDATE(x, 6, 4)
+#define SB_REG0107			0x041C
+#define SB_REG0108			0x0420
+#define SB_REG0109			0x0424
+#define ANA_SB_DMRX_AFC_DIV_RATIO_MASK	GENMASK(2, 0)
+#define ANA_SB_DMRX_AFC_DIV_RATIO(x)	UPDATE(x, 2, 0)
+#define SB_REG010A			0x0428
+#define SB_REG010B			0x042C
+#define SB_REG010C			0x0430
+#define SB_REG010D			0x0434
+#define SB_REG010E			0x0438
+#define SB_REG010F			0x043C
+#define OVRD_SB_VREG_EN_MASK		BIT(7)
+#define OVRD_SB_VREG_EN(x)		UPDATE(x, 7, 7)
+#define SB_VREG_EN_MASK			BIT(6)
+#define SB_VREG_EN(x)			UPDATE(x, 6, 6)
+#define OVRD_SB_VREG_LPF_BYPASS_MASK	BIT(5)
+#define OVRD_SB_VREG_LPF_BYPASS(x)	UPDATE(x, 5, 5)
+#define SB_VREG_LPF_BYPASS_MASK		BIT(4)
+#define SB_VREG_LPF_BYPASS(x)		UPDATE(x, 4, 4)
+#define ANA_SB_VREG_GAIN_CTRL_MASK	GENMASK(3, 0)
+#define ANA_SB_VREG_GAIN_CTRL(x)	UPDATE(x, 3, 0)
+#define SB_REG0110			0x0440
+#define ANA_SB_VREG_REF_SEL_MASK	BIT(0)
+#define ANA_SB_VREG_REF_SEL(x)		UPDATE(x, 0, 0)
+#define SB_REG0111			0x0444
+#define SB_REG0112			0x0448
+#define SB_REG0113			0x044C
+#define SB_RX_RCAL_OPT_CODE_MASK	GENMASK(5, 4)
+#define SB_RX_RCAL_OPT_CODE(x)		UPDATE(x, 5, 4)
+#define SB_RX_RTERM_CTRL_MASK		GENMASK(3, 0)
+#define SB_RX_RTERM_CTRL(x)		UPDATE(x, 3, 0)
+#define SB_REG0114			0x0450
+#define SB_TG_SB_EN_DELAY_TIME_MASK	GENMASK(5, 3)
+#define SB_TG_SB_EN_DELAY_TIME(x)	UPDATE(x, 5, 3)
+#define SB_TG_RXTERM_EN_DELAY_TIME_MASK	GENMASK(2, 0)
+#define SB_TG_RXTERM_EN_DELAY_TIME(x)	UPDATE(x, 2, 0)
+#define SB_REG0115			0x0454
+#define SB_READY_DELAY_TIME_MASK	GENMASK(5, 3)
+#define SB_READY_DELAY_TIME(x)		UPDATE(x, 5, 3)
+#define SB_TG_OSC_EN_DELAY_TIME_MASK	GENMASK(2, 0)
+#define SB_TG_OSC_EN_DELAY_TIME(x)	UPDATE(x, 2, 0)
+#define SB_REG0116			0x0458
+#define AFC_RSTN_DELAY_TIME_MASK	GENMASK(6, 4)
+#define AFC_RSTN_DELAY_TIME(x)		UPDATE(x, 6, 4)
+#define SB_REG0117			0x045C
+#define FAST_PULSE_TIME_MASK		GENMASK(3, 0)
+#define FAST_PULSE_TIME(x)		UPDATE(x, 3, 0)
+#define SB_REG0118			0x0460
+#define SB_REG0119			0x0464
+#define SB_REG011A			0x0468
+#define SB_REG011B			0x046C
+#define SB_EARC_SIG_DET_BYPASS_MASK	BIT(4)
+#define SB_EARC_SIG_DET_BYPASS(x)	UPDATE(x, 4, 4)
+#define SB_AFC_TOL_MASK			GENMASK(3, 0)
+#define SB_AFC_TOL(x)			UPDATE(x, 3, 0)
+#define SB_REG011C			0x0470
+#define SB_REG011D			0x0474
+#define SB_REG011E			0x0478
+#define SB_REG011F			0x047C
+#define SB_PWM_AFC_CTRL_MASK		GENMASK(7, 2)
+#define SB_PWM_AFC_CTRL(x)		UPDATE(x, 7, 2)
+#define SB_RCAL_RSTN_MASK		BIT(1)
+#define SB_RCAL_RSTN(x)			UPDATE(x, 1, 1)
+#define SB_REG0120			0x0480
+#define SB_EARC_EN_MASK			BIT(1)
+#define SB_EARC_EN(x)			UPDATE(x, 1, 1)
+#define SB_EARC_AFC_EN_MASK		BIT(2)
+#define SB_EARC_AFC_EN(x)		UPDATE(x, 2, 2)
+#define SB_REG0121			0x0484
+#define SB_REG0122			0x0488
+#define SB_REG0123			0x048C
+#define OVRD_SB_READY_MASK		BIT(5)
+#define OVRD_SB_READY(x)		UPDATE(x, 5, 5)
+#define SB_READY_MASK			BIT(4)
+#define SB_READY(x)			UPDATE(x, 4, 4)
+#define SB_REG0124			0x0490
+#define SB_REG0125			0x0494
+#define SB_REG0126			0x0498
+#define SB_REG0127			0x049C
+#define SB_REG0128			0x04A0
+#define SB_REG0129			0x04AD
+#define LNTOP_REG0200			0x0800
+#define PROTOCOL_SEL			BIT(2)
+#define HDMI_MODE			BIT(2)
+#define HDMI_TMDS_FRL_SEL		BIT(1)
+#define LNTOP_REG0201			0x0804
+#define LNTOP_REG0202			0x0808
+#define LNTOP_REG0203			0x080C
+#define LNTOP_REG0204			0x0810
+#define LNTOP_REG0205			0x0814
+#define LNTOP_REG0206			0x0818
+#define DATA_BUS_WIDTH			(0x3 << 1)
+#define WIDTH_40BIT			(0x3 << 1)
+#define WIDTH_36BIT			(0x2 << 1)
+#define DATA_BUS_SEL			BIT(0)
+#define DATA_BUS_36_40			BIT(0)
+#define LNTOP_REG0207			0x081C
+#define LANE_EN				0xf
+#define ALL_LANE_EN			0xf
+#define LNTOP_REG0208			0x0820
+#define LNTOP_REG0209			0x0824
+#define LNTOP_REG020A			0x0828
+#define LNTOP_REG020B			0x082C
+#define LNTOP_REG020C			0x0830
+#define LNTOP_REG020D			0x0834
+#define LNTOP_REG020E			0x0838
+#define LNTOP_REG020F			0x083C
+#define LNTOP_REG0210			0x0840
+#define LNTOP_REG0211			0x0844
+#define LNTOP_REG0212			0x0848
+#define LNTOP_REG0213			0x084C
+#define LNTOP_REG0214			0x0850
+#define LNTOP_REG0215			0x0854
+#define LNTOP_REG0216			0x0858
+#define LNTOP_REG0217			0x085C
+#define LNTOP_REG0218			0x0860
+#define LNTOP_REG0219			0x0864
+#define LNTOP_REG021A			0x0868
+#define LNTOP_REG021B			0x086C
+#define LNTOP_REG021C			0x0870
+#define LNTOP_REG021D			0x0874
+#define LNTOP_REG021E			0x0878
+#define LNTOP_REG021F			0x087C
+#define LNTOP_REG0220			0x0880
+#define LNTOP_REG0221			0x0884
+#define LNTOP_REG0222			0x0888
+#define LNTOP_REG0223			0x088C
+#define LNTOP_REG0224			0x0890
+#define LNTOP_REG0225			0x0894
+#define LNTOP_REG0226			0x0898
+#define LNTOP_REG0227			0x089C
+#define LNTOP_REG0228			0x08A0
+#define LNTOP_REG0229			0x08A4
+#define LANE_REG0300			0x0C00
+#define LANE_REG0301			0x0C04
+#define LANE_REG0302			0x0C08
+#define LANE_REG0303			0x0C0C
+#define LANE_REG0304			0x0C10
+#define LANE_REG0305			0x0C14
+#define LANE_REG0306			0x0C18
+#define LANE_REG0307			0x0C1C
+#define LANE_REG0308			0x0C20
+#define LANE_REG0309			0x0C24
+#define LANE_REG030A			0x0C28
+#define LANE_REG030B			0x0C2C
+#define LANE_REG030C			0x0C30
+#define LANE_REG030D			0x0C34
+#define LANE_REG030E			0x0C38
+#define LANE_REG030F			0x0C3C
+#define LANE_REG0310			0x0C40
+#define LANE_REG0311			0x0C44
+#define LANE_REG0312			0x0C48
+#define LN0_TX_SER_RATE_SEL_RBR		BIT(5)
+#define LN0_TX_SER_RATE_SEL_HBR		BIT(4)
+#define LN0_TX_SER_RATE_SEL_HBR2	BIT(3)
+#define LN0_TX_SER_RATE_SEL_HBR3	BIT(2)
+#define LANE_REG0313			0x0C4C
+#define LANE_REG0314			0x0C50
+#define LANE_REG0315			0x0C54
+#define LANE_REG0316			0x0C58
+#define LANE_REG0317			0x0C5C
+#define LANE_REG0318			0x0C60
+#define LANE_REG0319			0x0C64
+#define LANE_REG031A			0x0C68
+#define LANE_REG031B			0x0C6C
+#define LANE_REG031C			0x0C70
+#define LANE_REG031D			0x0C74
+#define LANE_REG031E			0x0C78
+#define LANE_REG031F			0x0C7C
+#define LANE_REG0320			0x0C80
+#define LANE_REG0321			0x0C84
+#define LANE_REG0322			0x0C88
+#define LANE_REG0323			0x0C8C
+#define LANE_REG0324			0x0C90
+#define LANE_REG0325			0x0C94
+#define LANE_REG0326			0x0C98
+#define LANE_REG0327			0x0C9C
+#define LANE_REG0328			0x0CA0
+#define LANE_REG0329			0x0CA4
+#define LANE_REG032A			0x0CA8
+#define LANE_REG032B			0x0CAC
+#define LANE_REG032C			0x0CB0
+#define LANE_REG032D			0x0CB4
+#define LANE_REG0400			0x1000
+#define LANE_REG0401			0x1004
+#define LANE_REG0402			0x1008
+#define LANE_REG0403			0x100C
+#define LANE_REG0404			0x1010
+#define LANE_REG0405			0x1014
+#define LANE_REG0406			0x1018
+#define LANE_REG0407			0x101C
+#define LANE_REG0408			0x1020
+#define LANE_REG0409			0x1024
+#define LANE_REG040A			0x1028
+#define LANE_REG040B			0x102C
+#define LANE_REG040C			0x1030
+#define LANE_REG040D			0x1034
+#define LANE_REG040E			0x1038
+#define LANE_REG040F			0x103C
+#define LANE_REG0410			0x1040
+#define LANE_REG0411			0x1044
+#define LANE_REG0412			0x1048
+#define LN1_TX_SER_RATE_SEL_RBR		BIT(5)
+#define LN1_TX_SER_RATE_SEL_HBR		BIT(4)
+#define LN1_TX_SER_RATE_SEL_HBR2	BIT(3)
+#define LN1_TX_SER_RATE_SEL_HBR3	BIT(2)
+#define LANE_REG0413			0x104C
+#define LANE_REG0414			0x1050
+#define LANE_REG0415			0x1054
+#define LANE_REG0416			0x1058
+#define LANE_REG0417			0x105C
+#define LANE_REG0418			0x1060
+#define LANE_REG0419			0x1064
+#define LANE_REG041A			0x1068
+#define LANE_REG041B			0x106C
+#define LANE_REG041C			0x1070
+#define LANE_REG041D			0x1074
+#define LANE_REG041E			0x1078
+#define LANE_REG041F			0x107C
+#define LANE_REG0420			0x1080
+#define LANE_REG0421			0x1084
+#define LANE_REG0422			0x1088
+#define LANE_REG0423			0x108C
+#define LANE_REG0424			0x1090
+#define LANE_REG0425			0x1094
+#define LANE_REG0426			0x1098
+#define LANE_REG0427			0x109C
+#define LANE_REG0428			0x10A0
+#define LANE_REG0429			0x10A4
+#define LANE_REG042A			0x10A8
+#define LANE_REG042B			0x10AC
+#define LANE_REG042C			0x10B0
+#define LANE_REG042D			0x10B4
+#define LANE_REG0500			0x1400
+#define LANE_REG0501			0x1404
+#define LANE_REG0502			0x1408
+#define LANE_REG0503			0x140C
+#define LANE_REG0504			0x1410
+#define LANE_REG0505			0x1414
+#define LANE_REG0506			0x1418
+#define LANE_REG0507			0x141C
+#define LANE_REG0508			0x1420
+#define LANE_REG0509			0x1424
+#define LANE_REG050A			0x1428
+#define LANE_REG050B			0x142C
+#define LANE_REG050C			0x1430
+#define LANE_REG050D			0x1434
+#define LANE_REG050E			0x1438
+#define LANE_REG050F			0x143C
+#define LANE_REG0510			0x1440
+#define LANE_REG0511			0x1444
+#define LANE_REG0512			0x1448
+#define LN2_TX_SER_RATE_SEL_RBR		BIT(5)
+#define LN2_TX_SER_RATE_SEL_HBR		BIT(4)
+#define LN2_TX_SER_RATE_SEL_HBR2	BIT(3)
+#define LN2_TX_SER_RATE_SEL_HBR3	BIT(2)
+#define LANE_REG0513			0x144C
+#define LANE_REG0514			0x1450
+#define LANE_REG0515			0x1454
+#define LANE_REG0516			0x1458
+#define LANE_REG0517			0x145C
+#define LANE_REG0518			0x1460
+#define LANE_REG0519			0x1464
+#define LANE_REG051A			0x1468
+#define LANE_REG051B			0x146C
+#define LANE_REG051C			0x1470
+#define LANE_REG051D			0x1474
+#define LANE_REG051E			0x1478
+#define LANE_REG051F			0x147C
+#define LANE_REG0520			0x1480
+#define LANE_REG0521			0x1484
+#define LANE_REG0522			0x1488
+#define LANE_REG0523			0x148C
+#define LANE_REG0524			0x1490
+#define LANE_REG0525			0x1494
+#define LANE_REG0526			0x1498
+#define LANE_REG0527			0x149C
+#define LANE_REG0528			0x14A0
+#define LANE_REG0529			0x14AD
+#define LANE_REG052A			0x14A8
+#define LANE_REG052B			0x14AC
+#define LANE_REG052C			0x14B0
+#define LANE_REG052D			0x14B4
+#define LANE_REG0600			0x1800
+#define LANE_REG0601			0x1804
+#define LANE_REG0602			0x1808
+#define LANE_REG0603			0x180C
+#define LANE_REG0604			0x1810
+#define LANE_REG0605			0x1814
+#define LANE_REG0606			0x1818
+#define LANE_REG0607			0x181C
+#define LANE_REG0608			0x1820
+#define LANE_REG0609			0x1824
+#define LANE_REG060A			0x1828
+#define LANE_REG060B			0x182C
+#define LANE_REG060C			0x1830
+#define LANE_REG060D			0x1834
+#define LANE_REG060E			0x1838
+#define LANE_REG060F			0x183C
+#define LANE_REG0610			0x1840
+#define LANE_REG0611			0x1844
+#define LANE_REG0612			0x1848
+#define LN3_TX_SER_RATE_SEL_RBR		BIT(5)
+#define LN3_TX_SER_RATE_SEL_HBR		BIT(4)
+#define LN3_TX_SER_RATE_SEL_HBR2	BIT(3)
+#define LN3_TX_SER_RATE_SEL_HBR3	BIT(2)
+#define LANE_REG0613			0x184C
+#define LANE_REG0614			0x1850
+#define LANE_REG0615			0x1854
+#define LANE_REG0616			0x1858
+#define LANE_REG0617			0x185C
+#define LANE_REG0618			0x1860
+#define LANE_REG0619			0x1864
+#define LANE_REG061A			0x1868
+#define LANE_REG061B			0x186C
+#define LANE_REG061C			0x1870
+#define LANE_REG061D			0x1874
+#define LANE_REG061E			0x1878
+#define LANE_REG061F			0x187C
+#define LANE_REG0620			0x1880
+#define LANE_REG0621			0x1884
+#define LANE_REG0622			0x1888
+#define LANE_REG0623			0x188C
+#define LANE_REG0624			0x1890
+#define LANE_REG0625			0x1894
+#define LANE_REG0626			0x1898
+#define LANE_REG0627			0x189C
+#define LANE_REG0628			0x18A0
+#define LANE_REG0629			0x18A4
+#define LANE_REG062A			0x18A8
+#define LANE_REG062B			0x18AC
+#define LANE_REG062C			0x18B0
+#define LANE_REG062D			0x18B4
+
+#define HDMI20_MAX_RATE 600000000
+#define DATA_RATE_MASK 0xFFFFFFF
+#define COLOR_DEPTH_MASK BIT(31)
+#define HDMI_MODE_MASK BIT(30)
+#define HDMI_EARC_MASK BIT(29)
+
+#define FRL_8G_4LANES 3200000000ULL
+#define FRL_6G_3LANES 1800000000
+#define FRL_3G_3LANES 900000000
+
+struct lcpll_config {
+	u32 bit_rate;
+	u8 lcvco_mode_en;
+	u8 pi_en;
+	u8 clk_en_100m;
+	u8 pms_mdiv;
+	u8 pms_mdiv_afc;
+	u8 pms_pdiv;
+	u8 pms_refdiv;
+	u8 pms_sdiv;
+	u8 pi_cdiv_rstn;
+	u8 pi_cdiv_sel;
+	u8 sdm_en;
+	u8 sdm_rstn;
+	u8 sdc_frac_en;
+	u8 sdc_rstn;
+	u8 sdm_deno;
+	u8 sdm_num_sign;
+	u8 sdm_num;
+	u8 sdc_n;
+	u8 sdc_n2;
+	u8 sdc_num;
+	u8 sdc_deno;
+	u8 sdc_ndiv_rstn;
+	u8 ssc_en;
+	u8 ssc_fm_dev;
+	u8 ssc_fm_freq;
+	u8 ssc_clk_div_sel;
+	u8 cd_tx_ser_rate_sel;
+};
+
+struct ropll_config {
+	u32 bit_rate;
+	u8 pms_mdiv;
+	u8 pms_mdiv_afc;
+	u8 pms_pdiv;
+	u8 pms_refdiv;
+	u8 pms_sdiv;
+	u8 pms_iqdiv_rstn;
+	u8 ref_clk_sel;
+	u8 sdm_en;
+	u8 sdm_rstn;
+	u8 sdc_frac_en;
+	u8 sdc_rstn;
+	u8 sdm_clk_div;
+	u8 sdm_deno;
+	u8 sdm_num_sign;
+	u8 sdm_num;
+	u8 sdc_n;
+	u8 sdc_num;
+	u8 sdc_deno;
+	u8 sdc_ndiv_rstn;
+	u8 ssc_en;
+	u8 ssc_fm_dev;
+	u8 ssc_fm_freq;
+	u8 ssc_clk_div_sel;
+	u8 ana_cpp_ctrl;
+	u8 ana_lpf_c_sel;
+	u8 cd_tx_ser_rate_sel;
+};
+
+struct rockchip_hdptx_phy {
+	struct udevice *dev;
+	void __iomem *base;
+	struct regmap *grf;
+
+	int id;
+	bool dclk_en;
+	bool pll_locked;
+
+	unsigned long rate;
+	u32 bus_width;
+
+	struct reset_ctl apb_reset;
+	struct reset_ctl cmn_reset;
+	struct reset_ctl init_reset;
+	struct reset_ctl lane_reset;
+	struct reset_ctl phy_reset;
+	struct reset_ctl ropll_reset;
+	struct reset_ctl lcpll_reset;
+};
+
+struct clk_hdptx {
+	struct udevice *dev;
+	ulong rate;
+};
+
+/* global variables are used to pass reource from phy drivers to clk driver */
+static struct rockchip_hdptx_phy *g_hdptx0;
+static struct rockchip_hdptx_phy *g_hdptx1;
+
+struct lcpll_config lcpll_cfg[] = {
+	{ 48000000, 1, 0, 0, 0x7d, 0x7d, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 2,
+		0, 0x13, 0x18, 1, 0, 0x20, 0x0c, 1, 0,
+	},
+	{ 40000000, 1, 1, 0, 0x68, 0x68, 1, 1, 0, 0, 0, 1, 1, 1, 1, 9, 0, 1, 1,
+		0, 2, 3, 1, 0, 0x20, 0x0c, 1, 0,
+	},
+	{ 24000000, 1, 0, 0, 0x7d, 0x7d, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 2,
+		0, 0x13, 0x18, 1, 0, 0x20, 0x0c, 1, 0,
+	},
+	{ 18000000, 1, 0, 0, 0x7d, 0x7d, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 2,
+		0, 0x13, 0x18, 1, 0, 0x20, 0x0c, 1, 0,
+	},
+	{ 9000000, 1, 0, 0, 0x7d, 0x7d, 1, 1, 3, 0, 0, 0, 0, 1, 1, 1, 0, 0, 2,
+		0, 0x13, 0x18, 1, 0, 0x20, 0x0c, 1, 0,
+	},
+	{ ~0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+		0, 0, 0, 0, 0, 0,
+	},
+};
+
+struct ropll_config ropll_frl_cfg[] = {
+	{ 24000000, 0x19, 0x19, 1, 1, 0, 1, 2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0,
+		0, 0x20, 0x0c, 1, 0x0e, 0, 0,
+	},
+	{ 18000000, 0x7d, 0x7d, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0,
+		0, 0x20, 0x0c, 1, 0x0e, 0, 0,
+	},
+	{ 9000000, 0x7d, 0x7d, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0,
+		0, 0x20, 0x0c, 1, 0x0e, 0, 0,
+	},
+	{ ~0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+		0, 0, 0, 0,
+	},
+};
+
+struct ropll_config ropll_tmds_cfg[] = {
+	{ 5940000, 124, 124, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 62, 1, 16, 5, 0,
+		1, 1, 0, 0x20, 0x0c, 1, 0x0e, 0, 0,
+	},
+	{ 3712500, 155, 155, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 62, 1, 16, 5, 0,
+		1, 1, 0, 0x20, 0x0c, 1, 0x0e, 0, 0,
+	},
+	{ 2970000, 124, 124, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 62, 1, 16, 5, 0,
+		1, 1, 0, 0x20, 0x0c, 1, 0x0e, 0, 0,
+	},
+	{ 1620000, 135, 135, 1, 1, 3, 1, 1, 0, 1, 1, 1, 1, 4, 0, 3, 5, 5, 0x10,
+		1, 0, 0x20, 0x0c, 1, 0x0e, 0, 0,
+	},
+	{ 1856250, 155, 155, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 62, 1, 16, 5, 0,
+		1, 1, 0, 0x20, 0x0c, 1, 0x0e, 0, 0,
+	},
+	{ 1485000, 0x7b, 0x7b, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 4, 0, 3, 5, 5, 0x10,
+		1, 0, 0x20, 0x0c, 1, 0x0e, 0, 0,
+	},
+	{ 1462500, 122, 122, 1, 1, 4, 1, 1, 1, 1, 1, 1, 1, 244, 1, 16, 1, 0, 1,
+		1, 0, 0x20, 0x0c, 1, 0x0e, 0, 0,
+	},
+	{ 1065000, 89, 89, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 89, 1, 16, 1, 0, 1,
+		1, 0, 0x20, 0x0c, 1, 0x0e, 0, 0,
+	},
+	{ 1080000, 135, 135, 1, 1, 5, 1, 1, 0, 1, 0, 1, 1, 0x9, 0, 0x05, 0, 0x14,
+		0x18, 1, 0, 0x20, 0x0c, 1, 0x0e, 0, 0,
+	},
+	{ 855000, 125, 125, 1, 1, 6, 1, 1, 1, 1, 1, 1, 1, 80, 1, 16, 2, 0,
+		1, 1, 0, 0x20, 0x0c, 1, 0x0e, 0, 0,
+	},
+	{ 835000, 105, 105, 1, 1, 5, 1, 1, 1, 1, 1, 1, 1, 42, 1, 16, 1, 0,
+		1, 1, 0, 0x20, 0x0c, 1, 0x0e, 0, 0,
+	},
+	{ 928125, 155, 155, 1, 1, 7, 1, 1, 1, 1, 1, 1, 1, 62, 1, 16, 5, 0,
+		1, 1, 0, 0x20, 0x0c, 1, 0x0e, 0, 0,
+	},
+	{ 742500, 124, 124, 1, 1, 7, 1, 1, 1, 1, 1, 1, 1, 62, 1, 16, 5, 0,
+		1, 1, 0, 0x20, 0x0c, 1, 0x0e, 0, 0,
+	},
+	{ 650000, 162, 162, 1, 1, 11, 1, 1, 1, 1, 1, 1, 1, 54, 0, 16, 4, 1,
+		1, 1, 0, 0x20, 0x0c, 1, 0x0e, 0, 0,
+	},
+	{ 337500, 0x70, 0x70, 1, 1, 0xf, 1, 1, 1, 1, 1, 1, 1, 0x2, 0, 0x01, 5, 1,
+		1, 1, 0, 0x20, 0x0c, 1, 0x0e, 0, 0,
+	},
+	{ 400000, 100, 100, 1, 1, 11, 1, 1, 0, 1, 0, 1, 1, 0x9, 0, 0x05, 0, 0x14,
+		0x18, 1, 0, 0x20, 0x0c, 1, 0x0e, 0, 0,
+	},
+	{ 270000, 0x5a, 0x5a, 1, 1, 0xf, 1, 1, 0, 1, 0, 1, 1, 0x9, 0, 0x05, 0, 0x14,
+		0x18, 1, 0, 0x20, 0x0c, 1, 0x0e, 0, 0,
+	},
+	{ 251750, 84, 84, 1, 1, 0xf, 1, 1, 1, 1, 1, 1, 1, 168, 1, 16, 4, 1,
+		1, 1, 0, 0x20, 0x0c, 1, 0x0e, 0, 0,
+	},
+	{ ~0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+		0, 0, 0, 0,
+	},
+};
+
+static inline void hdptx_write(struct rockchip_hdptx_phy *hdptx, uint reg,
+			       uint val)
+{
+	writel(val, hdptx->base + reg);
+}
+
+static inline uint hdptx_read(struct rockchip_hdptx_phy *hdptx, uint reg)
+{
+	return readl(hdptx->base + reg);
+}
+
+static void hdptx_update_bits(struct rockchip_hdptx_phy *hdptx, uint reg,
+			      uint mask, uint val)
+{
+	uint orig, tmp;
+
+	orig = hdptx_read(hdptx, reg);
+	tmp = orig & ~mask;
+	tmp |= val & mask;
+	hdptx_write(hdptx, reg, tmp);
+}
+
+static void hdptx_grf_write(struct rockchip_hdptx_phy *hdptx, uint reg,
+			    uint val)
+{
+	regmap_write(hdptx->grf, reg, val);
+}
+
+static uint hdptx_grf_read(struct rockchip_hdptx_phy *hdptx, uint reg)
+{
+	uint val;
+	int ret;
+
+	ret = regmap_read(hdptx->grf, reg, &val);
+	if (ret)
+		dev_err(hdptx->dev, "regmap_read err:%d", ret);
+
+	return val;
+}
+
+static void hdptx_pre_power_up(struct rockchip_hdptx_phy *hdptx)
+{
+	u32 val = 0;
+
+	reset_assert(&hdptx->apb_reset);
+	udelay(20);
+	reset_deassert(&hdptx->apb_reset);
+
+	reset_assert(&hdptx->lane_reset);
+	reset_assert(&hdptx->cmn_reset);
+	reset_assert(&hdptx->init_reset);
+
+	val = (HDPTX_I_PLL_EN | HDPTX_I_BIAS_EN | HDPTX_I_BGR_EN) << 16;
+	hdptx_grf_write(hdptx, GRF_HDPTX_CON0, val);
+}
+
+static int hdptx_post_enable_lane(struct rockchip_hdptx_phy *hdptx)
+{
+	u32 val = 0;
+	int i;
+
+	reset_deassert(&hdptx->lane_reset);
+
+	val = (HDPTX_I_BIAS_EN | HDPTX_I_BGR_EN) << 16 | HDPTX_I_BIAS_EN |
+		HDPTX_I_BGR_EN;
+	hdptx_grf_write(hdptx, GRF_HDPTX_CON0, val);
+
+	/* 3 lanes frl mode */
+	if (hdptx->rate == FRL_6G_3LANES || hdptx->rate == FRL_3G_3LANES)
+		hdptx_write(hdptx, LNTOP_REG0207, 0x07);
+	else
+		hdptx_write(hdptx, LNTOP_REG0207, 0x0f);
+
+	val = 0;
+	for (i = 0; i < 50; i++) {
+		val = hdptx_grf_read(hdptx, GRF_HDPTX_STATUS);
+
+		if (val & HDPTX_O_PHY_RDY && val & HDPTX_O_PLL_LOCK_DONE)
+			break;
+		udelay(100);
+	}
+
+	if (i == 50) {
+		dev_err(hdptx->dev, "hdptx phy lane can't ready!\n");
+		return -EINVAL;
+	}
+
+	dev_err(hdptx->dev, "hdptx phy lane locked!\n");
+
+	return 0;
+}
+
+static int hdptx_post_enable_pll(struct rockchip_hdptx_phy *hdptx)
+{
+	u32 val = 0;
+	int i;
+
+	val = (HDPTX_I_BIAS_EN | HDPTX_I_BGR_EN) << 16 | HDPTX_I_BIAS_EN |
+		HDPTX_I_BGR_EN;
+	hdptx_grf_write(hdptx, GRF_HDPTX_CON0, val);
+	udelay(10);
+	reset_deassert(&hdptx->init_reset);
+	udelay(10);
+	val = HDPTX_I_PLL_EN << 16 | HDPTX_I_PLL_EN;
+	hdptx_grf_write(hdptx, GRF_HDPTX_CON0, val);
+	udelay(10);
+	reset_deassert(&hdptx->cmn_reset);
+
+	val = 0;
+	for (i = 0; i < 50; i++) {
+		val = hdptx_grf_read(hdptx, GRF_HDPTX_STATUS);
+
+		if (val & HDPTX_O_PHY_CLK_RDY)
+			break;
+		udelay(20);
+	}
+
+	if (i == 50) {
+		dev_err(hdptx->dev, "hdptx phy pll can't lock!\n");
+		return -EINVAL;
+	}
+
+	hdptx->pll_locked = true;
+	dev_err(hdptx->dev, "hdptx phy pll locked!\n");
+
+	return 0;
+}
+
+static bool hdptx_phy_clk_pll_calc(unsigned int data_rate,
+				   struct ropll_config *cfg)
+{
+	unsigned int fref = 24000;
+	unsigned int sdc;
+	unsigned int fout = data_rate / 2;
+	unsigned int fvco;
+	u32 mdiv, sdiv, n = 8;
+	unsigned long k = 0, lc, k_sub, lc_sub;
+
+	for (sdiv = 1; sdiv <= 16; sdiv++) {
+		if (sdiv % 2 && sdiv != 1)
+			continue;
+
+		fvco = fout * sdiv;
+
+		if (fvco < 2000000 || fvco > 4000000)
+			continue;
+
+		mdiv = DIV_ROUND_UP(fvco, fref);
+		if (mdiv < 20 || mdiv > 255)
+			continue;
+
+		if (fref * mdiv - fvco) {
+			for (sdc = 264000; sdc <= 750000; sdc += fref)
+				if (sdc * n > fref * mdiv)
+					break;
+
+			if (sdc > 750000)
+				continue;
+
+			rational_best_approximation(fref * mdiv - fvco,
+						    sdc / 16,
+						    GENMASK(6, 0),
+						    GENMASK(7, 0),
+						    &k, &lc);
+
+			rational_best_approximation(sdc * n - fref * mdiv,
+						    sdc,
+						    GENMASK(6, 0),
+						    GENMASK(7, 0),
+						    &k_sub, &lc_sub);
+		}
+
+		break;
+	}
+
+	if (sdiv > 16)
+		return false;
+
+	if (cfg) {
+		cfg->pms_mdiv = mdiv;
+		cfg->pms_mdiv_afc = mdiv;
+		cfg->pms_pdiv = 1;
+		cfg->pms_refdiv = 1;
+		cfg->pms_sdiv = sdiv - 1;
+
+		cfg->sdm_en = k > 0 ? 1 : 0;
+		if (cfg->sdm_en) {
+			cfg->sdm_deno = lc;
+			cfg->sdm_num_sign = 1;
+			cfg->sdm_num = k;
+			cfg->sdc_n = n - 3;
+			cfg->sdc_num = k_sub;
+			cfg->sdc_deno = lc_sub;
+		}
+	}
+
+	return true;
+}
+
+static int hdptx_lcpll_cmn_config(struct rockchip_hdptx_phy *hdptx, unsigned long bit_rate)
+{
+	u8 color_depth = (bit_rate & COLOR_DEPTH_MASK) ? 1 : 0;
+	struct lcpll_config *cfg = lcpll_cfg;
+
+	printf("%s rate:%lu\n", __func__, bit_rate);
+	hdptx->rate = bit_rate * 100;
+
+	for (; cfg->bit_rate != ~0; cfg++)
+		if (bit_rate == cfg->bit_rate)
+			break;
+
+	if (cfg->bit_rate == ~0)
+		return -EINVAL;
+
+	hdptx_pre_power_up(hdptx);
+
+	reset_assert(&hdptx->lcpll_reset);
+	udelay(20);
+	reset_deassert(&hdptx->lcpll_reset);
+
+	hdptx_grf_write(hdptx, GRF_HDPTX_CON0, LC_REF_CLK_SEL << 16);
+
+	hdptx_update_bits(hdptx, CMN_REG0008, LCPLL_EN_MASK |
+		       LCPLL_LCVCO_MODE_EN_MASK, LCPLL_EN(1) |
+		       LCPLL_LCVCO_MODE_EN(cfg->lcvco_mode_en));
+	hdptx_write(hdptx, CMN_REG0009, 0x0c);
+	hdptx_write(hdptx, CMN_REG000A, 0x83);
+	hdptx_write(hdptx, CMN_REG000B, 0x06);
+	hdptx_write(hdptx, CMN_REG000C, 0x20);
+	hdptx_write(hdptx, CMN_REG000D, 0xb8);
+	hdptx_write(hdptx, CMN_REG000E, 0x0f);
+	hdptx_write(hdptx, CMN_REG000F, 0x0f);
+	hdptx_write(hdptx, CMN_REG0010, 0x04);
+	hdptx_write(hdptx, CMN_REG0011, 0x00);
+	hdptx_write(hdptx, CMN_REG0012, 0x26);
+	hdptx_write(hdptx, CMN_REG0013, 0x22);
+	hdptx_write(hdptx, CMN_REG0014, 0x24);
+	hdptx_write(hdptx, CMN_REG0015, 0x77);
+	hdptx_write(hdptx, CMN_REG0016, 0x08);
+	hdptx_write(hdptx, CMN_REG0017, 0x00);
+	hdptx_write(hdptx, CMN_REG0018, 0x04);
+	hdptx_write(hdptx, CMN_REG0019, 0x48);
+	hdptx_write(hdptx, CMN_REG001A, 0x01);
+	hdptx_write(hdptx, CMN_REG001B, 0x00);
+	hdptx_write(hdptx, CMN_REG001C, 0x01);
+	hdptx_write(hdptx, CMN_REG001D, 0x64);
+	hdptx_update_bits(hdptx, CMN_REG001E, LCPLL_PI_EN_MASK |
+		       LCPLL_100M_CLK_EN_MASK,
+		       LCPLL_PI_EN(cfg->pi_en) |
+		       LCPLL_100M_CLK_EN(cfg->clk_en_100m));
+	hdptx_write(hdptx, CMN_REG001F, 0x00);
+	hdptx_write(hdptx, CMN_REG0020, cfg->pms_mdiv);
+	hdptx_write(hdptx, CMN_REG0021, cfg->pms_mdiv_afc);
+	hdptx_write(hdptx, CMN_REG0022, (cfg->pms_pdiv << 4) | cfg->pms_refdiv);
+	hdptx_write(hdptx, CMN_REG0023, (cfg->pms_sdiv << 4) | cfg->pms_sdiv);
+	hdptx_write(hdptx, CMN_REG0025, 0x10);
+	hdptx_write(hdptx, CMN_REG0026, 0x53);
+	hdptx_write(hdptx, CMN_REG0027, 0x01);
+	hdptx_write(hdptx, CMN_REG0028, 0x0d);
+	hdptx_write(hdptx, CMN_REG0029, 0x01);
+	hdptx_write(hdptx, CMN_REG002A, cfg->sdm_deno);
+	hdptx_write(hdptx, CMN_REG002B, cfg->sdm_num_sign);
+	hdptx_write(hdptx, CMN_REG002C, cfg->sdm_num);
+	hdptx_update_bits(hdptx, CMN_REG002D, LCPLL_SDC_N_MASK,
+			  LCPLL_SDC_N(cfg->sdc_n));
+	hdptx_write(hdptx, CMN_REG002E, 0x02);
+	hdptx_write(hdptx, CMN_REG002F, 0x0d);
+	hdptx_write(hdptx, CMN_REG0030, 0x00);
+	hdptx_write(hdptx, CMN_REG0031, 0x20);
+	hdptx_write(hdptx, CMN_REG0032, 0x30);
+	hdptx_write(hdptx, CMN_REG0033, 0x0b);
+	hdptx_write(hdptx, CMN_REG0034, 0x23);
+	hdptx_write(hdptx, CMN_REG0035, 0x00);
+	hdptx_write(hdptx, CMN_REG0038, 0x00);
+	hdptx_write(hdptx, CMN_REG0039, 0x00);
+	hdptx_write(hdptx, CMN_REG003A, 0x00);
+	hdptx_write(hdptx, CMN_REG003B, 0x00);
+	hdptx_write(hdptx, CMN_REG003C, 0x80);
+	hdptx_write(hdptx, CMN_REG003D, 0x00);
+	hdptx_write(hdptx, CMN_REG003E, 0x0c);
+	hdptx_write(hdptx, CMN_REG003F, 0x83);
+	hdptx_write(hdptx, CMN_REG0040, 0x06);
+	hdptx_write(hdptx, CMN_REG0041, 0x20);
+	hdptx_write(hdptx, CMN_REG0042, 0xb8);
+	hdptx_write(hdptx, CMN_REG0043, 0x00);
+	hdptx_write(hdptx, CMN_REG0044, 0x46);
+	hdptx_write(hdptx, CMN_REG0045, 0x24);
+	hdptx_write(hdptx, CMN_REG0046, 0xff);
+	hdptx_write(hdptx, CMN_REG0047, 0x00);
+	hdptx_write(hdptx, CMN_REG0048, 0x44);
+	hdptx_write(hdptx, CMN_REG0049, 0xfa);
+	hdptx_write(hdptx, CMN_REG004A, 0x08);
+	hdptx_write(hdptx, CMN_REG004B, 0x00);
+	hdptx_write(hdptx, CMN_REG004C, 0x01);
+	hdptx_write(hdptx, CMN_REG004D, 0x64);
+	hdptx_write(hdptx, CMN_REG004E, 0x14);
+	hdptx_write(hdptx, CMN_REG004F, 0x00);
+	hdptx_write(hdptx, CMN_REG0050, 0x00);
+	hdptx_write(hdptx, CMN_REG0051, 0x00);
+	hdptx_write(hdptx, CMN_REG0055, 0x00);
+	hdptx_write(hdptx, CMN_REG0059, 0x11);
+	hdptx_write(hdptx, CMN_REG005A, 0x03);
+	hdptx_write(hdptx, CMN_REG005C, 0x05);
+	hdptx_write(hdptx, CMN_REG005D, 0x0c);
+	hdptx_write(hdptx, CMN_REG005E, 0x07);
+	hdptx_write(hdptx, CMN_REG005F, 0x01);
+	hdptx_write(hdptx, CMN_REG0060, 0x01);
+	hdptx_write(hdptx, CMN_REG0064, 0x07);
+	hdptx_write(hdptx, CMN_REG0065, 0x00);
+	hdptx_write(hdptx, CMN_REG0069, 0x00);
+	hdptx_write(hdptx, CMN_REG006B, 0x04);
+	hdptx_write(hdptx, CMN_REG006C, 0x00);
+	hdptx_write(hdptx, CMN_REG0070, 0x01);
+	hdptx_write(hdptx, CMN_REG0073, 0x30);
+	hdptx_write(hdptx, CMN_REG0074, 0x00);
+	hdptx_write(hdptx, CMN_REG0075, 0x20);
+	hdptx_write(hdptx, CMN_REG0076, 0x30);
+	hdptx_write(hdptx, CMN_REG0077, 0x08);
+	hdptx_write(hdptx, CMN_REG0078, 0x0c);
+	hdptx_write(hdptx, CMN_REG0079, 0x00);
+	hdptx_write(hdptx, CMN_REG007B, 0x00);
+	hdptx_write(hdptx, CMN_REG007C, 0x00);
+	hdptx_write(hdptx, CMN_REG007D, 0x00);
+	hdptx_write(hdptx, CMN_REG007E, 0x00);
+	hdptx_write(hdptx, CMN_REG007F, 0x00);
+	hdptx_write(hdptx, CMN_REG0080, 0x00);
+	hdptx_write(hdptx, CMN_REG0081, 0x09);
+	hdptx_write(hdptx, CMN_REG0082, 0x04);
+	hdptx_write(hdptx, CMN_REG0083, 0x24);
+	hdptx_write(hdptx, CMN_REG0084, 0x20);
+	hdptx_write(hdptx, CMN_REG0085, 0x03);
+	hdptx_write(hdptx, CMN_REG0086, 0x01);
+	hdptx_update_bits(hdptx, CMN_REG0086, PLL_PCG_POSTDIV_SEL_MASK,
+			  PLL_PCG_POSTDIV_SEL(cfg->pms_sdiv));
+	hdptx_update_bits(hdptx, CMN_REG0086, PLL_PCG_CLK_SEL_MASK,
+			  PLL_PCG_CLK_SEL(color_depth));
+	hdptx_write(hdptx, CMN_REG0087, 0x0c);
+	hdptx_write(hdptx, CMN_REG0089, 0x02);
+	hdptx_write(hdptx, CMN_REG008A, 0x55);
+	hdptx_write(hdptx, CMN_REG008B, 0x25);
+	hdptx_write(hdptx, CMN_REG008C, 0x2c);
+	hdptx_write(hdptx, CMN_REG008D, 0x22);
+	hdptx_write(hdptx, CMN_REG008E, 0x14);
+	hdptx_write(hdptx, CMN_REG008F, 0x20);
+	hdptx_write(hdptx, CMN_REG0090, 0x00);
+	hdptx_write(hdptx, CMN_REG0091, 0x00);
+	hdptx_write(hdptx, CMN_REG0092, 0x00);
+	hdptx_write(hdptx, CMN_REG0093, 0x00);
+	hdptx_write(hdptx, CMN_REG0095, 0x00);
+	hdptx_write(hdptx, CMN_REG0097, 0x00);
+	hdptx_write(hdptx, CMN_REG0099, 0x00);
+	hdptx_write(hdptx, CMN_REG009A, 0x11);
+	hdptx_write(hdptx, CMN_REG009B, 0x10);
+	hdptx_write(hdptx, SB_REG0114, 0x00);
+	hdptx_write(hdptx, SB_REG0115, 0x00);
+	hdptx_write(hdptx, SB_REG0116, 0x00);
+	hdptx_write(hdptx, SB_REG0117, 0x00);
+
+	return hdptx_post_enable_pll(hdptx);
+}
+
+static int hdptx_ropll_cmn_config(struct rockchip_hdptx_phy *hdptx, unsigned long bit_rate)
+{
+	int bus_width = hdptx->bus_width;
+	u8 color_depth = (bus_width & COLOR_DEPTH_MASK) ? 1 : 0;
+	struct ropll_config *cfg = ropll_tmds_cfg;
+	struct ropll_config rc = {0};
+
+	printf("%s bus_width:%x rate:%lu\n", __func__, bus_width, bit_rate);
+	hdptx->rate = bit_rate * 100;
+
+	for (; cfg->bit_rate != ~0; cfg++)
+		if (bit_rate == cfg->bit_rate)
+			break;
+
+	if (cfg->bit_rate == ~0) {
+		if (hdptx_phy_clk_pll_calc(bit_rate, &rc)) {
+			cfg = &rc;
+		} else {
+			dev_err(hdptx->dev, "%s can't find pll cfg\n", __func__);
+			return -EINVAL;
+		}
+	}
+
+	dev_dbg(hdptx->dev, "mdiv=%u, sdiv=%u\n",
+		cfg->pms_mdiv, cfg->pms_sdiv + 1);
+	dev_dbg(hdptx->dev, "sdm_en=%u, k_sign=%u, k=%u, lc=%u",
+		cfg->sdm_en, cfg->sdm_num_sign, cfg->sdm_num, cfg->sdm_deno);
+	dev_dbg(hdptx->dev, "n=%u, k_sub=%u, lc_sub=%u\n",
+		cfg->sdc_n + 3, cfg->sdc_num, cfg->sdc_deno);
+
+	hdptx_pre_power_up(hdptx);
+
+	reset_assert(&hdptx->ropll_reset);
+	udelay(20);
+	reset_deassert(&hdptx->ropll_reset);
+
+	hdptx_grf_write(hdptx, GRF_HDPTX_CON0, LC_REF_CLK_SEL << 16);
+
+	hdptx_write(hdptx, CMN_REG0008, 0x00);
+	hdptx_write(hdptx, CMN_REG0009, 0x0c);
+	hdptx_write(hdptx, CMN_REG000A, 0x83);
+	hdptx_write(hdptx, CMN_REG000B, 0x06);
+	hdptx_write(hdptx, CMN_REG000C, 0x20);
+	hdptx_write(hdptx, CMN_REG000D, 0xb8);
+	hdptx_write(hdptx, CMN_REG000E, 0x0f);
+	hdptx_write(hdptx, CMN_REG000F, 0x0f);
+	hdptx_write(hdptx, CMN_REG0010, 0x04);
+	hdptx_write(hdptx, CMN_REG0011, 0x01);
+	hdptx_write(hdptx, CMN_REG0012, 0x26);
+	hdptx_write(hdptx, CMN_REG0013, 0x22);
+	hdptx_write(hdptx, CMN_REG0014, 0x24);
+	hdptx_write(hdptx, CMN_REG0015, 0x77);
+	hdptx_write(hdptx, CMN_REG0016, 0x08);
+	hdptx_write(hdptx, CMN_REG0017, 0x20);
+	hdptx_write(hdptx, CMN_REG0018, 0x04);
+	hdptx_write(hdptx, CMN_REG0019, 0x48);
+	hdptx_write(hdptx, CMN_REG001A, 0x01);
+	hdptx_write(hdptx, CMN_REG001B, 0x00);
+	hdptx_write(hdptx, CMN_REG001C, 0x01);
+	hdptx_write(hdptx, CMN_REG001D, 0x64);
+	hdptx_write(hdptx, CMN_REG001E, 0x14);
+	hdptx_write(hdptx, CMN_REG001F, 0x00);
+	hdptx_write(hdptx, CMN_REG0020, 0x00);
+	hdptx_write(hdptx, CMN_REG0021, 0x00);
+	hdptx_write(hdptx, CMN_REG0022, 0x11);
+	hdptx_write(hdptx, CMN_REG0023, 0x00);
+	hdptx_write(hdptx, CMN_REG0024, 0x00);
+	hdptx_write(hdptx, CMN_REG0025, 0x53);
+	hdptx_write(hdptx, CMN_REG0026, 0x00);
+	hdptx_write(hdptx, CMN_REG0027, 0x00);
+	hdptx_write(hdptx, CMN_REG0028, 0x01);
+	hdptx_write(hdptx, CMN_REG0029, 0x01);
+	hdptx_write(hdptx, CMN_REG002A, 0x00);
+	hdptx_write(hdptx, CMN_REG002B, 0x00);
+	hdptx_write(hdptx, CMN_REG002C, 0x00);
+	hdptx_write(hdptx, CMN_REG002D, 0x00);
+	hdptx_write(hdptx, CMN_REG002E, 0x04);
+	hdptx_write(hdptx, CMN_REG002F, 0x00);
+	hdptx_write(hdptx, CMN_REG0030, 0x20);
+	hdptx_write(hdptx, CMN_REG0031, 0x30);
+	hdptx_write(hdptx, CMN_REG0032, 0x0b);
+	hdptx_write(hdptx, CMN_REG0033, 0x23);
+	hdptx_write(hdptx, CMN_REG0034, 0x00);
+	hdptx_write(hdptx, CMN_REG0035, 0x00);
+	hdptx_write(hdptx, CMN_REG0038, 0x00);
+	hdptx_write(hdptx, CMN_REG0039, 0x00);
+	hdptx_write(hdptx, CMN_REG003A, 0x00);
+	hdptx_write(hdptx, CMN_REG003B, 0x00);
+	hdptx_write(hdptx, CMN_REG003C, 0x80);
+	hdptx_write(hdptx, CMN_REG003D, 0x40);
+	hdptx_write(hdptx, CMN_REG003E, 0x0c);
+	hdptx_write(hdptx, CMN_REG003F, 0x83);
+	hdptx_write(hdptx, CMN_REG0040, 0x06);
+	hdptx_write(hdptx, CMN_REG0041, 0x20);
+	hdptx_write(hdptx, CMN_REG0042, 0x78);
+	hdptx_write(hdptx, CMN_REG0043, 0x00);
+	hdptx_write(hdptx, CMN_REG0044, 0x46);
+	hdptx_write(hdptx, CMN_REG0045, 0x24);
+	hdptx_write(hdptx, CMN_REG0046, 0xdd);
+	hdptx_write(hdptx, CMN_REG0047, 0x00);
+	hdptx_write(hdptx, CMN_REG0048, 0x11);
+	hdptx_write(hdptx, CMN_REG0049, 0xfa);
+	hdptx_write(hdptx, CMN_REG004A, 0x08);
+	hdptx_write(hdptx, CMN_REG004B, 0x00);
+	hdptx_write(hdptx, CMN_REG004C, 0x01);
+	hdptx_write(hdptx, CMN_REG004D, 0x64);
+	hdptx_write(hdptx, CMN_REG004E, 0x34);
+	hdptx_write(hdptx, CMN_REG004F, 0x00);
+	hdptx_write(hdptx, CMN_REG0050, 0x00);
+
+	hdptx_write(hdptx, CMN_REG0051, cfg->pms_mdiv);
+	hdptx_write(hdptx, CMN_REG0055, cfg->pms_mdiv_afc);
+
+	hdptx_write(hdptx, CMN_REG0059, (cfg->pms_pdiv << 4) | cfg->pms_refdiv);
+
+	hdptx_write(hdptx, CMN_REG005A, (cfg->pms_sdiv << 4));
+
+	hdptx_write(hdptx, CMN_REG005C, 0x25);
+	hdptx_write(hdptx, CMN_REG005D, 0x0c);
+	hdptx_write(hdptx, CMN_REG005E, 0x4f);
+	hdptx_update_bits(hdptx, CMN_REG005E, ROPLL_SDM_EN_MASK,
+			  ROPLL_SDM_EN(cfg->sdm_en));
+	if (!cfg->sdm_en)
+		hdptx_update_bits(hdptx, CMN_REG005E, 0xf, 0);
+
+	hdptx_write(hdptx, CMN_REG005F, 0x01);
+
+	hdptx_update_bits(hdptx, CMN_REG0064, ROPLL_SDM_NUM_SIGN_RBR_MASK,
+			  ROPLL_SDM_NUM_SIGN_RBR(cfg->sdm_num_sign));
+	hdptx_write(hdptx, CMN_REG0065, cfg->sdm_num);
+	hdptx_write(hdptx, CMN_REG0060, cfg->sdm_deno);
+
+	hdptx_update_bits(hdptx, CMN_REG0069, ROPLL_SDC_N_RBR_MASK,
+			  ROPLL_SDC_N_RBR(cfg->sdc_n));
+
+	hdptx_write(hdptx, CMN_REG006C, cfg->sdc_num);
+	hdptx_write(hdptx, CMN_REG0070, cfg->sdc_deno);
+
+	hdptx_write(hdptx, CMN_REG006B, 0x04);
+
+	hdptx_write(hdptx, CMN_REG0073, 0x30);
+	hdptx_write(hdptx, CMN_REG0074, 0x04);
+	hdptx_write(hdptx, CMN_REG0075, 0x20);
+	hdptx_write(hdptx, CMN_REG0076, 0x30);
+	hdptx_write(hdptx, CMN_REG0077, 0x08);
+	hdptx_write(hdptx, CMN_REG0078, 0x0c);
+	hdptx_write(hdptx, CMN_REG0079, 0x00);
+	hdptx_write(hdptx, CMN_REG007B, 0x00);
+	hdptx_write(hdptx, CMN_REG007C, 0x00);
+	hdptx_write(hdptx, CMN_REG007D, 0x00);
+	hdptx_write(hdptx, CMN_REG007E, 0x00);
+	hdptx_write(hdptx, CMN_REG007F, 0x00);
+	hdptx_write(hdptx, CMN_REG0080, 0x00);
+	hdptx_write(hdptx, CMN_REG0081, 0x01);
+	hdptx_write(hdptx, CMN_REG0082, 0x04);
+	hdptx_write(hdptx, CMN_REG0083, 0x24);
+	hdptx_write(hdptx, CMN_REG0084, 0x20);
+	hdptx_write(hdptx, CMN_REG0085, 0x03);
+
+	hdptx_update_bits(hdptx, CMN_REG0086, PLL_PCG_POSTDIV_SEL_MASK,
+			  PLL_PCG_POSTDIV_SEL(cfg->pms_sdiv));
+
+	hdptx_update_bits(hdptx, CMN_REG0086, PLL_PCG_CLK_SEL_MASK,
+			  PLL_PCG_CLK_SEL(color_depth));
+
+	hdptx_update_bits(hdptx, CMN_REG0086, PLL_PCG_CLK_EN, PLL_PCG_CLK_EN);
+
+	hdptx_write(hdptx, CMN_REG0087, 0x04);
+	hdptx_write(hdptx, CMN_REG0089, 0x00);
+	hdptx_write(hdptx, CMN_REG008A, 0x55);
+	hdptx_write(hdptx, CMN_REG008B, 0x25);
+	hdptx_write(hdptx, CMN_REG008C, 0x2c);
+	hdptx_write(hdptx, CMN_REG008D, 0x22);
+	hdptx_write(hdptx, CMN_REG008E, 0x14);
+	hdptx_write(hdptx, CMN_REG008F, 0x20);
+	hdptx_write(hdptx, CMN_REG0090, 0x00);
+	hdptx_write(hdptx, CMN_REG0091, 0x00);
+	hdptx_write(hdptx, CMN_REG0092, 0x00);
+	hdptx_write(hdptx, CMN_REG0093, 0x00);
+	hdptx_write(hdptx, CMN_REG0095, 0x00);
+	hdptx_write(hdptx, CMN_REG0097, 0x02);
+	hdptx_write(hdptx, CMN_REG0099, 0x04);
+	hdptx_write(hdptx, CMN_REG009A, 0x11);
+	hdptx_write(hdptx, CMN_REG009B, 0x00);
+
+	return hdptx_post_enable_pll(hdptx);
+}
+
+static int hdptx_ropll_tmds_mode_config(struct rockchip_hdptx_phy *hdptx, u32 rate)
+{
+	u32 bit_rate = rate & DATA_RATE_MASK;
+	u8 color_depth = (rate & COLOR_DEPTH_MASK) ? 1 : 0;
+
+	if (color_depth)
+		bit_rate = bit_rate * 5 / 4;
+
+	hdptx_write(hdptx, SB_REG0114, 0x00);
+	hdptx_write(hdptx, SB_REG0115, 0x00);
+	hdptx_write(hdptx, SB_REG0116, 0x00);
+	hdptx_write(hdptx, SB_REG0117, 0x00);
+	hdptx_write(hdptx, LNTOP_REG0200, 0x06);
+
+	if (bit_rate >= 3400000) {
+		/* For 1/40 bitrate clk */
+		hdptx_write(hdptx, LNTOP_REG0201, 0x00);
+		hdptx_write(hdptx, LNTOP_REG0202, 0x00);
+		hdptx_write(hdptx, LNTOP_REG0203, 0x0f);
+		hdptx_write(hdptx, LNTOP_REG0204, 0xff);
+		hdptx_write(hdptx, LNTOP_REG0205, 0xff);
+	} else {
+		/* For 1/10 bitrate clk */
+		hdptx_write(hdptx, LNTOP_REG0201, 0x07);
+		hdptx_write(hdptx, LNTOP_REG0202, 0xc1);
+		hdptx_write(hdptx, LNTOP_REG0203, 0xf0);
+		hdptx_write(hdptx, LNTOP_REG0204, 0x7c);
+		hdptx_write(hdptx, LNTOP_REG0205, 0x1f);
+	}
+
+	hdptx_write(hdptx, LNTOP_REG0206, 0x07);
+	hdptx_write(hdptx, LANE_REG0303, 0x0c);
+	hdptx_write(hdptx, LANE_REG0307, 0x20);
+	hdptx_write(hdptx, LANE_REG030A, 0x17);
+	hdptx_write(hdptx, LANE_REG030B, 0x77);
+	hdptx_write(hdptx, LANE_REG030C, 0x77);
+	hdptx_write(hdptx, LANE_REG030D, 0x77);
+	hdptx_write(hdptx, LANE_REG030E, 0x38);
+	hdptx_write(hdptx, LANE_REG0310, 0x03);
+	hdptx_write(hdptx, LANE_REG0311, 0x0f);
+	hdptx_write(hdptx, LANE_REG0312, 0x00);
+	hdptx_write(hdptx, LANE_REG0316, 0x02);
+	hdptx_write(hdptx, LANE_REG031B, 0x01);
+	hdptx_write(hdptx, LANE_REG031E, 0x00);
+	hdptx_write(hdptx, LANE_REG031F, 0x15);
+	hdptx_write(hdptx, LANE_REG0320, 0xa0);
+	hdptx_write(hdptx, LANE_REG0403, 0x0c);
+	hdptx_write(hdptx, LANE_REG0407, 0x20);
+	hdptx_write(hdptx, LANE_REG040A, 0x17);
+	hdptx_write(hdptx, LANE_REG040B, 0x77);
+	hdptx_write(hdptx, LANE_REG040C, 0x77);
+	hdptx_write(hdptx, LANE_REG040D, 0x77);
+	hdptx_write(hdptx, LANE_REG040E, 0x38);
+	hdptx_write(hdptx, LANE_REG0410, 0x03);
+	hdptx_write(hdptx, LANE_REG0411, 0x0f);
+	hdptx_write(hdptx, LANE_REG0412, 0x00);
+	hdptx_write(hdptx, LANE_REG0416, 0x02);
+	hdptx_write(hdptx, LANE_REG041B, 0x01);
+	hdptx_write(hdptx, LANE_REG041E, 0x00);
+	hdptx_write(hdptx, LANE_REG041F, 0x15);
+	hdptx_write(hdptx, LANE_REG0420, 0xa0);
+	hdptx_write(hdptx, LANE_REG0503, 0x0c);
+	hdptx_write(hdptx, LANE_REG0507, 0x20);
+	hdptx_write(hdptx, LANE_REG050A, 0x17);
+	hdptx_write(hdptx, LANE_REG050B, 0x77);
+	hdptx_write(hdptx, LANE_REG050C, 0x77);
+	hdptx_write(hdptx, LANE_REG050D, 0x77);
+	hdptx_write(hdptx, LANE_REG050E, 0x38);
+	hdptx_write(hdptx, LANE_REG0510, 0x03);
+	hdptx_write(hdptx, LANE_REG0511, 0x0f);
+	hdptx_write(hdptx, LANE_REG0512, 0x00);
+	hdptx_write(hdptx, LANE_REG0516, 0x02);
+	hdptx_write(hdptx, LANE_REG051B, 0x01);
+	hdptx_write(hdptx, LANE_REG051E, 0x00);
+	hdptx_write(hdptx, LANE_REG051F, 0x15);
+	hdptx_write(hdptx, LANE_REG0520, 0xa0);
+	hdptx_write(hdptx, LANE_REG0603, 0x0c);
+	hdptx_write(hdptx, LANE_REG0607, 0x20);
+	hdptx_write(hdptx, LANE_REG060A, 0x17);
+	hdptx_write(hdptx, LANE_REG060B, 0x77);
+	hdptx_write(hdptx, LANE_REG060C, 0x77);
+	hdptx_write(hdptx, LANE_REG060D, 0x77);
+	hdptx_write(hdptx, LANE_REG060E, 0x38);
+	hdptx_write(hdptx, LANE_REG0610, 0x03);
+	hdptx_write(hdptx, LANE_REG0611, 0x0f);
+	hdptx_write(hdptx, LANE_REG0612, 0x00);
+	hdptx_write(hdptx, LANE_REG0616, 0x02);
+	hdptx_write(hdptx, LANE_REG061B, 0x01);
+	hdptx_write(hdptx, LANE_REG061E, 0x08);
+
+	/* fix Inter-Pair Skew exceed the limits */
+	hdptx_write(hdptx, LANE_REG031E, 0x02);
+	hdptx_write(hdptx, LANE_REG041E, 0x02);
+	hdptx_write(hdptx, LANE_REG051E, 0x02);
+	hdptx_write(hdptx, LANE_REG061E, 0x0a);
+
+	hdptx_write(hdptx, LANE_REG061F, 0x15);
+	hdptx_write(hdptx, LANE_REG0620, 0xa0);
+
+	hdptx_write(hdptx, LANE_REG0303, 0x2f);
+	hdptx_write(hdptx, LANE_REG0403, 0x2f);
+	hdptx_write(hdptx, LANE_REG0503, 0x2f);
+	hdptx_write(hdptx, LANE_REG0603, 0x2f);
+	hdptx_write(hdptx, LANE_REG0305, 0x03);
+	hdptx_write(hdptx, LANE_REG0405, 0x03);
+	hdptx_write(hdptx, LANE_REG0505, 0x03);
+	hdptx_write(hdptx, LANE_REG0605, 0x03);
+	hdptx_write(hdptx, LANE_REG0306, 0x1c);
+	hdptx_write(hdptx, LANE_REG0406, 0x1c);
+	hdptx_write(hdptx, LANE_REG0506, 0x1c);
+	hdptx_write(hdptx, LANE_REG0606, 0x1c);
+
+	return hdptx_post_enable_lane(hdptx);
+}
+
+static int
+hdptx_lcpll_ropll_cmn_config(struct rockchip_hdptx_phy *hdptx,
+			     unsigned long rate)
+{
+	u32 val;
+
+	printf("%s rate:%lu\n", __func__, rate);
+
+	hdptx->rate = rate * 100;
+
+	hdptx_pre_power_up(hdptx);
+
+	reset_assert(&hdptx->ropll_reset);
+	udelay(20);
+	reset_deassert(&hdptx->ropll_reset);
+
+	reset_assert(&hdptx->lcpll_reset);
+	udelay(20);
+	reset_deassert(&hdptx->lcpll_reset);
+
+	/* ROPLL input reference clock from LCPLL (cascade mode) */
+	val = (LC_REF_CLK_SEL << 16) | LC_REF_CLK_SEL;
+	hdptx_grf_write(hdptx, GRF_HDPTX_CON0, val);
+
+	hdptx_write(hdptx, CMN_REG0008, 0xd0);
+	hdptx_write(hdptx, CMN_REG0009, 0x0c);
+	hdptx_write(hdptx, CMN_REG000A, 0x83);
+	hdptx_write(hdptx, CMN_REG000B, 0x06);
+	hdptx_write(hdptx, CMN_REG000C, 0x20);
+	hdptx_write(hdptx, CMN_REG000D, 0xb8);
+	hdptx_write(hdptx, CMN_REG000E, 0x0f);
+	hdptx_write(hdptx, CMN_REG000F, 0x0f);
+	hdptx_write(hdptx, CMN_REG0010, 0x04);
+	hdptx_write(hdptx, CMN_REG0011, 0x00);
+	hdptx_write(hdptx, CMN_REG0012, 0x26);
+	hdptx_write(hdptx, CMN_REG0013, 0x22);
+	hdptx_write(hdptx, CMN_REG0014, 0x24);
+	hdptx_write(hdptx, CMN_REG0015, 0x77);
+	hdptx_write(hdptx, CMN_REG0016, 0x08);
+	hdptx_write(hdptx, CMN_REG0017, 0x00);
+	hdptx_write(hdptx, CMN_REG0018, 0x04);
+	hdptx_write(hdptx, CMN_REG0019, 0x48);
+	hdptx_write(hdptx, CMN_REG001A, 0x01);
+	hdptx_write(hdptx, CMN_REG001B, 0x00);
+	hdptx_write(hdptx, CMN_REG001C, 0x01);
+	hdptx_write(hdptx, CMN_REG001D, 0x64);
+	hdptx_write(hdptx, CMN_REG001E, 0x35);
+	hdptx_write(hdptx, CMN_REG001F, 0x00);
+	hdptx_write(hdptx, CMN_REG0020, 0x6b);
+	hdptx_write(hdptx, CMN_REG0021, 0x6b);
+	hdptx_write(hdptx, CMN_REG0022, 0x11);
+	hdptx_write(hdptx, CMN_REG0024, 0x00);
+	hdptx_write(hdptx, CMN_REG0025, 0x10);
+	hdptx_write(hdptx, CMN_REG0026, 0x53);
+	hdptx_write(hdptx, CMN_REG0027, 0x15);
+	hdptx_write(hdptx, CMN_REG0028, 0x0d);
+	hdptx_write(hdptx, CMN_REG0029, 0x01);
+	hdptx_write(hdptx, CMN_REG002A, 0x09);
+	hdptx_write(hdptx, CMN_REG002B, 0x01);
+	hdptx_write(hdptx, CMN_REG002C, 0x02);
+	hdptx_write(hdptx, CMN_REG002D, 0x02);
+	hdptx_write(hdptx, CMN_REG002E, 0x0d);
+	hdptx_write(hdptx, CMN_REG002F, 0x61);
+	hdptx_write(hdptx, CMN_REG0030, 0x00);
+	hdptx_write(hdptx, CMN_REG0031, 0x20);
+	hdptx_write(hdptx, CMN_REG0032, 0x30);
+	hdptx_write(hdptx, CMN_REG0033, 0x0b);
+	hdptx_write(hdptx, CMN_REG0034, 0x23);
+	hdptx_write(hdptx, CMN_REG0035, 0x00);
+	hdptx_write(hdptx, CMN_REG0037, 0x00);
+	hdptx_write(hdptx, CMN_REG0038, 0x00);
+	hdptx_write(hdptx, CMN_REG0039, 0x00);
+	hdptx_write(hdptx, CMN_REG003A, 0x00);
+	hdptx_write(hdptx, CMN_REG003B, 0x00);
+	hdptx_write(hdptx, CMN_REG003C, 0x80);
+	hdptx_write(hdptx, CMN_REG003D, 0xc0);
+	hdptx_write(hdptx, CMN_REG003E, 0x0c);
+	hdptx_write(hdptx, CMN_REG003F, 0x83);
+	hdptx_write(hdptx, CMN_REG0040, 0x06);
+	hdptx_write(hdptx, CMN_REG0041, 0x20);
+	hdptx_write(hdptx, CMN_REG0042, 0xb8);
+	hdptx_write(hdptx, CMN_REG0043, 0x00);
+	hdptx_write(hdptx, CMN_REG0044, 0x46);
+	hdptx_write(hdptx, CMN_REG0045, 0x24);
+	hdptx_write(hdptx, CMN_REG0046, 0xff);
+	hdptx_write(hdptx, CMN_REG0047, 0x00);
+	hdptx_write(hdptx, CMN_REG0048, 0x44);
+	hdptx_write(hdptx, CMN_REG0049, 0xfa);
+	hdptx_write(hdptx, CMN_REG004A, 0x08);
+	hdptx_write(hdptx, CMN_REG004B, 0x00);
+	hdptx_write(hdptx, CMN_REG004C, 0x01);
+	hdptx_write(hdptx, CMN_REG004D, 0x64);
+	hdptx_write(hdptx, CMN_REG004E, 0x14);
+	hdptx_write(hdptx, CMN_REG004F, 0x00);
+	hdptx_write(hdptx, CMN_REG0050, 0x00);
+	hdptx_write(hdptx, CMN_REG0054, 0x19);
+	hdptx_write(hdptx, CMN_REG0058, 0x19);
+	hdptx_write(hdptx, CMN_REG0059, 0x11);
+	hdptx_write(hdptx, CMN_REG005B, 0x30);
+	hdptx_write(hdptx, CMN_REG005C, 0x25);
+	hdptx_write(hdptx, CMN_REG005D, 0x14);
+	hdptx_write(hdptx, CMN_REG005E, 0x0e);
+	hdptx_write(hdptx, CMN_REG005F, 0x01);
+	hdptx_write(hdptx, CMN_REG0063, 0x01);
+	hdptx_write(hdptx, CMN_REG0064, 0x0e);
+	hdptx_write(hdptx, CMN_REG0068, 0x00);
+	hdptx_write(hdptx, CMN_REG0069, 0x02);
+	hdptx_write(hdptx, CMN_REG006B, 0x00);
+	hdptx_write(hdptx, CMN_REG006F, 0x00);
+	hdptx_write(hdptx, CMN_REG0073, 0x02);
+	hdptx_write(hdptx, CMN_REG0074, 0x00);
+	hdptx_write(hdptx, CMN_REG0075, 0x20);
+	hdptx_write(hdptx, CMN_REG0076, 0x30);
+	hdptx_write(hdptx, CMN_REG0077, 0x08);
+	hdptx_write(hdptx, CMN_REG0078, 0x0c);
+	hdptx_write(hdptx, CMN_REG007A, 0x00);
+	hdptx_write(hdptx, CMN_REG007B, 0x00);
+	hdptx_write(hdptx, CMN_REG007C, 0x00);
+	hdptx_write(hdptx, CMN_REG007D, 0x00);
+	hdptx_write(hdptx, CMN_REG007E, 0x00);
+	hdptx_write(hdptx, CMN_REG007F, 0x00);
+	hdptx_write(hdptx, CMN_REG0080, 0x00);
+	hdptx_write(hdptx, CMN_REG0081, 0x09);
+	hdptx_write(hdptx, CMN_REG0082, 0x04);
+	hdptx_write(hdptx, CMN_REG0083, 0x24);
+	hdptx_write(hdptx, CMN_REG0084, 0x20);
+	hdptx_write(hdptx, CMN_REG0085, 0x03);
+	hdptx_write(hdptx, CMN_REG0086, 0x11);
+	hdptx_write(hdptx, CMN_REG0087, 0x0c);
+	hdptx_write(hdptx, CMN_REG0089, 0x00);
+	hdptx_write(hdptx, CMN_REG008A, 0x55);
+	hdptx_write(hdptx, CMN_REG008B, 0x25);
+	hdptx_write(hdptx, CMN_REG008C, 0x2c);
+	hdptx_write(hdptx, CMN_REG008D, 0x22);
+	hdptx_write(hdptx, CMN_REG008E, 0x14);
+	hdptx_write(hdptx, CMN_REG008F, 0x20);
+	hdptx_write(hdptx, CMN_REG0090, 0x00);
+	hdptx_write(hdptx, CMN_REG0091, 0x00);
+	hdptx_write(hdptx, CMN_REG0092, 0x00);
+	hdptx_write(hdptx, CMN_REG0093, 0x00);
+	hdptx_write(hdptx, CMN_REG0095, 0x03);
+	hdptx_write(hdptx, CMN_REG0097, 0x00);
+	hdptx_write(hdptx, CMN_REG0099, 0x00);
+	hdptx_write(hdptx, CMN_REG009A, 0x11);
+	hdptx_write(hdptx, CMN_REG009B, 0x10);
+
+	hdptx_write(hdptx, CMN_REG009E, 0x03);
+	hdptx_write(hdptx, CMN_REG00A0, 0x60);
+	hdptx_write(hdptx, CMN_REG009F, 0xff);
+
+	return hdptx_post_enable_pll(hdptx);
+}
+
+
+static int hdptx_lcpll_ropll_frl_mode_config(struct rockchip_hdptx_phy *hdptx)
+{
+	hdptx_write(hdptx, SB_REG0114, 0x00);
+	hdptx_write(hdptx, SB_REG0115, 0x00);
+	hdptx_write(hdptx, SB_REG0116, 0x00);
+	hdptx_write(hdptx, SB_REG0117, 0x00);
+	hdptx_write(hdptx, LNTOP_REG0200, 0x04);
+	hdptx_write(hdptx, LNTOP_REG0201, 0x00);
+	hdptx_write(hdptx, LNTOP_REG0202, 0x00);
+	hdptx_write(hdptx, LNTOP_REG0203, 0xf0);
+	hdptx_write(hdptx, LNTOP_REG0204, 0xff);
+	hdptx_write(hdptx, LNTOP_REG0205, 0xff);
+	hdptx_write(hdptx, LNTOP_REG0206, 0x05);
+	hdptx_write(hdptx, LANE_REG0303, 0x0c);
+	hdptx_write(hdptx, LANE_REG0307, 0x20);
+	hdptx_write(hdptx, LANE_REG030A, 0x17);
+	hdptx_write(hdptx, LANE_REG030B, 0x77);
+	hdptx_write(hdptx, LANE_REG030C, 0x77);
+	hdptx_write(hdptx, LANE_REG030D, 0x77);
+	hdptx_write(hdptx, LANE_REG030E, 0x38);
+	hdptx_write(hdptx, LANE_REG0310, 0x03);
+	hdptx_write(hdptx, LANE_REG0311, 0x0f);
+	hdptx_write(hdptx, LANE_REG0312, 0x3c);
+	hdptx_write(hdptx, LANE_REG0316, 0x02);
+	hdptx_write(hdptx, LANE_REG031B, 0x01);
+	hdptx_write(hdptx, LANE_REG031F, 0x15);
+	hdptx_write(hdptx, LANE_REG0320, 0xa0);
+	hdptx_write(hdptx, LANE_REG0403, 0x0c);
+	hdptx_write(hdptx, LANE_REG0407, 0x20);
+	hdptx_write(hdptx, LANE_REG040A, 0x17);
+	hdptx_write(hdptx, LANE_REG040B, 0x77);
+	hdptx_write(hdptx, LANE_REG040C, 0x77);
+	hdptx_write(hdptx, LANE_REG040D, 0x77);
+	hdptx_write(hdptx, LANE_REG040E, 0x38);
+	hdptx_write(hdptx, LANE_REG0410, 0x03);
+	hdptx_write(hdptx, LANE_REG0411, 0x0f);
+	hdptx_write(hdptx, LANE_REG0412, 0x3c);
+	hdptx_write(hdptx, LANE_REG0416, 0x02);
+	hdptx_write(hdptx, LANE_REG041B, 0x01);
+	hdptx_write(hdptx, LANE_REG041F, 0x15);
+	hdptx_write(hdptx, LANE_REG0420, 0xa0);
+	hdptx_write(hdptx, LANE_REG0503, 0x0c);
+	hdptx_write(hdptx, LANE_REG0507, 0x20);
+	hdptx_write(hdptx, LANE_REG050A, 0x17);
+	hdptx_write(hdptx, LANE_REG050B, 0x77);
+	hdptx_write(hdptx, LANE_REG050C, 0x77);
+	hdptx_write(hdptx, LANE_REG050D, 0x77);
+	hdptx_write(hdptx, LANE_REG0507, 0x20);
+	hdptx_write(hdptx, LANE_REG050A, 0x17);
+	hdptx_write(hdptx, LANE_REG050B, 0x77);
+	hdptx_write(hdptx, LANE_REG050C, 0x77);
+	hdptx_write(hdptx, LANE_REG050D, 0x77);
+	hdptx_write(hdptx, LANE_REG050E, 0x38);
+	hdptx_write(hdptx, LANE_REG0510, 0x03);
+	hdptx_write(hdptx, LANE_REG0511, 0x0f);
+	hdptx_write(hdptx, LANE_REG0512, 0x3c);
+	hdptx_write(hdptx, LANE_REG0516, 0x02);
+	hdptx_write(hdptx, LANE_REG051B, 0x01);
+	hdptx_write(hdptx, LANE_REG051F, 0x15);
+	hdptx_write(hdptx, LANE_REG0520, 0xa0);
+	hdptx_write(hdptx, LANE_REG0603, 0x0c);
+	hdptx_write(hdptx, LANE_REG0607, 0x20);
+	hdptx_write(hdptx, LANE_REG060A, 0x17);
+	hdptx_write(hdptx, LANE_REG060B, 0x77);
+	hdptx_write(hdptx, LANE_REG060C, 0x77);
+	hdptx_write(hdptx, LANE_REG060D, 0x77);
+	hdptx_write(hdptx, LANE_REG060E, 0x38);
+	hdptx_write(hdptx, LANE_REG0610, 0x03);
+	hdptx_write(hdptx, LANE_REG0611, 0x0f);
+	hdptx_write(hdptx, LANE_REG0612, 0x3c);
+	hdptx_write(hdptx, LANE_REG0616, 0x02);
+	hdptx_write(hdptx, LANE_REG061B, 0x01);
+	hdptx_write(hdptx, LANE_REG061F, 0x15);
+	hdptx_write(hdptx, LANE_REG0620, 0xa0);
+
+	hdptx_write(hdptx, LANE_REG031E, 0x02);
+	hdptx_write(hdptx, LANE_REG041E, 0x02);
+	hdptx_write(hdptx, LANE_REG051E, 0x02);
+	hdptx_write(hdptx, LANE_REG061E, 0x02);
+
+	hdptx_write(hdptx, LANE_REG0303, 0x2f);
+	hdptx_write(hdptx, LANE_REG0403, 0x2f);
+	hdptx_write(hdptx, LANE_REG0503, 0x2f);
+	hdptx_write(hdptx, LANE_REG0603, 0x2f);
+	hdptx_write(hdptx, LANE_REG0305, 0x03);
+	hdptx_write(hdptx, LANE_REG0405, 0x03);
+	hdptx_write(hdptx, LANE_REG0505, 0x03);
+	hdptx_write(hdptx, LANE_REG0605, 0x03);
+	hdptx_write(hdptx, LANE_REG0306, 0xfc);
+	hdptx_write(hdptx, LANE_REG0406, 0xfc);
+	hdptx_write(hdptx, LANE_REG0506, 0xfc);
+	hdptx_write(hdptx, LANE_REG0606, 0xfc);
+
+	hdptx_write(hdptx, LANE_REG0305, 0x4f);
+	hdptx_write(hdptx, LANE_REG0405, 0x4f);
+	hdptx_write(hdptx, LANE_REG0505, 0x4f);
+	hdptx_write(hdptx, LANE_REG0605, 0x4f);
+	hdptx_write(hdptx, LANE_REG0304, 0x14);
+	hdptx_write(hdptx, LANE_REG0404, 0x14);
+	hdptx_write(hdptx, LANE_REG0504, 0x14);
+	hdptx_write(hdptx, LANE_REG0604, 0x14);
+
+	return hdptx_post_enable_lane(hdptx);
+}
+
+
+static int hdptx_lcpll_frl_mode_config(struct rockchip_hdptx_phy *hdptx, u32 rate)
+{
+	hdptx_write(hdptx, LNTOP_REG0200, 0x04);
+	hdptx_write(hdptx, LNTOP_REG0201, 0x00);
+	hdptx_write(hdptx, LNTOP_REG0202, 0x00);
+	hdptx_write(hdptx, LNTOP_REG0203, 0xf0);
+	hdptx_write(hdptx, LNTOP_REG0204, 0xff);
+	hdptx_write(hdptx, LNTOP_REG0205, 0xff);
+	hdptx_write(hdptx, LNTOP_REG0206, 0x05);
+	hdptx_write(hdptx, LANE_REG0303, 0x0c);
+	hdptx_write(hdptx, LANE_REG0307, 0x20);
+	hdptx_write(hdptx, LANE_REG030A, 0x17);
+	hdptx_write(hdptx, LANE_REG030B, 0x77);
+	hdptx_write(hdptx, LANE_REG030C, 0x77);
+	hdptx_write(hdptx, LANE_REG030D, 0x77);
+	hdptx_write(hdptx, LANE_REG030E, 0x38);
+	hdptx_write(hdptx, LANE_REG0310, 0x03);
+	hdptx_write(hdptx, LANE_REG0311, 0x0f);
+	hdptx_write(hdptx, LANE_REG0312, 0x3c);
+	hdptx_write(hdptx, LANE_REG0316, 0x02);
+	hdptx_write(hdptx, LANE_REG031B, 0x01);
+	hdptx_write(hdptx, LANE_REG031F, 0x15);
+	hdptx_write(hdptx, LANE_REG0320, 0xa0);
+	hdptx_write(hdptx, LANE_REG0403, 0x0c);
+	hdptx_write(hdptx, LANE_REG0407, 0x20);
+	hdptx_write(hdptx, LANE_REG040A, 0x17);
+	hdptx_write(hdptx, LANE_REG040B, 0x77);
+	hdptx_write(hdptx, LANE_REG040C, 0x77);
+	hdptx_write(hdptx, LANE_REG040D, 0x77);
+	hdptx_write(hdptx, LANE_REG040E, 0x38);
+	hdptx_write(hdptx, LANE_REG0410, 0x03);
+	hdptx_write(hdptx, LANE_REG0411, 0x0f);
+	hdptx_write(hdptx, LANE_REG0412, 0x3c);
+	hdptx_write(hdptx, LANE_REG0416, 0x02);
+	hdptx_write(hdptx, LANE_REG041B, 0x01);
+	hdptx_write(hdptx, LANE_REG041F, 0x15);
+	hdptx_write(hdptx, LANE_REG0420, 0xa0);
+	hdptx_write(hdptx, LANE_REG0503, 0x0c);
+	hdptx_write(hdptx, LANE_REG0507, 0x20);
+	hdptx_write(hdptx, LANE_REG050A, 0x17);
+	hdptx_write(hdptx, LANE_REG050B, 0x77);
+	hdptx_write(hdptx, LANE_REG050C, 0x77);
+	hdptx_write(hdptx, LANE_REG050D, 0x77);
+	hdptx_write(hdptx, LANE_REG050E, 0x38);
+	hdptx_write(hdptx, LANE_REG0510, 0x03);
+	hdptx_write(hdptx, LANE_REG0511, 0x0f);
+	hdptx_write(hdptx, LANE_REG0512, 0x3c);
+	hdptx_write(hdptx, LANE_REG0516, 0x02);
+	hdptx_write(hdptx, LANE_REG051B, 0x01);
+	hdptx_write(hdptx, LANE_REG051F, 0x15);
+	hdptx_write(hdptx, LANE_REG0520, 0xa0);
+	hdptx_write(hdptx, LANE_REG0603, 0x0c);
+	hdptx_write(hdptx, LANE_REG0607, 0x20);
+	hdptx_write(hdptx, LANE_REG060A, 0x17);
+	hdptx_write(hdptx, LANE_REG060B, 0x77);
+	hdptx_write(hdptx, LANE_REG060C, 0x77);
+	hdptx_write(hdptx, LANE_REG060D, 0x77);
+	hdptx_write(hdptx, LANE_REG060E, 0x38);
+	hdptx_write(hdptx, LANE_REG0610, 0x03);
+	hdptx_write(hdptx, LANE_REG0611, 0x0f);
+	hdptx_write(hdptx, LANE_REG0612, 0x3c);
+	hdptx_write(hdptx, LANE_REG0616, 0x02);
+	hdptx_write(hdptx, LANE_REG061B, 0x01);
+	hdptx_write(hdptx, LANE_REG061F, 0x15);
+	hdptx_write(hdptx, LANE_REG0620, 0xa0);
+
+	hdptx_write(hdptx, LANE_REG031E, 0x02);
+	hdptx_write(hdptx, LANE_REG041E, 0x02);
+	hdptx_write(hdptx, LANE_REG051E, 0x02);
+	hdptx_write(hdptx, LANE_REG061E, 0x02);
+
+	hdptx_write(hdptx, LANE_REG0303, 0x2f);
+	hdptx_write(hdptx, LANE_REG0403, 0x2f);
+	hdptx_write(hdptx, LANE_REG0503, 0x2f);
+	hdptx_write(hdptx, LANE_REG0603, 0x2f);
+	hdptx_write(hdptx, LANE_REG0305, 0x03);
+	hdptx_write(hdptx, LANE_REG0405, 0x03);
+	hdptx_write(hdptx, LANE_REG0505, 0x03);
+	hdptx_write(hdptx, LANE_REG0605, 0x03);
+	hdptx_write(hdptx, LANE_REG0306, 0xfc);
+	hdptx_write(hdptx, LANE_REG0406, 0xfc);
+	hdptx_write(hdptx, LANE_REG0506, 0xfc);
+	hdptx_write(hdptx, LANE_REG0606, 0xfc);
+
+	hdptx_write(hdptx, LANE_REG0305, 0x4f);
+	hdptx_write(hdptx, LANE_REG0405, 0x4f);
+	hdptx_write(hdptx, LANE_REG0505, 0x4f);
+	hdptx_write(hdptx, LANE_REG0605, 0x4f);
+	hdptx_write(hdptx, LANE_REG0304, 0x14);
+	hdptx_write(hdptx, LANE_REG0404, 0x14);
+	hdptx_write(hdptx, LANE_REG0504, 0x14);
+	hdptx_write(hdptx, LANE_REG0604, 0x14);
+
+	return hdptx_post_enable_lane(hdptx);
+}
+
+static int rockchip_hdptx_phy_power_on(struct rockchip_phy *phy)
+{
+	struct rockchip_hdptx_phy *hdptx = dev_get_priv(phy->dev);
+	int bus_width = hdptx->bus_width;
+	int bit_rate = bus_width & DATA_RATE_MASK;
+
+	printf("bus_width:0x%x,bit_rate:%d\n", bus_width, bit_rate);
+
+	if (bus_width & HDMI_MODE_MASK)
+		if (bit_rate != (FRL_8G_4LANES / 100))
+			return hdptx_lcpll_frl_mode_config(hdptx, bus_width);
+		else
+			return hdptx_lcpll_ropll_frl_mode_config(hdptx);
+	else
+		return hdptx_ropll_tmds_mode_config(hdptx, bus_width);
+}
+
+static int rockchip_hdptx_phy_power_off(struct rockchip_phy *phy)
+{
+	return 0;
+}
+
+static long rockchip_hdptx_phy_clk_round_rate(struct rockchip_phy *phy,
+					      unsigned long rate)
+{
+	struct ropll_config *cfg = ropll_tmds_cfg;
+	u32 bit_rate = rate / 100;
+
+	for (; cfg->bit_rate != ~0; cfg++)
+		if (bit_rate == cfg->bit_rate)
+			break;
+
+	if (cfg->bit_rate == ~0 && !hdptx_phy_clk_pll_calc(bit_rate, NULL))
+		return -EINVAL;
+
+	return rate;
+}
+
+static unsigned long rockchip_hdptx_phy_clk_set_rate(struct rockchip_phy *phy,
+						     unsigned long rate)
+{
+	struct rockchip_hdptx_phy *hdptx = dev_get_priv(phy->dev);
+	int bus_width = hdptx->bus_width;
+	u8 color_depth = (bus_width & COLOR_DEPTH_MASK) ? 1 : 0;
+
+	if (color_depth)
+		rate = (rate / 100) * 5 / 4;
+	else
+		rate = rate / 100;
+	return hdptx_ropll_cmn_config(hdptx, rate);
+}
+
+static int
+rockchip_hdptx_phy_set_bus_width(struct rockchip_phy *phy, u32 bus_width)
+{
+	struct rockchip_hdptx_phy *hdptx = dev_get_priv(phy->dev);
+
+	hdptx->bus_width = bus_width;
+
+	return 0;
+}
+
+const struct rockchip_phy_funcs hdptx_hdmi_phy_funcs = {
+	.power_on = rockchip_hdptx_phy_power_on,
+	.power_off = rockchip_hdptx_phy_power_off,
+	.set_pll = rockchip_hdptx_phy_clk_set_rate,
+	.set_bus_width = rockchip_hdptx_phy_set_bus_width,
+	.round_rate = rockchip_hdptx_phy_clk_round_rate,
+};
+
+static struct rockchip_phy hdptx_hdmi_phy_driver_data0 = {
+	 .funcs = &hdptx_hdmi_phy_funcs,
+};
+
+static struct rockchip_phy hdptx_hdmi_phy_driver_data1 = {
+	 .funcs = &hdptx_hdmi_phy_funcs,
+};
+
+static int rockchip_hdptx_phy_hdmi_probe(struct udevice *dev)
+{
+	struct rockchip_hdptx_phy *hdptx = dev_get_priv(dev);
+	struct rockchip_phy *phy;
+	struct udevice *syscon;
+	int ret;
+
+	hdptx->id = of_alias_get_id(ofnode_to_np(dev->node_), "hdptxhdmi");
+	if (hdptx->id < 0)
+		hdptx->id = 0;
+
+	if (!hdptx->id) {
+		g_hdptx0 = hdptx;
+		dev->driver_data = (ulong)&hdptx_hdmi_phy_driver_data0;
+		phy = &hdptx_hdmi_phy_driver_data0;
+	} else {
+		g_hdptx1 = hdptx;
+		dev->driver_data = (ulong)&hdptx_hdmi_phy_driver_data1;
+		phy = &hdptx_hdmi_phy_driver_data1;
+	}
+
+	hdptx->base = dev_read_addr_ptr(dev);
+	if (!hdptx->base)
+		return -ENOENT;
+
+	ret = uclass_get_device_by_phandle(UCLASS_SYSCON, dev, "rockchip,grf",
+					   &syscon);
+	if (ret)
+		return ret;
+
+	hdptx->grf = syscon_get_regmap(syscon);
+	if (IS_ERR(hdptx->grf)) {
+		ret = PTR_ERR(hdptx->grf);
+		dev_err(dev, "unable to find regmap: %d\n", ret);
+		return ret;
+	}
+
+	hdptx->dev = dev;
+	phy->dev = dev;
+
+	ret = reset_get_by_name(dev, "apb", &hdptx->apb_reset);
+	if (ret < 0) {
+		dev_err(dev, "failed to get apb reset: %d\n", ret);
+		return ret;
+	}
+
+	ret = reset_get_by_name(dev, "init", &hdptx->init_reset);
+	if (ret < 0) {
+		dev_err(dev, "failed to get init reset: %d\n", ret);
+		return ret;
+	}
+
+	ret = reset_get_by_name(dev, "cmn", &hdptx->cmn_reset);
+	if (ret < 0) {
+		dev_err(dev, "failed to get cmn reset: %d\n", ret);
+		return ret;
+	}
+
+	ret = reset_get_by_name(dev, "lane", &hdptx->lane_reset);
+	if (ret < 0) {
+		dev_err(dev, "failed to get lane reset: %d\n", ret);
+		return ret;
+	}
+
+	ret = reset_get_by_name(dev, "ropll", &hdptx->ropll_reset);
+	if (ret < 0) {
+		dev_err(dev, "failed to get ropll reset: %d\n", ret);
+		return ret;
+	}
+
+	ret = reset_get_by_name(dev, "lcpll", &hdptx->lcpll_reset);
+	if (ret < 0) {
+		dev_err(dev, "failed to get lane reset: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int rockchip_hdptx_phy_hdmi_bind(struct udevice *parent)
+{
+	struct udevice *child;
+	ofnode subnode;
+	char name[30], *str;
+	int id, ret;
+
+	id = of_alias_get_id(ofnode_to_np(parent->node_), "hdptxhdmi");
+	if (id < 0)
+		id = 0;
+
+	sprintf(name, "hdmiphypll_clk%d", id);
+	str = strdup(name);
+
+	subnode = ofnode_find_subnode(parent->node_, "clk-port");
+	if (!ofnode_valid(subnode)) {
+		ret = device_bind_driver_to_node(parent, "clk_hdptx", str,
+						 dev_ofnode(parent), NULL);
+	} else {
+		ret = device_bind_driver_to_node(parent, "clk_hdptx", str,
+						 subnode, &child);
+	}
+
+	if (ret) {
+		free(str);
+		printf("%s: clk_hdptx cannot bind its driver\n", __func__);
+		return ret;
+	}
+
+	return 0;
+}
+
+static const struct udevice_id rockchip_hdptx_phy_hdmi_ids[] = {
+	{ .compatible = "rockchip,rk3588-hdptx-phy",
+	  .data = (ulong)&hdptx_hdmi_phy_driver_data0,
+	},
+	{}
+};
+
+U_BOOT_DRIVER(rockchip_hdptx_phy_hdmi) = {
+	.name		= "rockchip_hdptx_phy_hdmi",
+	.id		= UCLASS_PHY,
+	.of_match	= rockchip_hdptx_phy_hdmi_ids,
+	.probe		= rockchip_hdptx_phy_hdmi_probe,
+	.bind		= rockchip_hdptx_phy_hdmi_bind,
+	.priv_auto = sizeof(struct rockchip_hdptx_phy),
+};
+
+static struct rockchip_hdptx_phy *get_hdptx(struct udevice *dev)
+{
+	if (!strcmp(dev->name, "hdmiphypll_clk0"))
+		return g_hdptx0;
+
+	return g_hdptx1;
+}
+
+static ulong hdptx_clk_get_rate(struct clk *clk)
+{
+	struct clk_hdptx *priv = dev_get_priv(clk->dev);
+
+	return priv->rate;
+}
+
+static ulong hdptx_clk_set_rate(struct clk *clk, ulong rate)
+{
+	struct clk_hdptx *priv = dev_get_priv(clk->dev);
+	struct rockchip_hdptx_phy *hdptx = get_hdptx(clk->dev);
+	int bus_width = hdptx->bus_width;
+	u8 color_depth = (bus_width & COLOR_DEPTH_MASK) ? 1 : 0;
+	ulong new_rate = -ENOENT;
+
+	if (color_depth && rate <= HDMI20_MAX_RATE)
+		rate = (rate / 100) * 5 / 4;
+	else
+		rate = rate / 100;
+
+	if (rate > (HDMI20_MAX_RATE / 100)) {
+		if  (rate == FRL_8G_4LANES / 100) {
+			if (!hdptx_lcpll_ropll_cmn_config(hdptx, rate)) {
+				new_rate = rate;
+				priv->rate = rate;
+			}
+		} else {
+			if (!hdptx_lcpll_cmn_config(hdptx, rate)) {
+				new_rate = rate;
+				priv->rate = rate;
+			}
+		}
+	} else {
+		if (!hdptx_ropll_cmn_config(hdptx, rate)) {
+			new_rate = rate;
+			priv->rate = rate;
+		}
+	}
+
+	return new_rate;
+}
+
+static const struct clk_ops hdptx_clk_ops = {
+	.get_rate	= hdptx_clk_get_rate,
+	.set_rate	= hdptx_clk_set_rate,
+};
+
+static int hdptx_clk_probe(struct udevice *dev)
+{
+	return 0;
+}
+
+/*
+ * In order for other display interfaces to use hdmiphy as source
+ * for dclk, hdmiphy must register a virtual clock driver
+ */
+U_BOOT_DRIVER(clk_hdptx) = {
+	.name		= "clk_hdptx",
+	.id		= UCLASS_CLK,
+	.priv_auto = sizeof(struct clk_hdptx),
+	.ops		= &hdptx_clk_ops,
+	.probe		= hdptx_clk_probe,
+};
diff --git a/drivers/video/drm/rk1000.c b/drivers/video/drm/rk1000.c
new file mode 100644
index 0000000000..030d3c8fc5
--- /dev/null
+++ b/drivers/video/drm/rk1000.c
@@ -0,0 +1,139 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2019 Fuzhou Rockchip Electronics Co., Ltd
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <errno.h>
+#include <i2c.h>
+#include <dm/pinctrl.h>
+#include <dm/uclass.h>
+#include <dm/uclass-id.h>
+
+#include "rk1000.h"
+
+#define CTRL_ADC		0x00
+#define ADC_OFF			0x88
+#define CTRL_CODEC		0x01
+#define CODEC_OFF		0x0d
+#define CTRL_I2C		0x02
+#define I2C_TIMEOUT_PERIOD	0x22
+#define CTRL_TVE		0x03
+#define TVE_OFF			0x00
+
+int rk1000_ctl_i2c_write(struct rk1000_ctl *rk1000_ctl, u8 reg, u8 val)
+{
+	struct dm_i2c_chip *chip = dev_get_parent_platdata(rk1000_ctl->dev);
+	struct i2c_msg msg;
+	u8 buf[2];
+	int ret;
+
+	buf[0] = reg;
+	buf[1] = val;
+	msg.addr = chip->chip_addr;
+	msg.flags = 0;
+	msg.len = 2;
+	msg.buf = buf;
+
+	ret = dm_i2c_xfer(rk1000_ctl->dev, &msg, 1);
+	if (ret) {
+		dev_err(rk1000_ctl->dev, "rk1000 ctrl i2c write failed: %d\n",
+			ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+int rk1000_ctl_i2c_read(struct rk1000_ctl *rk1000_ctl, u8 reg, u8 *val)
+{
+	struct dm_i2c_chip *chip = dev_get_parent_platdata(rk1000_ctl->dev);
+	u8 data;
+	struct i2c_msg msg[] = {
+		{
+			.addr = chip->chip_addr,
+			.flags = 0,
+			.buf = (u8 *)&reg,
+			.len = 1,
+		}, {
+			.addr = chip->chip_addr,
+			.flags = I2C_M_RD,
+			.buf = (u8 *)&data,
+			.len = 1,
+		}
+	};
+	int ret;
+
+	ret = dm_i2c_xfer(rk1000_ctl->dev, msg, 2);
+	if (ret) {
+		dev_err(rk1000_ctl->dev, "rk1000 ctrl i2c read failed: %d\n",
+			ret);
+		return ret;
+	}
+
+	*val = data;
+
+	return 0;
+}
+
+int rk1000_ctl_write_block(struct rk1000_ctl *rk1000_ctl,
+			   u8 reg, const u8 *buf, u8 len)
+{
+	int i, ret;
+
+	for (i = 0; i < len; i++) {
+		ret = rk1000_ctl_i2c_write(rk1000_ctl, reg + i, buf[i]);
+		if (ret)
+			break;
+	}
+
+	return ret;
+}
+
+static int rk1000_ctl_probe(struct udevice *dev)
+{
+	struct rk1000_ctl *rk1000_ctl = dev_get_priv(dev);
+	int ret;
+
+	rk1000_ctl->dev = dev;
+
+	ret = gpio_request_by_name(dev, "reset-gpios", 0,
+				   &rk1000_ctl->reset_gpio, GPIOD_IS_OUT);
+	if (ret) {
+		dev_err(dev, "Cannot get reset GPIO: %d\n", ret);
+		return ret;
+	}
+
+	ret = clk_get_by_name(dev, "mclk", &rk1000_ctl->mclk);
+	if (ret < 0) {
+		dev_err(dev, "failed to get clkin: %d\n", ret);
+		return ret;
+	}
+
+	clk_enable(&rk1000_ctl->mclk);
+
+	pinctrl_select_state(rk1000_ctl->dev, "default");
+
+	dm_gpio_set_value(&rk1000_ctl->reset_gpio, 0);
+	mdelay(1);
+	dm_gpio_set_value(&rk1000_ctl->reset_gpio, 1);
+	mdelay(1);
+	dm_gpio_set_value(&rk1000_ctl->reset_gpio, 0);
+
+	return 0;
+}
+
+static const struct udevice_id rk1000_ctl_of_match[] = {
+	{ .compatible = "rockchip,rk1000-ctl" },
+	{}
+};
+
+U_BOOT_DRIVER(rk1000) = {
+	.name = "rk1000_ctl",
+	.id = UCLASS_I2C_GENERIC,
+	.of_match = rk1000_ctl_of_match,
+	.probe = rk1000_ctl_probe,
+	.bind = dm_scan_fdt_dev,
+	.priv_auto_alloc_size = sizeof(struct rk1000_ctl),
+};
diff --git a/drivers/video/drm/rk1000.h b/drivers/video/drm/rk1000.h
new file mode 100644
index 0000000000..60f67032ee
--- /dev/null
+++ b/drivers/video/drm/rk1000.h
@@ -0,0 +1,24 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * (C) Copyright 2019 Fuzhou Rockchip Electronics Co., Ltd
+ */
+
+#ifndef _RK1000_H_
+#define _RK1000_H_
+
+#include <clk.h>
+#include <asm/gpio.h>
+#include <dm/device.h>
+#include <power/regulator.h>
+
+struct rk1000_ctl {
+	struct udevice *dev;
+	struct gpio_desc reset_gpio;
+	struct clk mclk;
+};
+
+int rk1000_ctl_i2c_read(struct rk1000_ctl *rk1000_ctl, u8 reg, u8 *val);
+int rk1000_ctl_write_block(struct rk1000_ctl *rk1000_ctl,
+			   u8 reg, const u8 *buf, u8 len);
+
+#endif
diff --git a/drivers/video/drm/rk1000_tve.c b/drivers/video/drm/rk1000_tve.c
new file mode 100644
index 0000000000..19a9163ad0
--- /dev/null
+++ b/drivers/video/drm/rk1000_tve.c
@@ -0,0 +1,316 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2019 Fuzhou Rockchip Electronics Co., Ltd
+ */
+
+#include <common.h>
+#include <boot_rkimg.h>
+#include <dm.h>
+#include <errno.h>
+#include <i2c.h>
+#include <video_bridge.h>
+#include <asm/io.h>
+#include <dm/device.h>
+#include <dm/device-internal.h>
+#include <linux/media-bus-format.h>
+
+#include "rockchip_bridge.h"
+#include "rockchip_display.h"
+#include "rockchip_panel.h"
+
+#include "rk1000.h"
+
+#define TVE_POWCR	0x03
+#define TVE_OFF		0X07
+#define TVE_ON		0x03
+
+struct rk1000_tve {
+	struct udevice *dev;
+	struct rk1000_ctl rk1000_ctl;
+};
+
+enum {
+	CVBS_NTSC = 0,
+	CVBS_PAL,
+};
+
+int rk1000_tve_i2c_write(struct rk1000_tve *rk1000_tve, u8 reg, u8 val)
+{
+	struct dm_i2c_chip *chip = dev_get_parent_platdata(rk1000_tve->dev);
+	struct i2c_msg msg;
+	u8 buf[2];
+	int ret;
+
+	buf[0] = reg;
+	buf[1] = val;
+	msg.addr = chip->chip_addr;
+	msg.flags = 0;
+	msg.len = 2;
+	msg.buf = buf;
+
+	ret = dm_i2c_xfer(rk1000_tve->dev, &msg, 1);
+	if (ret) {
+		dev_err(rk1000_tve->dev,
+			"rk1000 tve i2c write failed: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+int rk1000_tve_i2c_read(struct rk1000_tve *rk1000_tve, u8 reg, u8 *val)
+{
+	struct dm_i2c_chip *chip = dev_get_parent_platdata(rk1000_tve->dev);
+	u8 data;
+	struct i2c_msg msg[] = {
+		{
+			.addr = chip->chip_addr,
+			.flags = 0,
+			.buf = (u8 *)&reg,
+			.len = 1,
+		}, {
+			.addr = chip->chip_addr,
+			.flags = I2C_M_RD,
+			.buf = (u8 *)&data,
+			.len = 1,
+		}
+	};
+	int ret;
+
+	ret = dm_i2c_xfer(rk1000_tve->dev, msg, 2);
+	if (ret) {
+		dev_err(rk1000_tve->dev,
+			"rk1000 tve i2c read failed: %d\n", ret);
+		return ret;
+	}
+
+	*val = data;
+
+	return 0;
+}
+
+static int rk1000_tv_write_block(struct rk1000_tve *rk1000_tve,
+				 u8 reg, const u8 *buf, u8 len)
+{
+	int i, ret;
+
+	for (i = 0; i < len; i++) {
+		ret = rk1000_tve_i2c_write(rk1000_tve, reg + i, buf[i]);
+		if (ret)
+			break;
+	}
+
+	return ret;
+}
+
+static int rk1000_tve_probe(struct udevice *dev)
+{
+	struct rk1000_tve *rk1000_tve = dev_get_priv(dev);
+	struct rockchip_bridge *bridge =
+		(struct rockchip_bridge *)dev_get_driver_data(dev);
+	int ret;
+
+	rk1000_tve->dev = dev;
+
+	ret = uclass_get_device_by_name(UCLASS_I2C_GENERIC,
+					"rk1000-ctl@40",
+					&rk1000_tve->rk1000_ctl.dev);
+	if (ret)
+		return ret;
+
+	bridge->dev = dev;
+
+	return 0;
+}
+
+static void rk1000_tve_bridge_enable(struct rockchip_bridge *bridge)
+{
+	u8 tv_encoder_regs_pal[] = {0x06, 0x00, 0x00, 0x03, 0x00, 0x00};
+	u8 tv_encoder_control_regs_pal[] = {0x41, 0x01};
+	u8 tv_encoder_regs_ntsc[] = {0x00, 0x00, 0x00, 0x03, 0x00, 0x00};
+	u8 tv_encoder_control_regs_ntsc[] = {0x43, 0x01};
+	char data[4] = {0x88, 0x00, 0x22, 0x00};
+	struct rk1000_tve *rk1000_tve = dev_get_priv(bridge->dev);
+	struct connector_state *conn_state = &bridge->state->conn_state;
+	struct drm_display_mode *mode = &conn_state->mode;
+	struct rk1000_ctl *rk1000_ctl = &rk1000_tve->rk1000_ctl;
+
+	rk1000_ctl_write_block(rk1000_ctl, 0, (u8 *)data, 4);
+
+	/* rk1000 power down output dac */
+	data[0] = 0x07;
+	rk1000_tv_write_block(rk1000_tve, 0x03, (u8 *)data, 1);
+
+	if (mode->vdisplay == 576) {
+		rk1000_tv_write_block(rk1000_tve, 0, tv_encoder_regs_pal,
+				      sizeof(tv_encoder_regs_pal));
+		rk1000_ctl_write_block(rk1000_ctl, 3,
+				       tv_encoder_control_regs_pal,
+				       sizeof(tv_encoder_control_regs_pal));
+	} else {
+		rk1000_tv_write_block(rk1000_tve, 0, tv_encoder_regs_ntsc,
+				      sizeof(tv_encoder_regs_ntsc));
+		rk1000_ctl_write_block(rk1000_ctl, 3,
+				       tv_encoder_control_regs_ntsc,
+				       sizeof(tv_encoder_control_regs_ntsc));
+	}
+}
+
+static void rk1000_tve_bridge_disable(struct rockchip_bridge *bridge)
+{
+	struct rk1000_tve *rk1000_tve = dev_get_priv(bridge->dev);
+	char data[1] = {0x07};
+
+	/* rk1000 power down output dac */
+	rk1000_tv_write_block(rk1000_tve, 0x03, (u8 *)data, 1);
+}
+
+static void drm_rk1000_select_output(struct overscan *overscan,
+				     struct drm_display_mode *mode)
+{
+	char baseparameter_buf[8 * RK_BLK_SIZE] __aligned(ARCH_DMA_MINALIGN);
+	struct base_screen_info *screen_info = NULL;
+	struct base_disp_info base_parameter;
+	struct blk_desc *dev_desc;
+	const struct base_overscan *scan;
+	disk_partition_t part_info;
+	int ret, i, screen_size;
+	int max_scan = 100;
+	int min_scan = 51;
+
+	overscan->left_margin = max_scan;
+	overscan->right_margin = max_scan;
+	overscan->top_margin = max_scan;
+	overscan->bottom_margin = max_scan;
+
+	mode->hdisplay = 720;
+	mode->hsync_start = 732;
+	mode->hsync_end = 738;
+	mode->htotal = 864;
+	mode->vdisplay = 576;
+	mode->vsync_start = 582;
+	mode->vsync_end = 588;
+	mode->vtotal = 625;
+	mode->clock = 27000;
+	mode->flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC;
+
+	dev_desc = rockchip_get_bootdev();
+	if (!dev_desc) {
+		printf("%s: Could not find device\n", __func__);
+		return;
+	}
+
+	if (part_get_info_by_name(dev_desc, "baseparameter", &part_info) < 0) {
+		printf("Could not find baseparameter partition\n");
+		return;
+	}
+
+	ret = blk_dread(dev_desc, part_info.start, 1,
+			(void *)baseparameter_buf);
+	if (ret < 0) {
+		printf("read baseparameter failed\n");
+		return;
+	}
+
+	memcpy(&base_parameter, baseparameter_buf, sizeof(base_parameter));
+	scan = &base_parameter.scan;
+
+	screen_size = sizeof(base_parameter.screen_list) /
+		sizeof(base_parameter.screen_list[0]);
+
+	for (i = 0; i < screen_size; i++) {
+		if (base_parameter.screen_list[i].type ==
+		    DRM_MODE_CONNECTOR_TV) {
+			screen_info = &base_parameter.screen_list[i];
+			break;
+		}
+	}
+
+	if (scan->leftscale < min_scan && scan->leftscale > 0)
+		overscan->left_margin = min_scan;
+	else if (scan->leftscale < max_scan)
+		overscan->left_margin = scan->leftscale;
+
+	if (scan->rightscale < min_scan && scan->rightscale > 0)
+		overscan->right_margin = min_scan;
+	else if (scan->rightscale < max_scan)
+		overscan->right_margin = scan->rightscale;
+
+	if (scan->topscale < min_scan && scan->topscale > 0)
+		overscan->top_margin = min_scan;
+	else if (scan->topscale < max_scan)
+		overscan->top_margin = scan->topscale;
+
+	if (scan->bottomscale < min_scan && scan->bottomscale > 0)
+		overscan->bottom_margin = min_scan;
+	else if (scan->bottomscale < max_scan)
+		overscan->bottom_margin = scan->bottomscale;
+
+	if (screen_info &&
+	    (screen_info->mode.hdisplay == 720 &&
+	     screen_info->mode.hsync_end == 742 &&
+	     screen_info->mode.vdisplay == 480)) {
+		mode->hdisplay = 720;
+		mode->hsync_start = 736;
+		mode->hsync_end = 742;
+		mode->htotal = 858;
+		mode->vdisplay = 480;
+		mode->vsync_start = 494;
+		mode->vsync_end = 500;
+		mode->vtotal = 525;
+		mode->clock = 27000;
+	} else {
+		mode->hdisplay = 720;
+		mode->hsync_start = 732;
+		mode->hsync_end = 738;
+		mode->htotal = 864;
+		mode->vdisplay = 576;
+		mode->vsync_start = 582;
+		mode->vsync_end = 588;
+		mode->vtotal = 625;
+		mode->clock = 27000;
+	}
+}
+
+static int rk1000_tve_get_timing(struct udevice *dev)
+{
+	struct rockchip_bridge *bridge =
+		(struct rockchip_bridge *)dev_get_driver_data(dev);
+	struct connector_state *conn_state = &bridge->state->conn_state;
+	struct drm_display_mode *mode = &conn_state->mode;
+	struct overscan *overscan = &conn_state->overscan;
+
+	drm_rk1000_select_output(overscan, mode);
+
+	return 0;
+}
+
+static const struct rockchip_bridge_funcs rk1000_tve_bridge_funcs = {
+	.enable = rk1000_tve_bridge_enable,
+	.disable = rk1000_tve_bridge_disable,
+};
+
+static struct rockchip_bridge rk1000_tve_driver_data = {
+	.funcs = &rk1000_tve_bridge_funcs,
+};
+
+struct video_bridge_ops rk1000_tve_ops = {
+	.get_timing = rk1000_tve_get_timing,
+};
+
+static const struct udevice_id rk1000_tve_ids[] = {
+	{
+		.compatible = "rockchip,rk1000-tve",
+		.data = (ulong)&rk1000_tve_driver_data,
+	},
+	{ }
+};
+
+U_BOOT_DRIVER(rk1000_tve) = {
+	.name = "rk1000_tve",
+	.id = UCLASS_VIDEO_BRIDGE,
+	.of_match = rk1000_tve_ids,
+	.ops = &rk1000_tve_ops,
+	.probe = rk1000_tve_probe,
+	.priv_auto_alloc_size = sizeof(struct rk1000_tve),
+};
diff --git a/drivers/video/drm/rk618.c b/drivers/video/drm/rk618.c
new file mode 100644
index 0000000000..e92b73a4b2
--- /dev/null
+++ b/drivers/video/drm/rk618.c
@@ -0,0 +1,183 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * (C) Copyright 2008-2018 Fuzhou Rockchip Electronics Co., Ltd
+ */
+
+#include <common.h>
+#include <i2c.h>
+#include <errno.h>
+#include <dm.h>
+#include <dm/uclass.h>
+#include <dm/uclass-id.h>
+
+#include "rk618.h"
+
+int rk618_i2c_write(struct rk618 *rk618, u16 reg, u32 val)
+{
+	struct dm_i2c_chip *chip = dev_get_parent_platdata(rk618->dev);
+	struct i2c_msg msg;
+	u8 buf[] = {
+		(reg >> 0) & 0xff, (reg >> 8) & 0xff,
+		(val >> 0) & 0xff, (val >> 8) & 0xff,
+		(val >> 16) & 0xff, (val >> 24) & 0xff
+	};
+	int ret;
+
+	msg.addr = chip->chip_addr;
+	msg.flags = 0;
+	msg.len = sizeof(buf);
+	msg.buf = buf;
+
+	ret = dm_i2c_xfer(rk618->dev, &msg, 1);
+	if (ret) {
+		dev_err(rk618->dev, "Could not execute transfer: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+int rk618_i2c_read(struct rk618 *rk618, u16 reg, u32 *val)
+{
+	struct dm_i2c_chip *chip = dev_get_parent_platdata(rk618->dev);
+	u32 data;
+	struct i2c_msg msg[] = {
+		{
+			.addr = chip->chip_addr,
+			.flags = 0,
+			.buf = (u8 *)&reg,
+			.len = 2,
+		}, {
+			.addr = chip->chip_addr,
+			.flags = I2C_M_RD,
+			.buf = (u8 *)&data,
+			.len = 4,
+		}
+	};
+	int ret;
+
+	ret = dm_i2c_xfer(rk618->dev, msg, 2);
+	if (ret) {
+		dev_err(rk618->dev, "Could not execute transfer: %d\n", ret);
+		return ret;
+	}
+
+	*val = data;
+
+	return 0;
+}
+
+void rk618_frc_dither_disable(struct rk618 *rk618)
+{
+	rk618_i2c_write(rk618, RK618_FRC_REG, FRC_DITHER_DISABLE);
+}
+
+void rk618_frc_dither_enable(struct rk618 *rk618)
+{
+	rk618_i2c_write(rk618, RK618_FRC_REG, FRC_DITHER_ENABLE);
+}
+
+void rk618_frc_dclk_invert(struct rk618 *rk618)
+{
+	rk618_i2c_write(rk618, RK618_FRC_REG, FRC_DCLK_INV);
+}
+
+static int rk618_power_on(struct rk618 *rk618)
+{
+	if (rk618->power_supply)
+		regulator_set_enable(rk618->power_supply, 1);
+
+	if (dm_gpio_is_valid(&rk618->enable_gpio))
+		dm_gpio_set_value(&rk618->enable_gpio, 1);
+
+	mdelay(2);
+	dm_gpio_set_value(&rk618->reset_gpio, 0);
+	mdelay(4);
+	dm_gpio_set_value(&rk618->reset_gpio, 1);
+	mdelay(50);
+	dm_gpio_set_value(&rk618->reset_gpio, 0);
+
+	return 0;
+}
+
+static void rk618_cru_init(struct rk618 *rk618)
+{
+	rk618_i2c_write(rk618, 0x0058, 0xffff0000);
+	rk618_i2c_write(rk618, 0x005c, 0xffff191e);
+	rk618_i2c_write(rk618, 0x0060, 0x00000000);
+	rk618_i2c_write(rk618, 0x0064, 0xffff2186);
+	rk618_i2c_write(rk618, 0x0068, 0xffff1028);
+	rk618_i2c_write(rk618, 0x006c, 0xffff0641);
+	rk618_i2c_write(rk618, 0x0070, 0x00800000);
+	rk618_i2c_write(rk618, 0x0074, 0xffff1028);
+	rk618_i2c_write(rk618, 0x0078, 0xffff0641);
+	rk618_i2c_write(rk618, 0x007c, 0x00800000);
+}
+
+static int rk618_probe(struct udevice *dev)
+{
+	struct rk618 *rk618 = dev_get_priv(dev);
+	int ret;
+
+	rk618->dev = dev;
+
+	ret = uclass_get_device_by_phandle(UCLASS_REGULATOR, dev,
+					   "power-supply",
+					   &rk618->power_supply);
+	if (ret && ret != -ENOENT) {
+		dev_err(dev, "Cannot get power supply: %d\n", ret);
+		return ret;
+	}
+
+	ret = gpio_request_by_name(dev, "enable-gpios", 0,
+				   &rk618->enable_gpio, GPIOD_IS_OUT);
+	if (ret && ret != -ENOENT) {
+		dev_err(dev, "Cannot get enable GPIO: %d\n", ret);
+		return ret;
+	}
+
+	ret = gpio_request_by_name(dev, "reset-gpios", 0,
+				   &rk618->reset_gpio, GPIOD_IS_OUT);
+	if (ret) {
+		dev_err(dev, "Cannot get reset GPIO: %d\n", ret);
+		return ret;
+	}
+
+	ret = clk_get_by_name(dev, "clkin", &rk618->clkin);
+	if (ret < 0) {
+		dev_err(dev, "failed to get clkin: %d\n", ret);
+		return ret;
+	}
+
+	ret = clk_set_rate(&rk618->clkin, 11289600);
+	if (ret < 0) {
+		dev_err(dev, "failed to set rate: %d\n", ret);
+		return ret;
+	}
+
+	clk_enable(&rk618->clkin);
+
+	ret = rk618_power_on(rk618);
+	if (ret) {
+		dev_err(dev, "failed to power on: %d\n", ret);
+		return ret;
+	}
+
+	rk618_cru_init(rk618);
+
+	return 0;
+}
+
+static const struct udevice_id rk618_of_match[] = {
+	{ .compatible = "rockchip,rk618" },
+	{}
+};
+
+U_BOOT_DRIVER(rk618) = {
+	.name = "rk618",
+	.id = UCLASS_I2C_GENERIC,
+	.of_match = rk618_of_match,
+	.probe = rk618_probe,
+	.bind = dm_scan_fdt_dev,
+	.priv_auto_alloc_size = sizeof(struct rk618),
+};
diff --git a/drivers/video/drm/rk618.h b/drivers/video/drm/rk618.h
new file mode 100644
index 0000000000..ab93da90b9
--- /dev/null
+++ b/drivers/video/drm/rk618.h
@@ -0,0 +1,73 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * (C) Copyright 2008-2018 Fuzhou Rockchip Electronics Co., Ltd
+ */
+
+#ifndef _RK618_H_
+#define _RK618_H_
+
+#include <clk.h>
+#include <dm/device.h>
+#include <power/regulator.h>
+#include <asm/gpio.h>
+
+#define UPDATE(v, h, l)	(((v) << (l)) & GENMASK((h), (l)))
+#define HIWORD_UPDATE(v, h, l)	(((v) << (l)) | (GENMASK(h, l) << 16))
+
+#define RK618_FRC_REG			0x0054
+#define FRC_DEN_INV			HIWORD_UPDATE(1, 6, 6)
+#define FRC_SYNC_INV			HIWORD_UPDATE(1, 5, 5)
+#define FRC_DCLK_INV			HIWORD_UPDATE(1, 4, 4)
+#define FRC_OUT_ZERO			HIWORD_UPDATE(1, 3, 3)
+#define FRC_OUT_MODE_RGB666		HIWORD_UPDATE(1, 2, 2)
+#define FRC_OUT_MODE_RGB888		HIWORD_UPDATE(0, 2, 2)
+#define FRC_DITHER_MODE_HI_FRC		HIWORD_UPDATE(1, 1, 1)
+#define FRC_DITHER_MODE_FRC		HIWORD_UPDATE(0, 1, 1)
+#define FRC_DITHER_ENABLE		HIWORD_UPDATE(1, 0, 0)
+#define FRC_DITHER_DISABLE		HIWORD_UPDATE(0, 0, 0)
+#define RK618_LVDS_CON			0x0084
+#define LVDS_CON_START_PHASE(x)		HIWORD_UPDATE(x, 14, 14)
+#define LVDS_DCLK_INV			HIWORD_UPDATE(1, 13, 13)
+#define LVDS_CON_CHADS_10PF		HIWORD_UPDATE(3, 12, 11)
+#define LVDS_CON_CHADS_5PF		HIWORD_UPDATE(2, 12, 11)
+#define LVDS_CON_CHADS_7PF		HIWORD_UPDATE(1, 12, 11)
+#define LVDS_CON_CHADS_3PF		HIWORD_UPDATE(0, 12, 11)
+#define LVDS_CON_CHA1TTL_ENABLE		HIWORD_UPDATE(1, 10, 10)
+#define LVDS_CON_CHA1TTL_DISABLE	HIWORD_UPDATE(0, 10, 10)
+#define LVDS_CON_CHA0TTL_ENABLE		HIWORD_UPDATE(1, 9, 9)
+#define LVDS_CON_CHA0TTL_DISABLE	HIWORD_UPDATE(0, 9, 9)
+#define LVDS_CON_CHA1_POWER_UP		HIWORD_UPDATE(1, 8, 8)
+#define LVDS_CON_CHA1_POWER_DOWN	HIWORD_UPDATE(0, 8, 8)
+#define LVDS_CON_CHA0_POWER_UP		HIWORD_UPDATE(1, 7, 7)
+#define LVDS_CON_CHA0_POWER_DOWN	HIWORD_UPDATE(0, 7, 7)
+#define LVDS_CON_CBG_POWER_UP		HIWORD_UPDATE(1, 6, 6)
+#define LVDS_CON_CBG_POWER_DOWN		HIWORD_UPDATE(0, 6, 6)
+#define LVDS_CON_PLL_POWER_DOWN		HIWORD_UPDATE(1, 5, 5)
+#define LVDS_CON_PLL_POWER_UP		HIWORD_UPDATE(0, 5, 5)
+#define LVDS_CON_START_SEL_EVEN_PIXEL	HIWORD_UPDATE(1, 4, 4)
+#define LVDS_CON_START_SEL_ODD_PIXEL	HIWORD_UPDATE(0, 4, 4)
+#define LVDS_CON_CHASEL_DOUBLE_CHANNEL	HIWORD_UPDATE(1, 3, 3)
+#define LVDS_CON_CHASEL_SINGLE_CHANNEL	HIWORD_UPDATE(0, 3, 3)
+#define LVDS_CON_MSBSEL_D7		HIWORD_UPDATE(1, 2, 2)
+#define LVDS_CON_MSBSEL_D0		HIWORD_UPDATE(0, 2, 2)
+#define LVDS_CON_SELECT(x)		HIWORD_UPDATE(x, 1, 0)
+#define LVDS_CON_SELECT_6BIT_MODE	HIWORD_UPDATE(3, 1, 0)
+#define LVDS_CON_SELECT_8BIT_MODE_3	HIWORD_UPDATE(2, 1, 0)
+#define LVDS_CON_SELECT_8BIT_MODE_2	HIWORD_UPDATE(1, 1, 0)
+#define LVDS_CON_SELECT_8BIT_MODE_1	HIWORD_UPDATE(0, 1, 0)
+
+struct rk618 {
+	struct udevice *dev;
+	struct udevice *power_supply;
+	struct gpio_desc enable_gpio;
+	struct gpio_desc reset_gpio;
+	struct clk clkin;
+};
+
+int rk618_i2c_write(struct rk618 *rk618, u16 reg, u32 val);
+int rk618_i2c_read(struct rk618 *rk618, u16 reg, u32 *val);
+void rk618_frc_dither_disable(struct rk618 *rk618);
+void rk618_frc_dither_enable(struct rk618 *rk618);
+void rk618_frc_dclk_invert(struct rk618 *rk618);
+
+#endif
diff --git a/drivers/video/drm/rk618_dsi.c b/drivers/video/drm/rk618_dsi.c
new file mode 100644
index 0000000000..3a946b4227
--- /dev/null
+++ b/drivers/video/drm/rk618_dsi.c
@@ -0,0 +1,1068 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2020 Rockchip Electronics Co., Ltd
+ *
+ * Author: Wyon Bi <bivvy.bi@rock-chips.com>
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <dm/device-internal.h>
+#include <drm/drm_mipi_dsi.h>
+#include <video_bridge.h>
+#include <asm/unaligned.h>
+#include <linux/math64.h>
+
+#include "rockchip_display.h"
+#include "rockchip_bridge.h"
+#include "rk618.h"
+
+/* host registers */
+#define HOSTREG(x)		((x) + 0x1000)
+#define DSI_VERSION		HOSTREG(0x0000)
+#define DSI_PWR_UP		HOSTREG(0x0004)
+#define SHUTDOWNZ		BIT(0)
+#define POWER_UP		BIT(0)
+#define RESET			0
+#define DSI_CLKMGR_CFG		HOSTREG(0x0008)
+#define TO_CLK_DIVIDSION(x)	UPDATE(x, 15, 8)
+#define TX_ESC_CLK_DIVIDSION(x)	UPDATE(x, 7, 0)
+#define DSI_DPI_CFG		HOSTREG(0x000c)
+#define EN18_LOOSELY		BIT(10)
+#define COLORM_ACTIVE_LOW	BIT(9)
+#define SHUTD_ACTIVE_LOW	BIT(8)
+#define HSYNC_ACTIVE_LOW	BIT(7)
+#define VSYNC_ACTIVE_LOW	BIT(6)
+#define DATAEN_ACTIVE_LOW	BIT(5)
+#define DPI_COLOR_CODING(x)	UPDATE(x, 4, 2)
+#define DPI_VID(x)		UPDATE(x, 1, 0)
+#define DSI_PCKHDL_CFG		HOSTREG(0x0018)
+#define GEN_VID_RX(x)		UPDATE(x, 6, 5)
+#define EN_CRC_RX		BIT(4)
+#define EN_ECC_RX		BIT(3)
+#define EN_BTA			BIT(2)
+#define EN_EOTP_RX		BIT(1)
+#define EN_EOTP_TX		BIT(0)
+#define DSI_VID_MODE_CFG	HOSTREG(0x001c)
+#define LPCMDEN			BIT(12)
+#define FRAME_BTA_ACK		BIT(11)
+#define EN_NULL_PKT		BIT(10)
+#define EN_MULTI_PKT		BIT(9)
+#define EN_LP_HFP		BIT(8)
+#define EN_LP_HBP		BIT(7)
+#define EN_LP_VACT		BIT(6)
+#define EN_LP_VFP		BIT(5)
+#define EN_LP_VBP		BIT(4)
+#define EN_LP_VSA		BIT(3)
+#define VID_MODE_TYPE(x)	UPDATE(x, 2, 1)
+#define EN_VIDEO_MODE		BIT(0)
+#define DSI_VID_PKT_CFG		HOSTREG(0x0020)
+#define NULL_PKT_SIZE(x)	UPDATE(x, 30, 21)
+#define NUM_CHUNKS(x)		UPDATE(x, 20, 11)
+#define VID_PKT_SIZE(x)		UPDATE(x, 10, 0)
+#define DSI_CMD_MODE_CFG	HOSTREG(0x0024)
+#define TEAR_FX_EN		BIT(14)
+#define ACK_RQST_EN		BIT(13)
+#define DCS_LW_TX		BIT(12)
+#define GEN_LW_TX		BIT(11)
+#define MAX_RD_PKT_SIZE		BIT(10)
+#define DCS_SR_0P_TX		BIT(9)
+#define DCS_SW_1P_TX		BIT(8)
+#define DCS_SW_0P_TX		BIT(7)
+#define GEN_SR_2P_TX		BIT(6)
+#define GEN_SR_1P_TX		BIT(5)
+#define GEN_SR_0P_TX		BIT(4)
+#define GEN_SW_2P_TX		BIT(3)
+#define GEN_SW_1P_TX		BIT(2)
+#define GEN_SW_0P_TX		BIT(1)
+#define EN_CMD_MODE		BIT(0)
+#define DSI_TMR_LINE_CFG	HOSTREG(0x0028)
+#define HLINE_TIME(x)		UPDATE(x, 31, 18)
+#define HBP_TIME(x)		UPDATE(x, 17, 9)
+#define HSA_TIME(x)		UPDATE(x, 8, 0)
+#define DSI_VTIMING_CFG		HOSTREG(0x002c)
+#define V_ACTIVE_LINES(x)	UPDATE(x, 26, 16)
+#define VFP_LINES(x)		UPDATE(x, 15, 10)
+#define VBP_LINES(x)		UPDATE(x, 9, 4)
+#define VSA_LINES(x)		UPDATE(x, 3, 0)
+#define DSI_PHY_TMR_CFG		HOSTREG(0x0030)
+#define PHY_HS2LP_TIME(x)	UPDATE(x, 31, 24)
+#define PHY_LP2HS_TIME(x)	UPDATE(x, 23, 16)
+#define MAX_RD_TIME(x)		UPDATE(x, 14, 0)
+#define DSI_GEN_HDR		HOSTREG(0x0034)
+#define DSI_GEN_PLD_DATA	HOSTREG(0x0038)
+#define DSI_GEN_PKT_STATUS	HOSTREG(0x003c)
+#define GEN_RD_CMD_BUSY		BIT(6)
+#define GEN_PLD_R_FULL		BIT(5)
+#define GEN_PLD_R_EMPTY		BIT(4)
+#define GEN_PLD_W_FULL		BIT(3)
+#define GEN_PLD_W_EMPTY		BIT(2)
+#define GEN_CMD_FULL		BIT(1)
+#define GEN_CMD_EMPTY		BIT(0)
+#define DSI_TO_CNT_CFG		HOSTREG(0x0040)
+#define LPRX_TO_CNT(x)		UPDATE(x, 31, 16)
+#define HSTX_TO_CNT(x)		UPDATE(x, 15, 0)
+#define DSI_INT_ST0		HOSTREG(0x0044)
+#define DSI_INT_ST1		HOSTREG(0x0048)
+#define DSI_INT_MSK0		HOSTREG(0x004c)
+#define DSI_INT_MSK1		HOSTREG(0x0050)
+#define DSI_PHY_RSTZ		HOSTREG(0x0054)
+#define PHY_ENABLECLK		BIT(2)
+#define DSI_PHY_IF_CFG		HOSTREG(0x0058)
+#define PHY_STOP_WAIT_TIME(x)	UPDATE(x, 9, 2)
+#define N_LANES(x)		UPDATE(x, 1, 0)
+#define DSI_PHY_IF_CTRL		HOSTREG(0x005c)
+#define PHY_TX_TRIGGERS(x)	UPDATE(x, 8, 5)
+#define PHY_TXEXITULPSLAN	BIT(4)
+#define PHY_TXREQULPSLAN	BIT(3)
+#define PHY_TXEXITULPSCLK	BIT(2)
+#define PHY_RXREQULPSCLK	BIT(1)
+#define PHY_TXREQUESCLKHS	BIT(0)
+#define DSI_PHY_STATUS		HOSTREG(0x0060)
+#define ULPSACTIVENOT3LANE	BIT(12)
+#define PHYSTOPSTATE3LANE	BIT(11)
+#define ULPSACTIVENOT2LANE	BIT(10)
+#define PHYSTOPSTATE2LANE	BIT(9)
+#define ULPSACTIVENOT1LANE	BIT(8)
+#define PHYSTOPSTATE1LANE	BIT(7)
+#define RXULPSESC0LANE		BIT(6)
+#define ULPSACTIVENOT0LANE	BIT(5)
+#define PHYSTOPSTATE0LANE	BIT(4)
+#define PHYULPSACTIVENOTCLK	BIT(3)
+#define PHYSTOPSTATECLKLANE	BIT(2)
+#define PHYSTOPSTATELANE	(PHYSTOPSTATE0LANE | PHYSTOPSTATECLKLANE)
+#define PHYDIRECTION		BIT(1)
+#define PHYLOCK			BIT(0)
+#define DSI_LP_CMD_TIM		HOSTREG(0x0070)
+#define OUTVACT_LPCMD_TIME(x)	UPDATE(x, 15, 8)
+#define INVACT_LPCMD_TIME(x)	UPDATE(x, 7, 0)
+#define DSI_MAX_REGISTER	DSI_LP_CMD_TIM
+
+/* phy registers */
+#define PHYREG(x)		((x) + 0x0c00)
+#define MIPI_PHY_REG0		PHYREG(0x0000)
+#define LANE_EN_MASK		GENMASK(6, 2)
+#define LANE_EN_CK		BIT(6)
+#define MIPI_PHY_REG1		PHYREG(0x0004)
+#define REG_DA_PPFC		BIT(4)
+#define REG_DA_SYNCRST		BIT(2)
+#define REG_DA_LDOPD		BIT(1)
+#define REG_DA_PLLPD		BIT(0)
+#define MIPI_PHY_REG3		PHYREG(0x000c)
+#define REG_FBDIV_HI_MASK	GENMASK(5, 5)
+#define REG_FBDIV_HI(x)		UPDATE(x, 5, 5)
+#define REG_PREDIV_MASK		GENMASK(4, 0)
+#define REG_PREDIV(x)		UPDATE(x, 4, 0)
+#define MIPI_PHY_REG4		PHYREG(0x0010)
+#define REG_FBDIV_LO_MASK	GENMASK(7, 0)
+#define REG_FBDIV_LO(x)		UPDATE(x, 7, 0)
+#define MIPI_PHY_REG5		PHYREG(0x0014)
+#define MIPI_PHY_REG6		PHYREG(0x0018)
+#define MIPI_PHY_REG7		PHYREG(0x001c)
+#define MIPI_PHY_REG9		PHYREG(0x0024)
+#define MIPI_PHY_REG20		PHYREG(0x0080)
+#define REG_DIG_RSTN		BIT(0)
+#define MIPI_PHY_MAX_REGISTER	PHYREG(0x0348)
+
+#define THS_SETTLE_OFFSET	0x00
+#define THS_SETTLE_MASK		GENMASK(3, 0)
+#define THS_SETTLE(x)		UPDATE(x, 3, 0)
+#define TLPX_OFFSET		0x14
+#define TLPX_MASK		GENMASK(5, 0)
+#define TLPX(x)			UPDATE(x, 5, 0)
+#define THS_PREPARE_OFFSET	0x18
+#define THS_PREPARE_MASK	GENMASK(6, 0)
+#define THS_PREPARE(x)		UPDATE(x, 6, 0)
+#define THS_ZERO_OFFSET		0x1c
+#define THS_ZERO_MASK		GENMASK(5, 0)
+#define THS_ZERO(x)		UPDATE(x, 5, 0)
+#define THS_TRAIL_OFFSET	0x20
+#define THS_TRAIL_MASK		GENMASK(6, 0)
+#define THS_TRAIL(x)		UPDATE(x, 6, 0)
+#define THS_EXIT_OFFSET		0x24
+#define THS_EXIT_MASK		GENMASK(4, 0)
+#define THS_EXIT(x)		UPDATE(x, 4, 0)
+#define TCLK_POST_OFFSET	0x28
+#define TCLK_POST_MASK		GENMASK(3, 0)
+#define TCLK_POST(x)		UPDATE(x, 3, 0)
+#define TWAKUP_HI_OFFSET	0x30
+#define TWAKUP_HI_MASK		GENMASK(1, 0)
+#define TWAKUP_HI(x)		UPDATE(x, 1, 0)
+#define TWAKUP_LO_OFFSET	0x34
+#define TWAKUP_LO_MASK		GENMASK(7, 0)
+#define TWAKUP_LO(x)		UPDATE(x, 7, 0)
+#define TCLK_PRE_OFFSET		0x38
+#define TCLK_PRE_MASK		GENMASK(3, 0)
+#define TCLK_PRE(x)		UPDATE(x, 3, 0)
+#define TTA_GO_OFFSET		0x40
+#define TTA_GO_MASK		GENMASK(5, 0)
+#define TTA_GO(x)		UPDATE(x, 5, 0)
+#define TTA_SURE_OFFSET		0x44
+#define TTA_SURE_MASK		GENMASK(5, 0)
+#define TTA_SURE(x)		UPDATE(x, 5, 0)
+#define TTA_WAIT_OFFSET		0x48
+#define TTA_WAIT_MASK		GENMASK(5, 0)
+#define TTA_WAIT(x)		UPDATE(x, 5, 0)
+
+#define USEC_PER_SEC		1000000L
+#define USEC_PER_MSEC		1000L
+#define PSEC_PER_NSEC		1000L
+#define PSEC_PER_SEC		1000000000000LL
+
+struct mipi_dphy {
+	u8 prediv;
+	u16 fbdiv;
+	unsigned int rate;
+};
+
+struct rk618_dsi {
+	struct udevice *dev;
+	struct rk618 *parent;
+	struct mipi_dphy phy;
+	unsigned int channel;
+	unsigned int lanes;
+	enum mipi_dsi_pixel_format format;
+	unsigned long mode_flags;
+	struct drm_display_mode mode;
+};
+
+enum {
+	NON_BURST_MODE_SYNC_PULSE,
+	NON_BURST_MODE_SYNC_EVENT,
+	BURST_MODE,
+};
+
+enum {
+	PIXEL_COLOR_CODING_16BIT_1,
+	PIXEL_COLOR_CODING_16BIT_2,
+	PIXEL_COLOR_CODING_16BIT_3,
+	PIXEL_COLOR_CODING_18BIT_1,
+	PIXEL_COLOR_CODING_18BIT_2,
+	PIXEL_COLOR_CODING_24BIT,
+};
+
+#define dsi_read_poll_timeout(dsi, addr, val, cond, sleep_us, timeout_us) \
+({ \
+	unsigned long timeout = timer_get_us() + (timeout_us); \
+	for (;;) { \
+		(val) = dsi_read(dsi, addr); \
+		if (cond) \
+			break; \
+		if ((timeout_us) && time_after(timer_get_us(), timeout)) { \
+			(val) = dsi_read(dsi, addr); \
+			break; \
+		} \
+		if (sleep_us) \
+			udelay(sleep_us); \
+	} \
+	(cond) ? 0 : -ETIMEDOUT; \
+})
+
+static inline int dsi_write(struct rk618_dsi *dsi, u32 reg, u32 val)
+{
+	return rk618_i2c_write(dsi->parent, reg, val);
+}
+
+static inline u32 dsi_read(struct rk618_dsi *dsi, u32 reg)
+{
+	u32 val;
+
+	rk618_i2c_read(dsi->parent, reg, &val);
+
+	return val;
+}
+
+static inline void dsi_update_bits(struct rk618_dsi *dsi,
+				   u32 reg, u32 mask, u32 val)
+{
+	u32 orig, tmp;
+
+	orig = dsi_read(dsi, reg);
+	tmp = orig & ~mask;
+	tmp |= val & mask;
+	dsi_write(dsi, reg, tmp);
+}
+
+static inline bool is_clk_lane(u32 offset)
+{
+	if (offset == 0x100)
+		return true;
+
+	return false;
+}
+
+static void rk618_dsi_set_hs_clk(struct rk618_dsi *dsi)
+{
+	const struct drm_display_mode *mode = &dsi->mode;
+	struct mipi_dphy *phy = &dsi->phy;
+	u32 fout, fref, prediv, fbdiv;
+	u32 min_delta = UINT_MAX;
+	unsigned int value;
+
+	value = dev_read_u32_default(dsi->dev, "rockchip,lane-rate", 0);
+	if (value > 0) {
+		fout = value * USEC_PER_SEC;
+	} else {
+		int bpp = mipi_dsi_pixel_format_to_bpp(dsi->format);
+		unsigned int lanes = dsi->lanes;
+		u64 bandwidth;
+
+		bandwidth = (u64)mode->clock * 1000 * bpp;
+		do_div(bandwidth, lanes);
+
+		/* take 1 / 0.9, since mbps must big than bandwidth of RGB */
+		bandwidth *= 10;
+		do_div(bandwidth, 9);
+
+		do_div(bandwidth, USEC_PER_SEC);
+		bandwidth *= USEC_PER_SEC;
+		fout = bandwidth;
+	}
+
+	if (fout > 1000000000UL)
+		fout = 1000000000UL;
+
+	fref = clk_get_rate(&dsi->parent->clkin);
+
+	for (prediv = 1; prediv <= 12; prediv++) {
+		u64 tmp;
+		u32 delta;
+
+		if (fref % prediv)
+			continue;
+
+		tmp = (u64)fout * prediv;
+		do_div(tmp, fref);
+		fbdiv = tmp;
+
+		if (fbdiv < 12 || fbdiv > 511)
+			continue;
+
+		if (fbdiv == 15)
+			continue;
+
+		tmp = (u64)fbdiv * fref;
+		do_div(tmp, prediv);
+
+		delta = abs(fout - tmp);
+		if (!delta) {
+			phy->rate = tmp;
+			phy->prediv = prediv;
+			phy->fbdiv = fbdiv;
+			break;
+		} else if (delta < min_delta) {
+			phy->rate = tmp;
+			phy->prediv = prediv;
+			phy->fbdiv = fbdiv;
+			min_delta = delta;
+		}
+	}
+}
+
+static void rk618_dsi_phy_power_off(struct rk618_dsi *dsi)
+{
+	dsi_update_bits(dsi, MIPI_PHY_REG0, LANE_EN_MASK, 0);
+	dsi_update_bits(dsi, MIPI_PHY_REG1, REG_DA_LDOPD | REG_DA_PLLPD,
+			REG_DA_LDOPD | REG_DA_PLLPD);
+}
+
+static void rk618_dsi_phy_power_on(struct rk618_dsi *dsi, u32 txclkesc)
+{
+	struct mipi_dphy *phy = &dsi->phy;
+	u32 offset, value, index;
+	const struct {
+		unsigned int rate;
+		u8 ths_settle;
+		u8 ths_zero;
+		u8 ths_trail;
+	} timing_table[] = {
+		{ 110000000, 0x00, 0x03, 0x0c},
+		{ 150000000, 0x01, 0x04, 0x0d},
+		{ 200000000, 0x02, 0x04, 0x11},
+		{ 250000000, 0x03, 0x05, 0x14},
+		{ 300000000, 0x04, 0x06, 0x18},
+		{ 400000000, 0x05, 0x07, 0x1d},
+		{ 500000000, 0x06, 0x08, 0x23},
+		{ 600000000, 0x07, 0x0a, 0x29},
+		{ 700000000, 0x08, 0x0b, 0x31},
+		{ 800000000, 0x09, 0x0c, 0x34},
+		{1000000000, 0x0a, 0x0f, 0x40},
+	};
+	u32 Ttxbyteclkhs, UI, Ttxddrclkhs, Ttxclkesc;
+	u32 Tlpx, Ths_exit, Tclk_post, Tclk_pre, Ths_prepare;
+	u32 Tta_go, Tta_sure, Tta_wait;
+
+	Ttxbyteclkhs = div_u64(PSEC_PER_SEC, phy->rate / 8);
+	UI = Ttxddrclkhs = div_u64(PSEC_PER_SEC, phy->rate);
+	Ttxclkesc = div_u64(PSEC_PER_SEC, txclkesc);
+
+	dsi_update_bits(dsi, MIPI_PHY_REG3, REG_FBDIV_HI_MASK |
+			REG_PREDIV_MASK, REG_FBDIV_HI(phy->fbdiv >> 8) |
+			REG_PREDIV(phy->prediv));
+	dsi_update_bits(dsi, MIPI_PHY_REG4,
+			REG_FBDIV_LO_MASK, REG_FBDIV_LO(phy->fbdiv));
+	dsi_update_bits(dsi, MIPI_PHY_REG1, REG_DA_LDOPD | REG_DA_PLLPD, 0);
+
+	dsi_update_bits(dsi, MIPI_PHY_REG0, LANE_EN_MASK,
+			LANE_EN_CK | GENMASK(dsi->lanes - 1 + 2, 2));
+
+	dsi_update_bits(dsi, MIPI_PHY_REG1, REG_DA_SYNCRST, REG_DA_SYNCRST);
+	udelay(1);
+	dsi_update_bits(dsi, MIPI_PHY_REG1, REG_DA_SYNCRST, 0);
+
+	dsi_update_bits(dsi, MIPI_PHY_REG20, REG_DIG_RSTN, 0);
+	udelay(1);
+	dsi_update_bits(dsi, MIPI_PHY_REG20, REG_DIG_RSTN, REG_DIG_RSTN);
+
+	/* XXX */
+	dsi_write(dsi, MIPI_PHY_REG6, 0x11);
+	dsi_write(dsi, MIPI_PHY_REG7, 0x11);
+	dsi_write(dsi, MIPI_PHY_REG9, 0xcc);
+
+	if (phy->rate < 800000000)
+		dsi_update_bits(dsi, MIPI_PHY_REG1, REG_DA_PPFC, REG_DA_PPFC);
+	else
+		dsi_write(dsi, MIPI_PHY_REG5, 0x30);
+
+	for (index = 0; index < ARRAY_SIZE(timing_table); index++)
+		if (phy->rate <= timing_table[index].rate)
+			break;
+
+	if (index == ARRAY_SIZE(timing_table))
+		--index;
+
+	for (offset = 0x100; offset <= 0x300; offset += 0x80) {
+		dsi_update_bits(dsi, PHYREG(offset + THS_SETTLE_OFFSET),
+				THS_SETTLE_MASK,
+				THS_SETTLE(timing_table[index].ths_settle));
+
+		/*
+		 * The value of counter for HS Tlpx Time
+		 * Tlpx = Tpin_txbyteclkhs * value
+		 */
+		Tlpx = 60 * PSEC_PER_NSEC;
+		value = DIV_ROUND_UP(Tlpx, Ttxbyteclkhs);
+		Tlpx = Ttxbyteclkhs * value;
+		dsi_update_bits(dsi, PHYREG(offset + TLPX_OFFSET),
+				TLPX_MASK, TLPX(value));
+
+		/*
+		 * The value of counter for HS Ths-prepare
+		 * For clock lane, Ths-prepare(38ns~95ns)
+		 * For data lane, Ths-prepare(40ns+4UI~85ns+6UI)
+		 * Ths-prepare = Ttxddrclkhs * value
+		 */
+		if (is_clk_lane(offset))
+			Ths_prepare = 65 * PSEC_PER_NSEC;
+		else
+			Ths_prepare = 65 * PSEC_PER_NSEC + 4 * UI;
+
+		value = DIV_ROUND_UP(Ths_prepare, Ttxddrclkhs);
+		dsi_update_bits(dsi, PHYREG(offset + THS_PREPARE_OFFSET),
+				THS_PREPARE_MASK, THS_PREPARE(value));
+
+		dsi_update_bits(dsi, PHYREG(offset + THS_ZERO_OFFSET),
+				THS_ZERO_MASK,
+				THS_ZERO(timing_table[index].ths_zero));
+
+		dsi_update_bits(dsi, PHYREG(offset + THS_TRAIL_OFFSET),
+				THS_TRAIL_MASK,
+				THS_TRAIL(timing_table[index].ths_trail));
+
+		/*
+		 * The value of counter for HS Ths-exit
+		 * Ths-exit = Tpin_txbyteclkhs * value
+		 */
+		Ths_exit = 120 * PSEC_PER_NSEC;
+		value = DIV_ROUND_UP(Ths_exit, Ttxbyteclkhs);
+		dsi_update_bits(dsi, PHYREG(offset + THS_EXIT_OFFSET),
+				THS_EXIT_MASK, THS_EXIT(value));
+
+		/*
+		 * The value of counter for HS Tclk-post
+		 * Tclk-post = Ttxbyteclkhs * value
+		 */
+		Tclk_post = 70 * PSEC_PER_NSEC + 52 * UI;
+		value = DIV_ROUND_UP(Tclk_post, Ttxbyteclkhs);
+		dsi_update_bits(dsi, PHYREG(offset + TCLK_POST_OFFSET),
+				TCLK_POST_MASK, TCLK_POST(value));
+
+		/*
+		 * The value of counter for HS Twakup
+		 * Twakup for ulpm,
+		 * Twakup = Tpin_sys_clk * value
+		 */
+		dsi_update_bits(dsi, PHYREG(offset + TWAKUP_HI_OFFSET),
+				TWAKUP_HI_MASK, TWAKUP_HI(0x3));
+		dsi_update_bits(dsi, PHYREG(offset + TWAKUP_LO_OFFSET),
+				TWAKUP_LO_MASK, TWAKUP_LO(0xff));
+
+		/*
+		 * The value of counter for HS Tclk-pre
+		 * Tclk-pre for clock lane
+		 * Tclk-pre = Tpin_txbyteclkhs * value
+		 */
+		Tclk_pre = 8 * UI;
+		value = DIV_ROUND_UP(Tclk_pre, Ttxbyteclkhs);
+		dsi_update_bits(dsi, PHYREG(offset + TCLK_PRE_OFFSET),
+				TCLK_PRE_MASK, TCLK_PRE(value));
+
+		/*
+		 * The value of counter for HS Tta-go
+		 * Tta-go for turnaround
+		 * Tta-go = Ttxclkesc * value
+		 */
+		Tta_go = 4 * Tlpx;
+		value = DIV_ROUND_UP(Tta_go, Ttxclkesc);
+		dsi_update_bits(dsi, PHYREG(offset + TTA_GO_OFFSET),
+				TTA_GO_MASK, TTA_GO(value));
+
+		/*
+		 * The value of counter for HS Tta-sure
+		 * Tta-sure for turnaround
+		 * Tta-sure = Ttxclkesc * value
+		 */
+		Tta_sure = 2 * Tlpx;
+		value = DIV_ROUND_UP(Tta_sure, Ttxclkesc);
+		dsi_update_bits(dsi, PHYREG(offset + TTA_SURE_OFFSET),
+				TTA_SURE_MASK, TTA_SURE(value));
+
+		/*
+		 * The value of counter for HS Tta-wait
+		 * Tta-wait for turnaround
+		 * Interval from receiving ppi turnaround request to
+		 * sending esc request.
+		 * Tta-wait = Ttxclkesc * value
+		 */
+		Tta_wait = 5 * Tlpx;
+		value = DIV_ROUND_UP(Tta_wait, Ttxclkesc);
+		dsi_update_bits(dsi, PHYREG(offset + TTA_WAIT_OFFSET),
+				TTA_WAIT_MASK, TTA_WAIT(value));
+	}
+}
+
+static int rk618_dsi_pre_enable(struct rk618_dsi *dsi)
+{
+	struct drm_display_mode *mode = &dsi->mode;
+	u32 esc_clk_div, txclkesc;
+	u32 lanebyteclk, dpipclk;
+	u32 hsw, hbp, vsw, vfp, vbp;
+	u32 hsa_time, hbp_time, hline_time;
+	u32 value;
+	int ret;
+
+	rk618_dsi_set_hs_clk(dsi);
+
+	dsi_update_bits(dsi, DSI_PWR_UP, SHUTDOWNZ, RESET);
+
+	/* Configuration of the internal clock dividers */
+	esc_clk_div = DIV_ROUND_UP(dsi->phy.rate >> 3, 20000000);
+	txclkesc = dsi->phy.rate >> 3 / esc_clk_div;
+	value = TO_CLK_DIVIDSION(10) | TX_ESC_CLK_DIVIDSION(esc_clk_div);
+	dsi_write(dsi, DSI_CLKMGR_CFG, value);
+
+	/* The DPI interface configuration */
+	value = DPI_VID(dsi->channel);
+
+	if (mode->flags & DRM_MODE_FLAG_NVSYNC)
+		value |= VSYNC_ACTIVE_LOW;
+	if (mode->flags & DRM_MODE_FLAG_NHSYNC)
+		value |= HSYNC_ACTIVE_LOW;
+
+	switch (dsi->format) {
+	case MIPI_DSI_FMT_RGB666:
+		value |= DPI_COLOR_CODING(PIXEL_COLOR_CODING_18BIT_2);
+		break;
+	case MIPI_DSI_FMT_RGB666_PACKED:
+		value |= DPI_COLOR_CODING(PIXEL_COLOR_CODING_18BIT_1);
+		value |= EN18_LOOSELY;
+		break;
+	case MIPI_DSI_FMT_RGB565:
+		value |= DPI_COLOR_CODING(PIXEL_COLOR_CODING_16BIT_1);
+		break;
+	case MIPI_DSI_FMT_RGB888:
+	default:
+		value |= DPI_COLOR_CODING(PIXEL_COLOR_CODING_24BIT);
+		break;
+	}
+
+	dsi_write(dsi, DSI_DPI_CFG, value);
+
+	/* Packet handler configuration */
+	value = GEN_VID_RX(dsi->channel) | EN_CRC_RX | EN_ECC_RX | EN_BTA;
+
+	if (!(dsi->mode_flags & MIPI_DSI_MODE_EOT_PACKET))
+		value |= EN_EOTP_TX;
+
+	dsi_write(dsi, DSI_PCKHDL_CFG, value);
+
+	/* Video mode configuration */
+	value = EN_LP_VACT | EN_LP_VBP | EN_LP_VFP | EN_LP_VSA;
+
+	if (!(dsi->mode_flags & MIPI_DSI_MODE_VIDEO_HFP))
+		value |= EN_LP_HFP;
+
+	if (!(dsi->mode_flags & MIPI_DSI_MODE_VIDEO_HBP))
+		value |= EN_LP_HBP;
+
+	if (dsi->mode_flags & MIPI_DSI_MODE_VIDEO_BURST)
+		value |= VID_MODE_TYPE(BURST_MODE);
+	else if (dsi->mode_flags & MIPI_DSI_MODE_VIDEO_SYNC_PULSE)
+		value |= VID_MODE_TYPE(NON_BURST_MODE_SYNC_PULSE);
+	else
+		value |= VID_MODE_TYPE(NON_BURST_MODE_SYNC_EVENT);
+
+	dsi_write(dsi, DSI_VID_MODE_CFG, value);
+
+	/* Video packet configuration */
+	dsi_write(dsi, DSI_VID_PKT_CFG, VID_PKT_SIZE(mode->hdisplay));
+
+	/* Timeout timers configuration */
+	dsi_write(dsi, DSI_TO_CNT_CFG, LPRX_TO_CNT(1000) | HSTX_TO_CNT(1000));
+
+	hsw = mode->hsync_end - mode->hsync_start;
+	hbp = mode->htotal - mode->hsync_end;
+	vsw = mode->vsync_end - mode->vsync_start;
+	vfp = mode->vsync_start - mode->vdisplay;
+	vbp = mode->vtotal - mode->vsync_end;
+
+	/* Line timing configuration */
+	lanebyteclk = (dsi->phy.rate >> 3) / USEC_PER_SEC;
+	dpipclk = mode->clock / USEC_PER_MSEC;
+	hline_time = DIV_ROUND_UP(mode->htotal * lanebyteclk, dpipclk);
+	hbp_time = DIV_ROUND_UP(hbp * lanebyteclk, dpipclk);
+	hsa_time = DIV_ROUND_UP(hsw * lanebyteclk, dpipclk);
+	dsi_write(dsi, DSI_TMR_LINE_CFG, HLINE_TIME(hline_time) |
+		  HBP_TIME(hbp_time) | HSA_TIME(hsa_time));
+
+	/* Vertical timing configuration */
+	dsi_write(dsi, DSI_VTIMING_CFG,
+		  V_ACTIVE_LINES(mode->vdisplay) | VFP_LINES(vfp) |
+		  VBP_LINES(vbp) | VSA_LINES(vsw));
+
+	/* D-PHY interface configuration */
+	value = N_LANES(dsi->lanes - 1) | PHY_STOP_WAIT_TIME(0x20);
+	dsi_write(dsi, DSI_PHY_IF_CFG, value);
+
+	/* D-PHY timing configuration */
+	value = PHY_HS2LP_TIME(20) | PHY_LP2HS_TIME(16) | MAX_RD_TIME(10000);
+	dsi_write(dsi, DSI_PHY_TMR_CFG, value);
+
+	/* enables the D-PHY Clock Lane Module */
+	dsi_update_bits(dsi, DSI_PHY_RSTZ, PHY_ENABLECLK, PHY_ENABLECLK);
+
+	dsi_update_bits(dsi, DSI_VID_MODE_CFG, EN_VIDEO_MODE, 0);
+	dsi_update_bits(dsi, DSI_CMD_MODE_CFG, EN_CMD_MODE, EN_CMD_MODE);
+
+	rk618_dsi_phy_power_on(dsi, txclkesc);
+
+	/* wait for the PHY to acquire lock */
+	ret = dsi_read_poll_timeout(dsi, DSI_PHY_STATUS,
+				    value, value & PHYLOCK, 50, 1000);
+	if (ret) {
+		dev_err(dsi->dev, "PHY is not locked\n");
+		return ret;
+	}
+
+	/* wait for the lane go to the stop state */
+	ret = dsi_read_poll_timeout(dsi, DSI_PHY_STATUS,
+				    value, value & PHYSTOPSTATELANE, 50, 1000);
+	if (ret) {
+		dev_err(dsi->dev, "lane module is not in stop state\n");
+		return ret;
+	}
+
+	dsi_update_bits(dsi, DSI_PWR_UP, SHUTDOWNZ, POWER_UP);
+
+	return 0;
+}
+
+static void rk618_dsi_enable(struct rk618_dsi *dsi)
+{
+	/* controls the D-PHY PPI txrequestclkhs signal */
+	dsi_update_bits(dsi, DSI_PHY_IF_CTRL,
+			PHY_TXREQUESCLKHS, PHY_TXREQUESCLKHS);
+
+	/* enables the DPI Video mode transmission */
+	dsi_update_bits(dsi, DSI_PWR_UP, SHUTDOWNZ, RESET);
+	dsi_update_bits(dsi, DSI_CMD_MODE_CFG, EN_CMD_MODE, 0);
+	dsi_update_bits(dsi, DSI_VID_MODE_CFG, EN_VIDEO_MODE, EN_VIDEO_MODE);
+	dsi_update_bits(dsi, DSI_PWR_UP, SHUTDOWNZ, POWER_UP);
+
+	printf("final DSI-Link bandwidth: %lu x %d Mbps\n",
+	       dsi->phy.rate / USEC_PER_SEC, dsi->lanes);
+}
+
+static void rk618_dsi_disable(struct rk618_dsi *dsi)
+{
+	/* enables the Command mode protocol for transmissions */
+	dsi_update_bits(dsi, DSI_PWR_UP, SHUTDOWNZ, RESET);
+	dsi_update_bits(dsi, DSI_PHY_IF_CTRL, PHY_TXREQUESCLKHS, 0);
+	dsi_update_bits(dsi, DSI_VID_MODE_CFG, EN_VIDEO_MODE, 0);
+	dsi_update_bits(dsi, DSI_CMD_MODE_CFG, EN_CMD_MODE, EN_CMD_MODE);
+	dsi_update_bits(dsi, DSI_PWR_UP, SHUTDOWNZ, POWER_UP);
+}
+
+static void rk618_dsi_post_disable(struct rk618_dsi *dsi)
+{
+	dsi_update_bits(dsi, DSI_PWR_UP, SHUTDOWNZ, RESET);
+	dsi_update_bits(dsi, DSI_PHY_RSTZ, PHY_ENABLECLK, 0);
+
+	rk618_dsi_phy_power_off(dsi);
+}
+
+static void rk618_dsi_bridge_pre_enable(struct rockchip_bridge *bridge)
+{
+	struct rk618_dsi *dsi = dev_get_priv(bridge->dev);
+
+	rk618_dsi_pre_enable(dsi);
+}
+
+static void rk618_dsi_bridge_enable(struct rockchip_bridge *bridge)
+{
+	struct rk618_dsi *dsi = dev_get_priv(bridge->dev);
+
+	rk618_dsi_enable(dsi);
+}
+
+static void rk618_dsi_bridge_post_disable(struct rockchip_bridge *bridge)
+{
+	struct rk618_dsi *dsi = dev_get_priv(bridge->dev);
+
+	rk618_dsi_post_disable(dsi);
+}
+
+static void rk618_dsi_bridge_disable(struct rockchip_bridge *bridge)
+{
+	struct rk618_dsi *dsi = dev_get_priv(bridge->dev);
+
+	rk618_dsi_disable(dsi);
+}
+
+static void rk618_dsi_bridge_mode_set(struct rockchip_bridge *bridge,
+				      const struct drm_display_mode *mode)
+{
+	struct rk618_dsi *dsi = dev_get_priv(bridge->dev);
+
+	memcpy(&dsi->mode, mode, sizeof(*mode));
+}
+
+static const struct rockchip_bridge_funcs rk618_dsi_bridge_funcs = {
+	.enable = rk618_dsi_bridge_enable,
+	.disable = rk618_dsi_bridge_disable,
+	.pre_enable = rk618_dsi_bridge_pre_enable,
+	.post_disable = rk618_dsi_bridge_post_disable,
+	.mode_set = rk618_dsi_bridge_mode_set,
+};
+
+static ssize_t rk618_dsi_transfer(struct rk618_dsi *dsi,
+				  const struct mipi_dsi_msg *msg)
+{
+	struct mipi_dsi_packet packet;
+	u32 value, mask;
+	int ret;
+
+	if (msg->flags & MIPI_DSI_MSG_USE_LPM)
+		dsi_update_bits(dsi, DSI_PHY_IF_CTRL, PHY_TXREQUESCLKHS, 0);
+	else
+		dsi_update_bits(dsi, DSI_PHY_IF_CTRL,
+				PHY_TXREQUESCLKHS, PHY_TXREQUESCLKHS);
+
+	switch (msg->type) {
+	case MIPI_DSI_DCS_SHORT_WRITE:
+		dsi_update_bits(dsi, DSI_CMD_MODE_CFG, DCS_SW_0P_TX,
+				msg->flags & MIPI_DSI_MSG_USE_LPM ?
+				DCS_SW_0P_TX : 0);
+		break;
+	case MIPI_DSI_DCS_SHORT_WRITE_PARAM:
+		dsi_update_bits(dsi, DSI_CMD_MODE_CFG, DCS_SW_1P_TX,
+				msg->flags & MIPI_DSI_MSG_USE_LPM ?
+				DCS_SW_1P_TX : 0);
+		break;
+	case MIPI_DSI_DCS_LONG_WRITE:
+		dsi_update_bits(dsi, DSI_CMD_MODE_CFG, DCS_LW_TX,
+				msg->flags & MIPI_DSI_MSG_USE_LPM ?
+				DCS_LW_TX : 0);
+		break;
+	case MIPI_DSI_DCS_READ:
+		dsi_update_bits(dsi, DSI_CMD_MODE_CFG, DCS_SR_0P_TX,
+				msg->flags & MIPI_DSI_MSG_USE_LPM ?
+				DCS_SR_0P_TX : 0);
+		break;
+	case MIPI_DSI_SET_MAXIMUM_RETURN_PACKET_SIZE:
+		dsi_update_bits(dsi, DSI_CMD_MODE_CFG,
+				MAX_RD_PKT_SIZE,
+				msg->flags & MIPI_DSI_MSG_USE_LPM ?
+				MAX_RD_PKT_SIZE : 0);
+		break;
+	case MIPI_DSI_GENERIC_SHORT_WRITE_0_PARAM:
+		dsi_update_bits(dsi, DSI_CMD_MODE_CFG, GEN_SW_0P_TX,
+				msg->flags & MIPI_DSI_MSG_USE_LPM ?
+				GEN_SW_0P_TX : 0);
+		break;
+	case MIPI_DSI_GENERIC_SHORT_WRITE_1_PARAM:
+		dsi_update_bits(dsi, DSI_CMD_MODE_CFG, GEN_SW_1P_TX,
+				msg->flags & MIPI_DSI_MSG_USE_LPM ?
+				GEN_SW_1P_TX : 0);
+		break;
+	case MIPI_DSI_GENERIC_SHORT_WRITE_2_PARAM:
+		dsi_update_bits(dsi, DSI_CMD_MODE_CFG, GEN_SW_2P_TX,
+				msg->flags & MIPI_DSI_MSG_USE_LPM ?
+				GEN_SW_2P_TX : 0);
+		break;
+	case MIPI_DSI_GENERIC_LONG_WRITE:
+		dsi_update_bits(dsi, DSI_CMD_MODE_CFG, GEN_LW_TX,
+				msg->flags & MIPI_DSI_MSG_USE_LPM ?
+				GEN_LW_TX : 0);
+		break;
+	case MIPI_DSI_GENERIC_READ_REQUEST_0_PARAM:
+		dsi_update_bits(dsi, DSI_CMD_MODE_CFG, GEN_SR_0P_TX,
+				msg->flags & MIPI_DSI_MSG_USE_LPM ?
+				GEN_SR_0P_TX : 0);
+		break;
+	case MIPI_DSI_GENERIC_READ_REQUEST_1_PARAM:
+		dsi_update_bits(dsi, DSI_CMD_MODE_CFG, GEN_SR_1P_TX,
+				msg->flags & MIPI_DSI_MSG_USE_LPM ?
+				GEN_SR_1P_TX : 0);
+		break;
+	case MIPI_DSI_GENERIC_READ_REQUEST_2_PARAM:
+		dsi_update_bits(dsi, DSI_CMD_MODE_CFG, GEN_SR_2P_TX,
+				msg->flags & MIPI_DSI_MSG_USE_LPM ?
+				GEN_SR_2P_TX : 0);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* create a packet to the DSI protocol */
+	ret = mipi_dsi_create_packet(&packet, msg);
+	if (ret) {
+		dev_err(dsi->dev, "failed to create packet: %d\n", ret);
+		return ret;
+	}
+
+	/* Send payload */
+	while (packet.payload_length >= 4) {
+		mask = GEN_PLD_W_FULL;
+		ret = dsi_read_poll_timeout(dsi, DSI_GEN_PKT_STATUS,
+					    value, !(value & mask), 50, 1000);
+		if (ret) {
+			dev_err(dsi->dev, "Write payload FIFO is full\n");
+			return ret;
+		}
+
+		value = get_unaligned_le32(packet.payload);
+		dsi_write(dsi, DSI_GEN_PLD_DATA, value);
+		packet.payload += 4;
+		packet.payload_length -= 4;
+	}
+
+	value = 0;
+	switch (packet.payload_length) {
+	case 3:
+		value |= packet.payload[2] << 16;
+		/* Fall through */
+	case 2:
+		value |= packet.payload[1] << 8;
+		/* Fall through */
+	case 1:
+		value |= packet.payload[0];
+		dsi_write(dsi, DSI_GEN_PLD_DATA, value);
+		break;
+	}
+
+	mask = GEN_CMD_FULL;
+	ret = dsi_read_poll_timeout(dsi, DSI_GEN_PKT_STATUS,
+				    value, !(value & mask), 50, 1000);
+	if (ret) {
+		dev_err(dsi->dev, "Command FIFO is full\n");
+		return ret;
+	}
+
+	/* Send packet header */
+	value = get_unaligned_le32(packet.header);
+	dsi_write(dsi, DSI_GEN_HDR, value);
+
+	mask = GEN_PLD_W_EMPTY | GEN_CMD_EMPTY;
+	ret = dsi_read_poll_timeout(dsi, DSI_GEN_PKT_STATUS,
+				    value, (value & mask) == mask, 50, 1000);
+	if (ret) {
+		dev_err(dsi->dev, "Write payload FIFO is not empty\n");
+		return ret;
+	}
+
+	if (msg->rx_len) {
+		u8 *payload = msg->rx_buf;
+		u16 length;
+
+		mask = GEN_RD_CMD_BUSY;
+		ret = dsi_read_poll_timeout(dsi, DSI_GEN_PKT_STATUS,
+					    value, !(value & mask), 50, 1000);
+		if (ret) {
+			dev_err(dsi->dev,
+				"entire response is not stored in the FIFO\n");
+			return ret;
+		}
+
+		/* Receive payload */
+		for (length = msg->rx_len; length; length -= 4) {
+			mask = GEN_PLD_R_EMPTY;
+			ret = dsi_read_poll_timeout(dsi, DSI_GEN_PKT_STATUS,
+						    value, !(value & mask),
+						    50, 1000);
+			if (ret) {
+				dev_err(dsi->dev,
+					"Read payload FIFO is empty\n");
+				return ret;
+			}
+
+			value = dsi_read(dsi, DSI_GEN_PLD_DATA);
+
+			switch (length) {
+			case 3:
+				payload[2] = (value >> 16) & 0xff;
+				/* Fall through */
+			case 2:
+				payload[1] = (value >> 8) & 0xff;
+				/* Fall through */
+			case 1:
+				payload[0] = value & 0xff;
+				return length;
+			}
+
+			payload[0] = (value >>  0) & 0xff;
+			payload[1] = (value >>  8) & 0xff;
+			payload[2] = (value >> 16) & 0xff;
+			payload[3] = (value >> 24) & 0xff;
+			payload += 4;
+		}
+	}
+
+	return packet.payload_length;
+}
+
+static int rk618_dsi_probe(struct udevice *dev)
+{
+	struct rk618_dsi *dsi = dev_get_priv(dev);
+	struct rockchip_bridge *bridge =
+		(struct rockchip_bridge *)dev_get_driver_data(dev);
+	int ret;
+
+	dsi->dev = dev;
+	dsi->parent = dev_get_priv(dev->parent);
+
+	ret = device_probe(dev->parent);
+	if (ret)
+		return ret;
+
+	bridge->dev = dev;
+
+	/* Mask all interrupts */
+	dsi_write(dsi, DSI_INT_MSK0, 0xffffffff);
+	dsi_write(dsi, DSI_INT_MSK1, 0xffffffff);
+
+	return 0;
+}
+
+static struct rockchip_bridge rk618_dsi_driver_data = {
+	.funcs = &rk618_dsi_bridge_funcs,
+};
+
+static const struct udevice_id rk618_dsi_ids[] = {
+	{
+		.compatible = "rockchip,rk618-dsi",
+		.data = (ulong)&rk618_dsi_driver_data,
+	},
+	{}
+};
+
+static ssize_t rk618_dsi_host_transfer(struct mipi_dsi_host *host,
+				       const struct mipi_dsi_msg *msg)
+{
+	struct rk618_dsi *dsi = dev_get_priv(host->dev);
+
+	return rk618_dsi_transfer(dsi, msg);
+}
+
+static int rk618_dsi_host_attach(struct mipi_dsi_host *host,
+				 struct mipi_dsi_device *device)
+{
+	struct rk618_dsi *dsi = dev_get_priv(host->dev);
+
+	if (device->lanes < 1 || device->lanes > 4)
+		return -EINVAL;
+
+	dsi->lanes = device->lanes;
+	dsi->channel = device->channel;
+	dsi->format = device->format;
+	dsi->mode_flags = device->mode_flags;
+
+	return 0;
+}
+
+static const struct mipi_dsi_host_ops rk618_dsi_host_ops = {
+	.attach = rk618_dsi_host_attach,
+	.transfer = rk618_dsi_host_transfer,
+};
+
+static int rk618_dsi_bind(struct udevice *dev)
+{
+	struct mipi_dsi_host *host = dev_get_platdata(dev);
+
+	host->dev = dev;
+	host->ops = &rk618_dsi_host_ops;
+
+	return dm_scan_fdt_dev(dev);
+}
+
+static int rk618_dsi_child_post_bind(struct udevice *dev)
+{
+	struct mipi_dsi_host *host = dev_get_platdata(dev->parent);
+	struct mipi_dsi_device *device = dev_get_parent_platdata(dev);
+	char name[20];
+
+	sprintf(name, "%s.%d", host->dev->name, device->channel);
+	device_set_name(dev, name);
+
+	device->dev = dev;
+	device->host = host;
+	device->lanes = dev_read_u32_default(dev, "dsi,lanes", 4);
+	device->format = dev_read_u32_default(dev, "dsi,format",
+					      MIPI_DSI_FMT_RGB888);
+	device->mode_flags = dev_read_u32_default(dev, "dsi,flags",
+						  MIPI_DSI_MODE_VIDEO |
+						  MIPI_DSI_MODE_VIDEO_BURST |
+						  MIPI_DSI_MODE_VIDEO_HBP |
+						  MIPI_DSI_MODE_LPM |
+						  MIPI_DSI_MODE_EOT_PACKET);
+	device->channel = dev_read_u32_default(dev, "reg", 0);
+
+	return 0;
+}
+
+static int rk618_dsi_child_pre_probe(struct udevice *dev)
+{
+	struct mipi_dsi_device *device = dev_get_parent_platdata(dev);
+	int ret;
+
+	ret = mipi_dsi_attach(device);
+	if (ret) {
+		dev_err(dev, "mipi_dsi_attach() failed: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+U_BOOT_DRIVER(rk618_dsi) = {
+	.name = "rk618_dsi",
+	.id = UCLASS_VIDEO_BRIDGE,
+	.of_match = rk618_dsi_ids,
+	.probe = rk618_dsi_probe,
+	.bind = rk618_dsi_bind,
+	.priv_auto_alloc_size = sizeof(struct rk618_dsi),
+	.per_child_platdata_auto_alloc_size = sizeof(struct mipi_dsi_device),
+	.platdata_auto_alloc_size = sizeof(struct mipi_dsi_host),
+	.child_post_bind = rk618_dsi_child_post_bind,
+	.child_pre_probe = rk618_dsi_child_pre_probe,
+};
diff --git a/drivers/video/drm/rk618_lvds.c b/drivers/video/drm/rk618_lvds.c
new file mode 100644
index 0000000000..4ef6bf84a1
--- /dev/null
+++ b/drivers/video/drm/rk618_lvds.c
@@ -0,0 +1,129 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * (C) Copyright 2008-2018 Fuzhou Rockchip Electronics Co., Ltd
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <dm/device-internal.h>
+#include <errno.h>
+#include <i2c.h>
+#include <video_bridge.h>
+#include <linux/media-bus-format.h>
+
+#include "rockchip_display.h"
+#include "rockchip_bridge.h"
+#include "rockchip_panel.h"
+#include "rockchip_connector.h"
+
+#include "rk618.h"
+
+enum {
+	LVDS_8BIT_MODE_FORMAT_1,
+	LVDS_8BIT_MODE_FORMAT_2,
+	LVDS_8BIT_MODE_FORMAT_3,
+	LVDS_6BIT_MODE,
+};
+
+struct rk618_lvds_priv {
+	struct udevice *dev;
+	struct rk618 *parent;
+	bool dual_channel;
+};
+
+static int lvds_write(struct rk618_lvds_priv *priv, u16 reg, u32 val)
+{
+	return rk618_i2c_write(priv->parent, reg, val);
+}
+
+static void rk618_lvds_bridge_enable(struct rockchip_bridge *bridge)
+{
+	struct rk618_lvds_priv *priv = dev_get_priv(bridge->dev);
+	struct rockchip_panel *panel = bridge->conn->panel;
+	u32 value, format;
+
+	rk618_frc_dclk_invert(priv->parent);
+
+	switch (panel->bus_format) {
+	case MEDIA_BUS_FMT_RGB666_1X7X3_JEIDA:	/* jeida-18 */
+		format = LVDS_6BIT_MODE;
+		break;
+	case MEDIA_BUS_FMT_RGB888_1X7X4_JEIDA:	/* jeida-24 */
+		format = LVDS_8BIT_MODE_FORMAT_2;
+		break;
+	case MEDIA_BUS_FMT_RGB666_1X7X3_SPWG:	/* vesa-18 */
+		format = LVDS_8BIT_MODE_FORMAT_3;
+		break;
+	case MEDIA_BUS_FMT_RGB888_1X7X4_SPWG:	/* vesa-24 */
+	default:
+		format = LVDS_8BIT_MODE_FORMAT_1;
+		break;
+	}
+
+	value = LVDS_CON_CHA0TTL_DISABLE | LVDS_CON_CHA1TTL_DISABLE |
+		LVDS_CON_CHA0_POWER_UP | LVDS_CON_CBG_POWER_UP |
+		LVDS_CON_PLL_POWER_UP | LVDS_CON_SELECT(format);
+
+	if (priv->dual_channel)
+		value |= LVDS_CON_CHA1_POWER_UP | LVDS_DCLK_INV |
+			 LVDS_CON_CHASEL_DOUBLE_CHANNEL;
+	else
+		value |= LVDS_CON_CHA1_POWER_DOWN |
+			 LVDS_CON_CHASEL_SINGLE_CHANNEL;
+
+	lvds_write(priv, RK618_LVDS_CON, value);
+}
+
+static void rk618_lvds_bridge_disable(struct rockchip_bridge *bridge)
+{
+	struct rk618_lvds_priv *priv = dev_get_priv(bridge->dev);
+
+	lvds_write(priv, RK618_LVDS_CON,
+		   LVDS_CON_CHA0_POWER_DOWN | LVDS_CON_CHA1_POWER_DOWN |
+		   LVDS_CON_CBG_POWER_DOWN | LVDS_CON_PLL_POWER_DOWN);
+}
+
+static const struct rockchip_bridge_funcs rk618_lvds_bridge_funcs = {
+	.enable = rk618_lvds_bridge_enable,
+	.disable = rk618_lvds_bridge_disable,
+};
+
+static int rk618_lvds_probe(struct udevice *dev)
+{
+	struct rk618_lvds_priv *priv = dev_get_priv(dev);
+	struct rockchip_bridge *bridge =
+		(struct rockchip_bridge *)dev_get_driver_data(dev);
+	int ret;
+
+	priv->dev = dev;
+	priv->parent = dev_get_priv(dev->parent);
+	priv->dual_channel = dev_read_bool(dev, "dual-channel");
+
+	ret = device_probe(dev->parent);
+	if (ret)
+		return ret;
+
+	bridge->dev = dev;
+
+	return 0;
+}
+
+static struct rockchip_bridge rk618_lvds_driver_data = {
+	.funcs = &rk618_lvds_bridge_funcs,
+};
+
+static const struct udevice_id rk618_lvds_ids[] = {
+	{
+		.compatible = "rockchip,rk618-lvds",
+		.data = (ulong)&rk618_lvds_driver_data,
+	},
+	{ }
+};
+
+U_BOOT_DRIVER(rk618_lvds) = {
+	.name = "rk618_lvds",
+	.id = UCLASS_VIDEO_BRIDGE,
+	.of_match = rk618_lvds_ids,
+	.probe = rk618_lvds_probe,
+	.priv_auto_alloc_size = sizeof(struct rk618_lvds_priv),
+};
diff --git a/drivers/video/drm/rockchip-inno-hdmi-phy.c b/drivers/video/drm/rockchip-inno-hdmi-phy.c
new file mode 100644
index 0000000000..1f60e1f604
--- /dev/null
+++ b/drivers/video/drm/rockchip-inno-hdmi-phy.c
@@ -0,0 +1,1522 @@
+/*
+ * SPDX-License-Identifier:     GPL-2.0+
+ * (C) Copyright 2008-2016 Fuzhou Rockchip Electronics Co., Ltd
+ */
+
+#include <clk-uclass.h>
+#include <config.h>
+#include <common.h>
+#include <errno.h>
+#include <malloc.h>
+#include <misc.h>
+#include <fdtdec.h>
+#include <fdt_support.h>
+#include <asm/unaligned.h>
+#include <asm/arch/clock.h>
+#include <dm/device.h>
+#include <dm/lists.h>
+#include <dm/read.h>
+#include <asm/io.h>
+#include <linux/list.h>
+#include <div64.h>
+#include <linux/media-bus-format.h>
+
+#include "rockchip_display.h"
+#include "rockchip_crtc.h"
+#include "rockchip_connector.h"
+#include "rockchip_phy.h"
+
+#define INNO_HDMI_PHY_TIMEOUT_LOOP_COUNT	1000
+#define UPDATE(x, h, l)	(((x) << (l)) & GENMASK((h), (l)))
+
+/* REG: 0x00 */
+#define PRE_PLL_REFCLK_SEL_MASK			BIT(0)
+#define PRE_PLL_REFCLK_SEL_PCLK			BIT(0)
+#define PRE_PLL_REFCLK_SEL_OSCCLK		0
+/* REG: 0x01 */
+#define BYPASS_RXSENSE_EN_MASK			BIT(2)
+#define BYPASS_RXSENSE_EN			BIT(2)
+#define BYPASS_PWRON_EN_MASK			BIT(1)
+#define BYPASS_PWRON_EN				BIT(1)
+#define BYPASS_PLLPD_EN_MASK			BIT(0)
+#define BYPASS_PLLPD_EN				BIT(0)
+/* REG: 0x02 */
+#define BYPASS_PDATA_EN_MASK			BIT(4)
+#define BYPASS_PDATA_EN				BIT(4)
+#define PDATAEN_MASK				BIT(0)
+#define PDATAEN_DISABLE				BIT(0)
+#define PDATAEN_ENABLE				0
+/* REG: 0x03 */
+#define BYPASS_AUTO_TERM_RES_CAL		BIT(7)
+#define AUDO_TERM_RES_CAL_SPEED_14_8(x)		UPDATE(x, 6, 0)
+/* REG: 0x04 */
+#define AUDO_TERM_RES_CAL_SPEED_7_0(x)		UPDATE(x, 7, 0)
+/* REG: 0xaa */
+#define POST_PLL_CTRL_MASK			BIT(0)
+#define POST_PLL_CTRL_MANUAL			BIT(0)
+/* REG: 0xe0 */
+#define POST_PLL_POWER_MASK			BIT(5)
+#define POST_PLL_POWER_DOWN			BIT(5)
+#define POST_PLL_POWER_UP			0
+#define PRE_PLL_POWER_MASK			BIT(4)
+#define PRE_PLL_POWER_DOWN			BIT(4)
+#define PRE_PLL_POWER_UP			0
+#define RXSENSE_CLK_CH_MASK			BIT(3)
+#define RXSENSE_CLK_CH_ENABLE			BIT(3)
+#define RXSENSE_DATA_CH2_MASK			BIT(2)
+#define RXSENSE_DATA_CH2_ENABLE			BIT(2)
+#define RXSENSE_DATA_CH1_MASK			BIT(1)
+#define RXSENSE_DATA_CH1_ENABLE			BIT(1)
+#define RXSENSE_DATA_CH0_MASK			BIT(0)
+#define RXSENSE_DATA_CH0_ENABLE			BIT(0)
+/* REG: 0xe1 */
+#define BANDGAP_MASK				BIT(4)
+#define BANDGAP_ENABLE				BIT(4)
+#define BANDGAP_DISABLE				0
+#define TMDS_DRIVER_MASK			GENMASK(3, 0)
+#define TMDS_DRIVER_ENABLE			UPDATE(0xf, 3, 0)
+#define TMDS_DRIVER_DISABLE			0
+/* REG: 0xe2 */
+#define PRE_PLL_FB_DIV_8_MASK			BIT(7)
+#define PRE_PLL_FB_DIV_8_SHIFT			7
+#define PRE_PLL_FB_DIV_8(x)			UPDATE(x, 7, 7)
+#define PCLK_VCO_DIV_5_MASK			BIT(5)
+#define PCLK_VCO_DIV_5_SHIFT			5
+#define PCLK_VCO_DIV_5(x)			UPDATE(x, 5, 5)
+#define PRE_PLL_PRE_DIV_MASK			GENMASK(4, 0)
+#define PRE_PLL_PRE_DIV(x)			UPDATE(x, 4, 0)
+/* REG: 0xe3 */
+#define PRE_PLL_FB_DIV_7_0(x)			UPDATE(x, 7, 0)
+/* REG: 0xe4 */
+#define PRE_PLL_PCLK_DIV_B_MASK			GENMASK(6, 5)
+#define PRE_PLL_PCLK_DIV_B_SHIFT		5
+#define PRE_PLL_PCLK_DIV_B(x)			UPDATE(x, 6, 5)
+#define PRE_PLL_PCLK_DIV_A_MASK			GENMASK(4, 0)
+#define PRE_PLL_PCLK_DIV_A_SHIFT		0
+#define PRE_PLL_PCLK_DIV_A(x)			UPDATE(x, 4, 0)
+/* REG: 0xe5 */
+#define PRE_PLL_PCLK_DIV_C_MASK			GENMASK(6, 5)
+#define PRE_PLL_PCLK_DIV_C_SHIFT		5
+#define PRE_PLL_PCLK_DIV_C(x)			UPDATE(x, 6, 5)
+#define PRE_PLL_PCLK_DIV_D_MASK			GENMASK(4, 0)
+#define PRE_PLL_PCLK_DIV_D_SHIFT		0
+#define PRE_PLL_PCLK_DIV_D(x)			UPDATE(x, 4, 0)
+/* REG: 0xe6 */
+#define PRE_PLL_TMDSCLK_DIV_C_MASK		GENMASK(5, 4)
+#define PRE_PLL_TMDSCLK_DIV_C(x)		UPDATE(x, 5, 4)
+#define PRE_PLL_TMDSCLK_DIV_A_MASK		GENMASK(3, 2)
+#define PRE_PLL_TMDSCLK_DIV_A(x)		UPDATE(x, 3, 2)
+#define PRE_PLL_TMDSCLK_DIV_B_MASK		GENMASK(1, 0)
+#define PRE_PLL_TMDSCLK_DIV_B(x)		UPDATE(x, 1, 0)
+/* REG: 0xe8 */
+#define PRE_PLL_LOCK_STATUS			BIT(0)
+/* REG: 0xe9 */
+#define POST_PLL_POST_DIV_EN_MASK		GENMASK(7, 6)
+#define POST_PLL_POST_DIV_ENABLE		UPDATE(3, 7, 6)
+#define POST_PLL_POST_DIV_DISABLE		0
+#define POST_PLL_PRE_DIV_MASK			GENMASK(4, 0)
+#define POST_PLL_PRE_DIV(x)			UPDATE(x, 4, 0)
+/* REG: 0xea */
+#define POST_PLL_FB_DIV_7_0(x)			UPDATE(x, 7, 0)
+/* REG: 0xeb */
+#define POST_PLL_FB_DIV_8_MASK			BIT(7)
+#define POST_PLL_FB_DIV_8(x)			UPDATE(x, 7, 7)
+#define POST_PLL_POST_DIV_MASK			GENMASK(5, 4)
+#define POST_PLL_POST_DIV(x)			UPDATE(x, 5, 4)
+#define POST_PLL_LOCK_STATUS			BIT(0)
+/* REG: 0xee */
+#define TMDS_CH_TA_MASK				GENMASK(7, 4)
+#define TMDS_CH_TA_ENABLE			UPDATE(0xf, 7, 4)
+#define TMDS_CH_TA_DISABLE			0
+/* REG: 0xef */
+#define TMDS_CLK_CH_TA(x)			UPDATE(x, 7, 6)
+#define TMDS_DATA_CH2_TA(x)			UPDATE(x, 5, 4)
+#define TMDS_DATA_CH1_TA(x)			UPDATE(x, 3, 2)
+#define TMDS_DATA_CH0_TA(x)			UPDATE(x, 1, 0)
+/* REG: 0xf0 */
+#define TMDS_DATA_CH2_PRE_EMPHASIS_MASK		GENMASK(5, 4)
+#define TMDS_DATA_CH2_PRE_EMPHASIS(x)		UPDATE(x, 5, 4)
+#define TMDS_DATA_CH1_PRE_EMPHASIS_MASK		GENMASK(3, 2)
+#define TMDS_DATA_CH1_PRE_EMPHASIS(x)		UPDATE(x, 3, 2)
+#define TMDS_DATA_CH0_PRE_EMPHASIS_MASK		GENMASK(1, 0)
+#define TMDS_DATA_CH0_PRE_EMPHASIS(x)		UPDATE(x, 1, 0)
+/* REG: 0xf1 */
+#define TMDS_CLK_CH_OUTPUT_SWING(x)		UPDATE(x, 7, 4)
+#define TMDS_DATA_CH2_OUTPUT_SWING(x)		UPDATE(x, 3, 0)
+/* REG: 0xf2 */
+#define TMDS_DATA_CH1_OUTPUT_SWING(x)		UPDATE(x, 7, 4)
+#define TMDS_DATA_CH0_OUTPUT_SWING(x)		UPDATE(x, 3, 0)
+
+enum inno_hdmi_phy_type {
+	INNO_HDMI_PHY_RK3228,
+	INNO_HDMI_PHY_RK3328,
+	INNO_HDMI_PHY_RK3528
+};
+
+struct inno_hdmi_phy_drv_data;
+
+struct phy_config {
+	unsigned long	tmdsclock;
+	u8		regs[14];
+};
+
+struct inno_hdmi_phy {
+	struct udevice *dev;
+	ofnode node;
+	void *regs;
+
+	/* platform data */
+	const struct inno_hdmi_phy_drv_data *plat_data;
+	unsigned long pixclock;
+	u32 bus_width;
+	struct phy_config *phy_cfg;
+};
+
+struct pre_pll_config {
+	unsigned long pixclock;
+	unsigned long tmdsclock;
+	u8 prediv;
+	u16 fbdiv;
+	u8 tmds_div_a;
+	u8 tmds_div_b;
+	u8 tmds_div_c;
+	u8 pclk_div_a;
+	u8 pclk_div_b;
+	u8 pclk_div_c;
+	u8 pclk_div_d;
+	u8 vco_div_5_en;
+	u32 fracdiv;
+};
+
+struct post_pll_config {
+	unsigned long tmdsclock;
+	u8 prediv;
+	u16 fbdiv;
+	u8 postdiv;
+	u8 version;
+};
+
+struct inno_hdmi_phy_ops {
+	void (*init)(struct inno_hdmi_phy *inno);
+	int (*power_on)(struct inno_hdmi_phy *inno,
+			const struct post_pll_config *cfg,
+			const struct phy_config *phy_cfg);
+	void (*power_off)(struct inno_hdmi_phy *inno);
+	int (*pre_pll_update)(struct inno_hdmi_phy *inno,
+			      const struct pre_pll_config *cfg);
+	unsigned long (*recalc_rate)(struct inno_hdmi_phy *inno,
+				     unsigned long parent_rate);
+};
+
+struct inno_hdmi_phy_drv_data {
+	enum inno_hdmi_phy_type		dev_type;
+	const struct inno_hdmi_phy_ops	*ops;
+	const struct phy_config		*phy_cfg_table;
+};
+
+struct rockchip_inno_data {
+	char compatible[30];
+	const void *data;
+};
+
+struct clk_inno_hdmi {
+	struct udevice *dev;
+	ulong rate;
+};
+
+/* global variables are used to pass reource from phy drivers to clk driver */
+static struct inno_hdmi_phy *g_inno;
+
+static const struct pre_pll_config pre_pll_cfg_table[] = {
+	{ 27000000,  27000000, 1,  90, 3, 2, 2, 10, 3, 3, 4, 0, 0},
+	{ 27000000,  33750000, 1,  90, 1, 3, 3, 10, 3, 3, 4, 0, 0},
+	{ 40000000,  40000000, 1,  80, 2, 2, 2, 12, 2, 2, 2, 0, 0},
+	{ 59341000,  59341000, 1,  98, 3, 1, 2,  1, 3, 3, 4, 0, 0xE6AE6B},
+	{ 59400000,  59400000, 1,  99, 3, 1, 1,  1, 3, 3, 4, 0, 0},
+	{ 59341000,  74176250, 1,  98, 0, 3, 3,  1, 3, 3, 4, 0, 0xE6AE6B},
+	{ 59400000,  74250000, 1,  99, 1, 2, 2,  1, 3, 3, 4, 0, 0},
+	{ 74176000,  74176000, 1,  98, 1, 2, 2,  1, 2, 3, 4, 0, 0xE6AE6B},
+	{ 74250000,  74250000, 1,  99, 1, 2, 2,  1, 2, 3, 4, 0, 0},
+	{ 74176000,  92720000, 4, 494, 1, 2, 2,  1, 3, 3, 4, 0, 0x816817},
+	{ 74250000,  92812500, 4, 495, 1, 2, 2,  1, 3, 3, 4, 0, 0},
+	{148352000, 148352000, 1,  98, 1, 1, 1,  1, 2, 2, 2, 0, 0xE6AE6B},
+	{148500000, 148500000, 1,  99, 1, 1, 1,  1, 2, 2, 2, 0, 0},
+	{148352000, 185440000, 4, 494, 0, 2, 2,  1, 3, 2, 2, 0, 0x816817},
+	{148500000, 185625000, 4, 495, 0, 2, 2,  1, 3, 2, 2, 0, 0},
+	{296703000, 296703000, 1,  98, 0, 1, 1,  1, 0, 2, 2, 0, 0xE6AE6B},
+	{297000000, 297000000, 1,  99, 0, 1, 1,  1, 0, 2, 2, 0, 0},
+	{296703000, 370878750, 4, 494, 1, 2, 0,  1, 3, 1, 1, 0, 0x816817},
+	{297000000, 371250000, 4, 495, 1, 2, 0,  1, 3, 1, 1, 0, 0},
+	{593407000, 296703500, 1,  98, 0, 1, 1,  1, 0, 2, 1, 0, 0xE6AE6B},
+	{594000000, 297000000, 1,  99, 0, 1, 1,  1, 0, 2, 1, 0, 0},
+	{593407000, 370879375, 4, 494, 1, 2, 0,  1, 3, 1, 1, 1, 0x816817},
+	{594000000, 371250000, 4, 495, 1, 2, 0,  1, 3, 1, 1, 1, 0},
+	{593407000, 593407000, 1,  98, 0, 2, 0,  1, 0, 1, 1, 0, 0xE6AE6B},
+	{594000000, 594000000, 1,  99, 0, 2, 0,  1, 0, 1, 1, 0, 0},
+	{     ~0UL,	    0, 0,   0, 0, 0, 0,  0, 0, 0, 0, 0, 0}
+};
+
+static const struct post_pll_config post_pll_cfg_table[] = {
+	{33750000,  1, 40, 8, 1},
+	{33750000,  1, 80, 8, 2},
+	{33750000,  1, 10, 2, 4},
+	{74250000,  1, 40, 8, 1},
+	{74250000, 18, 80, 8, 2},
+	{74250000,  1, 20, 4, 8},
+	{148500000, 2, 40, 4, 3},
+	{148500000, 1, 10, 2, 8},
+	{297000000, 4, 40, 2, 3},
+	{297000000, 2, 20, 2, 8},
+	{594000000, 8, 40, 1, 3},
+	{594000000, 4, 20, 1, 8},
+	{     ~0UL, 0,  0, 0, 0}
+};
+
+static const struct phy_config rk3228_phy_cfg[] = {
+	{	165000000, {
+			0xaa, 0x00, 0x44, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00, 0x00,
+		},
+	}, {
+		340000000, {
+			0xaa, 0x15, 0x6a, 0xaa, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00, 0x00,
+		},
+	}, {
+		594000000, {
+			0xaa, 0x15, 0x7a, 0xaa, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00, 0x00,
+		},
+	}, {
+		~0UL, {
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00, 0x00,
+		},
+	}
+};
+
+static const struct phy_config rk3328_phy_cfg[] = {
+	{	165000000, {
+			0x07, 0x08, 0x08, 0x08, 0x00, 0x00, 0x08, 0x08, 0x08,
+			0x00, 0xac, 0xcc, 0xcc, 0xcc,
+		},
+	}, {
+		340000000, {
+			0x0b, 0x0d, 0x0d, 0x0d, 0x07, 0x15, 0x08, 0x08, 0x08,
+			0x3f, 0xac, 0xcc, 0xcd, 0xdd,
+		},
+	}, {
+		594000000, {
+			0x10, 0x1a, 0x1a, 0x1a, 0x07, 0x15, 0x08, 0x08, 0x08,
+			0x00, 0xac, 0xcc, 0xcc, 0xcc,
+		},
+	}, {
+		~0UL, {
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00, 0x00,
+		},
+	}
+};
+
+static const struct phy_config rk3528_phy_cfg[] = {
+	/* tmdsclk bias-clk bias-data voltage-clk voltage-data pre-emphasis-data */
+	{	165000000, {
+			0x03, 0x04, 0x0c, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00, 0x00,
+		},
+	}, {
+		340000000, {
+			0x03, 0x04, 0x0c, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00, 0x00,
+		},
+	}, {
+		594000000, {
+			0x02, 0x08, 0x0d, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00, 0x00,
+		},
+	}, {
+		~0UL, {
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00, 0x00,
+		},
+	}
+};
+
+static inline void inno_write(struct inno_hdmi_phy *inno, u32 reg, u8 val)
+{
+	writel(val, inno->regs + (reg * 4));
+}
+
+static inline u8 inno_read(struct inno_hdmi_phy *inno, u32 reg)
+{
+	u32 val;
+
+	val = readl(inno->regs + (reg * 4));
+
+	return val;
+}
+
+static inline void inno_update_bits(struct inno_hdmi_phy *inno, u8 reg,
+				    u8 mask, u8 val)
+{
+	u32 tmp, orig;
+
+	orig = inno_read(inno, reg);
+	tmp = orig & ~mask;
+	tmp |= val & mask;
+	inno_write(inno, reg, tmp);
+}
+
+static u32 inno_hdmi_phy_get_tmdsclk(struct inno_hdmi_phy *inno,
+				     unsigned long rate)
+{
+	u32 tmdsclk;
+
+	switch (inno->bus_width) {
+	case 4:
+		tmdsclk = (u32)rate / 2;
+		break;
+	case 5:
+		tmdsclk = (u32)rate * 5 / 8;
+		break;
+	case 6:
+		tmdsclk = (u32)rate * 3 / 4;
+		break;
+	case 10:
+		tmdsclk = (u32)rate * 5 / 4;
+		break;
+	case 12:
+		tmdsclk = (u32)rate * 3 / 2;
+		break;
+	case 16:
+		tmdsclk = (u32)rate * 2;
+		break;
+	default:
+		tmdsclk = rate;
+	}
+
+	return tmdsclk;
+}
+
+static u8 rk_get_cpu_version(void)
+{
+	u8 val = 0;
+#ifdef CONFIG_ROCKCHIP_EFUSE
+	struct udevice *dev;
+	u32 regs[2] = {0};
+	u8 fuses[1];
+	ofnode node;
+	int ret;
+
+	ret = uclass_get_device_by_driver(UCLASS_MISC,
+					  DM_GET_DRIVER(rockchip_efuse), &dev);
+	if (ret) {
+		printf("%s: no misc-device found\n", __func__);
+		return -EINVAL;
+	}
+
+	node = dev_read_subnode(dev, "cpu-version");
+	if (!ofnode_valid(node))
+		return -EINVAL;
+
+	ret = ofnode_read_u32_array(node, "reg", regs, 2);
+	if (ret) {
+		printf("Cannot get efuse reg\n");
+		return -EINVAL;
+	}
+
+	ret = misc_read(dev, regs[0], &fuses, regs[1]);
+	if (ret) {
+		printf("%s: misc_read failed\n", __func__);
+		return 0;
+	}
+
+	val = fuses[0];
+	val = (val >> 3) & 0x1;
+#endif
+	return val;
+}
+
+static int inno_hdmi_phy_power_on(struct rockchip_phy *phy)
+{
+#ifdef CONFIG_SPL_BUILD
+	struct inno_hdmi_phy *inno = (struct inno_hdmi_phy *)phy->data;
+#else
+	struct inno_hdmi_phy *inno = dev_get_priv(phy->dev);
+#endif
+	const struct post_pll_config *cfg = post_pll_cfg_table;
+	const struct phy_config *phy_cfg = inno->plat_data->phy_cfg_table;
+	u32 tmdsclock = inno_hdmi_phy_get_tmdsclk(inno, inno->pixclock);
+	u32 chipversion = 1;
+
+	printf("start Inno HDMI PHY Power On\n");
+
+	if (inno->phy_cfg)
+		phy_cfg = inno->phy_cfg;
+
+	if (!tmdsclock) {
+		printf("TMDS clock is zero!\n");
+		return -EINVAL;
+	}
+
+	if (inno->plat_data->dev_type == INNO_HDMI_PHY_RK3328 &&
+	    rk_get_cpu_version())
+		chipversion = 2;
+	else if (inno->plat_data->dev_type == INNO_HDMI_PHY_RK3228 &&
+		 tmdsclock <= 33750000)
+		chipversion = 4;
+	else if (inno->plat_data->dev_type == INNO_HDMI_PHY_RK3528)
+		chipversion = 8;
+
+	printf("tmdsclock = %d; chipversion = %d\n", tmdsclock, chipversion);
+
+	for (; cfg->tmdsclock != ~0UL; cfg++)
+		if (tmdsclock <= cfg->tmdsclock &&
+		    cfg->version & chipversion)
+			break;
+
+	for (; phy_cfg->tmdsclock != ~0UL; phy_cfg++)
+		if (tmdsclock <= phy_cfg->tmdsclock)
+			break;
+
+	if (cfg->tmdsclock == ~0UL || phy_cfg->tmdsclock == ~0UL)
+		return -EINVAL;
+
+	printf("Inno HDMI PHY Power On\n");
+	if (inno->plat_data->ops->power_on)
+		return inno->plat_data->ops->power_on(inno, cfg, phy_cfg);
+	else
+		return -EINVAL;
+}
+
+static int inno_hdmi_phy_power_off(struct rockchip_phy *phy)
+{
+#ifdef CONFIG_SPL_BUILD
+	struct inno_hdmi_phy *inno = (struct inno_hdmi_phy *)phy->data;
+#else
+	struct inno_hdmi_phy *inno = dev_get_priv(phy->dev);
+#endif
+
+	if (inno->plat_data->ops->power_off)
+		inno->plat_data->ops->power_off(inno);
+	printf("Inno HDMI PHY Power Off\n");
+
+	return 0;
+}
+
+static int inno_hdmi_phy_clk_is_prepared(struct inno_hdmi_phy *inno)
+{
+	u8 status;
+
+	if (inno->plat_data->dev_type == INNO_HDMI_PHY_RK3228)
+		status = inno_read(inno, 0xe0) & PRE_PLL_POWER_MASK;
+	else
+		status = inno_read(inno, 0xa0) & 1;
+
+	return status ? 0 : 1;
+}
+
+static int inno_hdmi_phy_clk_prepare(struct inno_hdmi_phy *inno)
+{
+	if (inno->plat_data->dev_type == INNO_HDMI_PHY_RK3228)
+		inno_update_bits(inno, 0xe0, PRE_PLL_POWER_MASK,
+				 PRE_PLL_POWER_UP);
+	else
+		inno_update_bits(inno, 0xa0, 1, 0);
+
+	return 0;
+}
+
+static int inno_hdmi_phy_clk_set_rate(struct inno_hdmi_phy *inno,
+				      unsigned long rate)
+{
+	const struct pre_pll_config *cfg = pre_pll_cfg_table;
+	u32 tmdsclock = inno_hdmi_phy_get_tmdsclk(inno, rate);
+
+	for (; cfg->pixclock != ~0UL; cfg++)
+		if (cfg->pixclock == rate && cfg->tmdsclock == tmdsclock)
+			break;
+
+	if (cfg->pixclock == ~0UL) {
+		printf("unsupported rate %lu\n", rate);
+		return -EINVAL;
+	}
+
+	if (inno->plat_data->ops->pre_pll_update)
+		inno->plat_data->ops->pre_pll_update(inno, cfg);
+
+	inno->pixclock = rate;
+
+	return 0;
+}
+
+static void inno_hdmi_phy_rk3228_init(struct inno_hdmi_phy *inno)
+{
+	u32 m, v;
+
+	/*
+	 * Use phy internal register control
+	 * rxsense/poweron/pllpd/pdataen signal.
+	 */
+	m = BYPASS_RXSENSE_EN_MASK | BYPASS_PWRON_EN_MASK |
+	    BYPASS_PLLPD_EN_MASK;
+	v = BYPASS_RXSENSE_EN | BYPASS_PWRON_EN | BYPASS_PLLPD_EN;
+	inno_update_bits(inno, 0x01, m, v);
+	inno_update_bits(inno, 0x02, BYPASS_PDATA_EN_MASK, BYPASS_PDATA_EN);
+
+	/* manual power down post-PLL */
+	inno_update_bits(inno, 0xaa, POST_PLL_CTRL_MASK, POST_PLL_CTRL_MANUAL);
+}
+
+static int
+inno_hdmi_phy_rk3228_power_on(struct inno_hdmi_phy *inno,
+			      const struct post_pll_config *cfg,
+			      const struct phy_config *phy_cfg)
+{
+	int pll_tries;
+	u32 m, v;
+
+	/* pdata_en disable */
+	inno_update_bits(inno, 0x02, PDATAEN_MASK, PDATAEN_DISABLE);
+
+	/* Power down Post-PLL */
+	inno_update_bits(inno, 0xe0, PRE_PLL_POWER_MASK, PRE_PLL_POWER_DOWN);
+	inno_update_bits(inno, 0xe0, POST_PLL_POWER_MASK, POST_PLL_POWER_DOWN);
+
+	/* Post-PLL update */
+	m = POST_PLL_PRE_DIV_MASK;
+	v = POST_PLL_PRE_DIV(cfg->prediv);
+	inno_update_bits(inno, 0xe9, m, v);
+
+	m = POST_PLL_FB_DIV_8_MASK;
+	v = POST_PLL_FB_DIV_8(cfg->fbdiv >> 8);
+	inno_update_bits(inno, 0xeb, m, v);
+	inno_write(inno, 0xea, POST_PLL_FB_DIV_7_0(cfg->fbdiv));
+
+	if (cfg->postdiv == 1) {
+		/* Disable Post-PLL post divider */
+		m = POST_PLL_POST_DIV_EN_MASK;
+		v = POST_PLL_POST_DIV_DISABLE;
+		inno_update_bits(inno, 0xe9, m, v);
+	} else {
+		/* Enable Post-PLL post divider */
+		m = POST_PLL_POST_DIV_EN_MASK;
+		v = POST_PLL_POST_DIV_ENABLE;
+		inno_update_bits(inno, 0xe9, m, v);
+
+		m = POST_PLL_POST_DIV_MASK;
+		v = POST_PLL_POST_DIV(cfg->postdiv / 2 - 1);
+		inno_update_bits(inno, 0xeb, m, v);
+	}
+
+	for (v = 0; v < 4; v++)
+		inno_write(inno, 0xef + v, phy_cfg->regs[v]);
+
+	/* Power up Post-PLL */
+	inno_update_bits(inno, 0xe0, POST_PLL_POWER_MASK, POST_PLL_POWER_UP);
+	inno_update_bits(inno, 0xe0, PRE_PLL_POWER_MASK, PRE_PLL_POWER_UP);
+
+	/* BandGap enable */
+	inno_update_bits(inno, 0xe1, BANDGAP_MASK, BANDGAP_ENABLE);
+
+	/* TMDS driver enable */
+	inno_update_bits(inno, 0xe1, TMDS_DRIVER_MASK, TMDS_DRIVER_ENABLE);
+
+	/* Wait for post PLL lock */
+	pll_tries = 0;
+	while (!(inno_read(inno, 0xeb) & POST_PLL_LOCK_STATUS)) {
+		if (pll_tries == INNO_HDMI_PHY_TIMEOUT_LOOP_COUNT) {
+			printf("Post-PLL unlock\n");
+			return -ETIMEDOUT;
+		}
+
+		pll_tries++;
+		udelay(100);
+	}
+
+	if (cfg->tmdsclock > 340000000)
+		mdelay(100);
+
+	/* pdata_en enable */
+	inno_update_bits(inno, 0x02, PDATAEN_MASK, PDATAEN_ENABLE);
+	return 0;
+}
+
+static void inno_hdmi_phy_rk3228_power_off(struct inno_hdmi_phy *inno)
+{
+	/* TMDS driver Disable */
+	inno_update_bits(inno, 0xe1, TMDS_DRIVER_MASK, TMDS_DRIVER_DISABLE);
+
+	/* BandGap Disable */
+	inno_update_bits(inno, 0xe1, BANDGAP_MASK, BANDGAP_DISABLE);
+
+	/* Post-PLL power down */
+	inno_update_bits(inno, 0xe0, POST_PLL_POWER_MASK, POST_PLL_POWER_DOWN);
+}
+
+static int
+inno_hdmi_phy_rk3228_pre_pll_update(struct inno_hdmi_phy *inno,
+				    const struct pre_pll_config *cfg)
+{
+	int pll_tries;
+	u32 m, v;
+
+	/* Power down PRE-PLL */
+	inno_update_bits(inno, 0xe0, PRE_PLL_POWER_MASK, PRE_PLL_POWER_DOWN);
+
+	m = PRE_PLL_FB_DIV_8_MASK | PCLK_VCO_DIV_5_MASK | PRE_PLL_PRE_DIV_MASK;
+	v = PRE_PLL_FB_DIV_8(cfg->fbdiv >> 8) |
+	    PCLK_VCO_DIV_5(cfg->vco_div_5_en) | PRE_PLL_PRE_DIV(cfg->prediv);
+	inno_update_bits(inno, 0xe2, m, v);
+
+	inno_write(inno, 0xe3, PRE_PLL_FB_DIV_7_0(cfg->fbdiv));
+
+	m = PRE_PLL_PCLK_DIV_B_MASK | PRE_PLL_PCLK_DIV_A_MASK;
+	v = PRE_PLL_PCLK_DIV_B(cfg->pclk_div_b) |
+	    PRE_PLL_PCLK_DIV_A(cfg->pclk_div_a);
+	inno_update_bits(inno, 0xe4, m, v);
+
+	m = PRE_PLL_PCLK_DIV_C_MASK | PRE_PLL_PCLK_DIV_D_MASK;
+	v = PRE_PLL_PCLK_DIV_C(cfg->pclk_div_c) |
+	    PRE_PLL_PCLK_DIV_D(cfg->pclk_div_d);
+	inno_update_bits(inno, 0xe5, m, v);
+
+	m = PRE_PLL_TMDSCLK_DIV_C_MASK | PRE_PLL_TMDSCLK_DIV_A_MASK |
+	    PRE_PLL_TMDSCLK_DIV_B_MASK;
+	v = PRE_PLL_TMDSCLK_DIV_C(cfg->tmds_div_c) |
+	    PRE_PLL_TMDSCLK_DIV_A(cfg->tmds_div_a) |
+	    PRE_PLL_TMDSCLK_DIV_B(cfg->tmds_div_b);
+	inno_update_bits(inno, 0xe6, m, v);
+
+	/* Power up PRE-PLL */
+	inno_update_bits(inno, 0xe0, PRE_PLL_POWER_MASK, PRE_PLL_POWER_UP);
+
+	/* Wait for Pre-PLL lock */
+	pll_tries = 0;
+	while (!(inno_read(inno, 0xe8) & PRE_PLL_LOCK_STATUS)) {
+		if (pll_tries == INNO_HDMI_PHY_TIMEOUT_LOOP_COUNT) {
+			printf("Pre-PLL unlock\n");
+			return -ETIMEDOUT;
+		}
+
+		pll_tries++;
+		udelay(100);
+	}
+
+	return 0;
+}
+
+static void inno_hdmi_phy_rk3328_init(struct inno_hdmi_phy *inno)
+{
+	/*
+	 * Use phy internal register control
+	 * rxsense/poweron/pllpd/pdataen signal.
+	 */
+	inno_write(inno, 0x01, 0x07);
+	inno_write(inno, 0x02, 0x91);
+}
+
+static int
+inno_hdmi_phy_rk3328_power_on(struct inno_hdmi_phy *inno,
+			      const struct post_pll_config *cfg,
+			      const struct phy_config *phy_cfg)
+{
+	u32 val;
+
+	/* set pdata_en to 0 */
+	inno_update_bits(inno, 0x02, 1, 0);
+	/* Power off post PLL */
+	inno_update_bits(inno, 0xaa, 1, 1);
+
+	val = cfg->fbdiv & 0xff;
+	inno_write(inno, 0xac, val);
+	if (cfg->postdiv == 1) {
+		inno_write(inno, 0xaa, 2);
+		val = (cfg->fbdiv >> 8) | cfg->prediv;
+		inno_write(inno, 0xab, val);
+	} else {
+		val = (cfg->postdiv / 2) - 1;
+		inno_write(inno, 0xad, val);
+		val = (cfg->fbdiv >> 8) | cfg->prediv;
+		inno_write(inno, 0xab, val);
+		inno_write(inno, 0xaa, 0x0e);
+	}
+
+	for (val = 0; val < 14; val++)
+		inno_write(inno, 0xb5 + val, phy_cfg->regs[val]);
+
+	/* bit[7:6] of reg c8/c9/ca/c8 is ESD detect threshold:
+	 * 00 - 340mV
+	 * 01 - 280mV
+	 * 10 - 260mV
+	 * 11 - 240mV
+	 * default is 240mV, now we set it to 340mV
+	 */
+	inno_write(inno, 0xc8, 0);
+	inno_write(inno, 0xc9, 0);
+	inno_write(inno, 0xca, 0);
+	inno_write(inno, 0xcb, 0);
+
+	if (phy_cfg->tmdsclock > 340000000) {
+		/* Set termination resistor to 100ohm */
+		val = 75000000 / 100000;
+		inno_write(inno, 0xc5, ((val >> 8) & 0xff) | 0x80);
+		inno_write(inno, 0xc6, val & 0xff);
+		inno_write(inno, 0xc7, 3 << 1);
+		inno_write(inno, 0xc5, ((val >> 8) & 0xff));
+	} else if (phy_cfg->tmdsclock > 165000000) {
+		inno_write(inno, 0xc5, 0x81);
+		/* clk termination resistor is 50ohm
+		 * data termination resistor is 150ohm
+		 */
+		inno_write(inno, 0xc8, 0x30);
+		inno_write(inno, 0xc9, 0x10);
+		inno_write(inno, 0xca, 0x10);
+		inno_write(inno, 0xcb, 0x10);
+	} else {
+		inno_write(inno, 0xc5, 0x81);
+	}
+
+	/* set TMDS sync detection counter length */
+	val = 47520000000UL / phy_cfg->tmdsclock;
+	inno_write(inno, 0xd8, (val >> 8) & 0xff);
+	inno_write(inno, 0xd9, val & 0xff);
+
+	/* Power up post PLL */
+	inno_update_bits(inno, 0xaa, 1, 0);
+	/* Power up tmds driver */
+	inno_update_bits(inno, 0xb0, 4, 4);
+	inno_write(inno, 0xb2, 0x0f);
+
+	/* Wait for post PLL lock */
+	for (val = 0; val < 5; val++) {
+		if (inno_read(inno, 0xaf) & 1)
+			break;
+		udelay(1000);
+	}
+	if (!(inno_read(inno, 0xaf) & 1)) {
+		printf("HDMI PHY Post PLL unlock\n");
+		return -ETIMEDOUT;
+	}
+	if (phy_cfg->tmdsclock > 340000000)
+		mdelay(100);
+	/* set pdata_en to 1 */
+	inno_update_bits(inno, 0x02, 1, 1);
+
+	return 0;
+}
+
+static void inno_hdmi_phy_rk3328_power_off(struct inno_hdmi_phy *inno)
+{
+	/* Power off driver */
+	inno_write(inno, 0xb2, 0);
+	/* Power off band gap */
+	inno_update_bits(inno, 0xb0, 4, 0);
+	/* Power off post pll */
+	inno_update_bits(inno, 0xaa, 1, 1);
+}
+
+static int
+inno_hdmi_phy_rk3328_pre_pll_update(struct inno_hdmi_phy *inno,
+				    const struct pre_pll_config *cfg)
+{
+	u32 val;
+
+	/* Power off PLL */
+	inno_update_bits(inno, 0xa0, 1, 1);
+	/* Configure pre-pll */
+	inno_update_bits(inno, 0xa0, 2, (cfg->vco_div_5_en & 1) << 1);
+	inno_write(inno, 0xa1, cfg->prediv);
+	if (cfg->fracdiv)
+		val = ((cfg->fbdiv >> 8) & 0x0f) | 0xc0;
+	else
+		val = ((cfg->fbdiv >> 8) & 0x0f) | 0xf0;
+	inno_write(inno, 0xa2, val);
+	inno_write(inno, 0xa3, cfg->fbdiv & 0xff);
+	val = (cfg->pclk_div_a & 0x1f) |
+	      ((cfg->pclk_div_b & 3) << 5);
+	inno_write(inno, 0xa5, val);
+	val = (cfg->pclk_div_d & 0x1f) |
+	      ((cfg->pclk_div_c & 3) << 5);
+	inno_write(inno, 0xa6, val);
+	val = ((cfg->tmds_div_a & 3) << 4) |
+	      ((cfg->tmds_div_b & 3) << 2) |
+	      (cfg->tmds_div_c & 3);
+	inno_write(inno, 0xa4, val);
+
+	if (cfg->fracdiv) {
+		val = cfg->fracdiv & 0xff;
+		inno_write(inno, 0xd3, val);
+		val = (cfg->fracdiv >> 8) & 0xff;
+		inno_write(inno, 0xd2, val);
+		val = (cfg->fracdiv >> 16) & 0xff;
+		inno_write(inno, 0xd1, val);
+	} else {
+		inno_write(inno, 0xd3, 0);
+		inno_write(inno, 0xd2, 0);
+		inno_write(inno, 0xd1, 0);
+	}
+
+	/* Power up PLL */
+	inno_update_bits(inno, 0xa0, 1, 0);
+
+	/* Wait for PLL lock */
+	for (val = 0; val < 5; val++) {
+		if (inno_read(inno, 0xa9) & 1)
+			break;
+		udelay(1000);
+	}
+	if (val == 5) {
+		printf("Pre-PLL unlock\n");
+		return -ETIMEDOUT;
+	}
+
+	return 0;
+}
+
+static unsigned long
+inno_hdmi_3328_phy_pll_recalc_rate(struct inno_hdmi_phy *inno,
+				   unsigned long parent_rate)
+{
+	unsigned long rate, vco, frac;
+	u8 nd, no_a, no_b, no_d;
+	__maybe_unused u8 no_c;
+	u16 nf;
+
+	nd = inno_read(inno, 0xa1) & 0x3f;
+	nf = ((inno_read(inno, 0xa2) & 0x0f) << 8) | inno_read(inno, 0xa3);
+	vco = parent_rate * nf;
+	if ((inno_read(inno, 0xa2) & 0x30) == 0) {
+		frac = inno_read(inno, 0xd3) |
+		       (inno_read(inno, 0xd2) << 8) |
+		       (inno_read(inno, 0xd1) << 16);
+		vco += DIV_ROUND_CLOSEST(parent_rate * frac, (1 << 24));
+	}
+	if (inno_read(inno, 0xa0) & 2) {
+		rate = vco / (nd * 5);
+	} else {
+		no_a = inno_read(inno, 0xa5) & 0x1f;
+		no_b = ((inno_read(inno, 0xa5) >> 5) & 7) + 2;
+		no_c = (1 << ((inno_read(inno, 0xa6) >> 5) & 7));
+		no_d = inno_read(inno, 0xa6) & 0x1f;
+		if (no_a == 1)
+			rate = vco / (nd * no_b * no_d * 2);
+		else
+			rate = vco / (nd * no_a * no_d * 2);
+	}
+	inno->pixclock = rate;
+
+	return rate;
+}
+
+static int
+inno_hdmi_phy_rk3528_power_on(struct inno_hdmi_phy *inno,
+			      const struct post_pll_config *cfg,
+			      const struct phy_config *phy_cfg)
+{
+	u32 val;
+	u64 temp;
+	u32 tmdsclock = inno_hdmi_phy_get_tmdsclk(inno, inno->pixclock);
+
+	/* Power off post PLL */
+	inno_update_bits(inno, 0xaa, 1, 0);
+
+	val = cfg->prediv;
+	inno_write(inno, 0xab, val);
+
+	if (cfg->postdiv == 1) {
+		inno_write(inno, 0xad, 0x8);
+		inno_write(inno, 0xaa, 2);
+	} else {
+		val = (cfg->postdiv / 2) - 1;
+		inno_write(inno, 0xad, val);
+		inno_write(inno, 0xaa, 0x0e);
+	}
+
+	val = cfg->fbdiv & 0xff;
+	inno_write(inno, 0xac, val);
+	val = (cfg->fbdiv >> 8) & BIT(0);
+	inno_update_bits(inno, 0xad, BIT(4), val);
+
+	/* current bias clk/data 2 */
+	val = phy_cfg->regs[0] << 4 | phy_cfg->regs[1];
+	inno_write(inno, 0xbf, val);
+
+	/* current bias data 1/0 */
+	val = phy_cfg->regs[1] << 4 | phy_cfg->regs[1];
+	inno_write(inno, 0xc0, val);
+
+	/* output voltage */
+	inno_write(inno, 0xb5, phy_cfg->regs[2]);
+	inno_write(inno, 0xb6, phy_cfg->regs[3]);
+	inno_write(inno, 0xb7, phy_cfg->regs[3]);
+	inno_write(inno, 0xb8, phy_cfg->regs[3]);
+
+	/* pre-emphasis */
+	inno_write(inno, 0xbb, phy_cfg->regs[4]);
+	inno_write(inno, 0xbc, phy_cfg->regs[4]);
+	inno_write(inno, 0xbd, phy_cfg->regs[4]);
+
+	/* enable LDO */
+	inno_write(inno, 0xb4, 0x7);
+
+	/* enable serializer */
+	inno_write(inno, 0xbe, 0x70);
+
+	inno_write(inno, 0xb2, 0x0f);
+
+	for (val = 0; val < 5; val++) {
+		if (inno_read(inno, 0xaf) & 1)
+			break;
+		udelay(1000);
+	}
+	if (!(inno_read(inno, 0xaf) & 1)) {
+		dev_err(inno->dev, "HDMI PHY Post PLL unlock\n");
+		return -ETIMEDOUT;
+	}
+
+	/* set termination resistance */
+	if (phy_cfg->tmdsclock > 340000000) {
+		inno_write(inno, 0xc7, 0x76);
+		inno_write(inno, 0xc5, 0x83);
+		inno_write(inno, 0xc8, 0x00);
+		inno_write(inno, 0xc9, 0x2f);
+		inno_write(inno, 0xca, 0x2f);
+		inno_write(inno, 0xcb, 0x2f);
+	} else {
+		inno_write(inno, 0xc7, 0x76);
+		inno_write(inno, 0xc5, 0x83);
+		inno_write(inno, 0xc8, 0x00);
+		inno_write(inno, 0xc9, 0x0f);
+		inno_write(inno, 0xca, 0x0f);
+		inno_write(inno, 0xcb, 0x0f);
+	}
+
+
+	/* set TMDS sync detection counter length */
+	temp = 47520000000UL / tmdsclock;
+	inno_write(inno, 0xd8, (temp >> 8) & 0xff);
+	inno_write(inno, 0xd9, temp & 0xff);
+
+	if (phy_cfg->tmdsclock > 340000000)
+		mdelay(100);
+	/* set pdata_en to 0/1 */
+	inno_update_bits(inno, 0x02, 1, 0);
+	inno_update_bits(inno, 0x02, 1, 1);
+
+	/* Enable PHY IRQ */
+	inno_write(inno, 0x05, 0x22);
+	inno_write(inno, 0x07, 0x22);
+	inno_write(inno, 0xcc, 0x0f);
+
+	return 0;
+}
+
+static void inno_hdmi_phy_rk3528_power_off(struct inno_hdmi_phy *inno)
+{
+	/* Power off driver */
+	inno_write(inno, 0xb2, 0);
+	/* Power off band gap */
+	inno_update_bits(inno, 0xb0, 4, 0);
+	/* Power off post pll */
+	inno_update_bits(inno, 0xaa, 1, 1);
+
+	/* Disable PHY IRQ */
+	inno_write(inno, 0x05, 0);
+	inno_write(inno, 0x07, 0);
+}
+
+static void inno_hdmi_phy_rk3528_init(struct inno_hdmi_phy *inno)
+{
+	/*
+	 * Use phy internal register control
+	 * rxsense/poweron/pllpd/pdataen signal.
+	 */
+	inno_write(inno, 0x02, 0x81);
+}
+
+static int
+inno_hdmi_phy_rk3528_pre_pll_update(struct inno_hdmi_phy *inno,
+				    const struct pre_pll_config *cfg)
+{
+	u32 val;
+
+	inno_update_bits(inno, 0xb0, 4, 4);
+	inno_write(inno, 0xcc, 0x0f);
+
+	/* Power on PLL */
+	inno_update_bits(inno, 0xa0, 1, 0);
+	/* Configure pre-pll */
+	inno_update_bits(inno, 0xa0, 2, (cfg->vco_div_5_en & 1) << 1);
+	inno_write(inno, 0xa1, cfg->prediv);
+	if (cfg->fracdiv)
+		val = ((cfg->fbdiv >> 8) & 0x0f) | 0xc0;
+	else
+		val = ((cfg->fbdiv >> 8) & 0x0f) | 0xf0;
+	inno_write(inno, 0xa2, val);
+	inno_write(inno, 0xa3, cfg->fbdiv & 0xff);
+	val = (cfg->pclk_div_a & 0x1f) |
+	      ((cfg->pclk_div_b & 3) << 5);
+	inno_write(inno, 0xa5, val);
+	val = (cfg->pclk_div_d & 0x1f) |
+	      ((cfg->pclk_div_c & 3) << 5);
+	inno_write(inno, 0xa6, val);
+	val = ((cfg->tmds_div_a & 3) << 4) |
+	      ((cfg->tmds_div_b & 3) << 2) |
+	      (cfg->tmds_div_c & 3);
+	inno_write(inno, 0xa4, val);
+
+	if (cfg->fracdiv) {
+		val = cfg->fracdiv & 0xff;
+		inno_write(inno, 0xd3, val);
+		val = (cfg->fracdiv >> 8) & 0xff;
+		inno_write(inno, 0xd2, val);
+		val = (cfg->fracdiv >> 16) & 0xff;
+		inno_write(inno, 0xd1, val);
+	} else {
+		inno_write(inno, 0xd3, 0);
+		inno_write(inno, 0xd2, 0);
+		inno_write(inno, 0xd1, 0);
+	}
+
+	/* Wait for PLL lock */
+	for (val = 0; val < 5; val++) {
+		if (inno_read(inno, 0xa9) & 1)
+			break;
+		udelay(1000);
+	}
+	if (val == 5) {
+		dev_err(inno->dev, "Pre-PLL unlock\n");
+		return -ETIMEDOUT;
+	}
+
+	return 0;
+}
+
+static unsigned long
+inno_hdmi_rk3528_phy_pll_recalc_rate(struct inno_hdmi_phy *inno,
+				     unsigned long parent_rate)
+{
+	unsigned long frac;
+	u8 nd, no_a, no_b, no_d;
+	u16 nf;
+	u64 vco = parent_rate;
+
+	nd = inno_read(inno, 0xa1) & 0x3f;
+	nf = ((inno_read(inno, 0xa2) & 0x0f) << 8) | inno_read(inno, 0xa3);
+	vco *= nf;
+	if ((inno_read(inno, 0xa2) & 0x30) == 0) {
+		frac = inno_read(inno, 0xd3) |
+		       (inno_read(inno, 0xd2) << 8) |
+		       (inno_read(inno, 0xd1) << 16);
+		vco += DIV_ROUND_CLOSEST(parent_rate * frac, (1 << 24));
+	}
+	if (inno_read(inno, 0xa0) & 2) {
+		do_div(vco, nd * 5);
+	} else {
+		no_a = inno_read(inno, 0xa5) & 0x1f;
+		no_b = ((inno_read(inno, 0xa5) >> 5) & 7) + 2;
+		no_d = inno_read(inno, 0xa6) & 0x1f;
+		if (no_a == 1)
+			do_div(vco, nd * no_b * no_d * 2);
+		else
+			do_div(vco, nd * no_a * no_d * 2);
+	}
+
+	frac = vco;
+	inno->pixclock = DIV_ROUND_CLOSEST(frac, 1000) * 1000;
+
+	dev_dbg(inno->dev, "%s rate %lu\n", __func__, inno->pixclock);
+
+	return frac;
+}
+
+#ifndef CONFIG_SPL_BUILD
+#define PHY_TAB_LEN 60
+
+static
+int inno_hdmi_update_phy_table(struct inno_hdmi_phy *inno, u32 *config,
+			       struct phy_config *phy_cfg,
+			       int phy_table_size)
+{
+	int i, j;
+
+	for (i = 0; i < phy_table_size; i++) {
+		phy_cfg[i].tmdsclock =
+			(unsigned long)config[i * 15];
+
+		debug("%ld ", phy_cfg[i].tmdsclock);
+		for (j = 0; j < 14; j++) {
+			phy_cfg[i].regs[j] = (u8)config[i * 15 + 1 + j];
+			debug("0x%02x ", phy_cfg[i].regs[j]);
+		}
+		debug("\n");
+	}
+
+	/*
+	 * The last set of phy cfg is used to indicate whether
+	 * there is no more phy cfg data.
+	 */
+	phy_cfg[i].tmdsclock = ~0UL;
+	for (j = 0; j < 14; j++)
+		phy_cfg[i].regs[j] = 0;
+
+	return 0;
+}
+#endif
+
+static const struct inno_hdmi_phy_ops rk3228_hdmi_phy_ops = {
+	.init = inno_hdmi_phy_rk3228_init,
+	.power_on = inno_hdmi_phy_rk3228_power_on,
+	.power_off = inno_hdmi_phy_rk3228_power_off,
+	.pre_pll_update = inno_hdmi_phy_rk3228_pre_pll_update,
+};
+
+static const struct inno_hdmi_phy_ops rk3328_hdmi_phy_ops = {
+	.init = inno_hdmi_phy_rk3328_init,
+	.power_on = inno_hdmi_phy_rk3328_power_on,
+	.power_off = inno_hdmi_phy_rk3328_power_off,
+	.pre_pll_update = inno_hdmi_phy_rk3328_pre_pll_update,
+	.recalc_rate = inno_hdmi_3328_phy_pll_recalc_rate,
+};
+
+static const struct inno_hdmi_phy_ops rk3528_hdmi_phy_ops = {
+	.init = inno_hdmi_phy_rk3528_init,
+	.power_on = inno_hdmi_phy_rk3528_power_on,
+	.power_off = inno_hdmi_phy_rk3528_power_off,
+	.pre_pll_update = inno_hdmi_phy_rk3528_pre_pll_update,
+	.recalc_rate = inno_hdmi_rk3528_phy_pll_recalc_rate,
+};
+
+static const struct inno_hdmi_phy_drv_data rk3228_hdmi_phy_drv_data = {
+	.dev_type = INNO_HDMI_PHY_RK3228,
+	.ops = &rk3228_hdmi_phy_ops,
+	.phy_cfg_table = rk3228_phy_cfg,
+};
+
+static const struct inno_hdmi_phy_drv_data rk3328_hdmi_phy_drv_data = {
+	.dev_type = INNO_HDMI_PHY_RK3328,
+	.ops = &rk3328_hdmi_phy_ops,
+	.phy_cfg_table = rk3328_phy_cfg,
+};
+
+static const struct inno_hdmi_phy_drv_data rk3528_hdmi_phy_drv_data = {
+	.dev_type = INNO_HDMI_PHY_RK3528,
+	.ops = &rk3528_hdmi_phy_ops,
+	.phy_cfg_table = rk3528_phy_cfg,
+};
+
+static const struct rockchip_inno_data inno_hdmi_phy_of_match[] = {
+	{ .compatible = "rockchip,rk3228-hdmi-phy",
+	  .data = &rk3228_hdmi_phy_drv_data
+	},
+	{ .compatible = "rockchip,rk3328-hdmi-phy",
+	  .data = &rk3328_hdmi_phy_drv_data
+	},
+	{ .compatible = "rockchip,rk3528-hdmi-phy",
+	  .data = &rk3528_hdmi_phy_drv_data
+	},
+	{}
+};
+
+static int inno_hdmi_phy_init(struct rockchip_phy *phy)
+{
+#ifdef CONFIG_SPL_BUILD
+	struct inno_hdmi_phy *inno = (struct inno_hdmi_phy *)phy->data;
+#else
+	struct udevice *dev = phy->dev;
+	struct inno_hdmi_phy *inno = dev_get_priv(phy->dev);
+	int val, phy_table_size, ret;
+	u32 *phy_config;
+#endif
+	int i;
+	const char *name;
+
+#ifdef CONFIG_SPL_BUILD
+	inno->regs = (void *)RK3528_HDMIPHY_BASE;
+#else
+	inno->regs = dev_read_addr_ptr(dev);
+	inno->node = dev->node;
+#endif
+	if (!inno->regs) {
+		printf("%s: failed to get phy address\n", __func__);
+		return -ENOMEM;
+	}
+
+#ifdef CONFIG_SPL_BUILD
+	name = "rockchip,rk3528-hdmi-phy";
+#else
+	name = dev_read_string(dev, "compatible");
+#endif
+	for (i = 0; i < ARRAY_SIZE(inno_hdmi_phy_of_match); i++) {
+		if (!strcmp(name, inno_hdmi_phy_of_match[i].compatible)) {
+			inno->plat_data = inno_hdmi_phy_of_match[i].data;
+			break;
+		}
+	}
+
+#ifndef CONFIG_SPL_BUILD
+	dev_read_prop(dev, "rockchip,phy-table", &val);
+
+	if (val >= 0) {
+		if (val % PHY_TAB_LEN || !val) {
+			printf("Invalid phy cfg table format!\n");
+			return -EINVAL;
+		}
+
+		phy_config = malloc(val);
+		if (!phy_config) {
+			printf("kmalloc phy table failed\n");
+			return -ENOMEM;
+		}
+
+		phy_table_size = val / PHY_TAB_LEN;
+		/* Effective phy cfg data and the end of phy cfg table */
+		inno->phy_cfg = malloc(val + PHY_TAB_LEN);
+		if (!inno->phy_cfg) {
+			free(phy_config);
+			return -ENOMEM;
+		}
+
+		dev_read_u32_array(dev, "rockchip,phy-table",
+				   phy_config, val / sizeof(u32));
+		ret = inno_hdmi_update_phy_table(inno, phy_config,
+						 inno->phy_cfg,
+						 phy_table_size);
+		if (ret) {
+			free(phy_config);
+			return ret;
+		}
+		free(phy_config);
+	} else {
+		printf("use default hdmi phy table\n");
+	}
+#endif
+
+	if (i >= ARRAY_SIZE(inno_hdmi_phy_of_match))
+		return 0;
+
+	if (!inno->plat_data || !inno->plat_data->ops)
+		return -EINVAL;
+
+	if (inno->plat_data->ops->init)
+		inno->plat_data->ops->init(inno);
+
+	return 0;
+}
+
+static unsigned long inno_hdmi_phy_set_pll(struct rockchip_phy *phy,
+					   unsigned long rate)
+{
+#ifdef CONFIG_SPL_BUILD
+	struct inno_hdmi_phy *inno = (struct inno_hdmi_phy *)phy->data;
+#else
+	struct inno_hdmi_phy *inno = dev_get_priv(phy->dev);
+#endif
+
+#ifdef CONFIG_SPL_BUILD
+	if (!inno)
+		inno = g_inno;
+#endif
+	inno_hdmi_phy_clk_prepare(inno);
+	inno_hdmi_phy_clk_is_prepared(inno);
+	inno_hdmi_phy_clk_set_rate(inno, rate);
+	return 0;
+}
+
+static int
+inno_hdmi_phy_set_bus_width(struct rockchip_phy *phy, u32 bus_width)
+{
+#ifdef CONFIG_SPL_BUILD
+	struct inno_hdmi_phy *inno = (struct inno_hdmi_phy *)phy->data;
+#else
+	struct inno_hdmi_phy *inno = dev_get_priv(phy->dev);
+#endif
+
+	inno->bus_width = bus_width;
+
+	return 0;
+}
+
+static long
+inno_hdmi_phy_clk_round_rate(struct rockchip_phy *phy, unsigned long rate)
+{
+#ifdef CONFIG_SPL_BUILD
+	struct inno_hdmi_phy *inno = (struct inno_hdmi_phy *)phy->data;
+#else
+	struct inno_hdmi_phy *inno = dev_get_priv(phy->dev);
+#endif
+	int i;
+	const struct pre_pll_config *cfg = pre_pll_cfg_table;
+	u32 tmdsclock = inno_hdmi_phy_get_tmdsclk(inno, rate);
+
+	for (; cfg->pixclock != ~0UL; cfg++)
+		if (cfg->pixclock == rate)
+			break;
+
+	/*
+	 * XXX: Limit pixel clock under 600MHz
+	 * rk3228 does not support non-zero fracdiv
+	 */
+	if ((inno->plat_data->dev_type == INNO_HDMI_PHY_RK3228 &&
+	     cfg->fracdiv) || cfg->pixclock > 600000000)
+		return -EINVAL;
+
+	/*
+	 * If there is no dts phy cfg table, use default phy cfg table.
+	 * The tmds clock maximum is 594MHz. So there is no need to check
+	 * whether tmds clock is out of range.
+	 */
+	if (!inno->phy_cfg)
+		return cfg->pixclock;
+
+	/* Check if tmds clock is out of dts phy config's range. */
+	for (i = 0; inno->phy_cfg[i].tmdsclock != ~0UL; i++) {
+		if (inno->phy_cfg[i].tmdsclock >= tmdsclock)
+			break;
+	}
+
+	if (inno->phy_cfg[i].tmdsclock == ~0UL)
+		return -EINVAL;
+
+	return cfg->pixclock;
+}
+
+const struct rockchip_phy_funcs inno_hdmi_phy_funcs = {
+	.init = inno_hdmi_phy_init,
+	.power_on = inno_hdmi_phy_power_on,
+	.power_off = inno_hdmi_phy_power_off,
+	.set_pll = inno_hdmi_phy_set_pll,
+	.set_bus_width = inno_hdmi_phy_set_bus_width,
+	.round_rate = inno_hdmi_phy_clk_round_rate,
+};
+
+static struct rockchip_phy inno_hdmi_phy_driver_data = {
+	 .funcs = &inno_hdmi_phy_funcs,
+};
+
+static const struct udevice_id inno_hdmi_phy_ids[] = {
+	{
+	 .compatible = "rockchip,rk3328-hdmi-phy",
+	 .data = (ulong)&inno_hdmi_phy_driver_data,
+	},
+	{
+	 .compatible = "rockchip,rk3228-hdmi-phy",
+	 .data = (ulong)&inno_hdmi_phy_driver_data,
+	},
+	{
+	 .compatible = "rockchip,rk3528-hdmi-phy",
+	 .data = (ulong)&inno_hdmi_phy_driver_data,
+	},
+	{}
+};
+
+#ifdef CONFIG_SPL_BUILD
+int inno_spl_hdmi_phy_probe(struct display_state *state)
+{
+	struct inno_hdmi_phy *inno = malloc(sizeof(struct inno_hdmi_phy));
+
+	memset(inno, 0, sizeof(*inno));
+	g_inno = inno;
+
+	state->conn_state.connector->phy = &inno_hdmi_phy_driver_data;
+	state->conn_state.connector->phy->data = (void *)inno;
+	return 0;
+}
+#else
+static int inno_hdmi_phy_probe(struct udevice *dev)
+{
+	struct inno_hdmi_phy *inno = dev_get_priv(dev);
+	struct rockchip_phy *phy =
+		(struct rockchip_phy *)dev_get_driver_data(dev);
+
+	inno->dev = dev;
+	phy->dev = dev;
+
+	g_inno = inno;
+	dev->driver_data = (ulong)&inno_hdmi_phy_driver_data;
+	phy = &inno_hdmi_phy_driver_data;
+
+	return 0;
+}
+#endif
+
+static int rockchip_inno_phy_hdmi_bind(struct udevice *parent)
+{
+	struct udevice *child;
+	ofnode subnode;
+	int ret;
+
+	subnode = ofnode_find_subnode(parent->node, "clk-port");
+	if (!ofnode_valid(subnode)) {
+		printf("%s: no subnode for %s\n", __func__, parent->name);
+		return -ENXIO;
+	}
+
+	ret = device_bind_driver_to_node(parent, "clk_inno_hdmi", "inno_hdmi_pll_clk", subnode, &child);
+	if (ret) {
+		printf("%s: clk-port cannot bind its driver\n", __func__);
+		return ret;
+	}
+
+	return 0;
+}
+
+U_BOOT_DRIVER(inno_hdmi_phy) = {
+	.name = "inno_hdmi_phy",
+	.id = UCLASS_PHY,
+	.of_match = inno_hdmi_phy_ids,
+#ifndef CONFIG_SPL_BUILD
+	.probe = inno_hdmi_phy_probe,
+#endif
+	.bind = rockchip_inno_phy_hdmi_bind,
+	.priv_auto_alloc_size = sizeof(struct inno_hdmi_phy),
+};
+
+
+static ulong inno_hdmi_clk_get_rate(struct clk *clk)
+{
+	struct clk_inno_hdmi *priv = dev_get_priv(clk->dev);
+
+	return priv->rate;
+}
+
+static ulong inno_hdmi_clk_set_rate(struct clk *clk, ulong rate)
+{
+	struct clk_inno_hdmi *priv = dev_get_priv(clk->dev);
+	int ret;
+
+	inno_hdmi_phy_clk_prepare(g_inno);
+	inno_hdmi_phy_clk_is_prepared(g_inno);
+	ret = inno_hdmi_phy_clk_set_rate(g_inno, rate);
+	if (ret < 0) {
+		printf("inno hdmi set rate failed ret:%d\n", ret);
+		return ret;
+	}
+
+	priv->rate = g_inno->pixclock;
+
+	return priv->rate;
+}
+
+static const struct clk_ops inno_hdmi_clk_ops = {
+	.get_rate	= inno_hdmi_clk_get_rate,
+	.set_rate	= inno_hdmi_clk_set_rate,
+};
+
+static int inno_hdmi_clk_probe(struct udevice *dev)
+{
+	return 0;
+}
+
+/*
+ * In order for other display interfaces to use hdmiphy as source
+ * for dclk, hdmiphy must register a virtual clock driver
+ */
+U_BOOT_DRIVER(clk_inno_hdmi) = {
+	.name		= "clk_inno_hdmi",
+	.id		= UCLASS_CLK,
+	.priv_auto_alloc_size = sizeof(struct clk_inno_hdmi),
+	.ops		= &inno_hdmi_clk_ops,
+	.probe		= inno_hdmi_clk_probe,
+};
diff --git a/drivers/video/drm/rockchip_bridge.c b/drivers/video/drm/rockchip_bridge.c
new file mode 100644
index 0000000000..aa08992457
--- /dev/null
+++ b/drivers/video/drm/rockchip_bridge.c
@@ -0,0 +1,93 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * (C) Copyright 2008-2018 Fuzhou Rockchip Electronics Co., Ltd
+ */
+
+#include "rockchip_bridge.h"
+
+void rockchip_bridge_init(struct rockchip_bridge *bridge,
+			  struct rockchip_connector *conn,
+			  struct display_state *state)
+{
+	if (!bridge)
+		return;
+
+	bridge->conn = conn;
+	bridge->state = state;
+
+	if (bridge->next_bridge)
+		rockchip_bridge_init(bridge->next_bridge, conn, state);
+}
+
+void rockchip_bridge_pre_enable(struct rockchip_bridge *bridge)
+{
+	if (!bridge)
+		return;
+
+	if (bridge->funcs && bridge->funcs->pre_enable)
+		bridge->funcs->pre_enable(bridge);
+
+	if (bridge->next_bridge)
+		rockchip_bridge_pre_enable(bridge->next_bridge);
+}
+
+void rockchip_bridge_post_disable(struct rockchip_bridge *bridge)
+{
+	if (!bridge)
+		return;
+
+	if (bridge->next_bridge)
+		rockchip_bridge_post_disable(bridge->next_bridge);
+
+	if (bridge->funcs && bridge->funcs->post_disable)
+		bridge->funcs->post_disable(bridge);
+}
+
+void rockchip_bridge_enable(struct rockchip_bridge *bridge)
+{
+	if (!bridge)
+		return;
+
+	if (bridge->funcs && bridge->funcs->enable)
+		bridge->funcs->enable(bridge);
+
+	if (bridge->next_bridge)
+		rockchip_bridge_enable(bridge->next_bridge);
+}
+
+void rockchip_bridge_disable(struct rockchip_bridge *bridge)
+{
+	if (!bridge)
+		return;
+
+	if (bridge->next_bridge)
+		rockchip_bridge_disable(bridge->next_bridge);
+
+	if (bridge->funcs && bridge->funcs->disable)
+		bridge->funcs->disable(bridge);
+}
+
+void rockchip_bridge_mode_set(struct rockchip_bridge *bridge,
+			      const struct drm_display_mode *mode)
+{
+	if (!bridge || !mode)
+		return;
+
+	if (bridge->funcs && bridge->funcs->mode_set)
+		bridge->funcs->mode_set(bridge, mode);
+
+	if (bridge->next_bridge)
+		rockchip_bridge_mode_set(bridge->next_bridge, mode);
+}
+
+bool rockchip_bridge_detect(struct rockchip_bridge *bridge)
+{
+	if (bridge->funcs && bridge->funcs->detect)
+		if (!bridge->funcs->detect(bridge))
+			return false;
+
+	if (bridge->next_bridge)
+		return rockchip_bridge_detect(bridge->next_bridge);
+
+	return true;
+}
diff --git a/drivers/video/drm/rockchip_bridge.h b/drivers/video/drm/rockchip_bridge.h
new file mode 100644
index 0000000000..3ce20b6e98
--- /dev/null
+++ b/drivers/video/drm/rockchip_bridge.h
@@ -0,0 +1,48 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * (C) Copyright 2008-2018 Fuzhou Rockchip Electronics Co., Ltd
+ */
+
+#ifndef _ROCKCHIP_BRIDGE_H_
+#define _ROCKCHIP_BRIDGE_H_
+
+#include <config.h>
+#include <common.h>
+#include <dm/device.h>
+#include <errno.h>
+
+struct display_state;
+struct rockchip_bridge;
+struct drm_display_mode;
+struct rockchip_connector;
+
+struct rockchip_bridge_funcs {
+	void (*enable)(struct rockchip_bridge *bridge);
+	void (*disable)(struct rockchip_bridge *bridge);
+	void (*pre_enable)(struct rockchip_bridge *bridge);
+	void (*post_disable)(struct rockchip_bridge *bridge);
+	void (*mode_set)(struct rockchip_bridge *bridge,
+			 const struct drm_display_mode *mode);
+	bool (*detect)(struct rockchip_bridge *bridge);
+};
+
+struct rockchip_bridge {
+	struct udevice *dev;
+	const struct rockchip_bridge_funcs *funcs;
+	struct rockchip_bridge *next_bridge;
+	struct rockchip_connector *conn;
+	struct display_state *state;
+};
+
+void rockchip_bridge_init(struct rockchip_bridge *bridge,
+			  struct rockchip_connector *conn,
+			  struct display_state *state);
+void rockchip_bridge_enable(struct rockchip_bridge *bridge);
+void rockchip_bridge_disable(struct rockchip_bridge *bridge);
+void rockchip_bridge_pre_enable(struct rockchip_bridge *bridge);
+void rockchip_bridge_post_disable(struct rockchip_bridge *bridge);
+void rockchip_bridge_mode_set(struct rockchip_bridge *bridge,
+			      const struct drm_display_mode *mode);
+bool rockchip_bridge_detect(struct rockchip_bridge *bridge);
+
+#endif
diff --git a/drivers/video/drm/rockchip_connector.c b/drivers/video/drm/rockchip_connector.c
new file mode 100644
index 0000000000..5ee95df903
--- /dev/null
+++ b/drivers/video/drm/rockchip_connector.c
@@ -0,0 +1,338 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Rockchip Connector Helper Function
+ *
+ * Copyright (C) 2021 Rockchip Electronics Co., Ltd
+ */
+
+#include <dm/device.h>
+#include <dm/read.h>
+#include <linux/compat.h>
+#include <linux/list.h>
+
+#include "rockchip_display.h"
+#include "rockchip_crtc.h"
+#include "rockchip_connector.h"
+#include "rockchip_phy.h"
+
+#ifdef CONFIG_SPL_BUILD
+int rockchip_connector_bind(struct rockchip_connector *conn, struct udevice *dev, int id,
+			    const struct rockchip_connector_funcs *funcs, void *data, int type)
+{
+	conn->id = id;
+	conn->funcs = funcs;
+	conn->data = data;
+	conn->type = type;
+
+	return 0;
+}
+
+#else
+static LIST_HEAD(rockchip_connector_list);
+
+int rockchip_connector_bind(struct rockchip_connector *conn, struct udevice *dev, int id,
+			    const struct rockchip_connector_funcs *funcs, void *data, int type)
+{
+	conn->id = id;
+	conn->dev = dev;
+	conn->funcs = funcs;
+	conn->data = data;
+	conn->type = type;
+	list_add_tail(&conn->head, &rockchip_connector_list);
+
+	return 0;
+}
+
+struct rockchip_connector *get_rockchip_connector_by_device(struct udevice *dev)
+{
+	struct rockchip_connector *conn;
+
+	list_for_each_entry(conn, &rockchip_connector_list, head) {
+		if (conn->dev == dev)
+			return conn;
+	}
+
+	return NULL;
+}
+
+int rockchip_connector_pre_init(struct display_state *state)
+{
+	int ret = 0;
+	struct rockchip_connector *conn;
+
+	conn = state->conn_state.connector;
+	if (conn->funcs->pre_init) {
+		ret = conn->funcs->pre_init(conn, state);
+		if (ret)
+			return ret;
+		if (state->conn_state.secondary) {
+			conn = state->conn_state.connector;
+			ret = conn->funcs->pre_init(conn, state);
+			if (ret)
+				return ret;
+		}
+	}
+
+	return ret;
+}
+
+static int rockchip_connector_path_init(struct rockchip_connector *conn,
+					struct display_state *state)
+{
+	int ret = 0;
+
+	if (conn->panel)
+		rockchip_panel_init(conn->panel, conn, state);
+
+	if (conn->bridge)
+		rockchip_bridge_init(conn->bridge, conn, state);
+
+	if (conn->funcs->init) {
+		ret = conn->funcs->init(conn, state);
+		if (ret)
+			return ret;
+	}
+
+	if (conn->phy)
+		rockchip_phy_init(conn->phy);
+
+	return ret;
+}
+
+int rockchip_connector_init(struct display_state *state)
+{
+	int ret = 0;
+	struct rockchip_connector *conn;
+
+	conn = state->conn_state.connector;
+	ret = rockchip_connector_path_init(conn, state);
+	if (ret)
+		return ret;
+	if (state->conn_state.secondary) {
+		conn = state->conn_state.secondary;
+		ret = rockchip_connector_path_init(conn, state);
+		if (ret)
+			return ret;
+	}
+
+	return ret;
+}
+
+
+static bool rockchip_connector_path_detect(struct rockchip_connector *conn,
+					   struct display_state *state)
+{
+	int ret;
+
+	if (conn->funcs->detect) {
+		ret = conn->funcs->detect(conn, state);
+		if (!ret) {
+			printf("%s disconnected\n", conn->dev->name);
+			return false;
+		}
+	}
+	if (conn->bridge) {
+		ret = rockchip_bridge_detect(conn->bridge);
+		if (!ret) {
+			printf("%s disconnected\n",
+			       dev_np(conn->bridge->dev)->full_name);
+			return false;
+		}
+	}
+
+	return true;
+}
+
+bool rockchip_connector_detect(struct display_state *state)
+{
+	bool ret;
+	struct rockchip_connector *conn;
+
+	conn = state->conn_state.connector;
+	ret = rockchip_connector_path_detect(conn, state);
+	if (!ret)
+		return false;
+	if (state->conn_state.secondary) {
+		conn = state->conn_state.secondary;
+		ret = rockchip_connector_path_detect(conn, state);
+		if (!ret)
+			return false;
+	}
+
+	return true;
+}
+
+int rockchip_connector_get_timing(struct display_state *state)
+{
+	int ret = 0;
+	struct rockchip_connector *conn;
+
+	conn = state->conn_state.connector;
+	if (conn->funcs->get_timing) {
+		ret = conn->funcs->get_timing(conn, state);
+		if (ret)
+			return ret;
+		if (state->conn_state.secondary) {
+			conn = state->conn_state.secondary;
+			ret = conn->funcs->get_timing(conn, state);
+			if (ret)
+				return ret;
+		}
+	}
+
+	return ret;
+}
+
+int rockchip_connector_get_edid(struct display_state *state)
+{
+	int ret = 0;
+	struct rockchip_connector *conn;
+
+	conn = state->conn_state.connector;
+	if (conn->funcs->get_edid) {
+		ret = conn->funcs->get_edid(conn, state);
+		if (ret)
+			return ret;
+		if (state->conn_state.secondary) {
+			conn = state->conn_state.secondary;
+			ret = conn->funcs->get_edid(conn, state);
+			if (ret)
+				return ret;
+		}
+	}
+
+	return ret;
+}
+
+static int rockchip_connector_path_pre_enable(struct rockchip_connector *conn,
+					      struct display_state *state)
+{
+	if (conn->funcs->prepare)
+		conn->funcs->prepare(conn, state);
+
+	if (conn->bridge)
+		rockchip_bridge_pre_enable(conn->bridge);
+
+	if (conn->panel)
+		rockchip_panel_prepare(conn->panel);
+
+	return 0;
+}
+
+int rockchip_connector_pre_enable(struct display_state *state)
+{
+	struct rockchip_connector *conn;
+
+	conn = state->conn_state.connector;
+	rockchip_connector_path_pre_enable(conn, state);
+	if (state->conn_state.secondary) {
+		conn = state->conn_state.secondary;
+		rockchip_connector_path_pre_enable(conn, state);
+	}
+
+	return 0;
+}
+
+static int rockchip_connector_path_enable(struct rockchip_connector *conn,
+					  struct display_state *state)
+{
+	if (conn->funcs->enable)
+		conn->funcs->enable(conn, state);
+
+	if (conn->bridge)
+		rockchip_bridge_enable(conn->bridge);
+
+	if (conn->panel)
+		rockchip_panel_enable(conn->panel);
+
+	return 0;
+}
+
+int rockchip_connector_enable(struct display_state *state)
+{
+	struct rockchip_connector *conn;
+
+	conn = state->conn_state.connector;
+	rockchip_connector_path_enable(conn, state);
+	if (state->conn_state.secondary) {
+		conn = state->conn_state.secondary;
+		rockchip_connector_path_enable(conn, state);
+	}
+
+	return 0;
+}
+
+static int rockchip_connector_path_disable(struct rockchip_connector *conn,
+					   struct display_state *state)
+{
+	if (conn->panel)
+		rockchip_panel_disable(conn->panel);
+
+	if (conn->bridge)
+		rockchip_bridge_disable(conn->bridge);
+
+	if (conn->funcs->disable)
+		conn->funcs->disable(conn, state);
+
+	return 0;
+}
+
+int rockchip_connector_disable(struct display_state *state)
+{
+	struct rockchip_connector *conn;
+
+	conn = state->conn_state.connector;
+	rockchip_connector_path_disable(conn, state);
+	if (state->conn_state.secondary) {
+		conn = state->conn_state.secondary;
+		rockchip_connector_path_disable(conn, state);
+	}
+
+	return 0;
+}
+
+static int rockchip_connector_path_post_disable(struct rockchip_connector *conn,
+						struct display_state *state)
+{
+	if (conn->panel)
+		rockchip_panel_unprepare(conn->panel);
+
+	if (conn->bridge)
+		rockchip_bridge_post_disable(conn->bridge);
+
+	if (conn->funcs->unprepare)
+		conn->funcs->unprepare(conn, state);
+
+	return 0;
+}
+
+int rockchip_connector_post_disable(struct display_state *state)
+{
+	struct rockchip_connector *conn;
+
+	conn = state->conn_state.connector;
+	rockchip_connector_path_post_disable(conn, state);
+	if (state->conn_state.secondary) {
+		conn = state->conn_state.secondary;
+		rockchip_connector_path_post_disable(conn, state);
+	}
+
+	return 0;
+}
+#endif
+
+int rockchip_connector_deinit(struct display_state *state)
+{
+	struct rockchip_connector *conn;
+
+	conn = state->conn_state.connector;
+	if (conn->funcs->deinit) {
+		conn->funcs->deinit(conn, state);
+		if (state->conn_state.secondary) {
+			conn = state->conn_state.secondary;
+			conn->funcs->deinit(conn, state);
+		}
+	}
+
+	return 0;
+}
diff --git a/drivers/video/drm/rockchip_connector.h b/drivers/video/drm/rockchip_connector.h
new file mode 100644
index 0000000000..8c2ff7569f
--- /dev/null
+++ b/drivers/video/drm/rockchip_connector.h
@@ -0,0 +1,223 @@
+/*
+ * (C) Copyright 2008-2017 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _ROCKCHIP_CONNECTOR_H_
+#define _ROCKCHIP_CONNECTOR_H_
+
+#ifdef CONFIG_SPL_BUILD
+struct rockchip_connector {
+	struct rockchip_phy *phy;
+	int id;
+	int type;
+	bool hpd;
+
+	const struct rockchip_connector_funcs *funcs;
+	void *data;
+};
+#else
+#include "rockchip_bridge.h"
+#include "rockchip_panel.h"
+
+struct rockchip_connector {
+	struct udevice *dev;
+	struct rockchip_bridge *bridge;
+	struct rockchip_panel *panel;
+	struct rockchip_phy *phy;
+	struct list_head head;
+	int id;
+	int type;
+	bool hpd;
+
+	const struct rockchip_connector_funcs *funcs;
+	void *data;
+};
+#endif
+
+/**
+ * enum drm_bus_flags - bus_flags info for &drm_display_info
+ *
+ * This enum defines signal polarities and clock edge information for signals on
+ * a bus as bitmask flags.
+ *
+ * The clock edge information is conveyed by two sets of symbols,
+ * DRM_BUS_FLAGS_*_DRIVE_\* and DRM_BUS_FLAGS_*_SAMPLE_\*. When this enum is
+ * used to describe a bus from the point of view of the transmitter, the
+ * \*_DRIVE_\* flags should be used. When used from the point of view of the
+ * receiver, the \*_SAMPLE_\* flags should be used. The \*_DRIVE_\* and
+ * \*_SAMPLE_\* flags alias each other, with the \*_SAMPLE_POSEDGE and
+ * \*_SAMPLE_NEGEDGE flags being equal to \*_DRIVE_NEGEDGE and \*_DRIVE_POSEDGE
+ * respectively. This simplifies code as signals are usually sampled on the
+ * opposite edge of the driving edge. Transmitters and receivers may however
+ * need to take other signal timings into account to convert between driving
+ * and sample edges.
+ */
+enum drm_bus_flags {
+	/**
+	 * @DRM_BUS_FLAG_DE_LOW:
+	 *
+	 * The Data Enable signal is active low
+	 */
+	DRM_BUS_FLAG_DE_LOW = BIT(0),
+
+	/**
+	 * @DRM_BUS_FLAG_DE_HIGH:
+	 *
+	 * The Data Enable signal is active high
+	 */
+	DRM_BUS_FLAG_DE_HIGH = BIT(1),
+
+	/**
+	 * @DRM_BUS_FLAG_PIXDATA_DRIVE_POSEDGE:
+	 *
+	 * Data is driven on the rising edge of the pixel clock
+	 */
+	DRM_BUS_FLAG_PIXDATA_DRIVE_POSEDGE = BIT(2),
+
+	/**
+	 * @DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE:
+	 *
+	 * Data is driven on the falling edge of the pixel clock
+	 */
+	DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE = BIT(3),
+
+	/**
+	 * @DRM_BUS_FLAG_PIXDATA_SAMPLE_POSEDGE:
+	 *
+	 * Data is sampled on the rising edge of the pixel clock
+	 */
+	DRM_BUS_FLAG_PIXDATA_SAMPLE_POSEDGE = DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE,
+
+	/**
+	 * @DRM_BUS_FLAG_PIXDATA_SAMPLE_NEGEDGE:
+	 *
+	 * Data is sampled on the falling edge of the pixel clock
+	 */
+	DRM_BUS_FLAG_PIXDATA_SAMPLE_NEGEDGE = DRM_BUS_FLAG_PIXDATA_DRIVE_POSEDGE,
+
+	/**
+	 * @DRM_BUS_FLAG_DATA_MSB_TO_LSB:
+	 *
+	 * Data is transmitted MSB to LSB on the bus
+	 */
+	DRM_BUS_FLAG_DATA_MSB_TO_LSB = BIT(4),
+
+	/**
+	 * @DRM_BUS_FLAG_DATA_LSB_TO_MSB:
+	 *
+	 * Data is transmitted LSB to MSB on the bus
+	 */
+	DRM_BUS_FLAG_DATA_LSB_TO_MSB = BIT(5),
+
+	/**
+	 * @DRM_BUS_FLAG_SYNC_DRIVE_POSEDGE:
+	 *
+	 * Sync signals are driven on the rising edge of the pixel clock
+	 */
+	DRM_BUS_FLAG_SYNC_DRIVE_POSEDGE = BIT(6),
+
+	/**
+	 * @DRM_BUS_FLAG_SYNC_DRIVE_NEGEDGE:
+	 *
+	 * Sync signals are driven on the falling edge of the pixel clock
+	 */
+	DRM_BUS_FLAG_SYNC_DRIVE_NEGEDGE = BIT(7),
+
+	/**
+	 * @DRM_BUS_FLAG_SYNC_SAMPLE_POSEDGE:
+	 *
+	 * Sync signals are sampled on the rising edge of the pixel clock
+	 */
+	DRM_BUS_FLAG_SYNC_SAMPLE_POSEDGE = DRM_BUS_FLAG_SYNC_DRIVE_NEGEDGE,
+
+	/**
+	 * @DRM_BUS_FLAG_SYNC_SAMPLE_NEGEDGE:
+	 *
+	 * Sync signals are sampled on the falling edge of the pixel clock
+	 */
+	DRM_BUS_FLAG_SYNC_SAMPLE_NEGEDGE = DRM_BUS_FLAG_SYNC_DRIVE_POSEDGE,
+
+	/**
+	 * @DRM_BUS_FLAG_SHARP_SIGNALS:
+	 *
+	 *  Set if the Sharp-specific signals (SPL, CLS, PS, REV) must be used
+	 */
+	DRM_BUS_FLAG_SHARP_SIGNALS = BIT(8),
+};
+
+struct rockchip_connector_funcs {
+	/*
+	 * pre init connector, prepare some parameter out_if, this will be
+	 * used by rockchip_display.c and vop
+	 */
+	int (*pre_init)(struct rockchip_connector *connector, struct display_state *state);
+
+	/*
+	 * init connector, prepare resource to ensure
+	 * detect and get_timing can works
+	 */
+	int (*init)(struct rockchip_connector *connector, struct display_state *state);
+
+	void (*deinit)(struct rockchip_connector *connector, struct display_state *state);
+	/*
+	 * Optional, if connector not support hotplug,
+	 * Returns:
+	 *   0 means disconnected, else means connected
+	 */
+	int (*detect)(struct rockchip_connector *connector, struct display_state *state);
+	/*
+	 * Optional, if implement it, need fill the timing data:
+	 *     state->conn_state->mode
+	 * you can refer to the rockchip_display: display_get_timing(),
+	 * Returns:
+	 *   0 means success, else means failed
+	 */
+	int (*get_timing)(struct rockchip_connector *connector, struct display_state *state);
+	/*
+	 * Optional, if implement it, need fill the edid data:
+	 *     state->conn_state->edid
+	 * Returns:
+	 *   0 means success, else means failed
+	 */
+	int (*get_edid)(struct rockchip_connector *connector, struct display_state *state);
+	/*
+	 * call before crtc enable.
+	 */
+	int (*prepare)(struct rockchip_connector *connector, struct display_state *state);
+	/*
+	 * call after crtc enable
+	 */
+	int (*enable)(struct rockchip_connector *connector, struct display_state *state);
+	int (*disable)(struct rockchip_connector *connector, struct display_state *state);
+	void (*unprepare)(struct rockchip_connector *connector, struct display_state *state);
+
+	int (*check)(struct rockchip_connector *connector, struct display_state *state);
+	int (*mode_valid)(struct rockchip_connector *connector, struct display_state *state);
+};
+
+const struct rockchip_connector *
+rockchip_get_connector(const void *blob, int connector_node);
+int rockchip_connector_bind(struct rockchip_connector *connector, struct udevice *dev, int id,
+			    const struct rockchip_connector_funcs *funcs, void *data, int type);
+struct rockchip_connector *get_rockchip_connector_by_device(struct udevice *dev);
+int rockchip_connector_pre_init(struct display_state *state);
+int rockchip_connector_init(struct display_state *state);
+int rockchip_connector_deinit(struct display_state *state);
+bool rockchip_connector_detect(struct display_state *state);
+int rockchip_connector_get_timing(struct display_state *state);
+int rockchip_connector_get_edid(struct display_state *state);
+int rockchip_connector_pre_enable(struct display_state *state);
+int rockchip_connector_enable(struct display_state *state);
+int rockchip_connector_disable(struct display_state *state);
+int rockchip_connector_post_disable(struct display_state *state);
+
+#ifdef CONFIG_DRM_ROCKCHIP_ANALOGIX_DP
+struct rockchip_dp_chip_data;
+extern const struct rockchip_connector_funcs rockchip_analogix_dp_funcs;
+extern const struct rockchip_dp_chip_data rk3399_analogix_edp_drv_data;
+extern const struct rockchip_dp_chip_data rk3368_analogix_edp_drv_data;
+extern const struct rockchip_dp_chip_data rk3288_analogix_dp_drv_data;
+#endif
+#endif
diff --git a/drivers/video/drm/rockchip_crtc.c b/drivers/video/drm/rockchip_crtc.c
new file mode 100644
index 0000000000..c25df7d32b
--- /dev/null
+++ b/drivers/video/drm/rockchip_crtc.c
@@ -0,0 +1,280 @@
+/*
+ * (C) Copyright 2008-2017 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <clk.h>
+#include <config.h>
+#include <common.h>
+#include <errno.h>
+#include <malloc.h>
+#include <asm/unaligned.h>
+#include <linux/list.h>
+#include <dm/device.h>
+#include <dm/device_compat.h>
+#include <dm.h>
+#include <dm/device-internal.h>
+#include <dm/lists.h>
+
+#include "rockchip_display.h"
+#include "rockchip_crtc.h"
+#include "rockchip_connector.h"
+
+#ifndef CONFIG_SPL_BUILD
+static const struct udevice_id rockchip_vp_ids[] = {
+	{ .compatible = "rockchip-vp" },
+	{ }
+};
+
+U_BOOT_DRIVER(rockchip_vp) = {
+	.name		= "rockchip-vp",
+	.id		= UCLASS_VIDEO_CRTC,
+	.of_match	= rockchip_vp_ids,
+};
+
+static const struct rockchip_crtc rk3036_vop_data = {
+	.funcs = &rockchip_vop_funcs,
+	.data = &rk3036_vop,
+};
+
+static const struct rockchip_crtc rv1106_vop_data = {
+	.funcs = &rockchip_vop_funcs,
+	.data = &rv1106_vop,
+};
+
+static const struct rockchip_crtc rv1108_vop_data = {
+	.funcs = &rockchip_vop_funcs,
+	.data = &rv1108_vop,
+};
+
+static const struct rockchip_crtc rv1126_vop_data = {
+	.funcs = &rockchip_vop_funcs,
+	.data = &rv1126_vop,
+};
+
+static const struct rockchip_crtc px30_vop_lit_data = {
+	.funcs = &rockchip_vop_funcs,
+	.data = &px30_vop_lit,
+};
+
+static const struct rockchip_crtc px30_vop_big_data = {
+	.funcs = &rockchip_vop_funcs,
+	.data = &px30_vop_big,
+};
+
+static const struct rockchip_crtc rk3308_vop_data = {
+	.funcs = &rockchip_vop_funcs,
+	.data = &rk3308_vop,
+};
+
+static const struct rockchip_crtc rk1808_vop_data = {
+	.funcs = &rockchip_vop_funcs,
+	.data = &rk1808_vop,
+};
+
+static const struct rockchip_crtc rk3288_vop_big_data = {
+	.funcs = &rockchip_vop_funcs,
+	.data = &rk3288_vop_big,
+};
+
+static const struct rockchip_crtc rk3288_vop_lit_data = {
+	.funcs = &rockchip_vop_funcs,
+	.data = &rk3288_vop_lit,
+};
+
+static const struct rockchip_crtc rk3368_vop_data = {
+	.funcs = &rockchip_vop_funcs,
+	.data = &rk3368_vop,
+};
+
+static const struct rockchip_crtc rk3366_vop_data = {
+	.funcs = &rockchip_vop_funcs,
+	.data = &rk3366_vop,
+};
+
+static const struct rockchip_crtc rk3399_vop_big_data = {
+	.funcs = &rockchip_vop_funcs,
+	.data = &rk3399_vop_big,
+};
+
+static const struct rockchip_crtc rk3399_vop_lit_data = {
+	.funcs = &rockchip_vop_funcs,
+	.data = &rk3399_vop_lit,
+};
+
+static const struct rockchip_crtc rk322x_vop_data = {
+	.funcs = &rockchip_vop_funcs,
+	.data = &rk322x_vop,
+};
+
+static const struct rockchip_crtc rk3328_vop_data = {
+	.funcs = &rockchip_vop_funcs,
+	.data = &rk3328_vop,
+};
+
+static const struct rockchip_crtc rk3528_vop_data = {
+	.funcs = &rockchip_vop2_funcs,
+	.data = &rk3528_vop,
+};
+
+static const struct rockchip_crtc rk3562_vop_data = {
+	.funcs = &rockchip_vop2_funcs,
+	.data = &rk3562_vop,
+};
+
+static const struct rockchip_crtc rk3568_vop_data = {
+	.funcs = &rockchip_vop2_funcs,
+	.data = &rk3568_vop,
+};
+
+static const struct rockchip_crtc rk3588_vop_data = {
+	.funcs = &rockchip_vop2_funcs,
+	.data = &rk3588_vop,
+};
+
+static const struct udevice_id rockchip_vop_ids[] = {
+	{
+		.compatible = "rockchip,rk3036-vop",
+		.data = (ulong)&rk3036_vop_data,
+	}, {
+		.compatible = "rockchip,rv1108-vop",
+		.data = (ulong)&rv1108_vop_data,
+	}, {
+		.compatible = "rockchip,rv1106-vop",
+		.data = (ulong)&rv1106_vop_data,
+	}, {
+		.compatible = "rockchip,rv1126-vop",
+		.data = (ulong)&rv1126_vop_data,
+	}, {
+		.compatible = "rockchip,rk3126-vop",
+		.data = (ulong)&rk3036_vop_data,
+	}, {
+		.compatible = "rockchip,px30-vop-lit",
+		.data = (ulong)&px30_vop_lit_data,
+	}, {
+		.compatible = "rockchip,px30-vop-big",
+		.data = (ulong)&px30_vop_big_data,
+	}, {
+		.compatible = "rockchip,rk3308-vop",
+		.data = (ulong)&rk3308_vop_data,
+	}, {
+		.compatible = "rockchip,rk1808-vop-lit",
+		.data = (ulong)&rk1808_vop_data,
+	}, {
+		.compatible = "rockchip,rk3288-vop-big",
+		.data = (ulong)&rk3288_vop_big_data,
+	}, {
+		.compatible = "rockchip,rk3288-vop-lit",
+		.data = (ulong)&rk3288_vop_lit_data,
+	}, {
+		.compatible = "rockchip,rk3368-vop",
+		.data = (ulong)&rk3368_vop_data,
+	}, {
+		.compatible = "rockchip,rk3366-vop",
+		.data = (ulong)&rk3366_vop_data,
+	}, {
+		.compatible = "rockchip,rk3399-vop-big",
+		.data = (ulong)&rk3399_vop_big_data,
+	}, {
+		.compatible = "rockchip,rk3399-vop-lit",
+		.data = (ulong)&rk3399_vop_lit_data,
+	}, {
+		.compatible = "rockchip,rk322x-vop",
+		.data = (ulong)&rk322x_vop_data,
+	}, {
+		.compatible = "rockchip,rk3328-vop",
+		.data = (ulong)&rk3328_vop_data,
+	}, {
+		.compatible = "rockchip,rk3528-vop",
+		.data = (ulong)&rk3528_vop_data,
+	}, {
+		.compatible = "rockchip,rk3562-vop",
+		.data = (ulong)&rk3562_vop_data,
+	}, {
+		.compatible = "rockchip,rk3568-vop",
+		.data = (ulong)&rk3568_vop_data,
+	}, {
+		.compatible = "rockchip,rk3588-vop",
+		.data = (ulong)&rk3588_vop_data,
+	}, { }
+};
+
+static int rockchip_vop_probe(struct udevice *dev)
+{
+	struct udevice *child;
+	int ret;
+
+	/* Process 'assigned-{clocks/clock-parents/clock-rates}' properties */
+	ret = clk_set_defaults(dev, CLK_DEFAULTS_PRE);
+	if (ret) {
+		dev_err(dev, "%s clk_set_defaults failed %d\n", __func__, ret);
+		return ret;
+	}
+
+	for (device_find_first_child(dev, &child);
+	     child;
+	     device_find_next_child(&child)) {
+		ret = device_probe(child);
+		if (ret)
+			return ret;
+
+		ret = clk_set_defaults(child, CLK_DEFAULTS_PRE);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int rockchip_vop_bind(struct udevice *dev)
+{
+	ofnode ports, node;
+	int ret;
+
+	ports = dev_read_subnode(dev, "ports");
+	if (!ofnode_valid(ports))
+		return 0;
+
+	ofnode_for_each_subnode(node, ports) {
+		const char *name = ofnode_get_name(node);
+
+		ret = device_bind_driver_to_node(dev, "rockchip-vp", name,
+						 node, NULL);
+		if (ret) {
+			dev_err(dev, "unable to bind vp device node: %d\n", ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+U_BOOT_DRIVER(rockchip_vop) = {
+	.name	= "rockchip-vop",
+	.id	= UCLASS_VIDEO_CRTC,
+	.of_match = rockchip_vop_ids,
+	.bind	= rockchip_vop_bind,
+	.probe	= rockchip_vop_probe,
+};
+
+UCLASS_DRIVER(rockchip_crtc) = {
+	.id		= UCLASS_VIDEO_CRTC,
+	.name		= "CRTC",
+};
+
+#else
+static struct rockchip_crtc rk3528_vop_data = {
+	.funcs = &rockchip_vop2_funcs,
+	.data = &rk3528_vop,
+};
+
+int rockchip_spl_vop_probe(struct crtc_state *crtc_state)
+{
+
+	crtc_state->crtc = &rk3528_vop_data;
+
+	return 0;
+}
+#endif
+
diff --git a/drivers/video/drm/rockchip_crtc.h b/drivers/video/drm/rockchip_crtc.h
new file mode 100644
index 0000000000..1078f8c9d7
--- /dev/null
+++ b/drivers/video/drm/rockchip_crtc.h
@@ -0,0 +1,78 @@
+/*
+ * (C) Copyright 2008-2017 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _ROCKCHIP_CRTC_H_
+#define _ROCKCHIP_CRTC_H_
+
+#define VOP2_MAX_VP				4
+
+struct rockchip_vp {
+	bool enable;
+	bool xmirror_en;
+	u8 bg_ovl_dly;
+	u8 primary_plane_id;
+	int output_type;
+	u32 plane_mask;
+	int cursor_plane;
+};
+
+struct rockchip_crtc {
+	const struct rockchip_crtc_funcs *funcs;
+	const void *data;
+	struct drm_display_mode active_mode;
+	struct rockchip_vp vps[4];
+	bool hdmi_hpd : 1;
+	bool active : 1;
+	bool assign_plane : 1;
+	bool splice_mode : 1;
+	u8 splice_crtc_id;
+};
+
+struct rockchip_crtc_funcs {
+	int (*preinit)(struct display_state *state);
+	int (*init)(struct display_state *state);
+	void (*deinit)(struct display_state *state);
+	int (*set_plane)(struct display_state *state);
+	int (*prepare)(struct display_state *state);
+	int (*enable)(struct display_state *state);
+	int (*disable)(struct display_state *state);
+	void (*unprepare)(struct display_state *state);
+	int (*fixup_dts)(struct display_state *state, void *blob);
+	int (*send_mcu_cmd)(struct display_state *state, u32 type, u32 value);
+	int (*check)(struct display_state *state);
+	int (*mode_valid)(struct display_state *state);
+	int (*mode_fixup)(struct display_state *state);
+	int (*plane_check)(struct display_state *state);
+	int (*regs_dump)(struct display_state *state);
+	int (*active_regs_dump)(struct display_state *state);
+	int (*apply_soft_te)(struct display_state *state);
+};
+
+struct vop_data;
+struct vop2_data;
+extern const struct rockchip_crtc_funcs rockchip_vop_funcs;
+extern const struct rockchip_crtc_funcs rockchip_vop2_funcs;
+extern const struct vop_data rk3036_vop;
+extern const struct vop_data px30_vop_lit;
+extern const struct vop_data px30_vop_big;
+extern const struct vop_data rk3308_vop;
+extern const struct vop_data rk1808_vop;
+extern const struct vop_data rk3288_vop_big;
+extern const struct vop_data rk3288_vop_lit;
+extern const struct vop_data rk3368_vop;
+extern const struct vop_data rk3366_vop;
+extern const struct vop_data rk3399_vop_big;
+extern const struct vop_data rk3399_vop_lit;
+extern const struct vop_data rk322x_vop;
+extern const struct vop_data rk3328_vop;
+extern const struct vop_data rv1106_vop;
+extern const struct vop_data rv1108_vop;
+extern const struct vop_data rv1126_vop;
+extern const struct vop2_data rk3528_vop;
+extern const struct vop2_data rk3562_vop;
+extern const struct vop2_data rk3568_vop;
+extern const struct vop2_data rk3588_vop;
+#endif
diff --git a/drivers/video/drm/rockchip_display.c b/drivers/video/drm/rockchip_display.c
new file mode 100644
index 0000000000..7715e0f371
--- /dev/null
+++ b/drivers/video/drm/rockchip_display.c
@@ -0,0 +1,2135 @@
+/*
+ * (C) Copyright 2008-2017 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/unaligned.h>
+#include <config.h>
+#include <common.h>
+#include <command.h>
+#include <errno.h>
+#include <linux/libfdt.h>
+#include <fdtdec.h>
+#include <fdt_support.h>
+#include <linux/hdmi.h>
+#include <linux/list.h>
+#include <linux/compat.h>
+#include <linux/media-bus-format.h>
+#include <malloc.h>
+#include <video.h>
+#include <video_rockchip.h>
+#include <video_bridge.h>
+#include <dm/device.h>
+#include <dm/uclass-internal.h>
+#include <asm/arch-rockchip/cpu.h>
+#include <asm/cache.h>
+
+#include "bmp_helper.h"
+#include "libnsbmp.h"
+#include "rockchip_display.h"
+#include "rockchip_crtc.h"
+#include "rockchip_connector.h"
+#include "rockchip_bridge.h"
+#include "rockchip_phy.h"
+#include "rockchip_panel.h"
+#include <dm.h>
+#include <dm/of_access.h>
+#include <dm/ofnode.h>
+#include <asm/io.h>
+
+#define DRIVER_VERSION	"v1.0.1"
+
+/***********************************************************************
+ *  Rockchip UBOOT DRM driver version
+ *
+ *  v1.0.0	: add basic version for rockchip drm driver(hjc)
+ *  v1.0.1	: add much dsi update(hjc)
+ *
+ **********************************************************************/
+
+#define RK_BLK_SIZE 512
+#define BMP_PROCESSED_FLAG 8399
+#define BYTES_PER_PIXEL sizeof(uint32_t)
+#define MAX_IMAGE_BYTES (8 * 1024 * 1024)
+
+DECLARE_GLOBAL_DATA_PTR;
+static LIST_HEAD(rockchip_display_list);
+static LIST_HEAD(logo_cache_list);
+
+static unsigned long memory_start;
+static unsigned long cubic_lut_memory_start;
+static unsigned long memory_end;
+static struct base2_info base_parameter;
+static u32 align_size = PAGE_SIZE;
+
+/*
+ * the phy types are used by different connectors in public.
+ * The current version only has inno hdmi phy for hdmi and tve.
+ */
+enum public_use_phy {
+	NONE,
+	INNO_HDMI_PHY
+};
+
+/* save public phy data */
+struct public_phy_data {
+	const struct rockchip_phy *phy_drv;
+	int phy_node;
+	int public_phy_type;
+	bool phy_init;
+};
+
+char* rockchip_get_output_if_name(u32 output_if, char *name)
+{
+	if (output_if & VOP_OUTPUT_IF_RGB)
+		strcat(name, " RGB");
+	if (output_if & VOP_OUTPUT_IF_BT1120)
+		strcat(name, " BT1120");
+	if (output_if & VOP_OUTPUT_IF_BT656)
+		strcat(name, " BT656");
+	if (output_if & VOP_OUTPUT_IF_LVDS0)
+		strcat(name, " LVDS0");
+	if (output_if & VOP_OUTPUT_IF_LVDS1)
+		strcat(name, " LVDS1");
+	if (output_if & VOP_OUTPUT_IF_MIPI0)
+		strcat(name, " MIPI0");
+	if (output_if & VOP_OUTPUT_IF_MIPI1)
+		strcat(name, " MIPI1");
+	if (output_if & VOP_OUTPUT_IF_eDP0)
+		strcat(name, " eDP0");
+	if (output_if & VOP_OUTPUT_IF_eDP1)
+		strcat(name, " eDP1");
+	if (output_if & VOP_OUTPUT_IF_DP0)
+		strcat(name, " DP0");
+	if (output_if & VOP_OUTPUT_IF_DP1)
+		strcat(name, " DP1");
+	if (output_if & VOP_OUTPUT_IF_HDMI0)
+		strcat(name, " HDMI0");
+	if (output_if & VOP_OUTPUT_IF_HDMI1)
+		strcat(name, " HDMI1");
+
+	return name;
+}
+
+u32 rockchip_drm_get_cycles_per_pixel(u32 bus_format)
+{
+	switch (bus_format) {
+	case MEDIA_BUS_FMT_RGB565_1X16:
+	case MEDIA_BUS_FMT_RGB666_1X18:
+	case MEDIA_BUS_FMT_RGB888_1X24:
+	case MEDIA_BUS_FMT_RGB666_1X24_CPADHI:
+		return 1;
+	case MEDIA_BUS_FMT_RGB565_2X8_LE:
+	case MEDIA_BUS_FMT_BGR565_2X8_LE:
+		return 2;
+	case MEDIA_BUS_FMT_RGB666_3X6:
+	case MEDIA_BUS_FMT_RGB888_3X8:
+	case MEDIA_BUS_FMT_BGR888_3X8:
+		return 3;
+	case MEDIA_BUS_FMT_RGB888_DUMMY_4X8:
+	case MEDIA_BUS_FMT_BGR888_DUMMY_4X8:
+		return 4;
+	default:
+		return 1;
+	}
+}
+
+struct base2_disp_info *rockchip_get_disp_info(int type, int id)
+{
+	struct base2_disp_info *disp_info;
+	struct base2_disp_header *disp_header;
+	int i = 0, offset = -1;
+	u32 crc_val;
+	u32 base2_length;
+	void *base_parameter_addr = (void *)&base_parameter;
+
+	for (i = 0; i < 8; i++) {
+		disp_header = &base_parameter.disp_header[i];
+		if (disp_header->connector_type == type &&
+		    disp_header->connector_id == id) {
+			printf("disp info %d, type:%d, id:%d\n", i, type, id);
+			offset = disp_header->offset;
+			break;
+		}
+	}
+
+	if (offset < 0)
+		return NULL;
+	disp_info = base_parameter_addr + offset;
+	if (disp_info->screen_info[0].type != type ||
+	    disp_info->screen_info[0].id != id) {
+		printf("base2_disp_info couldn't be found, screen_info type[%d] or id[%d] mismatched\n",
+		       disp_info->screen_info[0].type,
+		       disp_info->screen_info[0].id);
+		return NULL;
+	}
+
+	if (strncasecmp(disp_info->disp_head_flag, "DISP", 4))
+		return NULL;
+
+	if (base_parameter.major_version == 3 && base_parameter.minor_version == 0) {
+		crc_val = rockchip_display_crc32c_cal((unsigned char *)disp_info,
+						      sizeof(struct base2_disp_info) - 4);
+		if (crc_val != disp_info->crc2) {
+			printf("error: connector type[%d], id[%d] disp info crc2 check error\n",
+			       type, id);
+			return NULL;
+		}
+	} else {
+		base2_length = sizeof(struct base2_disp_info) - sizeof(struct csc_info) -
+			       sizeof(struct acm_data) - 10 * 1024 - 4;
+		crc_val = rockchip_display_crc32c_cal((unsigned char *)disp_info, base2_length - 4);
+		if (crc_val != disp_info->crc) {
+			printf("error: connector type[%d], id[%d] disp info crc check error\n",
+			       type, id);
+			return NULL;
+		}
+	}
+
+	return disp_info;
+}
+
+/* check which kind of public phy does connector use */
+static int check_public_use_phy(struct rockchip_connector *conn)
+{
+	int ret = NONE;
+#ifdef CONFIG_ROCKCHIP_INNO_HDMI_PHY
+
+	if (!strncmp(dev_read_name(conn->dev), "tve", 3) ||
+	    !strncmp(dev_read_name(conn->dev), "hdmi", 4))
+		ret = INNO_HDMI_PHY;
+#endif
+
+	return ret;
+}
+
+/*
+ * get public phy driver and initialize it.
+ * The current version only has inno hdmi phy for hdmi and tve.
+ */
+static int get_public_phy(struct rockchip_connector *conn,
+			  struct public_phy_data *data)
+{
+	struct rockchip_phy *phy;
+	struct udevice *dev;
+	int ret = 0;
+
+	switch (data->public_phy_type) {
+	case INNO_HDMI_PHY:
+#if defined(CONFIG_ROCKCHIP_RK3328)
+		ret = uclass_get_device_by_name(UCLASS_PHY,
+						"hdmiphy@ff430000", &dev);
+#elif defined(CONFIG_ROCKCHIP_RK322X)
+		ret = uclass_get_device_by_name(UCLASS_PHY,
+						"hdmi-phy@12030000", &dev);
+#else
+		ret = -EINVAL;
+#endif
+		if (ret) {
+			printf("Warn: can't find phy driver\n");
+			return 0;
+		}
+
+		phy = (struct rockchip_phy *)dev_get_driver_data(dev);
+		if (!phy) {
+			printf("failed to get phy driver\n");
+			return 0;
+		}
+
+		ret = rockchip_phy_init(phy);
+		if (ret) {
+			printf("failed to init phy driver\n");
+			return ret;
+		}
+		conn->phy = phy;
+
+		debug("inno hdmi phy init success, save it\n");
+		data->phy_drv = conn->phy;
+		data->phy_init = true;
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+static void init_display_buffer(ulong base)
+{
+	memory_start = ALIGN(base + DRM_ROCKCHIP_FB_SIZE, align_size);
+	memory_end = memory_start;
+	cubic_lut_memory_start = ALIGN(memory_start + MEMORY_POOL_SIZE, align_size);
+}
+
+void *get_display_buffer(int size)
+{
+	unsigned long roundup_memory = roundup(memory_end, PAGE_SIZE);
+	void *buf;
+
+	if (roundup_memory + size > memory_start + MEMORY_POOL_SIZE) {
+		printf("failed to alloc %dbyte memory to display\n", size);
+		return NULL;
+	}
+	buf = (void *)roundup_memory;
+
+	memory_end = roundup_memory + size;
+
+	return buf;
+}
+
+static unsigned long get_single_cubic_lut_size(void)
+{
+	ulong cubic_lut_size;
+	int cubic_lut_step = CONFIG_ROCKCHIP_CUBIC_LUT_SIZE;
+
+	/* This is depend on IC designed */
+	cubic_lut_size = (cubic_lut_step * cubic_lut_step * cubic_lut_step + 1) / 2 * 16;
+	cubic_lut_size = roundup(cubic_lut_size, PAGE_SIZE);
+
+	return cubic_lut_size;
+}
+
+unsigned long get_cubic_lut_buffer(int crtc_id)
+{
+	return cubic_lut_memory_start + crtc_id * get_single_cubic_lut_size();
+}
+
+bool can_direct_logo(int bpp)
+{
+	return bpp == 16 || bpp == 32;
+}
+
+static int connector_phy_init(struct rockchip_connector *conn,
+			      struct public_phy_data *data)
+{
+	int type;
+
+	/* does this connector use public phy with others */
+	type = check_public_use_phy(conn);
+	if (type == INNO_HDMI_PHY) {
+		/* there is no public phy was initialized */
+		if (!data->phy_init) {
+			debug("start get public phy\n");
+			data->public_phy_type = type;
+			if (get_public_phy(conn, data)) {
+				printf("can't find correct public phy type\n");
+				free(data);
+				return -EINVAL;
+			}
+			return 0;
+		}
+
+		/* if this phy has been initialized, get it directly */
+		conn->phy = (struct rockchip_phy *)data->phy_drv;
+		return 0;
+	}
+
+	return 0;
+}
+
+int rockchip_ofnode_get_display_mode(ofnode node, struct drm_display_mode *mode, u32 *bus_flags)
+{
+	int hactive, vactive, pixelclock;
+	int hfront_porch, hback_porch, hsync_len;
+	int vfront_porch, vback_porch, vsync_len;
+	int val, flags = 0;
+
+#define FDT_GET_BOOL(val, name) \
+	val = ofnode_read_bool(node, name);
+
+#define FDT_GET_INT(val, name) \
+	val = ofnode_read_s32_default(node, name, -1); \
+	if (val < 0) { \
+		printf("Can't get %s\n", name); \
+		return -ENXIO; \
+	}
+
+#define FDT_GET_INT_DEFAULT(val, name, default) \
+	val = ofnode_read_s32_default(node, name, default);
+
+	FDT_GET_INT(hactive, "hactive");
+	FDT_GET_INT(vactive, "vactive");
+	FDT_GET_INT(pixelclock, "clock-frequency");
+	FDT_GET_INT(hsync_len, "hsync-len");
+	FDT_GET_INT(hfront_porch, "hfront-porch");
+	FDT_GET_INT(hback_porch, "hback-porch");
+	FDT_GET_INT(vsync_len, "vsync-len");
+	FDT_GET_INT(vfront_porch, "vfront-porch");
+	FDT_GET_INT(vback_porch, "vback-porch");
+	FDT_GET_INT(val, "hsync-active");
+	flags |= val ? DRM_MODE_FLAG_PHSYNC : DRM_MODE_FLAG_NHSYNC;
+	FDT_GET_INT(val, "vsync-active");
+	flags |= val ? DRM_MODE_FLAG_PVSYNC : DRM_MODE_FLAG_NVSYNC;
+
+	FDT_GET_BOOL(val, "interlaced");
+	flags |= val ? DRM_MODE_FLAG_INTERLACE : 0;
+	FDT_GET_BOOL(val, "doublescan");
+	flags |= val ? DRM_MODE_FLAG_DBLSCAN : 0;
+	FDT_GET_BOOL(val, "doubleclk");
+	flags |= val ? DISPLAY_FLAGS_DOUBLECLK : 0;
+
+	FDT_GET_INT(val, "de-active");
+	*bus_flags |= val ? DRM_BUS_FLAG_DE_HIGH : DRM_BUS_FLAG_DE_LOW;
+	FDT_GET_INT(val, "pixelclk-active");
+	*bus_flags |= val ? DRM_BUS_FLAG_PIXDATA_DRIVE_POSEDGE : DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE;
+
+	FDT_GET_INT_DEFAULT(val, "screen-rotate", 0);
+	if (val == DRM_MODE_FLAG_XMIRROR) {
+		flags |= DRM_MODE_FLAG_XMIRROR;
+	} else if (val == DRM_MODE_FLAG_YMIRROR) {
+		flags |= DRM_MODE_FLAG_YMIRROR;
+	} else if (val == DRM_MODE_FLAG_XYMIRROR) {
+		flags |= DRM_MODE_FLAG_XMIRROR;
+		flags |= DRM_MODE_FLAG_YMIRROR;
+	}
+	mode->hdisplay = hactive;
+	mode->hsync_start = mode->hdisplay + hfront_porch;
+	mode->hsync_end = mode->hsync_start + hsync_len;
+	mode->htotal = mode->hsync_end + hback_porch;
+
+	mode->vdisplay = vactive;
+	mode->vsync_start = mode->vdisplay + vfront_porch;
+	mode->vsync_end = mode->vsync_start + vsync_len;
+	mode->vtotal = mode->vsync_end + vback_porch;
+
+	mode->clock = pixelclock / 1000;
+	mode->flags = flags;
+	mode->vrefresh = drm_mode_vrefresh(mode);
+
+	return 0;
+}
+
+static int display_get_force_timing_from_dts(ofnode node,
+					     struct drm_display_mode *mode,
+					     u32 *bus_flags)
+{
+	int ret = 0;
+
+	ret = rockchip_ofnode_get_display_mode(node, mode, bus_flags);
+
+	if (ret) {
+		mode->clock = 74250;
+		mode->flags = 0x5;
+		mode->hdisplay = 1280;
+		mode->hsync_start = 1390;
+		mode->hsync_end = 1430;
+		mode->htotal = 1650;
+		mode->hskew = 0;
+		mode->vdisplay = 720;
+		mode->vsync_start = 725;
+		mode->vsync_end = 730;
+		mode->vtotal = 750;
+		mode->vrefresh = 60;
+		mode->picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9;
+		mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	}
+
+	printf("route node %s force_timing, use %dx%dp%d as default mode\n",
+	       ret ? "undefine" : "define", mode->hdisplay, mode->vdisplay,
+	       mode->vscan);
+
+	return 0;
+}
+
+static int display_get_timing_from_dts(struct rockchip_panel *panel,
+				       struct drm_display_mode *mode,
+				       u32 *bus_flags)
+{
+	struct ofnode_phandle_args args;
+	ofnode dt, timing, mcu_panel;
+	int ret;
+
+	mcu_panel = dev_read_subnode(panel->dev, "mcu-panel");
+	dt = dev_read_subnode(panel->dev, "display-timings");
+	if (ofnode_valid(dt)) {
+		ret = ofnode_parse_phandle_with_args(dt, "native-mode", NULL,
+						     0, 0, &args);
+		if (ret)
+			return ret;
+
+		timing = args.node;
+	} else if (ofnode_valid(mcu_panel)) {
+		dt = ofnode_find_subnode(mcu_panel, "display-timings");
+		ret = ofnode_parse_phandle_with_args(dt, "native-mode", NULL,
+						     0, 0, &args);
+		if (ret)
+			return ret;
+
+		timing = args.node;
+	} else {
+		timing = dev_read_subnode(panel->dev, "panel-timing");
+	}
+
+	if (!ofnode_valid(timing)) {
+		printf("failed to get display timings from DT\n");
+		return -ENXIO;
+	}
+
+	rockchip_ofnode_get_display_mode(timing, mode, bus_flags);
+
+	if (IS_ENABLED(CONFIG_ROCKCHIP_RK3568) || IS_ENABLED(CONFIG_ROCKCHIP_RK3588)) {
+		if (mode->hdisplay % 4) {
+			int old_hdisplay = mode->hdisplay;
+			int align = 4 - (mode->hdisplay % 4);
+
+			mode->hdisplay += align;
+			mode->hsync_start += align;
+			mode->hsync_end += align;
+			mode->htotal += align;
+
+			ofnode_write_u32_array(timing, "hactive", (u32 *)&mode->hdisplay, 1);
+
+			printf("WARN: hactive need to be aligned with 4-pixel, %d -> %d\n",
+				old_hdisplay, mode->hdisplay);
+		}
+	}
+
+	return 0;
+}
+
+static int display_get_timing(struct display_state *state)
+{
+	struct connector_state *conn_state = &state->conn_state;
+	struct drm_display_mode *mode = &conn_state->mode;
+	const struct drm_display_mode *m;
+	struct rockchip_panel *panel = conn_state->connector->panel;
+
+	if (panel->funcs->get_mode)
+		return panel->funcs->get_mode(panel, mode);
+
+	if (dev_has_ofnode(panel->dev) &&
+	    !display_get_timing_from_dts(panel, mode, &conn_state->bus_flags)) {
+		printf("Using display timing dts\n");
+		return 0;
+	}
+
+	if (panel->data) {
+		m = (const struct drm_display_mode *)panel->data;
+		memcpy(mode, m, sizeof(*m));
+		printf("Using display timing from compatible panel driver\n");
+		return 0;
+	}
+
+	return -ENODEV;
+}
+
+static int display_pre_init(void)
+{
+	struct display_state *state;
+	int ret = 0;
+
+	list_for_each_entry(state, &rockchip_display_list, head) {
+		struct connector_state *conn_state = &state->conn_state;
+		struct crtc_state *crtc_state = &state->crtc_state;
+		struct rockchip_crtc *crtc = crtc_state->crtc;
+
+		ret = rockchip_connector_pre_init(state);
+		if (ret)
+			printf("pre init conn error\n");
+
+		crtc->vps[crtc_state->crtc_id].output_type = conn_state->type;
+	}
+	return ret;
+}
+
+static int display_use_force_mode(struct display_state *state)
+{
+	struct connector_state *conn_state = &state->conn_state;
+	struct drm_display_mode *mode = &conn_state->mode;
+
+	conn_state->bpc = 8;
+	memcpy(mode, &state->force_mode, sizeof(struct drm_display_mode));
+	conn_state->bus_format = state->force_bus_format;
+
+	return 0;
+}
+
+static int display_get_edid_mode(struct display_state *state)
+{
+	int ret = 0;
+	struct connector_state *conn_state = &state->conn_state;
+	struct drm_display_mode *mode = &conn_state->mode;
+	int bpc;
+
+	ret = edid_get_drm_mode(conn_state->edid, sizeof(conn_state->edid), mode, &bpc);
+	if (!ret) {
+		conn_state->bpc = bpc;
+		edid_print_info((void *)&conn_state->edid);
+	} else {
+		conn_state->bpc = 8;
+		mode->clock = 74250;
+		mode->flags = 0x5;
+		mode->hdisplay = 1280;
+		mode->hsync_start = 1390;
+		mode->hsync_end = 1430;
+		mode->htotal = 1650;
+		mode->hskew = 0;
+		mode->vdisplay = 720;
+		mode->vsync_start = 725;
+		mode->vsync_end = 730;
+		mode->vtotal = 750;
+		mode->vrefresh = 60;
+		mode->picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9;
+		mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+
+		printf("error: %s get mode from edid failed, use 720p60 as default mode\n",
+		       state->conn_state.connector->dev->name);
+	}
+
+	return ret;
+}
+
+static int display_mode_valid(struct display_state *state)
+{
+	struct connector_state *conn_state = &state->conn_state;
+	struct rockchip_connector *conn = conn_state->connector;
+	const struct rockchip_connector_funcs *conn_funcs = conn->funcs;
+	struct crtc_state *crtc_state = &state->crtc_state;
+	const struct rockchip_crtc *crtc = crtc_state->crtc;
+	const struct rockchip_crtc_funcs *crtc_funcs = crtc->funcs;
+	int ret;
+
+	if (conn_funcs->mode_valid && state->enabled_at_spl == false) {
+		ret = conn_funcs->mode_valid(conn, state);
+		if (ret)
+			return ret;
+	}
+
+	if (crtc_funcs->mode_valid) {
+		ret = crtc_funcs->mode_valid(state);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int display_mode_fixup(struct display_state *state)
+{
+	struct crtc_state *crtc_state = &state->crtc_state;
+	const struct rockchip_crtc *crtc = crtc_state->crtc;
+	const struct rockchip_crtc_funcs *crtc_funcs = crtc->funcs;
+	int ret;
+
+	if (crtc_funcs->mode_fixup) {
+		ret = crtc_funcs->mode_fixup(state);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int display_init(struct display_state *state)
+{
+	struct connector_state *conn_state = &state->conn_state;
+	struct rockchip_connector *conn = conn_state->connector;
+	struct crtc_state *crtc_state = &state->crtc_state;
+	struct rockchip_crtc *crtc = crtc_state->crtc;
+	const struct rockchip_crtc_funcs *crtc_funcs = crtc->funcs;
+	struct drm_display_mode *mode = &conn_state->mode;
+	const char *compatible;
+	int ret = 0;
+	static bool __print_once = false;
+#ifdef CONFIG_SPL_BUILD
+	struct spl_display_info *spl_disp_info = (struct spl_display_info *)CONFIG_SPL_VIDEO_BUF;
+#endif
+	if (!__print_once) {
+		__print_once = true;
+		printf("Rockchip UBOOT DRM driver version: %s\n", DRIVER_VERSION);
+	}
+
+	if (state->is_init)
+		return 0;
+
+	if (!crtc_funcs) {
+		printf("failed to find crtc functions\n");
+		return -ENXIO;
+	}
+
+#ifdef CONFIG_SPL_BUILD
+	if (state->conn_state.type == DRM_MODE_CONNECTOR_HDMIA)
+		state->enabled_at_spl = spl_disp_info->enabled == 1 ? true : false;
+	if (state->enabled_at_spl)
+		printf("HDMI enabled at SPL\n");
+#endif
+	if (crtc_state->crtc->active && !crtc_state->ports_node &&
+	    memcmp(&crtc_state->crtc->active_mode, &conn_state->mode,
+		   sizeof(struct drm_display_mode))) {
+		printf("%s has been used for output type: %d, mode: %dx%dp%d\n",
+			crtc_state->dev->name,
+			crtc_state->crtc->active_mode.type,
+			crtc_state->crtc->active_mode.hdisplay,
+			crtc_state->crtc->active_mode.vdisplay,
+			crtc_state->crtc->active_mode.vrefresh);
+		return -ENODEV;
+	}
+
+	if (crtc_funcs->preinit) {
+		ret = crtc_funcs->preinit(state);
+		if (ret)
+			return ret;
+	}
+
+	if (state->enabled_at_spl == false) {
+		printf("going to init connector\n");
+		ret = rockchip_connector_init(state);
+		if (ret)
+			goto deinit;
+	}
+
+	/*
+	 * support hotplug, but not connect;
+	 */
+#ifdef CONFIG_DRM_ROCKCHIP_TVE
+	if (crtc->hdmi_hpd && conn_state->type == DRM_MODE_CONNECTOR_TV) {
+		printf("hdmi plugin ,skip tve\n");
+		goto deinit;
+	}
+#elif defined(CONFIG_DRM_ROCKCHIP_RK1000)
+	if (crtc->hdmi_hpd && conn_state->type == DRM_MODE_CONNECTOR_LVDS) {
+		printf("hdmi plugin ,skip tve\n");
+		goto deinit;
+	}
+#endif
+
+	printf("going to detect connector\n");
+	ret = rockchip_connector_detect(state);
+#if defined(CONFIG_DRM_ROCKCHIP_TVE) || defined(CONFIG_DRM_ROCKCHIP_RK1000)
+	if (conn_state->type == DRM_MODE_CONNECTOR_HDMIA)
+		crtc->hdmi_hpd = ret;
+	if (state->enabled_at_spl)
+		crtc->hdmi_hpd = true;
+#endif
+	if (!ret && !state->force_output)
+		goto deinit;
+
+	ret = 0;
+	if (state->enabled_at_spl == true) {
+#ifdef CONFIG_SPL_BUILD
+		struct drm_display_mode *mode = &conn_state->mode;
+
+		memcpy(mode, &spl_disp_info->mode,  sizeof(*mode));
+		conn_state->bus_format = spl_disp_info->bus_format;
+
+		printf("%s get display mode from spl:%dx%d, bus format:0x%x\n",
+			conn->dev->name, mode->hdisplay, mode->vdisplay, conn_state->bus_format);
+#endif
+	} else if (conn->panel) {
+		ret = display_get_timing(state);
+		if (!ret)
+			conn_state->bpc = conn->panel->bpc;
+#if defined(CONFIG_I2C_EDID)
+		if (ret < 0 && conn->funcs->get_edid) {
+			rockchip_panel_prepare(conn->panel);
+			ret = conn->funcs->get_edid(conn, state);
+			if (!ret)
+				display_get_edid_mode(state);
+		}
+#endif
+	} else if (conn->bridge) {
+		ret = video_bridge_read_edid(conn->bridge->dev,
+					     conn_state->edid, EDID_SIZE);
+		if (ret > 0) {
+#if defined(CONFIG_I2C_EDID)
+			display_get_edid_mode(state);
+#endif
+		} else {
+			ret = video_bridge_get_timing(conn->bridge->dev);
+		}
+	} else if (conn->funcs->get_timing) {
+		ret = conn->funcs->get_timing(conn, state);
+	} else if (conn->funcs->get_edid) {
+		ret = conn->funcs->get_edid(conn, state);
+#if defined(CONFIG_I2C_EDID)
+		if (!ret)
+			display_get_edid_mode(state);
+#endif
+	}
+	printf("readed edid\n");
+	if (!ret && conn_state->secondary) {
+		struct rockchip_connector *connector = conn_state->secondary;
+
+		if (connector->panel) {
+			if (connector->panel->funcs->get_mode) {
+				struct drm_display_mode *_mode = drm_mode_create();
+
+				ret = connector->panel->funcs->get_mode(connector->panel, _mode);
+				if (!ret && !drm_mode_equal(_mode, mode))
+					ret = -EINVAL;
+
+				drm_mode_destroy(_mode);
+			}
+		}
+	}
+
+	if (ret && !state->force_output)
+		goto deinit;
+	if (state->force_output)
+		display_use_force_mode(state);
+
+	if (display_mode_valid(state))
+		goto deinit;
+
+	/* rk356x series drive mipi pixdata on posedge */
+	compatible = dev_read_string(conn->dev, "compatible");
+	if (!strcmp(compatible, "rockchip,rk3568-mipi-dsi")) {
+		conn_state->bus_flags &= ~DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE;
+		conn_state->bus_flags |= DRM_BUS_FLAG_PIXDATA_DRIVE_POSEDGE;
+	}
+
+	printf("%s: %s detailed mode clock %u kHz, flags[%x]\n"
+	       "    H: %04d %04d %04d %04d\n"
+	       "    V: %04d %04d %04d %04d\n"
+	       "bus_format: %x\n",
+	       conn->dev->name,
+	       state->force_output ? "use force output" : "",
+	       mode->clock, mode->flags,
+	       mode->hdisplay, mode->hsync_start,
+	       mode->hsync_end, mode->htotal,
+	       mode->vdisplay, mode->vsync_start,
+	       mode->vsync_end, mode->vtotal,
+	       conn_state->bus_format);
+
+	if (display_mode_fixup(state))
+		goto deinit;
+
+	if (conn->bridge)
+		rockchip_bridge_mode_set(conn->bridge, &conn_state->mode);
+
+	if (crtc_funcs->init && state->enabled_at_spl == false) {
+		ret = crtc_funcs->init(state);
+		if (ret)
+			goto deinit;
+	}
+	state->is_init = 1;
+
+	crtc_state->crtc->active = true;
+	memcpy(&crtc_state->crtc->active_mode,
+	       &conn_state->mode, sizeof(struct drm_display_mode));
+
+	return 0;
+
+deinit:
+	rockchip_connector_deinit(state);
+	return ret;
+}
+
+int display_send_mcu_cmd(struct display_state *state, u32 type, u32 val)
+{
+	struct crtc_state *crtc_state = &state->crtc_state;
+	const struct rockchip_crtc *crtc = crtc_state->crtc;
+	const struct rockchip_crtc_funcs *crtc_funcs = crtc->funcs;
+	int ret;
+
+	if (!state->is_init)
+		return -EINVAL;
+
+	if (crtc_funcs->send_mcu_cmd) {
+		ret = crtc_funcs->send_mcu_cmd(state, type, val);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int display_set_plane(struct display_state *state)
+{
+	struct crtc_state *crtc_state = &state->crtc_state;
+	const struct rockchip_crtc *crtc = crtc_state->crtc;
+	const struct rockchip_crtc_funcs *crtc_funcs = crtc->funcs;
+	int ret;
+
+	if (!state->is_init)
+		return -EINVAL;
+
+	if (crtc_funcs->set_plane) {
+		ret = crtc_funcs->set_plane(state);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int display_enable(struct display_state *state)
+{
+	struct crtc_state *crtc_state = &state->crtc_state;
+	const struct rockchip_crtc *crtc = crtc_state->crtc;
+	const struct rockchip_crtc_funcs *crtc_funcs = crtc->funcs;
+
+	if (!state->is_init)
+		return -EINVAL;
+
+	if (state->is_enable)
+		return 0;
+
+	if (crtc_funcs->prepare)
+		crtc_funcs->prepare(state);
+
+	if (state->enabled_at_spl == false)
+		rockchip_connector_pre_enable(state);
+
+	if (crtc_funcs->enable)
+		crtc_funcs->enable(state);
+
+	if (state->enabled_at_spl == false)
+		rockchip_connector_enable(state);
+
+	if (crtc_state->soft_te)
+		crtc_funcs->apply_soft_te(state);
+
+	state->is_enable = true;
+
+	return 0;
+}
+
+static int display_disable(struct display_state *state)
+{
+	struct crtc_state *crtc_state = &state->crtc_state;
+	const struct rockchip_crtc *crtc = crtc_state->crtc;
+	const struct rockchip_crtc_funcs *crtc_funcs = crtc->funcs;
+
+	if (!state->is_init)
+		return 0;
+
+	if (!state->is_enable)
+		return 0;
+
+	rockchip_connector_disable(state);
+
+	if (crtc_funcs->disable)
+		crtc_funcs->disable(state);
+
+	rockchip_connector_post_disable(state);
+
+	state->is_enable = 0;
+	state->is_init = 0;
+
+	return 0;
+}
+
+static int display_check(struct display_state *state)
+{
+	struct connector_state *conn_state = &state->conn_state;
+	struct rockchip_connector *conn = conn_state->connector;
+	const struct rockchip_connector_funcs *conn_funcs = conn->funcs;
+	struct crtc_state *crtc_state = &state->crtc_state;
+	const struct rockchip_crtc *crtc = crtc_state->crtc;
+	const struct rockchip_crtc_funcs *crtc_funcs = crtc->funcs;
+	int ret;
+
+	if (!state->is_init)
+		return 0;
+
+	if (conn_funcs->check) {
+		ret = conn_funcs->check(conn, state);
+		if (ret)
+			goto check_fail;
+	}
+
+	if (crtc_funcs->check) {
+		ret = crtc_funcs->check(state);
+		if (ret)
+			goto check_fail;
+	}
+
+	if (crtc_funcs->plane_check) {
+		ret = crtc_funcs->plane_check(state);
+		if (ret)
+			goto check_fail;
+	}
+
+	return 0;
+
+check_fail:
+	state->is_init = false;
+	return ret;
+}
+
+static int display_logo(struct display_state *state)
+{
+	struct crtc_state *crtc_state = &state->crtc_state;
+	struct connector_state *conn_state = &state->conn_state;
+	struct logo_info *logo = &state->logo;
+	int hdisplay, vdisplay, ret;
+
+	ret = display_init(state);
+	if (!state->is_init || ret)
+		return -ENODEV;
+
+	switch (logo->bpp) {
+	case 16:
+		crtc_state->format = ROCKCHIP_FMT_RGB565;
+		break;
+	case 24:
+		crtc_state->format = ROCKCHIP_FMT_RGB888;
+		break;
+	case 32:
+		crtc_state->format = ROCKCHIP_FMT_ARGB8888;
+		break;
+	default:
+		printf("can't support bmp bits[%d]\n", logo->bpp);
+		return -EINVAL;
+	}
+	hdisplay = conn_state->mode.crtc_hdisplay;
+	vdisplay = conn_state->mode.vdisplay;
+	crtc_state->src_rect.w = logo->width;
+	crtc_state->src_rect.h = logo->height;
+	crtc_state->src_rect.x = 0;
+	crtc_state->src_rect.y = 0;
+	crtc_state->ymirror = logo->ymirror;
+	crtc_state->rb_swap = 0;
+
+	crtc_state->dma_addr = (u32)(unsigned long)logo->mem + logo->offset;
+	crtc_state->xvir = ALIGN(crtc_state->src_rect.w * logo->bpp, 32) >> 5;
+
+	if (state->logo_mode == ROCKCHIP_DISPLAY_FULLSCREEN) {
+		crtc_state->crtc_rect.x = 0;
+		crtc_state->crtc_rect.y = 0;
+		crtc_state->crtc_rect.w = hdisplay;
+		crtc_state->crtc_rect.h = vdisplay;
+	} else {
+		if (crtc_state->src_rect.w >= hdisplay) {
+			crtc_state->crtc_rect.x = 0;
+			crtc_state->crtc_rect.w = hdisplay;
+		} else {
+			crtc_state->crtc_rect.x = (hdisplay - crtc_state->src_rect.w) / 2;
+			crtc_state->crtc_rect.w = crtc_state->src_rect.w;
+		}
+
+		if (crtc_state->src_rect.h >= vdisplay) {
+			crtc_state->crtc_rect.y = 0;
+			crtc_state->crtc_rect.h = vdisplay;
+		} else {
+			crtc_state->crtc_rect.y = (vdisplay - crtc_state->src_rect.h) / 2;
+			crtc_state->crtc_rect.h = crtc_state->src_rect.h;
+		}
+	}
+
+	display_check(state);
+	ret = display_set_plane(state);
+	if (ret)
+		return ret;
+	display_enable(state);
+
+	return 0;
+}
+
+static int get_crtc_id(ofnode connect, bool is_ports_node)
+{
+	struct device_node *port_node;
+	struct device_node *remote;
+	int phandle;
+	int val;
+
+	if (is_ports_node) {
+		port_node = of_get_parent(connect.np);
+		if (!port_node)
+			goto err;
+
+		val = ofnode_read_u32_default(np_to_ofnode(port_node), "reg", -1);
+		if (val < 0)
+			goto err;
+	} else {
+		phandle = ofnode_read_u32_default(connect, "remote-endpoint", -1);
+		if (phandle < 0)
+			goto err;
+
+		remote = of_find_node_by_phandle(NULL, phandle);
+		if (!remote)
+			goto err;
+
+		val = ofnode_read_u32_default(np_to_ofnode(remote), "reg", -1);
+		if (val < 0)
+			goto err;
+	}
+
+	return val;
+err:
+	printf("Can't get crtc id, default set to id = 0\n");
+	return 0;
+}
+
+static int get_crtc_mcu_mode(struct crtc_state *crtc_state, struct device_node *port_node,
+			     bool is_ports_node)
+{
+	ofnode mcu_node, vp_node;
+	int total_pixel, cs_pst, cs_pend, rw_pst, rw_pend;
+
+	if (is_ports_node) {
+		vp_node = np_to_ofnode(port_node);
+		mcu_node = ofnode_find_subnode(vp_node, "mcu-timing");
+		if (!ofnode_valid(mcu_node))
+			return -ENODEV;
+	} else {
+		mcu_node = dev_read_subnode(crtc_state->dev, "mcu-timing");
+		if (!ofnode_valid(mcu_node))
+			return -ENODEV;
+	}
+
+#define FDT_GET_MCU_INT(val, name) \
+	do { \
+		val = ofnode_read_s32_default(mcu_node, name, -1); \
+		if (val < 0) { \
+			printf("Can't get %s\n", name); \
+			return -ENXIO; \
+		} \
+	} while (0)
+
+	FDT_GET_MCU_INT(total_pixel, "mcu-pix-total");
+	FDT_GET_MCU_INT(cs_pst, "mcu-cs-pst");
+	FDT_GET_MCU_INT(cs_pend, "mcu-cs-pend");
+	FDT_GET_MCU_INT(rw_pst, "mcu-rw-pst");
+	FDT_GET_MCU_INT(rw_pend, "mcu-rw-pend");
+
+	crtc_state->mcu_timing.mcu_pix_total = total_pixel;
+	crtc_state->mcu_timing.mcu_cs_pst = cs_pst;
+	crtc_state->mcu_timing.mcu_cs_pend = cs_pend;
+	crtc_state->mcu_timing.mcu_rw_pst = rw_pst;
+	crtc_state->mcu_timing.mcu_rw_pend = rw_pend;
+
+	return 0;
+}
+
+struct rockchip_logo_cache *find_or_alloc_logo_cache(const char *bmp, int rotate)
+{
+	struct rockchip_logo_cache *tmp, *logo_cache = NULL;
+
+	list_for_each_entry(tmp, &logo_cache_list, head) {
+		if ((!strcmp(tmp->name, bmp) && rotate == tmp->logo_rotate) ||
+		    (soc_is_rk3566() && tmp->logo_rotate)) {
+			logo_cache = tmp;
+			break;
+		}
+	}
+
+	if (!logo_cache) {
+		logo_cache = malloc(sizeof(*logo_cache));
+		if (!logo_cache) {
+			printf("failed to alloc memory for logo cache\n");
+			return NULL;
+		}
+		memset(logo_cache, 0, sizeof(*logo_cache));
+		strcpy(logo_cache->name, bmp);
+		INIT_LIST_HEAD(&logo_cache->head);
+		list_add_tail(&logo_cache->head, &logo_cache_list);
+	}
+
+	return logo_cache;
+}
+
+#ifdef BMP_DECODEER_LEGACY
+static int load_bmp_logo_legacy(struct logo_info *logo, const char *bmp_name)
+{
+#ifdef CONFIG_ROCKCHIP_RESOURCE_IMAGE
+	struct rockchip_logo_cache *logo_cache;
+	struct bmp_header *header;
+	void *dst = NULL, *pdst;
+	int size, len;
+	int ret = 0;
+	int reserved = 0;
+	int dst_size;
+
+	if (!logo || !bmp_name)
+		return -EINVAL;
+	logo_cache = find_or_alloc_logo_cache(bmp_name, logo->rotate);
+	if (!logo_cache)
+		return -ENOMEM;
+
+	if (logo_cache->logo.mem) {
+		memcpy(logo, &logo_cache->logo, sizeof(*logo));
+		return 0;
+	}
+
+	header = malloc(RK_BLK_SIZE);
+	if (!header)
+		return -ENOMEM;
+
+	len = rockchip_read_resource_file(header, bmp_name, 0, RK_BLK_SIZE);
+	if (len != RK_BLK_SIZE) {
+		ret = -EINVAL;
+		goto free_header;
+	}
+
+	logo->bpp = get_unaligned_le16(&header->bit_count);
+	logo->width = get_unaligned_le32(&header->width);
+	logo->height = get_unaligned_le32(&header->height);
+	dst_size = logo->width * logo->height * logo->bpp >> 3;
+	reserved = get_unaligned_le32(&header->reserved);
+	if (logo->height < 0)
+	    logo->height = -logo->height;
+	size = get_unaligned_le32(&header->file_size);
+	if (!can_direct_logo(logo->bpp)) {
+		if (size > MEMORY_POOL_SIZE) {
+			printf("failed to use boot buf as temp bmp buffer\n");
+			ret = -ENOMEM;
+			goto free_header;
+		}
+		pdst = get_display_buffer(size);
+
+	} else {
+		pdst = get_display_buffer(size);
+		dst = pdst;
+	}
+
+	len = rockchip_read_resource_file(pdst, bmp_name, 0, size);
+	if (len != size) {
+		printf("failed to load bmp %s\n", bmp_name);
+		ret = -ENOENT;
+		goto free_header;
+	}
+
+	if (!can_direct_logo(logo->bpp)) {
+		/*
+		 * TODO: force use 16bpp if bpp less than 16;
+		 */
+		logo->bpp = (logo->bpp <= 16) ? 16 : logo->bpp;
+		dst_size = logo->width * logo->height * logo->bpp >> 3;
+		dst = get_display_buffer(dst_size);
+		if (!dst) {
+			ret = -ENOMEM;
+			goto free_header;
+		}
+		if (bmpdecoder(pdst, dst, logo->bpp)) {
+			printf("failed to decode bmp %s\n", bmp_name);
+			ret = -EINVAL;
+			goto free_header;
+		}
+
+		logo->offset = 0;
+		logo->ymirror = 0;
+	} else {
+		logo->offset = get_unaligned_le32(&header->data_offset);
+		if (reserved == BMP_PROCESSED_FLAG)
+			logo->ymirror = 0;
+		else
+			logo->ymirror = 1;
+	}
+	logo->mem = dst;
+
+	memcpy(&logo_cache->logo, logo, sizeof(*logo));
+
+	flush_dcache_range((ulong)dst, ALIGN((ulong)dst + dst_size, CONFIG_SYS_CACHELINE_SIZE));
+
+free_header:
+
+	free(header);
+
+	return ret;
+#else
+	return -EINVAL;
+#endif
+}
+#endif
+
+static int load_bmp_logo(struct logo_info *logo, const char *bmp_name)
+{
+#ifdef CONFIG_ROCKCHIP_RESOURCE_IMAGE
+	struct rockchip_logo_cache *logo_cache;
+	bmp_bitmap_callback_vt bitmap_callbacks = {
+		bitmap_create,
+		bitmap_destroy,
+		bitmap_get_buffer,
+	};
+	bmp_result code;
+	bmp_image bmp;
+	void *bmp_data;
+	void *dst = NULL;
+	void *dst_rotate = NULL;
+	int len, dst_size;
+	int ret = 0;
+
+	if (!logo || !bmp_name)
+		return -EINVAL;
+
+	logo_cache = find_or_alloc_logo_cache(bmp_name, logo->rotate);
+	if (!logo_cache)
+		return -ENOMEM;
+
+	if (logo_cache->logo.mem) {
+		memcpy(logo, &logo_cache->logo, sizeof(*logo));
+		return 0;
+	}
+
+	bmp_data = malloc(MAX_IMAGE_BYTES);
+	if (!bmp_data)
+		return -ENOMEM;
+
+	bmp_create(&bmp, &bitmap_callbacks);
+
+	len = rockchip_read_resource_file(bmp_data, bmp_name, 0, MAX_IMAGE_BYTES);
+	if (len < 0) {
+		ret = -EINVAL;
+		goto free_bmp_data;
+	}
+
+	/* analyse the BMP */
+	code = bmp_analyse(&bmp, len, bmp_data);
+	if (code != BMP_OK) {
+		printf("failed to parse bmp:%s header\n", bmp_name);
+		ret = -EINVAL;
+		goto free_bmp_data;
+	}
+	/* fix bpp to 32 */
+	logo->bpp = 32;
+	logo->offset = 0;
+	logo->ymirror = 0;
+	logo->width = get_unaligned_le32(&bmp.width);
+	logo->height = get_unaligned_le32(&bmp.height);
+	dst_size = logo->width * logo->height * logo->bpp >> 3;
+	/* decode the image to RGBA8888 format */
+	code = bmp_decode(&bmp);
+	if (code != BMP_OK) {
+		/* allow partially decoded images */
+		if (code != BMP_INSUFFICIENT_DATA && code != BMP_DATA_ERROR) {
+			printf("failed to allocate the buffer of bmp:%s\n", bmp_name);
+			ret = -EINVAL;
+			goto free_bmp_data;
+		}
+
+		/* skip if the partially decoded image would be ridiculously large */
+		if ((bmp.width * bmp.height) > 200000) {
+			printf("partially decoded bmp:%s can not be too large\n", bmp_name);
+			ret = -EINVAL;
+			goto free_bmp_data;
+		}
+	}
+
+	dst = get_display_buffer(dst_size);
+	if (!dst) {
+		ret = -ENOMEM;
+		goto free_bmp_data;
+	}
+	bmp_copy(dst, &bmp);
+
+	if (logo->rotate) {
+		dst_rotate = rockchip_logo_rotate(logo, dst);
+		if (dst_rotate) {
+			dst = dst_rotate;
+			dst_size = logo->width * logo->height * logo->bpp >> 3;
+		}
+		printf("logo ratate %d\n", logo->rotate);
+	}
+	logo->mem = dst;
+
+	memcpy(&logo_cache->logo, logo, sizeof(*logo));
+	logo_cache->logo_rotate = logo->rotate;
+
+	flush_dcache_range((ulong)dst, ALIGN((ulong)dst + dst_size, CONFIG_SYS_CACHELINE_SIZE));
+free_bmp_data:
+	/* clean up */
+	bmp_finalise(&bmp);
+	free(bmp_data);
+
+	return ret;
+#else
+	return -EINVAL;
+#endif
+}
+
+void rockchip_show_fbbase(ulong fbbase)
+{
+	struct display_state *s;
+
+	list_for_each_entry(s, &rockchip_display_list, head) {
+		s->logo.mode = ROCKCHIP_DISPLAY_FULLSCREEN;
+		s->logo.mem = (char *)fbbase;
+		s->logo.width = DRM_ROCKCHIP_FB_WIDTH;
+		s->logo.height = DRM_ROCKCHIP_FB_HEIGHT;
+		s->logo.bpp = 32;
+		s->logo.ymirror = 0;
+
+		display_logo(s);
+	}
+}
+
+int rockchip_show_bmp(const char *bmp)
+{
+	struct display_state *s;
+	int ret = 0;
+
+	if (!bmp) {
+		list_for_each_entry(s, &rockchip_display_list, head)
+			display_disable(s);
+		return -ENOENT;
+	}
+
+	list_for_each_entry(s, &rockchip_display_list, head) {
+		s->logo.mode = s->charge_logo_mode;
+		if (load_bmp_logo(&s->logo, bmp))
+			continue;
+		ret = display_logo(s);
+	}
+
+	return ret;
+}
+
+int rockchip_show_logo(void)
+{
+	struct display_state *s;
+	struct display_state *ms = NULL;
+	int ret = 0;
+	int count = 0;
+
+	list_for_each_entry(s, &rockchip_display_list, head) {
+		s->logo.mode = s->logo_mode;
+		s->logo.rotate = s->logo_rotate;
+		if (load_bmp_logo(&s->logo, s->ulogo_name)) {
+			printf("failed to display uboot logo\n");
+		} else {
+			ret = display_logo(s);
+			if (ret == -EAGAIN)
+				ms = s;
+		}
+		/* Load kernel bmp in rockchip_display_fixup() later */
+	}
+
+	/*
+	 * For rk3566, the mirror win must be enabled after the related
+	 * source win. If error code is EAGAIN, the mirror win may be
+	 * first enabled unexpectedly, and we will move the enabling process
+	 * as follows.
+	 */
+	if (ms) {
+		while (count < 5) {
+			ret = display_logo(ms);
+			if (ret != -EAGAIN)
+				break;
+			mdelay(10);
+			count++;
+		}
+	}
+
+	return ret;
+}
+
+int rockchip_vop_dump(const char *cmd)
+{
+	struct display_state *state;
+	struct crtc_state *crtc_state;
+	struct rockchip_crtc *crtc;
+	const struct rockchip_crtc_funcs *crtc_funcs;
+	int ret = -EINVAL;
+
+	list_for_each_entry(state, &rockchip_display_list, head) {
+		if (!state->is_init)
+			continue;
+		crtc_state = &state->crtc_state;
+		crtc = crtc_state->crtc;
+		crtc_funcs = crtc->funcs;
+
+		if (!cmd)
+			ret = crtc_funcs->active_regs_dump(state);
+		else if (!strcmp(cmd, "a") || !strcmp(cmd, "all"))
+			ret = crtc_funcs->regs_dump(state);
+		if (!ret)
+			break;
+	}
+
+	if (ret)
+		ret = CMD_RET_USAGE;
+
+	return ret;
+}
+
+enum {
+	PORT_DIR_IN,
+	PORT_DIR_OUT,
+};
+
+struct device_node *rockchip_of_graph_get_port_by_id(ofnode node, int id)
+{
+	ofnode ports, port;
+	u32 reg;
+
+	ports = ofnode_find_subnode(node, "ports");
+	if (!ofnode_valid(ports))
+		return NULL;
+
+	ofnode_for_each_subnode(port, ports) {
+		if (ofnode_read_u32(port, "reg", &reg))
+			continue;
+
+		if (reg == id)
+			break;
+	}
+
+	if (reg == id)
+		return ofnode_to_np(port);
+
+	return NULL;
+}
+
+static struct device_node *rockchip_of_graph_get_port_parent(ofnode port)
+{
+	ofnode parent;
+	int is_ports_node;
+
+	parent = ofnode_get_parent(port);
+	is_ports_node = strstr(ofnode_to_np(parent)->full_name, "ports") ? 1 : 0;
+	if (is_ports_node)
+		parent = ofnode_get_parent(parent);
+
+	return ofnode_to_np(parent);
+}
+
+struct device_node *
+rockchip_of_graph_get_endpoint_by_regs(ofnode node, int port, int endpoint)
+{
+	struct device_node *port_node;
+	ofnode ep;
+	u32 reg;
+
+	port_node = rockchip_of_graph_get_port_by_id(node, port);
+	if (!port_node)
+		return NULL;
+
+	ofnode_for_each_subnode(ep, np_to_ofnode(port_node)) {
+		if (ofnode_read_u32(ep, "reg", &reg))
+			break;
+		if (reg == endpoint)
+			break;
+	}
+
+	if (!ofnode_valid(ep))
+		return NULL;
+
+	return ofnode_to_np(ep);
+}
+
+static struct device_node *
+rockchip_of_graph_get_remote_node(ofnode node, int port, int endpoint)
+{
+	struct device_node *ep_node;
+	ofnode ep;
+	uint phandle;
+
+	ep_node = rockchip_of_graph_get_endpoint_by_regs(node, port, endpoint);
+	if (!ep_node)
+		return NULL;
+
+	if (ofnode_read_u32(np_to_ofnode(ep_node), "remote-endpoint", &phandle))
+		return NULL;
+
+	ep = ofnode_get_by_phandle(phandle);
+	if (!ofnode_valid(ep))
+		return NULL;
+
+	return ofnode_to_np(ep);
+}
+
+static int rockchip_of_find_panel(struct udevice *dev, struct rockchip_panel **panel)
+{
+	struct device_node *ep_node, *panel_node;
+	ofnode panel_ofnode, port;
+	struct udevice *panel_dev;
+	int ret = 0;
+
+	*panel = NULL;
+	panel_ofnode = dev_read_subnode(dev, "panel");
+	if (ofnode_valid(panel_ofnode) && ofnode_is_enabled(panel_ofnode)) {
+		ret = uclass_get_device_by_ofnode(UCLASS_PANEL, panel_ofnode,
+						  &panel_dev);
+		if (!ret)
+			goto found;
+	}
+
+	ep_node = rockchip_of_graph_get_remote_node(dev->node_, PORT_DIR_OUT, 0);
+	if (!ep_node)
+		return -ENODEV;
+
+	port = ofnode_get_parent(np_to_ofnode(ep_node));
+	if (!ofnode_valid(port))
+		return -ENODEV;
+
+	panel_node = rockchip_of_graph_get_port_parent(port);
+	if (!panel_node)
+		return -ENODEV;
+
+	ret = uclass_get_device_by_ofnode(UCLASS_PANEL, np_to_ofnode(panel_node), &panel_dev);
+	if (!ret)
+		goto found;
+
+	return -ENODEV;
+
+found:
+	*panel = (struct rockchip_panel *)dev_get_driver_data(panel_dev);
+	return 0;
+}
+
+static int rockchip_of_find_bridge(struct udevice *dev, struct rockchip_bridge **bridge)
+{
+	struct device_node *ep_node, *bridge_node;
+	ofnode port;
+	struct udevice *bridge_dev;
+	int ret = 0;
+
+	ep_node = rockchip_of_graph_get_remote_node(dev->node_, PORT_DIR_OUT, 0);
+	if (!ep_node)
+		return -ENODEV;
+
+	port = ofnode_get_parent(np_to_ofnode(ep_node));
+	if (!ofnode_valid(port))
+		return -ENODEV;
+
+	bridge_node = rockchip_of_graph_get_port_parent(port);
+	if (!bridge_node)
+		return -ENODEV;
+
+	ret = uclass_get_device_by_ofnode(UCLASS_VIDEO_BRIDGE, np_to_ofnode(bridge_node),
+					  &bridge_dev);
+	if (!ret)
+		goto found;
+
+	return -ENODEV;
+
+found:
+	*bridge = (struct rockchip_bridge *)dev_get_driver_data(bridge_dev);
+	return 0;
+}
+
+static int rockchip_of_find_panel_or_bridge(struct udevice *dev, struct rockchip_panel **panel,
+					    struct rockchip_bridge **bridge)
+{
+	int ret = 0;
+
+	if (*panel)
+		return 0;
+
+	*panel = NULL;
+	*bridge = NULL;
+
+	if (panel) {
+		ret  = rockchip_of_find_panel(dev, panel);
+		if (!ret)
+			return 0;
+	}
+
+	if (ret) {
+		ret = rockchip_of_find_bridge(dev, bridge);
+		if (!ret)
+			ret = rockchip_of_find_panel_or_bridge((*bridge)->dev, panel,
+							       &(*bridge)->next_bridge);
+	}
+
+	return ret;
+}
+
+static struct rockchip_phy *rockchip_of_find_phy(struct udevice *dev)
+{
+	struct udevice *phy_dev;
+	int ret;
+	struct rockchip_phy *driver_data;
+
+	ret = uclass_get_device_by_phandle(UCLASS_PHY, dev, "phys", &phy_dev);
+	printf("find phy ret:%d\n",ret);
+	printf("phy-name:%s\n",phy_dev->name);
+	if (ret)
+		return NULL;
+	driver_data = (struct rockchip_phy *)dev_get_driver_data(phy_dev);
+	if (driver_data)
+		printf("driver_data valid\n");
+
+	return (struct rockchip_phy *)dev_get_driver_data(phy_dev);
+}
+
+static struct udevice *rockchip_of_find_connector_device(ofnode endpoint)
+{
+	ofnode ep, port, ports, conn;
+	uint phandle;
+	struct udevice *dev;
+	int ret;
+
+	if (ofnode_read_u32(endpoint, "remote-endpoint", &phandle))
+		return NULL;
+
+	ep = ofnode_get_by_phandle(phandle);
+	if (!ofnode_valid(ep) || !ofnode_is_enabled(ep))
+		return NULL;
+
+	port = ofnode_get_parent(ep);
+	if (!ofnode_valid(port))
+		return NULL;
+
+	ports = ofnode_get_parent(port);
+	if (!ofnode_valid(ports))
+		return NULL;
+
+	conn = ofnode_get_parent(ports);
+	if (!ofnode_valid(conn) || !ofnode_is_enabled(conn))
+		return NULL;
+
+	ret = uclass_get_device_by_ofnode(UCLASS_DISPLAY, conn, &dev);
+	if (ret)
+		return NULL;
+
+	return dev;
+}
+
+static struct rockchip_connector *rockchip_of_get_connector(ofnode endpoint)
+{
+	struct rockchip_connector *conn;
+	struct udevice *dev;
+	int ret;
+
+	dev = rockchip_of_find_connector_device(endpoint);
+	printf("dev_name:%s",dev->name);
+	if (!dev) {
+		printf("Warn: can't find connect driver\n");
+		return NULL;
+	}
+
+	conn = get_rockchip_connector_by_device(dev);
+	if (!conn)
+		return NULL;
+	ret = rockchip_of_find_panel_or_bridge(dev, &conn->panel, &conn->bridge);
+	if (ret)
+		debug("Warn: no find panel or bridge\n");
+
+	conn->phy = rockchip_of_find_phy(dev);
+	if (conn->phy){
+		if (conn->phy->dev)
+			printf("conn have phy:%s\n",conn->phy->dev->name);
+	}
+
+	return conn;
+}
+
+static struct rockchip_connector *rockchip_get_split_connector(struct rockchip_connector *conn)
+{
+	char *conn_name;
+	struct device_node *split_node;
+	struct udevice *split_dev;
+	struct rockchip_connector *split_conn;
+	bool split_mode;
+	int ret;
+
+	split_mode = ofnode_read_bool(conn->dev->node_, "split-mode");
+	split_mode |= ofnode_read_bool(conn->dev->node_, "dual-channel");
+	if (!split_mode)
+		return NULL;
+
+	switch (conn->type) {
+	case DRM_MODE_CONNECTOR_DisplayPort:
+		conn_name = "dp";
+		break;
+	case DRM_MODE_CONNECTOR_eDP:
+		conn_name = "edp";
+		break;
+	case DRM_MODE_CONNECTOR_HDMIA:
+		conn_name = "hdmi";
+		break;
+	case DRM_MODE_CONNECTOR_LVDS:
+		conn_name = "lvds";
+		break;
+	default:
+		return NULL;
+	}
+
+	split_node = of_alias_get_dev(conn_name, !conn->id);
+	if (!split_node || !of_device_is_available(split_node))
+		return NULL;
+
+	ret = uclass_get_device_by_ofnode(UCLASS_DISPLAY, np_to_ofnode(split_node), &split_dev);
+	if (ret)
+		return NULL;
+
+	split_conn = get_rockchip_connector_by_device(split_dev);
+	if (!split_conn)
+		return NULL;
+	ret = rockchip_of_find_panel_or_bridge(split_dev, &split_conn->panel, &split_conn->bridge);
+	if (ret)
+		debug("Warn: no find panel or bridge\n");
+
+	split_conn->phy = rockchip_of_find_phy(split_dev);
+
+	return split_conn;
+}
+
+static bool rockchip_get_display_path_status(ofnode endpoint)
+{
+	ofnode ep;
+	uint phandle;
+
+	if (ofnode_read_u32(endpoint, "remote-endpoint", &phandle))
+		return false;
+
+	ep = ofnode_get_by_phandle(phandle);
+	if (!ofnode_valid(ep) || !ofnode_is_enabled(ep))
+		return false;
+
+	return true;
+}
+
+#if defined(CONFIG_ROCKCHIP_RK3568)
+static int rockchip_display_fixup_dts(void *blob)
+{
+	ofnode route_node, route_subnode, conn_ep, conn_port;
+	struct device_node *route_sub_devnode;
+	struct device_node *ep_node, *conn_ep_dev_node;
+	u32 phandle;
+	int conn_ep_offset;
+	const char *route_sub_path, *path;
+
+	/* Don't go further if new variant after
+	 * reading PMUGRF_SOC_CON15
+	 */
+	if ((readl(0xfdc20100) & GENMASK(15, 14)))
+		return 0;
+
+	route_node = ofnode_path("/display-subsystem/route");
+	if (!ofnode_valid(route_node))
+		return -EINVAL;
+
+	ofnode_for_each_subnode(route_subnode, route_node) {
+		if (!ofnode_is_enabled(route_subnode))
+			continue;
+
+		route_sub_devnode = ofnode_to_np(route_subnode);
+		route_sub_path = route_sub_devnode->full_name;
+		if (!strstr(ofnode_get_name(route_subnode), "dsi") &&
+		    !strstr(ofnode_get_name(route_subnode), "edp"))
+			return 0;
+
+		phandle = ofnode_read_u32_default(route_subnode, "connect", -1);
+		if (phandle < 0) {
+			printf("Warn: can't find connect node's handle\n");
+			continue;
+		}
+
+		ep_node = of_find_node_by_phandle(NULL, phandle);
+		if (!ofnode_valid(np_to_ofnode(ep_node))) {
+			printf("Warn: can't find endpoint node from phandle\n");
+			continue;
+		}
+
+		ofnode_read_u32(np_to_ofnode(ep_node), "remote-endpoint", &phandle);
+		conn_ep = ofnode_get_by_phandle(phandle);
+		if (!ofnode_valid(conn_ep) || !ofnode_is_enabled(conn_ep))
+			return -ENODEV;
+
+		conn_port = ofnode_get_parent(conn_ep);
+		if (!ofnode_valid(conn_port))
+			return -ENODEV;
+
+		ofnode_for_each_subnode(conn_ep, conn_port) {
+			conn_ep_dev_node = ofnode_to_np(conn_ep);
+			path = conn_ep_dev_node->full_name;
+			ofnode_read_u32(conn_ep, "remote-endpoint", &phandle);
+			conn_ep_offset = fdt_path_offset(blob, path);
+
+			if (!ofnode_is_enabled(conn_ep) &&
+			    strstr(ofnode_get_name(conn_ep), "endpoint@0")) {
+				do_fixup_by_path_u32(blob, route_sub_path,
+						     "connect", phandle, 1);
+				fdt_status_okay(blob, conn_ep_offset);
+
+			} else if (ofnode_is_enabled(conn_ep) &&
+				   strstr(ofnode_get_name(conn_ep), "endpoint@1")) {
+				fdt_status_disabled(blob, conn_ep_offset);
+			}
+		}
+	}
+
+	return 0;
+}
+#endif
+
+static int rockchip_display_probe(struct udevice *dev)
+{
+	struct video_priv *uc_priv = dev_get_uclass_priv(dev);
+	struct video_uc_plat *plat = dev_get_uclass_plat(dev);
+	const void *blob = gd->fdt_blob;
+	int phandle;
+	struct udevice *crtc_dev;
+	struct rockchip_crtc *crtc;
+	struct rockchip_connector *conn, *split_conn;
+	struct display_state *s;
+	const char *name;
+	int ret;
+	ofnode node, route_node, timing_node;
+	struct device_node *port_node, *vop_node, *ep_node, *port_parent_node;
+	struct public_phy_data *data;
+	bool is_ports_node = false;
+
+#if defined(CONFIG_ROCKCHIP_RK3568)
+	rockchip_display_fixup_dts((void *)blob);
+#endif
+	/* Before relocation we don't need to do anything */
+	if (!(gd->flags & GD_FLG_RELOC))
+		return 0;
+
+	data = malloc(sizeof(struct public_phy_data));
+	if (!data) {
+		printf("failed to alloc phy data\n");
+		return -ENOMEM;
+	}
+	data->phy_init = false;
+
+	init_display_buffer(plat->base);
+
+	route_node = dev_read_subnode(dev, "route");
+	if (!ofnode_valid(route_node))
+		return -ENODEV;
+
+	ofnode_for_each_subnode(node, route_node) {
+		if (!ofnode_is_enabled(node))
+			continue;
+		phandle = ofnode_read_u32_default(node, "connect", -1);
+		if (phandle < 0) {
+			printf("Warn: can't find connect node's handle\n");
+			continue;
+		}
+		ep_node = of_find_node_by_phandle(NULL, phandle);
+		if (!ofnode_valid(np_to_ofnode(ep_node))) {
+			printf("Warn: can't find endpoint node from phandle\n");
+			continue;
+		}
+		port_node = of_get_parent(ep_node);
+		if (!ofnode_valid(np_to_ofnode(port_node))) {
+			printf("Warn: can't find port node from phandle\n");
+			continue;
+		}
+
+		port_parent_node = of_get_parent(port_node);
+		if (!ofnode_valid(np_to_ofnode(port_parent_node))) {
+			printf("Warn: can't find port parent node from phandle\n");
+			continue;
+		}
+
+		is_ports_node = strstr(port_parent_node->full_name, "ports") ? 1 : 0;
+		if (is_ports_node) {
+			vop_node = of_get_parent(port_parent_node);
+			if (!ofnode_valid(np_to_ofnode(vop_node))) {
+				printf("Warn: can't find crtc node from phandle\n");
+				continue;
+			}
+		} else {
+			vop_node = port_parent_node;
+		}
+
+		ret = uclass_get_device_by_ofnode(UCLASS_VIDEO_CRTC,
+						  np_to_ofnode(vop_node),
+						  &crtc_dev);
+		if (ret) {
+			printf("Warn: can't find crtc driver %d\n", ret);
+			continue;
+		}
+		crtc = (struct rockchip_crtc *)dev_get_driver_data(crtc_dev);
+
+		conn = rockchip_of_get_connector(np_to_ofnode(ep_node));
+		if (!conn) {
+			printf("Warn: can't get connect driver\n");
+			continue;
+		}
+		split_conn = rockchip_get_split_connector(conn);
+
+		s = malloc(sizeof(*s));
+		if (!s)
+			continue;
+
+		memset(s, 0, sizeof(*s));
+
+		INIT_LIST_HEAD(&s->head);
+		ret = ofnode_read_string_index(node, "logo,uboot", 0, &name);
+		if (!ret)
+			memcpy(s->ulogo_name, name, strlen(name));
+		ret = ofnode_read_string_index(node, "logo,kernel", 0, &name);
+		if (!ret)
+			memcpy(s->klogo_name, name, strlen(name));
+		ret = ofnode_read_string_index(node, "logo,mode", 0, &name);
+		if (!strcmp(name, "fullscreen"))
+			s->logo_mode = ROCKCHIP_DISPLAY_FULLSCREEN;
+		else
+			s->logo_mode = ROCKCHIP_DISPLAY_CENTER;
+		ret = ofnode_read_string_index(node, "charge_logo,mode", 0, &name);
+		if (!strcmp(name, "fullscreen"))
+			s->charge_logo_mode = ROCKCHIP_DISPLAY_FULLSCREEN;
+		else
+			s->charge_logo_mode = ROCKCHIP_DISPLAY_CENTER;
+
+		s->logo_rotate = ofnode_read_u32_default(node, "logo,rotate", 0);
+
+		s->force_output = ofnode_read_bool(node, "force-output");
+
+		if (s->force_output) {
+			timing_node = ofnode_find_subnode(node, "force_timing");
+			ret = display_get_force_timing_from_dts(timing_node,
+								&s->force_mode,
+								&s->conn_state.bus_flags);
+			if (ofnode_read_u32(node, "force-bus-format", &s->force_bus_format))
+				s->force_bus_format = MEDIA_BUS_FMT_RGB888_1X24;
+		}
+
+		s->blob = blob;
+		s->conn_state.connector = conn;
+		s->conn_state.secondary = NULL;
+		s->conn_state.type = conn->type;
+		if (split_conn) {
+			s->conn_state.secondary = split_conn;
+			s->conn_state.output_flags |= ROCKCHIP_OUTPUT_DUAL_CHANNEL_LEFT_RIGHT_MODE;
+			s->conn_state.output_flags |= conn->id ? ROCKCHIP_OUTPUT_DATA_SWAP : 0;
+		}
+		s->conn_state.overscan.left_margin = 100;
+		s->conn_state.overscan.right_margin = 100;
+		s->conn_state.overscan.top_margin = 100;
+		s->conn_state.overscan.bottom_margin = 100;
+		s->crtc_state.node = np_to_ofnode(vop_node);
+		s->crtc_state.dev = crtc_dev;
+		s->crtc_state.crtc = crtc;
+		s->crtc_state.crtc_id = get_crtc_id(np_to_ofnode(ep_node), is_ports_node);
+		s->node = node;
+
+		if (is_ports_node) { /* only vop2 will get into here */
+			ofnode vp_node = np_to_ofnode(port_node);
+			static bool get_plane_mask_from_dts;
+
+			s->crtc_state.ports_node = port_parent_node;
+			if (!get_plane_mask_from_dts) {
+				ofnode vp_sub_node;
+				int vp_id = 0;
+				bool vp_enable = false;
+
+				ofnode_for_each_subnode(vp_node, np_to_ofnode(port_parent_node)) {
+					int cursor_plane = -1;
+
+					vp_id = ofnode_read_u32_default(vp_node, "reg", 0);
+
+					s->crtc_state.crtc->vps[vp_id].xmirror_en =
+						ofnode_read_bool(vp_node, "xmirror-enable");
+
+					ret = ofnode_read_u32_default(vp_node, "rockchip,plane-mask", 0);
+
+					cursor_plane = ofnode_read_u32_default(vp_node, "cursor-win-id", -1);
+					s->crtc_state.crtc->vps[vp_id].cursor_plane = cursor_plane;
+					if (ret) {
+						s->crtc_state.crtc->vps[vp_id].plane_mask = ret;
+						s->crtc_state.crtc->assign_plane |= true;
+						s->crtc_state.crtc->vps[vp_id].primary_plane_id =
+							ofnode_read_u32_default(vp_node, "rockchip,primary-plane", U8_MAX);
+						printf("get vp%d plane mask:0x%x, primary id:%d, cursor_plane:%d, from dts\n",
+						       vp_id,
+						       s->crtc_state.crtc->vps[vp_id].plane_mask,
+						       s->crtc_state.crtc->vps[vp_id].primary_plane_id == U8_MAX ? -1 :
+						       s->crtc_state.crtc->vps[vp_id].primary_plane_id,
+						       cursor_plane);
+					}
+
+					/* To check current vp status */
+					vp_enable = false;
+					ofnode_for_each_subnode(vp_sub_node, vp_node)
+						vp_enable |= rockchip_get_display_path_status(vp_sub_node);
+					s->crtc_state.crtc->vps[vp_id].enable = vp_enable;
+				}
+				get_plane_mask_from_dts = true;
+			}
+		}
+
+		get_crtc_mcu_mode(&s->crtc_state, port_node, is_ports_node);
+
+		ret = ofnode_read_u32_default(s->crtc_state.node,
+					      "rockchip,dual-channel-swap", 0);
+		s->crtc_state.dual_channel_swap = ret;
+
+		if (connector_phy_init(conn, data)) {
+			printf("Warn: Failed to init phy drivers\n");
+			free(s);
+			continue;
+		}
+		list_add_tail(&s->head, &rockchip_display_list);
+	}
+
+	if (list_empty(&rockchip_display_list)) {
+		debug("Failed to found available display route\n");
+		return -ENODEV;
+	}
+	// rockchip_get_baseparameter();
+	display_pre_init();
+
+	uc_priv->xsize = DRM_ROCKCHIP_FB_WIDTH;
+	uc_priv->ysize = DRM_ROCKCHIP_FB_HEIGHT;
+	uc_priv->bpix = VIDEO_BPP32;
+
+	#ifdef CONFIG_DRM_ROCKCHIP_VIDEO_FRAMEBUFFER
+	rockchip_show_fbbase(plat->base);
+	video_set_flush_dcache(dev, true);
+	#endif
+
+	return 0;
+}
+
+int rockchip_display_bind(struct udevice *dev)
+{
+	struct video_uc_plat *plat = dev_get_uclass_plat(dev);
+
+	plat->size = DRM_ROCKCHIP_FB_SIZE + MEMORY_POOL_SIZE;
+
+	return 0;
+}
+
+static const struct udevice_id rockchip_display_ids[] = {
+	{ .compatible = "rockchip,display-subsystem" },
+	{ }
+};
+
+U_BOOT_DRIVER(rockchip_display) = {
+	.name	= "rockchip_display",
+	.id	= UCLASS_VIDEO,
+	.of_match = rockchip_display_ids,
+	.bind	= rockchip_display_bind,
+	.probe	= rockchip_display_probe,
+};
+
+static int do_rockchip_logo_show(struct cmd_tbl *cmdtp, int flag, int argc,
+			char *const argv[])
+{
+	if (argc != 1)
+		return CMD_RET_USAGE;
+
+	rockchip_show_logo();
+
+	return 0;
+}
+
+static int do_rockchip_show_bmp(struct cmd_tbl *cmdtp, int flag, int argc,
+				char *const argv[])
+{
+	if (argc != 2)
+		return CMD_RET_USAGE;
+
+	rockchip_show_bmp(argv[1]);
+
+	return 0;
+}
+
+static int do_rockchip_vop_dump(struct cmd_tbl *cmdtp, int flag, int argc,
+				char *const argv[])
+{
+	int ret;
+
+	if (argc < 1 || argc > 2)
+		return CMD_RET_USAGE;
+
+	ret = rockchip_vop_dump(argv[1]);
+
+	return ret;
+}
+
+U_BOOT_CMD(
+	rockchip_show_logo, 1, 1, do_rockchip_logo_show,
+	"load and display log from resource partition",
+	NULL
+);
+
+U_BOOT_CMD(
+	rockchip_show_bmp, 2, 1, do_rockchip_show_bmp,
+	"load and display bmp from resource partition",
+	"    <bmp_name>"
+);
+
+U_BOOT_CMD(
+	vop_dump, 2, 1, do_rockchip_vop_dump,
+	"dump vop regs",
+	" [a/all]"
+);
diff --git a/drivers/video/drm/rockchip_display.h b/drivers/video/drm/rockchip_display.h
new file mode 100644
index 0000000000..6853fb65da
--- /dev/null
+++ b/drivers/video/drm/rockchip_display.h
@@ -0,0 +1,333 @@
+/*
+ * (C) Copyright 2008-2017 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _ROCKCHIP_DISPLAY_H
+#define _ROCKCHIP_DISPLAY_H
+
+#ifdef CONFIG_SPL_BUILD
+#include <linux/hdmi.h>
+#include <linux/media-bus-format.h>
+#else
+#include <bmp_layout.h>
+#include <edid.h>
+#endif
+#include <drm_modes.h>
+#include <dm/ofnode.h>
+#include <drm/drm_dsc.h>
+#include <spl_display.h>
+#include <clk.h>
+
+/*
+ * major: IP major version, used for IP structure
+ * minor: big feature change under same structure
+ * build: RTL current SVN number
+ */
+#define VOP_VERSION(major, minor)		((major) << 8 | (minor))
+#define VOP_MAJOR(version)			((version) >> 8)
+#define VOP_MINOR(version)			((version) & 0xff)
+
+#define VOP2_VERSION(major, minor, build)	((major) << 24 | (minor) << 16 | (build))
+#define VOP2_MAJOR(version)			(((version) >> 24) & 0xff)
+#define VOP2_MINOR(version)			(((version) >> 16) & 0xff)
+#define VOP2_BUILD(version)			((version) & 0xffff)
+
+#define VOP_VERSION_RK3528			VOP2_VERSION(0x50, 0x17, 0x1263)
+#define VOP_VERSION_RK3562			VOP2_VERSION(0x50, 0x17, 0x4350)
+#define VOP_VERSION_RK3568			VOP2_VERSION(0x40, 0x15, 0x8023)
+#define VOP_VERSION_RK3588			VOP2_VERSION(0x40, 0x17, 0x6786)
+
+#define ROCKCHIP_OUTPUT_DUAL_CHANNEL_LEFT_RIGHT_MODE	BIT(0)
+#define ROCKCHIP_OUTPUT_DUAL_CHANNEL_ODD_EVEN_MODE	BIT(1)
+#define ROCKCHIP_OUTPUT_DATA_SWAP			BIT(2)
+#define ROCKCHIP_OUTPUT_MIPI_DS_MODE			BIT(3)
+
+#define ROCKCHIP_DSC_PPS_SIZE_BYTE			88
+
+enum data_format {
+	ROCKCHIP_FMT_ARGB8888 = 0,
+	ROCKCHIP_FMT_RGB888,
+	ROCKCHIP_FMT_RGB565,
+	ROCKCHIP_FMT_YUV420SP = 4,
+	ROCKCHIP_FMT_YUV422SP,
+	ROCKCHIP_FMT_YUV444SP,
+};
+
+enum display_mode {
+	ROCKCHIP_DISPLAY_FULLSCREEN,
+	ROCKCHIP_DISPLAY_CENTER,
+};
+
+enum rockchip_cmd_type {
+	CMD_TYPE_DEFAULT,
+	CMD_TYPE_SPI,
+	CMD_TYPE_MCU
+};
+
+enum rockchip_mcu_cmd {
+	MCU_WRCMD = 0,
+	MCU_WRDATA,
+	MCU_SETBYPASS,
+};
+
+/*
+ * display output interface supported by rockchip lcdc
+ */
+#define ROCKCHIP_OUT_MODE_P888		0
+#define ROCKCHIP_OUT_MODE_BT1120	0
+#define ROCKCHIP_OUT_MODE_P666		1
+#define ROCKCHIP_OUT_MODE_P565		2
+#define ROCKCHIP_OUT_MODE_BT656		5
+#define ROCKCHIP_OUT_MODE_S888		8
+#define ROCKCHIP_OUT_MODE_YUV422	9
+#define ROCKCHIP_OUT_MODE_S888_DUMMY	12
+#define ROCKCHIP_OUT_MODE_YUV420	14
+/* for use special outface */
+#define ROCKCHIP_OUT_MODE_AAAA		15
+
+#define VOP_OUTPUT_IF_RGB	BIT(0)
+#define VOP_OUTPUT_IF_BT1120	BIT(1)
+#define VOP_OUTPUT_IF_BT656	BIT(2)
+#define VOP_OUTPUT_IF_LVDS0	BIT(3)
+#define VOP_OUTPUT_IF_LVDS1	BIT(4)
+#define VOP_OUTPUT_IF_MIPI0	BIT(5)
+#define VOP_OUTPUT_IF_MIPI1	BIT(6)
+#define VOP_OUTPUT_IF_eDP0	BIT(7)
+#define VOP_OUTPUT_IF_eDP1	BIT(8)
+#define VOP_OUTPUT_IF_DP0	BIT(9)
+#define VOP_OUTPUT_IF_DP1	BIT(10)
+#define VOP_OUTPUT_IF_HDMI0	BIT(11)
+#define VOP_OUTPUT_IF_HDMI1	BIT(12)
+
+struct rockchip_mcu_timing {
+	int mcu_pix_total;
+	int mcu_cs_pst;
+	int mcu_cs_pend;
+	int mcu_rw_pst;
+	int mcu_rw_pend;
+	int mcu_hold_mode;
+};
+
+struct vop_rect {
+	int width;
+	int height;
+};
+
+struct rockchip_dsc_sink_cap {
+	/**
+	 * @slice_width: the number of pixel columns that comprise the slice width
+	 * @slice_height: the number of pixel rows that comprise the slice height
+	 * @block_pred: Does block prediction
+	 * @native_420: Does sink support DSC with 4:2:0 compression
+	 * @bpc_supported: compressed bpc supported by sink : 10, 12 or 16 bpc
+	 * @version_major: DSC major version
+	 * @version_minor: DSC minor version
+	 * @target_bits_per_pixel_x16: bits num after compress and multiply 16
+	 */
+	u16 slice_width;
+	u16 slice_height;
+	bool block_pred;
+	bool native_420;
+	u8 bpc_supported;
+	u8 version_major;
+	u8 version_minor;
+	u16 target_bits_per_pixel_x16;
+};
+
+struct display_rect {
+	int x;
+	int y;
+	int w;
+	int h;
+};
+
+struct bcsh_state {
+	int brightness;
+	int contrast;
+	int saturation;
+	int sin_hue;
+	int cos_hue;
+};
+
+struct crtc_state {
+	struct udevice *dev;
+	struct rockchip_crtc *crtc;
+	void *private;
+	ofnode node;
+	struct device_node *ports_node; /* if (ports_node) it's vop2; */
+	struct clk dclk;
+	int crtc_id;
+
+	int format;
+	u32 dma_addr;
+	int ymirror;
+	int rb_swap;
+	int xvir;
+	int post_csc_mode;
+	int dclk_core_div;
+	int dclk_out_div;
+	struct display_rect src_rect;
+	struct display_rect crtc_rect;
+	struct display_rect right_src_rect;
+	struct display_rect right_crtc_rect;
+	bool yuv_overlay;
+	bool post_r2y_en;
+	bool post_y2r_en;
+	bool bcsh_en;
+	bool splice_mode;
+	bool soft_te;
+	u8 splice_crtc_id;
+	u8 dsc_id;
+	u8 dsc_enable;
+	u8 dsc_slice_num;
+	u8 dsc_pixel_num;
+	struct rockchip_mcu_timing mcu_timing;
+	u32 dual_channel_swap;
+	u32 feature;
+	struct vop_rect max_output;
+
+	u64 dsc_txp_clk_rate;
+	u64 dsc_pxl_clk_rate;
+	u64 dsc_cds_clk_rate;
+	struct drm_dsc_picture_parameter_set pps;
+	struct rockchip_dsc_sink_cap dsc_sink_cap;
+};
+
+struct panel_state {
+	struct rockchip_panel *panel;
+
+	ofnode dsp_lut_node;
+};
+
+struct overscan {
+	int left_margin;
+	int right_margin;
+	int top_margin;
+	int bottom_margin;
+};
+
+struct connector_state {
+	struct rockchip_connector *connector;
+	struct rockchip_connector *secondary;
+
+	struct drm_display_mode mode;
+	struct overscan overscan;
+	u8 edid[EDID_SIZE * 4];
+	int bus_format;
+	u32 bus_flags;
+	int output_mode;
+	int type;
+	int output_if;
+	int output_flags;
+	int color_space;
+	unsigned int bpc;
+
+	/**
+	 * @hold_mode: enabled when it's:
+	 * (1) mcu hold mode
+	 * (2) mipi dsi cmd mode
+	 * (3) edp psr mode
+	 */
+	bool hold_mode;
+
+	struct base2_disp_info *disp_info; /* disp_info from baseparameter 2.0 */
+
+	u8 dsc_id;
+	u8 dsc_slice_num;
+	u8 dsc_pixel_num;
+	u64 dsc_txp_clk;
+	u64 dsc_pxl_clk;
+	u64 dsc_cds_clk;
+	struct rockchip_dsc_sink_cap dsc_sink_cap;
+	struct drm_dsc_picture_parameter_set pps;
+
+	struct gpio_desc *te_gpio;
+
+	struct {
+		u32 *lut;
+		int size;
+	} gamma;
+};
+
+struct logo_info {
+	int mode;
+	int rotate;
+	char *mem;
+	bool ymirror;
+	u32 offset;
+	u32 width;
+	int height;
+	u32 bpp;
+};
+
+struct rockchip_logo_cache {
+	struct list_head head;
+	char name[20];
+	struct logo_info logo;
+	int logo_rotate;
+};
+
+struct display_state {
+	struct list_head head;
+
+	const void *blob;
+	ofnode node;
+
+	struct crtc_state crtc_state;
+	struct connector_state conn_state;
+	struct panel_state panel_state;
+
+	char ulogo_name[30];
+	char klogo_name[30];
+
+	struct logo_info logo;
+	int logo_mode;
+	int charge_logo_mode;
+	int logo_rotate;
+	void *mem_base;
+	int mem_size;
+
+	int enable;
+	int is_init;
+	int is_enable;
+	bool is_klogo_valid;
+	bool force_output;
+	bool enabled_at_spl;
+	struct drm_display_mode force_mode;
+	u32 force_bus_format;
+};
+
+int drm_mode_vrefresh(const struct drm_display_mode *mode);
+int display_send_mcu_cmd(struct display_state *state, u32 type, u32 val);
+bool drm_mode_is_420(const struct drm_display_info *display,
+		     struct drm_display_mode *mode);
+struct base2_disp_info *rockchip_get_disp_info(int type, int id);
+
+void drm_mode_max_resolution_filter(struct hdmi_edid_data *edid_data,
+				    struct vop_rect *max_output);
+unsigned long get_cubic_lut_buffer(int crtc_id);
+int rockchip_ofnode_get_display_mode(ofnode node, struct drm_display_mode *mode,
+				     u32 *bus_flags);
+void rockchip_display_make_crc32_table(void);
+uint32_t rockchip_display_crc32c_cal(unsigned char *data, int length);
+void drm_mode_set_crtcinfo(struct drm_display_mode *p, int adjust_flags);
+
+int display_rect_calc_hscale(struct display_rect *src, struct display_rect *dst,
+			     int min_hscale, int max_hscale);
+int display_rect_calc_vscale(struct display_rect *src, struct display_rect *dst,
+			     int min_vscale, int max_vscale);
+struct device_node *
+rockchip_of_graph_get_endpoint_by_regs(ofnode node, int port, int endpoint);
+struct device_node *
+rockchip_of_graph_get_port_by_id(ofnode node, int id);
+uint32_t rockchip_drm_get_cycles_per_pixel(uint32_t bus_format);
+char* rockchip_get_output_if_name(u32 output_if, char *name);
+
+#ifdef CONFIG_SPL_BUILD
+int rockchip_spl_vop_probe(struct crtc_state *crtc_state);
+int rockchip_spl_dw_hdmi_probe(struct connector_state *conn_state);
+int inno_spl_hdmi_phy_probe(struct display_state *state);
+#endif
+#endif
diff --git a/drivers/video/drm/rockchip_display_helper.c b/drivers/video/drm/rockchip_display_helper.c
new file mode 100644
index 0000000000..696f6d4d0a
--- /dev/null
+++ b/drivers/video/drm/rockchip_display_helper.c
@@ -0,0 +1,277 @@
+/*
+ * (C) Copyright 2023 Rockchip Electronics Co., Ltd
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <linux/hdmi.h>
+#include <linux/compat.h>
+#include <linux/bug.h>
+#include "rockchip_display.h"
+#include <spl_display.h>
+
+#define RK_BLK_SIZE 512
+#define BMP_PROCESSED_FLAG 8399
+
+static uint32_t crc32_table[256];
+
+void rockchip_display_make_crc32_table(void)
+{
+	uint32_t c;
+	int n, k;
+	unsigned long poly;		/* polynomial exclusive-or pattern */
+	/* terms of polynomial defining this crc (except x^32): */
+	static const char p[] = {0, 1, 2, 4, 5, 7, 8, 10, 11, 12, 16, 22, 23, 26};
+
+	/* make exclusive-or pattern from polynomial (0xedb88320L) */
+	poly = 0L;
+	for (n = 0; n < sizeof(p) / sizeof(char); n++)
+		poly |= 1L << (31 - p[n]);
+
+	for (n = 0; n < 256; n++) {
+		c = (unsigned long)n;
+		for (k = 0; k < 8; k++)
+		c = c & 1 ? poly ^ (c >> 1) : c >> 1;
+		crc32_table[n] = cpu_to_le32(c);
+	}
+}
+
+uint32_t rockchip_display_crc32c_cal(unsigned char *data, int length)
+{
+	int i;
+	uint32_t crc;
+	crc = 0xFFFFFFFF;
+
+	for (i = 0; i < length; i++) {
+		crc = crc32_table[(crc ^ *data) & 0xff] ^ (crc >> 8);
+		data++;
+	}
+
+	return crc ^ 0xffffffff;
+}
+
+/**
+ * drm_mode_max_resolution_filter - mark modes out of vop max resolution
+ * @edid_data: structure store mode list
+ * @max_output: vop max output resolution
+ */
+void drm_mode_max_resolution_filter(struct hdmi_edid_data *edid_data,
+				    struct vop_rect *max_output)
+{
+	int i;
+
+	for (i = 0; i < edid_data->modes; i++) {
+		if (edid_data->mode_buf[i].hdisplay > max_output->width ||
+		    edid_data->mode_buf[i].vdisplay > max_output->height)
+			edid_data->mode_buf[i].invalid = true;
+	}
+}
+
+int drm_mode_vrefresh(const struct drm_display_mode *mode)
+{
+	int refresh = 0;
+	unsigned int calc_val;
+
+	if (mode->vrefresh > 0) {
+		refresh = mode->vrefresh;
+	} else if (mode->htotal > 0 && mode->vtotal > 0) {
+		int vtotal;
+
+		vtotal = mode->vtotal;
+		/* work out vrefresh the value will be x1000 */
+		calc_val = (mode->clock * 1000);
+		calc_val /= mode->htotal;
+		refresh = (calc_val + vtotal / 2) / vtotal;
+
+		if (mode->flags & DRM_MODE_FLAG_INTERLACE)
+		refresh *= 2;
+		if (mode->flags & DRM_MODE_FLAG_DBLSCAN)
+		refresh /= 2;
+		if (mode->vscan > 1)
+		refresh /= mode->vscan;
+	}
+	return refresh;
+}
+
+/**
+ * drm_mode_set_crtcinfo - set CRTC modesetting timing parameters
+ * @p: mode
+ * @adjust_flags: a combination of adjustment flags
+ *
+ * Setup the CRTC modesetting timing parameters for @p, adjusting if necessary.
+ *
+ * - The CRTC_INTERLACE_HALVE_V flag can be used to halve vertical timings of
+ *   interlaced modes.
+ * - The CRTC_STEREO_DOUBLE flag can be used to compute the timings for
+ *   buffers containing two eyes (only adjust the timings when needed, eg. for
+ *   "frame packing" or "side by side full").
+ * - The CRTC_NO_DBLSCAN and CRTC_NO_VSCAN flags request that adjustment *not*
+ *   be performed for doublescan and vscan > 1 modes respectively.
+ */
+void drm_mode_set_crtcinfo(struct drm_display_mode *p, int adjust_flags)
+{
+	if ((p == NULL) || ((p->type & DRM_MODE_TYPE_CRTC_C) == DRM_MODE_TYPE_BUILTIN))
+		return;
+
+	p->crtc_clock = p->clock;
+	p->crtc_hdisplay = p->hdisplay;
+	p->crtc_hsync_start = p->hsync_start;
+	p->crtc_hsync_end = p->hsync_end;
+	p->crtc_htotal = p->htotal;
+	p->crtc_hskew = p->hskew;
+	p->crtc_vdisplay = p->vdisplay;
+	p->crtc_vsync_start = p->vsync_start;
+	p->crtc_vsync_end = p->vsync_end;
+	p->crtc_vtotal = p->vtotal;
+
+	if (p->flags & DRM_MODE_FLAG_INTERLACE) {
+		if (adjust_flags & CRTC_INTERLACE_HALVE_V) {
+			p->crtc_vdisplay /= 2;
+			p->crtc_vsync_start /= 2;
+			p->crtc_vsync_end /= 2;
+			p->crtc_vtotal /= 2;
+		}
+	}
+
+	if (!(adjust_flags & CRTC_NO_DBLSCAN)) {
+		if (p->flags & DRM_MODE_FLAG_DBLSCAN) {
+			p->crtc_vdisplay *= 2;
+			p->crtc_vsync_start *= 2;
+			p->crtc_vsync_end *= 2;
+			p->crtc_vtotal *= 2;
+		}
+	}
+
+	if (!(adjust_flags & CRTC_NO_VSCAN)) {
+		if (p->vscan > 1) {
+			p->crtc_vdisplay *= p->vscan;
+			p->crtc_vsync_start *= p->vscan;
+			p->crtc_vsync_end *= p->vscan;
+			p->crtc_vtotal *= p->vscan;
+		}
+	}
+
+	if (adjust_flags & CRTC_STEREO_DOUBLE) {
+		unsigned int layout = p->flags & DRM_MODE_FLAG_3D_MASK;
+
+		switch (layout) {
+		case DRM_MODE_FLAG_3D_FRAME_PACKING:
+			p->crtc_clock *= 2;
+			p->crtc_vdisplay += p->crtc_vtotal;
+			p->crtc_vsync_start += p->crtc_vtotal;
+			p->crtc_vsync_end += p->crtc_vtotal;
+			p->crtc_vtotal += p->crtc_vtotal;
+			break;
+		}
+	}
+
+	p->crtc_vblank_start = min(p->crtc_vsync_start, p->crtc_vdisplay);
+	p->crtc_vblank_end = max(p->crtc_vsync_end, p->crtc_vtotal);
+	p->crtc_hblank_start = min(p->crtc_hsync_start, p->crtc_hdisplay);
+	p->crtc_hblank_end = max(p->crtc_hsync_end, p->crtc_htotal);
+}
+
+/**
+ * drm_mode_is_420_only - if a given videomode can be only supported in YCBCR420
+ * output format
+ *
+ * @connector: drm connector under action.
+ * @mode: video mode to be tested.
+ *
+ * Returns:
+ * true if the mode can be supported in YCBCR420 format
+ * false if not.
+ */
+static bool drm_mode_is_420_only(const struct drm_display_info *display,
+			  struct drm_display_mode *mode)
+{
+	u8 vic = drm_match_cea_mode(mode);
+
+	return test_bit(vic, display->hdmi.y420_vdb_modes);
+}
+
+/**
+ * drm_mode_is_420_also - if a given videomode can be supported in YCBCR420
+ * output format also (along with RGB/YCBCR444/422)
+ *
+ * @display: display under action.
+ * @mode: video mode to be tested.
+ *
+ * Returns:
+ * true if the mode can be support YCBCR420 format
+ * false if not.
+ */
+static bool drm_mode_is_420_also(const struct drm_display_info *display,
+			  struct drm_display_mode *mode)
+{
+	u8 vic = drm_match_cea_mode(mode);
+
+	return test_bit(vic, display->hdmi.y420_cmdb_modes);
+}
+
+/**
+ * drm_mode_is_420 - if a given videomode can be supported in YCBCR420
+ * output format
+ *
+ * @display: display under action.
+ * @mode: video mode to be tested.
+ *
+ * Returns:
+ * true if the mode can be supported in YCBCR420 format
+ * false if not.
+ */
+bool drm_mode_is_420(const struct drm_display_info *display,
+		     struct drm_display_mode *mode)
+{
+	return drm_mode_is_420_only(display, mode) ||
+		drm_mode_is_420_also(display, mode);
+}
+
+static int display_rect_calc_scale(int src, int dst)
+{
+	int scale = 0;
+
+	if (WARN_ON(src < 0 || dst < 0))
+		return -EINVAL;
+
+	if (dst == 0)
+		return 0;
+
+	src <<= 16;
+
+	if (src > (dst << 16))
+		return DIV_ROUND_UP(src, dst);
+	else
+		scale = src / dst;
+
+	return scale;
+}
+
+int display_rect_calc_hscale(struct display_rect *src, struct display_rect *dst,
+			     int min_hscale, int max_hscale)
+{
+	int hscale = display_rect_calc_scale(src->w, dst->w);
+
+	if (hscale < 0 || dst->w == 0)
+		return hscale;
+
+	if (hscale < min_hscale || hscale > max_hscale)
+		return -ERANGE;
+
+	return hscale;
+}
+
+int display_rect_calc_vscale(struct display_rect *src, struct display_rect *dst,
+			     int min_vscale, int max_vscale)
+{
+	int vscale = display_rect_calc_scale(src->h, dst->h);
+
+	if (vscale < 0 || dst->h == 0)
+		return vscale;
+
+	if (vscale < min_vscale || vscale > max_vscale)
+		return -ERANGE;
+
+	return vscale;
+}
+
diff --git a/drivers/video/drm/rockchip_dw_hdmi.c b/drivers/video/drm/rockchip_dw_hdmi.c
new file mode 100644
index 0000000000..6e6139f317
--- /dev/null
+++ b/drivers/video/drm/rockchip_dw_hdmi.c
@@ -0,0 +1,722 @@
+/*
+ * (C) Copyright 2008-2017 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <boot_rkimg.h>
+#include <asm/io.h>
+#include <asm/gpio.h>
+#include <dm/of_access.h>
+#include <dm/device.h>
+#include <linux/dw_hdmi.h>
+#include <linux/hdmi.h>
+#include <linux/media-bus-format.h>
+#include "rockchip_display.h"
+#include "rockchip_crtc.h"
+#include "rockchip_connector.h"
+#include "dw_hdmi.h"
+#include "rockchip_dw_hdmi.h"
+
+#define HDMI_SEL_LCDC(x, bit)  ((((x) & 1) << bit) | (1 << (16 + bit)))
+#define RK3288_GRF_SOC_CON6		0x025C
+#define RK3288_HDMI_LCDC_SEL		BIT(4)
+#define RK3399_GRF_SOC_CON20		0x6250
+#define RK3399_HDMI_LCDC_SEL		BIT(6)
+
+#define RK3228_IO_3V_DOMAIN              ((7 << 4) | (7 << (4 + 16)))
+#define RK3328_IO_3V_DOMAIN              (7 << (9 + 16))
+#define RK3328_IO_5V_DOMAIN              ((7 << 9) | (3 << (9 + 16)))
+#define RK3328_IO_CTRL_BY_HDMI           ((1 << 13) | (1 << (13 + 16)))
+#define RK3328_IO_DDC_IN_MSK             ((3 << 10) | (3 << (10 + 16)))
+#define RK3228_IO_DDC_IN_MSK             ((3 << 13) | (3 << (13 + 16)))
+#define RK3228_GRF_SOC_CON2              0x0408
+#define RK3228_GRF_SOC_CON6              0x0418
+#define RK3328_GRF_SOC_CON2              0x0408
+#define RK3328_GRF_SOC_CON3              0x040c
+#define RK3328_GRF_SOC_CON4              0x0410
+
+#define RK3528_GPIO0A_IOMUX_SEL_H	0x4
+#define RK3528_GPIO0A_PULL 		0x200
+#define RK3528_DDC_PULL			(0xf00 << 16)
+#define RK3528_VO_GRF_HDMI_MASK		0x60014
+#define RK3528_HDMI_SNKDET_SEL		((BIT(6) << 16) | BIT(6))
+#define RK3528_HDMI_SNKDET		BIT(21)
+#define RK3528_HDMI_CECIN_MSK		((BIT(2) << 16) | BIT(2))
+#define RK3528_HDMI_SDAIN_MSK		((BIT(1) << 16) | BIT(1))
+#define RK3528_HDMI_SCLIN_MSK		((BIT(0) << 16) | BIT(0))
+
+#define RK3528_GPIO_SWPORT_DR_L		0x0000
+#define RK3528_GPIO0_A2_DR		((BIT(2) << 16) | BIT(2))
+
+#define RK3568_GRF_VO_CON1               0x0364
+#define RK3568_HDMI_SDAIN_MSK            ((1 << 15) | (1 << (15 + 16)))
+#define RK3568_HDMI_SCLIN_MSK            ((1 << 14) | (1 << (14 + 16)))
+
+static const struct dw_hdmi_mpll_config rockchip_mpll_cfg[] = {
+	{
+		30666000, {
+			{ 0x00b3, 0x0000 },
+			{ 0x2153, 0x0000 },
+			{ 0x40f3, 0x0000 },
+		},
+	},  {
+		36800000, {
+			{ 0x00b3, 0x0000 },
+			{ 0x2153, 0x0000 },
+			{ 0x40a2, 0x0001 },
+		},
+	},  {
+		46000000, {
+			{ 0x00b3, 0x0000 },
+			{ 0x2142, 0x0001 },
+			{ 0x40a2, 0x0001 },
+		},
+	},  {
+		61333000, {
+			{ 0x0072, 0x0001 },
+			{ 0x2142, 0x0001 },
+			{ 0x40a2, 0x0001 },
+		},
+	},  {
+		73600000, {
+			{ 0x0072, 0x0001 },
+			{ 0x2142, 0x0001 },
+			{ 0x4061, 0x0002 },
+		},
+	},  {
+		92000000, {
+			{ 0x0072, 0x0001 },
+			{ 0x2145, 0x0002 },
+			{ 0x4061, 0x0002 },
+		},
+	},  {
+		122666000, {
+			{ 0x0051, 0x0002 },
+			{ 0x2145, 0x0002 },
+			{ 0x4061, 0x0002 },
+		},
+	},  {
+		147200000, {
+			{ 0x0051, 0x0002 },
+			{ 0x2145, 0x0002 },
+			{ 0x4064, 0x0003 },
+		},
+	},  {
+		184000000, {
+			{ 0x0051, 0x0002 },
+			{ 0x214c, 0x0003 },
+			{ 0x4064, 0x0003 },
+		},
+	},  {
+		226666000, {
+			{ 0x0040, 0x0003 },
+			{ 0x214c, 0x0003 },
+			{ 0x4064, 0x0003 },
+		},
+	},  {
+		272000000, {
+			{ 0x0040, 0x0003 },
+			{ 0x214c, 0x0003 },
+			{ 0x5a64, 0x0003 },
+		},
+	},  {
+		340000000, {
+			{ 0x0040, 0x0003 },
+			{ 0x3b4c, 0x0003 },
+			{ 0x5a64, 0x0003 },
+		},
+	},  {
+		600000000, {
+			{ 0x1a40, 0x0003 },
+			{ 0x3b4c, 0x0003 },
+			{ 0x5a64, 0x0003 },
+		},
+	},  {
+		~0UL, {
+			{ 0x0000, 0x0000 },
+			{ 0x0000, 0x0000 },
+			{ 0x0000, 0x0000 },
+		},
+	}
+};
+
+static const struct dw_hdmi_mpll_config rockchip_mpll_cfg_420[] = {
+	{
+		30666000, {
+			{ 0x00b7, 0x0000 },
+			{ 0x2157, 0x0000 },
+			{ 0x40f7, 0x0000 },
+		},
+	},  {
+		92000000, {
+			{ 0x00b7, 0x0000 },
+			{ 0x2143, 0x0001 },
+			{ 0x40a3, 0x0001 },
+		},
+	},  {
+		184000000, {
+			{ 0x0073, 0x0001 },
+			{ 0x2146, 0x0002 },
+			{ 0x4062, 0x0002 },
+		},
+	},  {
+		340000000, {
+			{ 0x0052, 0x0003 },
+			{ 0x214d, 0x0003 },
+			{ 0x4065, 0x0003 },
+		},
+	},  {
+		600000000, {
+			{ 0x0041, 0x0003 },
+			{ 0x3b4d, 0x0003 },
+			{ 0x5a65, 0x0003 },
+		},
+	},  {
+		~0UL, {
+			{ 0x0000, 0x0000 },
+			{ 0x0000, 0x0000 },
+			{ 0x0000, 0x0000 },
+		},
+	}
+};
+
+static const struct dw_hdmi_curr_ctrl rockchip_cur_ctr[] = {
+	/*      pixelclk    bpp8    bpp10   bpp12 */
+	{
+		600000000, { 0x0000, 0x0000, 0x0000 },
+	},  {
+		~0UL,      { 0x0000, 0x0000, 0x0000},
+	}
+};
+
+static struct dw_hdmi_phy_config rockchip_phy_config[] = {
+	/*pixelclk   symbol   term   vlev*/
+	{ 74250000,  0x8009, 0x0004, 0x0272},
+	{ 165000000, 0x802b, 0x0004, 0x0209},
+	{ 297000000, 0x8039, 0x0005, 0x028d},
+	{ 594000000, 0x8039, 0x0000, 0x019d},
+	{ ~0UL,	     0x0000, 0x0000, 0x0000},
+	{ ~0UL,	     0x0000, 0x0000, 0x0000}
+};
+
+static unsigned int drm_rk_select_color(struct hdmi_edid_data *edid_data,
+					struct base_screen_info *screen_info,
+					enum dw_hdmi_devtype dev_type,
+					bool output_bus_format_rgb)
+{
+	struct drm_display_info *info = &edid_data->display_info;
+	struct drm_display_mode *mode = edid_data->preferred_mode;
+	int max_tmds_clock = info->max_tmds_clock;
+	bool support_dc = false;
+	bool mode_420 = drm_mode_is_420(info, mode);
+	unsigned int color_depth = 8;
+	unsigned int base_color = DRM_HDMI_OUTPUT_YCBCR444;
+	unsigned int color_format = DRM_HDMI_OUTPUT_DEFAULT_RGB;
+	unsigned long tmdsclock, pixclock = mode->clock;
+
+	if (screen_info)
+		base_color = screen_info->format;
+
+	switch (base_color) {
+	case DRM_HDMI_OUTPUT_YCBCR_HQ:
+		if (info->color_formats & DRM_COLOR_FORMAT_YCRCB444)
+			color_format = DRM_HDMI_OUTPUT_YCBCR444;
+		else if (info->color_formats & DRM_COLOR_FORMAT_YCRCB422)
+			color_format = DRM_HDMI_OUTPUT_YCBCR422;
+		else if (mode_420)
+			color_format = DRM_HDMI_OUTPUT_YCBCR420;
+		break;
+	case DRM_HDMI_OUTPUT_YCBCR_LQ:
+		if (mode_420)
+			color_format = DRM_HDMI_OUTPUT_YCBCR420;
+		else if (info->color_formats & DRM_COLOR_FORMAT_YCRCB422)
+			color_format = DRM_HDMI_OUTPUT_YCBCR422;
+		else if (info->color_formats & DRM_COLOR_FORMAT_YCRCB444)
+			color_format = DRM_HDMI_OUTPUT_YCBCR444;
+		break;
+	case DRM_HDMI_OUTPUT_YCBCR420:
+		if (mode_420)
+			color_format = DRM_HDMI_OUTPUT_YCBCR420;
+		break;
+	case DRM_HDMI_OUTPUT_YCBCR422:
+		if (info->color_formats & DRM_COLOR_FORMAT_YCRCB422)
+			color_format = DRM_HDMI_OUTPUT_YCBCR422;
+		break;
+	case DRM_HDMI_OUTPUT_YCBCR444:
+		if (info->color_formats & DRM_COLOR_FORMAT_YCRCB444)
+			color_format = DRM_HDMI_OUTPUT_YCBCR444;
+		break;
+	case DRM_HDMI_OUTPUT_DEFAULT_RGB:
+	default:
+		break;
+	}
+
+	if (output_bus_format_rgb)
+		color_format = DRM_HDMI_OUTPUT_DEFAULT_RGB;
+
+	if (color_format == DRM_HDMI_OUTPUT_DEFAULT_RGB &&
+	    info->edid_hdmi_dc_modes & DRM_EDID_HDMI_DC_30)
+		support_dc = true;
+	if (color_format == DRM_HDMI_OUTPUT_YCBCR444 &&
+	    (info->edid_hdmi_dc_modes &
+	     (DRM_EDID_HDMI_DC_Y444 | DRM_EDID_HDMI_DC_30)))
+		support_dc = true;
+	if (color_format == DRM_HDMI_OUTPUT_YCBCR422)
+		support_dc = true;
+	if (color_format == DRM_HDMI_OUTPUT_YCBCR420 &&
+	    info->hdmi.y420_dc_modes & DRM_EDID_YCBCR420_DC_30)
+		support_dc = true;
+
+	if (mode->flags & DRM_MODE_FLAG_DBLCLK)
+		pixclock *= 2;
+
+	if (screen_info && screen_info->depth == 10)
+		color_depth = screen_info->depth;
+
+	if (color_format == DRM_HDMI_OUTPUT_YCBCR422 || color_depth == 8)
+		tmdsclock = pixclock;
+	else
+		tmdsclock = pixclock * color_depth / 8;
+
+	if (color_format == DRM_HDMI_OUTPUT_YCBCR420)
+		tmdsclock /= 2;
+
+	if (!max_tmds_clock)
+		max_tmds_clock = 340000;
+
+	switch (dev_type) {
+	case RK3368_HDMI:
+		max_tmds_clock = min(max_tmds_clock, 340000);
+		break;
+	case RK3328_HDMI:
+	case RK3228_HDMI:
+		max_tmds_clock = min(max_tmds_clock, 371250);
+		break;
+	default:
+		max_tmds_clock = min(max_tmds_clock, 594000);
+		break;
+	}
+
+	if (tmdsclock > max_tmds_clock) {
+		if (max_tmds_clock >= 594000) {
+			color_depth = 8;
+		} else if (max_tmds_clock > 340000) {
+			if (drm_mode_is_420(info, mode))
+				color_format = DRM_HDMI_OUTPUT_YCBCR420;
+		} else {
+			color_depth = 8;
+			if (drm_mode_is_420(info, mode))
+				color_format = DRM_HDMI_OUTPUT_YCBCR420;
+		}
+	}
+
+	if (color_depth > 8 && support_dc) {
+		if (dev_type == RK3288_HDMI)
+			return MEDIA_BUS_FMT_RGB101010_1X30;
+		switch (color_format) {
+		case DRM_HDMI_OUTPUT_YCBCR444:
+			return MEDIA_BUS_FMT_YUV10_1X30;
+		case DRM_HDMI_OUTPUT_YCBCR422:
+			return MEDIA_BUS_FMT_UYVY10_1X20;
+		case DRM_HDMI_OUTPUT_YCBCR420:
+			return MEDIA_BUS_FMT_UYYVYY10_0_5X30;
+		default:
+			return MEDIA_BUS_FMT_RGB101010_1X30;
+		}
+	} else {
+		if (dev_type == RK3288_HDMI)
+			return MEDIA_BUS_FMT_RGB888_1X24;
+		switch (color_format) {
+		case DRM_HDMI_OUTPUT_YCBCR444:
+			return MEDIA_BUS_FMT_YUV8_1X24;
+		case DRM_HDMI_OUTPUT_YCBCR422:
+			return MEDIA_BUS_FMT_UYVY8_1X16;
+		case DRM_HDMI_OUTPUT_YCBCR420:
+			return MEDIA_BUS_FMT_UYYVYY8_0_5X24;
+		default:
+			return MEDIA_BUS_FMT_RGB888_1X24;
+		}
+	}
+}
+
+void drm_rk_selete_output(struct hdmi_edid_data *edid_data,
+			  struct connector_state *conn_state,
+			  unsigned int *bus_format,
+			  struct overscan *overscan,
+			  enum dw_hdmi_devtype dev_type,
+			  bool output_bus_format_rgb)
+{
+	struct base2_disp_info *base2_parameter = conn_state->disp_info;
+	const struct base_overscan *scan;
+	struct base_screen_info *screen_info = NULL;
+	struct base2_screen_info *screen_info2 = NULL;
+	int max_scan = 100;
+	int min_scan = 51;
+#ifdef CONFIG_SPL_BUILD
+	int i, screen_size;
+#else
+	int ret, i, screen_size;
+	int offset = 0;
+	bool found = false;
+	struct blk_desc *dev_desc;
+	disk_partition_t part_info;
+	char baseparameter_buf[8 * RK_BLK_SIZE] __aligned(ARCH_DMA_MINALIGN);
+	struct base_disp_info base_parameter;
+#endif
+
+	overscan->left_margin = max_scan;
+	overscan->right_margin = max_scan;
+	overscan->top_margin = max_scan;
+	overscan->bottom_margin = max_scan;
+
+	if (dev_type == RK3288_HDMI || output_bus_format_rgb)
+		*bus_format = MEDIA_BUS_FMT_RGB888_1X24;
+	else
+		*bus_format = MEDIA_BUS_FMT_YUV8_1X24;
+
+#ifdef CONFIG_SPL_BUILD
+	scan = &base2_parameter->overscan_info;
+	screen_size = sizeof(base2_parameter->screen_info) /
+		sizeof(base2_parameter->screen_info[0]);
+
+	for (i = 0; i < screen_size; i++) {
+		if (base2_parameter->screen_info[i].type ==
+		    DRM_MODE_CONNECTOR_HDMIA) {
+			screen_info2 =
+				&base2_parameter->screen_info[i];
+			break;
+		}
+	}
+	screen_info = malloc(sizeof(*screen_info));
+
+	screen_info->type = screen_info2->type;
+	screen_info->mode = screen_info2->resolution;
+	screen_info->format = screen_info2->format;
+	screen_info->depth = screen_info2->depthc;
+	screen_info->feature = screen_info2->feature;
+#else
+	if (!base2_parameter) {
+		dev_desc = rockchip_get_bootdev();
+		if (!dev_desc) {
+			printf("%s: Could not find device\n", __func__);
+			goto null_basep;
+		}
+
+		ret = part_get_info_by_name(dev_desc, "baseparameter",
+					    &part_info);
+		if (ret < 0) {
+			printf("Could not find baseparameter partition\n");
+			goto null_basep;
+		}
+
+read_aux:
+		ret = blk_dread(dev_desc, part_info.start + offset, 1,
+				(void *)baseparameter_buf);
+		if (ret < 0) {
+			printf("read baseparameter failed\n");
+			goto null_basep;
+		}
+
+		memcpy(&base_parameter, baseparameter_buf,
+		       sizeof(base_parameter));
+		scan = &base_parameter.scan;
+
+		screen_size = sizeof(base_parameter.screen_list) /
+			sizeof(base_parameter.screen_list[0]);
+
+		for (i = 0; i < screen_size; i++) {
+			if (base_parameter.screen_list[i].type ==
+			    DRM_MODE_CONNECTOR_HDMIA) {
+				found = true;
+				screen_info = &base_parameter.screen_list[i];
+				break;
+			}
+		}
+
+		if (!found && !offset) {
+			printf("hdmi info isn't saved in main block\n");
+			offset += 16;
+			goto read_aux;
+		}
+	} else {
+		scan = &base2_parameter->overscan_info;
+		screen_size = sizeof(base2_parameter->screen_info) /
+			sizeof(base2_parameter->screen_info[0]);
+
+		for (i = 0; i < screen_size; i++) {
+			if (base2_parameter->screen_info[i].type ==
+			    DRM_MODE_CONNECTOR_HDMIA) {
+				screen_info2 =
+					&base2_parameter->screen_info[i];
+				break;
+			}
+		}
+		screen_info = malloc(sizeof(*screen_info));
+
+		screen_info->type = screen_info2->type;
+		screen_info->mode = screen_info2->resolution;
+		screen_info->format = screen_info2->format;
+		screen_info->depth = screen_info2->depthc;
+		screen_info->feature = screen_info2->feature;
+	}
+#endif
+
+	if (scan->leftscale < min_scan && scan->leftscale > 0)
+		overscan->left_margin = min_scan;
+	else if (scan->leftscale < max_scan && scan->leftscale > 0)
+		overscan->left_margin = scan->leftscale;
+
+	if (scan->rightscale < min_scan && scan->rightscale > 0)
+		overscan->right_margin = min_scan;
+	else if (scan->rightscale < max_scan && scan->rightscale > 0)
+		overscan->right_margin = scan->rightscale;
+
+	if (scan->topscale < min_scan && scan->topscale > 0)
+		overscan->top_margin = min_scan;
+	else if (scan->topscale < max_scan && scan->topscale > 0)
+		overscan->top_margin = scan->topscale;
+
+	if (scan->bottomscale < min_scan && scan->bottomscale > 0)
+		overscan->bottom_margin = min_scan;
+	else if (scan->bottomscale < max_scan && scan->bottomscale > 0)
+		overscan->bottom_margin = scan->bottomscale;
+
+#ifndef CONFIG_SPL_BUILD
+null_basep:
+#endif
+
+	if (screen_info)
+		printf("base_parameter.mode:%dx%d\n",
+		       screen_info->mode.hdisplay,
+		       screen_info->mode.vdisplay);
+	drm_rk_select_mode(edid_data, screen_info);
+
+	*bus_format = drm_rk_select_color(edid_data, screen_info,
+					  dev_type, output_bus_format_rgb);
+}
+
+void inno_dw_hdmi_set_domain(void *grf, int status)
+{
+	if (status)
+		writel(RK3328_IO_5V_DOMAIN, grf + RK3328_GRF_SOC_CON4);
+	else
+		writel(RK3328_IO_3V_DOMAIN, grf + RK3328_GRF_SOC_CON4);
+}
+
+void dw_hdmi_set_iomux(void *grf, void *gpio_base, struct gpio_desc *hpd_gpiod,
+		       int dev_type)
+{
+	u32 val = 0;
+	int i = 400;
+#ifdef CONFIG_SPL_BUILD
+	void *gpio0_ioc = (void *)RK3528_GPIO0_IOC_BASE;
+#endif
+
+	switch (dev_type) {
+	case RK3328_HDMI:
+		writel(RK3328_IO_DDC_IN_MSK, grf + RK3328_GRF_SOC_CON2);
+		writel(RK3328_IO_CTRL_BY_HDMI, grf + RK3328_GRF_SOC_CON3);
+		break;
+	case RK3228_HDMI:
+		writel(RK3228_IO_3V_DOMAIN, grf + RK3228_GRF_SOC_CON6);
+		writel(RK3228_IO_DDC_IN_MSK, grf + RK3228_GRF_SOC_CON2);
+		break;
+	case RK3528_HDMI:
+		writel(RK3528_HDMI_SDAIN_MSK | RK3528_HDMI_SCLIN_MSK |
+		       RK3528_HDMI_SNKDET_SEL,
+		       grf + RK3528_VO_GRF_HDMI_MASK);
+
+#ifdef CONFIG_SPL_BUILD
+		val = (0x11 << 16) | 0x11;
+		writel(val, gpio0_ioc + RK3528_GPIO0A_IOMUX_SEL_H);
+
+		writel(RK3528_DDC_PULL, gpio0_ioc + RK3528_GPIO0A_PULL);
+
+		/* gpio0_a2's input enable is controlled by gpio output data bit */
+		writel(RK3528_GPIO0_A2_DR, gpio_base + RK3528_GPIO_SWPORT_DR_L);
+
+		while (i--) {
+			val = readl(gpio_base + 0x70) & BIT(2);
+			if (val)
+				break;
+			mdelay(5);
+		}
+#else
+		writel(val, grf + RK3528_VO_GRF_HDMI_MASK);
+
+		/* gpio0_a2's input enable is controlled by gpio output data bit */
+		writel(RK3528_GPIO0_A2_DR, gpio_base + RK3528_GPIO_SWPORT_DR_L);
+
+		if (dm_gpio_is_valid(hpd_gpiod)) {
+			while (i--) {
+				val = dm_gpio_get_value(hpd_gpiod);
+				if (val)
+					break;
+				mdelay(5);
+			}
+		}
+#endif
+
+		if (val)
+			val = RK3528_HDMI_SNKDET | BIT(5);
+		else
+			val = RK3528_HDMI_SNKDET;
+		writel(val, grf + RK3528_VO_GRF_HDMI_MASK);
+
+		break;
+	case RK3568_HDMI:
+		writel(RK3568_HDMI_SDAIN_MSK | RK3568_HDMI_SCLIN_MSK,
+		       grf + RK3568_GRF_VO_CON1);
+		break;
+	default:
+		break;
+	}
+}
+
+static const struct dw_hdmi_phy_ops inno_dw_hdmi_phy_ops = {
+	.init = inno_dw_hdmi_phy_init,
+	.disable = inno_dw_hdmi_phy_disable,
+	.read_hpd = inno_dw_hdmi_phy_read_hpd,
+	.mode_valid = inno_dw_hdmi_mode_valid,
+};
+
+static const struct rockchip_connector_funcs rockchip_dw_hdmi_funcs = {
+	.init = rockchip_dw_hdmi_init,
+	.deinit = rockchip_dw_hdmi_deinit,
+	.prepare = rockchip_dw_hdmi_prepare,
+	.enable = rockchip_dw_hdmi_enable,
+	.disable = rockchip_dw_hdmi_disable,
+	.get_timing = rockchip_dw_hdmi_get_timing,
+	.detect = rockchip_dw_hdmi_detect,
+	.get_edid = rockchip_dw_hdmi_get_edid,
+};
+
+const struct dw_hdmi_plat_data rk3288_hdmi_drv_data = {
+	.vop_sel_bit = 4,
+	.grf_vop_sel_reg = RK3288_GRF_SOC_CON6,
+	.mpll_cfg   = rockchip_mpll_cfg,
+	.cur_ctr    = rockchip_cur_ctr,
+	.phy_config = rockchip_phy_config,
+	.dev_type   = RK3288_HDMI,
+};
+
+const struct dw_hdmi_plat_data rk3328_hdmi_drv_data = {
+	.vop_sel_bit = 0,
+	.grf_vop_sel_reg = 0,
+	.phy_ops    = &inno_dw_hdmi_phy_ops,
+	.phy_name   = "inno_dw_hdmi_phy2",
+	.dev_type   = RK3328_HDMI,
+};
+
+const struct dw_hdmi_plat_data rk3228_hdmi_drv_data = {
+	.vop_sel_bit = 0,
+	.grf_vop_sel_reg = 0,
+	.phy_ops    = &inno_dw_hdmi_phy_ops,
+	.phy_name   = "inno_dw_hdmi_phy",
+	.dev_type   = RK3228_HDMI,
+};
+
+const struct dw_hdmi_plat_data rk3368_hdmi_drv_data = {
+	.mpll_cfg   = rockchip_mpll_cfg,
+	.cur_ctr    = rockchip_cur_ctr,
+	.phy_config = rockchip_phy_config,
+	.mpll_cfg_420 = rockchip_mpll_cfg_420,
+	.dev_type   = RK3368_HDMI,
+};
+
+const struct dw_hdmi_plat_data rk3399_hdmi_drv_data = {
+	.vop_sel_bit = 6,
+	.grf_vop_sel_reg = RK3399_GRF_SOC_CON20,
+	.mpll_cfg   = rockchip_mpll_cfg,
+	.cur_ctr    = rockchip_cur_ctr,
+	.phy_config = rockchip_phy_config,
+	.mpll_cfg_420 = rockchip_mpll_cfg_420,
+	.dev_type   = RK3399_HDMI,
+};
+
+const struct dw_hdmi_plat_data rk3528_hdmi_drv_data = {
+	.vop_sel_bit = 0,
+	.grf_vop_sel_reg = 0,
+	.phy_ops    = &inno_dw_hdmi_phy_ops,
+	.phy_name   = "inno_dw_hdmi_phy2",
+	.dev_type   = RK3528_HDMI,
+};
+
+const struct dw_hdmi_plat_data rk3568_hdmi_drv_data = {
+	.vop_sel_bit = 0,
+	.grf_vop_sel_reg = 0,
+	.mpll_cfg   = rockchip_mpll_cfg,
+	.cur_ctr    = rockchip_cur_ctr,
+	.phy_config = rockchip_phy_config,
+	.mpll_cfg_420 = rockchip_mpll_cfg_420,
+	.dev_type   = RK3568_HDMI,
+};
+
+#ifdef CONFIG_SPL_BUILD
+int rockchip_spl_dw_hdmi_probe(struct connector_state *conn_state)
+{
+	conn_state->connector = malloc(sizeof(struct rockchip_connector));
+
+	memset(conn_state->connector, 0, sizeof(*conn_state->connector));
+	rockchip_connector_bind(conn_state->connector, NULL, 0, &rockchip_dw_hdmi_funcs,
+				(void *)&rk3528_hdmi_drv_data,
+				DRM_MODE_CONNECTOR_HDMIA);
+
+	return 0;
+}
+#else
+static int rockchip_dw_hdmi_probe(struct udevice *dev)
+{
+	int id;
+	struct rockchip_connector *conn = dev_get_priv(dev);
+
+	id = of_alias_get_id(ofnode_to_np(dev->node), "hdmi");
+	if (id < 0)
+		id = 0;
+
+	rockchip_connector_bind(conn, dev, id, &rockchip_dw_hdmi_funcs, NULL,
+				DRM_MODE_CONNECTOR_HDMIA);
+
+	return 0;
+}
+#endif
+
+static const struct udevice_id rockchip_dw_hdmi_ids[] = {
+	{
+	 .compatible = "rockchip,rk3528-dw-hdmi",
+	 .data = (ulong)&rk3528_hdmi_drv_data,
+	}, {
+	 .compatible = "rockchip,rk3568-dw-hdmi",
+	 .data = (ulong)&rk3568_hdmi_drv_data,
+	}, {
+	 .compatible = "rockchip,rk3399-dw-hdmi",
+	 .data = (ulong)&rk3399_hdmi_drv_data,
+	}, {
+	 .compatible = "rockchip,rk3368-dw-hdmi",
+	 .data = (ulong)&rk3368_hdmi_drv_data,
+	}, {
+	 .compatible = "rockchip,rk3288-dw-hdmi",
+	 .data = (ulong)&rk3288_hdmi_drv_data,
+	}, {
+	 .compatible = "rockchip,rk3328-dw-hdmi",
+	 .data = (ulong)&rk3328_hdmi_drv_data,
+	}, {
+	 .compatible = "rockchip,rk3128-inno-hdmi",
+	 .data = (ulong)&rk3228_hdmi_drv_data,
+	}, {
+	 .compatible = "rockchip,rk3228-dw-hdmi",
+	 .data = (ulong)&rk3228_hdmi_drv_data,
+	}, {}
+};
+
+U_BOOT_DRIVER(rockchip_dw_hdmi) = {
+	.name = "rockchip_dw_hdmi",
+	.id = UCLASS_DISPLAY,
+	.of_match = rockchip_dw_hdmi_ids,
+#ifndef CONFIG_SPL_BUILD
+	.probe	= rockchip_dw_hdmi_probe,
+#endif
+	.priv_auto_alloc_size = sizeof(struct rockchip_connector),
+};
diff --git a/drivers/video/drm/rockchip_dw_hdmi.h b/drivers/video/drm/rockchip_dw_hdmi.h
new file mode 100644
index 0000000000..7e8ea00465
--- /dev/null
+++ b/drivers/video/drm/rockchip_dw_hdmi.h
@@ -0,0 +1,30 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * (C) Copyright 2021 Fuzhou Rockchip Electronics Co., Ltd
+ */
+#ifndef _ROCKCHIP_DW_HDMI_REG_H_
+#define _ROCKCHIP_DW_HDMI_REG_H_
+
+/*
+ * Rockchip connector callbacks.
+ * If you want to know the details, please refer to rockchip_connector.h
+ */
+int rockchip_dw_hdmi_init(struct rockchip_connector *conn, struct display_state *state);
+void rockchip_dw_hdmi_deinit(struct rockchip_connector *conn, struct display_state *state);
+int rockchip_dw_hdmi_prepare(struct rockchip_connector *conn, struct display_state *state);
+int rockchip_dw_hdmi_enable(struct rockchip_connector *conn, struct display_state *state);
+int rockchip_dw_hdmi_disable(struct rockchip_connector *conn, struct display_state *state);
+int rockchip_dw_hdmi_get_timing(struct rockchip_connector *conn, struct display_state *state);
+int rockchip_dw_hdmi_detect(struct rockchip_connector *conn, struct display_state *state);
+int rockchip_dw_hdmi_get_edid(struct rockchip_connector *conn, struct display_state *state);
+
+enum drm_connector_status
+inno_dw_hdmi_phy_read_hpd(struct dw_hdmi *hdmi,
+			  void *data);
+void inno_dw_hdmi_phy_disable(struct rockchip_connector *conn, struct dw_hdmi *dw_hdmi,
+			      void *data);
+int inno_dw_hdmi_phy_init(struct rockchip_connector *conn, struct dw_hdmi *dw_hdmi,
+			  void *data);
+void inno_dw_hdmi_mode_valid(struct rockchip_connector *conn, struct dw_hdmi *hdmi, void *data);
+
+#endif /* _ROCKCHIP_DW_HDMI_REG_H_ */
diff --git a/drivers/video/drm/rockchip_dw_hdmi_qp.c b/drivers/video/drm/rockchip_dw_hdmi_qp.c
new file mode 100644
index 0000000000..d101c98e14
--- /dev/null
+++ b/drivers/video/drm/rockchip_dw_hdmi_qp.c
@@ -0,0 +1,1330 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2021 Fuzhou Rockchip Electronics Co., Ltd
+ * Author: Algea Cao <algea.cao@rock-chips.com>
+ */
+
+#include <common.h>
+#include <clk.h>
+#include <fdtdec.h>
+#include <regmap.h>
+#include <syscon.h>
+#include <asm/arch-rockchip/clock.h>
+#include <asm/io.h>
+#include <asm-generic/gpio.h>
+#include <dm/of_access.h>
+#include <dm/device.h>
+#include <dm/device_compat.h>
+#include <linux/dw_hdmi.h>
+#include <linux/hdmi.h>
+#include <linux/media-bus-format.h>
+#include "rockchip_display.h"
+#include "rockchip_crtc.h"
+#include "rockchip_connector.h"
+#include "rockchip_phy.h"
+#include "dw_hdmi_qp.h"
+#include "rockchip_dw_hdmi_qp.h"
+
+#define HIWORD_UPDATE(val, mask)	((val) | (mask) << 16)
+
+#define RK3588_GRF_SOC_CON2		0x0308
+#define RK3588_HDMI1_HPD_INT_MSK	BIT(15)
+#define RK3588_HDMI1_HPD_INT_CLR	BIT(14)
+#define RK3588_HDMI0_HPD_INT_MSK	BIT(13)
+#define RK3588_HDMI0_HPD_INT_CLR	BIT(12)
+#define RK3588_GRF_SOC_CON7		0x031c
+#define RK3588_SET_HPD_PATH_MASK	(0x3 << 12)
+#define RK3588_GRF_SOC_STATUS1		0x0384
+#define RK3588_HDMI0_LOW_MORETHAN100MS	BIT(20)
+#define RK3588_HDMI0_HPD_PORT_LEVEL	BIT(19)
+#define RK3588_HDMI0_IHPD_PORT		BIT(18)
+#define RK3588_HDMI0_OHPD_INT		BIT(17)
+#define RK3588_HDMI0_LEVEL_INT		BIT(16)
+#define RK3588_HDMI0_INTR_CHANGE_CNT	(0x7 << 13)
+#define RK3588_HDMI1_LOW_MORETHAN100MS	BIT(28)
+#define RK3588_HDMI1_HPD_PORT_LEVEL	BIT(27)
+#define RK3588_HDMI1_IHPD_PORT		BIT(26)
+#define RK3588_HDMI1_OHPD_INT		BIT(25)
+#define RK3588_HDMI1_LEVEL_INT		BIT(24)
+#define RK3588_HDMI1_INTR_CHANGE_CNT	(0x7 << 21)
+
+#define RK3588_GRF_VO1_CON3		0x000c
+#define RK3588_COLOR_FORMAT_MASK	0xf
+#define RK3588_YUV422			0x1
+#define RK3588_YUV444			0x2
+#define RK3588_YUV420			0x3
+#define RK3588_COMPRESSED_DATA		0xb
+#define RK3588_COLOR_DEPTH_MASK		(0xf << 4)
+#define RK3588_8BPC			0
+#define RK3588_10BPC			(0x6 << 4)
+#define RK3588_CECIN_MASK		BIT(8)
+#define RK3588_SCLIN_MASK		BIT(9)
+#define RK3588_SDAIN_MASK		BIT(10)
+#define RK3588_MODE_MASK		BIT(11)
+#define RK3588_COMPRESS_MODE_MASK	BIT(12)
+#define RK3588_I2S_SEL_MASK		BIT(13)
+#define RK3588_SPDIF_SEL_MASK		BIT(14)
+#define RK3588_GRF_VO1_CON4		0x0010
+#define RK3588_HDMI21_MASK		BIT(0)
+#define RK3588_GRF_VO1_CON9		0x0024
+#define RK3588_HDMI0_GRANT_SEL		BIT(10)
+#define RK3588_HDMI0_GRANT_SW		BIT(11)
+#define RK3588_HDMI1_GRANT_SEL		BIT(12)
+#define RK3588_HDMI1_GRANT_SW		BIT(13)
+#define RK3588_GRF_VO1_CON6		0x0018
+#define RK3588_GRF_VO1_CON7		0x001c
+
+#define PPS_TABLE_LEN 8
+
+#define COLOR_DEPTH_10BIT		BIT(31)
+#define HDMI_FRL_MODE			BIT(30)
+#define HDMI_EARC_MODE			BIT(29)
+#define DATA_RATE_MASK			0xFFFFFFF
+
+#define HDMI20_MAX_RATE			600000
+#define HDMI_8K60_RATE			2376000
+
+enum device_type {
+	RK3588_HDMI
+};
+
+struct pps_data {
+	u32 pic_width;
+	u32 pic_height;
+	u32 slice_width;
+	u32 slice_height;
+	bool convert_rgb;
+	u8 bpc;
+	u8 bpp;
+	u8 raw_pps[128];
+};
+
+enum hdmi_frl_rate_per_lane {
+	FRL_12G_PER_LANE = 12,
+	FRL_10G_PER_LANE = 10,
+	FRL_8G_PER_LANE = 8,
+	FRL_6G_PER_LANE = 6,
+	FRL_3G_PER_LANE = 3,
+};
+
+struct rockchip_hdmi {
+	struct rockchip_connector connector;
+	int id;
+	struct udevice *dev;
+	struct regmap *regmap;
+	struct regmap *vo1_regmap;
+	void *grf;
+	void *vo1_grf;
+
+	unsigned long bus_format;
+	unsigned long output_bus_format;
+	unsigned long enc_out_encoding;
+
+	u8 max_frl_rate_per_lane;
+	u8 max_lanes;
+	bool allm_en;
+	u32 bus_width;
+	struct drm_hdmi_dsc_cap dsc_cap;
+	struct dw_hdmi_link_config link_cfg;
+
+	struct clk link_clk;
+
+	struct gpio_desc enable_gpio;
+};
+
+/*
+ * Selected Rate Control Related Parameter Recommended Values
+ * from DSC_v1.11 spec & C Model release: DSC_model_20161212
+ */
+static struct pps_data pps_datas[PPS_TABLE_LEN] = {
+	{
+		/* 7680x4320/960X96 rgb 8bpc 12bpp */
+		7680, 4320, 960, 96, 1, 8, 192,
+		{
+			0x12, 0x00, 0x00, 0x8d, 0x30, 0xc0, 0x10, 0xe0,
+			0x1e, 0x00, 0x00, 0x60, 0x03, 0xc0, 0x05, 0xa0,
+			0x01, 0x55, 0x03, 0x90, 0x00, 0x0a, 0x05, 0xc9,
+			0x00, 0xa0, 0x00, 0x0f, 0x01, 0x44, 0x01, 0xaa,
+			0x08, 0x00, 0x10, 0xf4, 0x03, 0x0c, 0x20, 0x00,
+			0x06, 0x0b, 0x0b, 0x33, 0x0e, 0x1c, 0x2a, 0x38,
+			0x46, 0x54, 0x62, 0x69, 0x70, 0x77, 0x79, 0x7b,
+			0x7d, 0x7e, 0x00, 0x82, 0x00, 0xc0, 0x09, 0x00,
+			0x09, 0x7e, 0x19, 0xbc, 0x19, 0xba, 0x19, 0xf8,
+			0x1a, 0x38, 0x1a, 0x38, 0x1a, 0x76, 0x2a, 0x76,
+			0x2a, 0x76, 0x2a, 0x74, 0x3a, 0xb4, 0x52, 0xf4,
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+		},
+	},
+	{
+		/* 7680x4320/960X96 rgb 8bpc 11bpp */
+		7680, 4320, 960, 96, 1, 8, 176,
+		{
+			0x12, 0x00, 0x00, 0x8d, 0x30, 0xb0, 0x10, 0xe0,
+			0x1e, 0x00, 0x00, 0x60, 0x03, 0xc0, 0x05, 0x28,
+			0x01, 0x74, 0x03, 0x40, 0x00, 0x0f, 0x06, 0xe0,
+			0x00, 0x2d, 0x00, 0x0f, 0x01, 0x44, 0x01, 0x33,
+			0x0f, 0x00, 0x10, 0xf4, 0x03, 0x0c, 0x20, 0x00,
+			0x06, 0x0b, 0x0b, 0x33, 0x0e, 0x1c, 0x2a, 0x38,
+			0x46, 0x54, 0x62, 0x69, 0x70, 0x77, 0x79, 0x7b,
+			0x7d, 0x7e, 0x00, 0x82, 0x01, 0x00, 0x09, 0x40,
+			0x09, 0xbe, 0x19, 0xfc, 0x19, 0xfa, 0x19, 0xf8,
+			0x1a, 0x38, 0x1a, 0x38, 0x1a, 0x76, 0x2a, 0x76,
+			0x2a, 0x76, 0x2a, 0xb4, 0x3a, 0xb4, 0x52, 0xf4,
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+		},
+	},
+	{
+		/* 7680x4320/960X96 rgb 8bpc 10bpp */
+		7680, 4320, 960, 96, 1, 8, 160,
+		{
+			0x12, 0x00, 0x00, 0x8d, 0x30, 0xa0, 0x10, 0xe0,
+			0x1e, 0x00, 0x00, 0x60, 0x03, 0xc0, 0x04, 0xb0,
+			0x01, 0x9a, 0x02, 0xe0, 0x00, 0x19, 0x09, 0xb0,
+			0x00, 0x12, 0x00, 0x0f, 0x01, 0x44, 0x00, 0xbb,
+			0x16, 0x00, 0x10, 0xec, 0x03, 0x0c, 0x20, 0x00,
+			0x06, 0x0b, 0x0b, 0x33, 0x0e, 0x1c, 0x2a, 0x38,
+			0x46, 0x54, 0x62, 0x69, 0x70, 0x77, 0x79, 0x7b,
+			0x7d, 0x7e, 0x00, 0xc2, 0x01, 0x00, 0x09, 0x40,
+			0x09, 0xbe, 0x19, 0xfc, 0x19, 0xfa, 0x19, 0xf8,
+			0x1a, 0x38, 0x1a, 0x78, 0x1a, 0x76, 0x2a, 0xb6,
+			0x2a, 0xb6, 0x2a, 0xf4, 0x3a, 0xf4, 0x5b, 0x34,
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+		},
+	},
+	{
+		/* 7680x4320/960X96 rgb 8bpc 9bpp */
+		7680, 4320, 960, 96, 1, 8, 144,
+		{
+			0x12, 0x00, 0x00, 0x8d, 0x30, 0x90, 0x10, 0xe0,
+			0x1e, 0x00, 0x00, 0x60, 0x03, 0xc0, 0x04, 0x38,
+			0x01, 0xc7, 0x03, 0x16, 0x00, 0x1c, 0x08, 0xc7,
+			0x00, 0x10, 0x00, 0x0f, 0x01, 0x44, 0x00, 0xaa,
+			0x17, 0x00, 0x10, 0xf1, 0x03, 0x0c, 0x20, 0x00,
+			0x06, 0x0b, 0x0b, 0x33, 0x0e, 0x1c, 0x2a, 0x38,
+			0x46, 0x54, 0x62, 0x69, 0x70, 0x77, 0x79, 0x7b,
+			0x7d, 0x7e, 0x00, 0xc2, 0x01, 0x00, 0x09, 0x40,
+			0x09, 0xbe, 0x19, 0xfc, 0x19, 0xfa, 0x19, 0xf8,
+			0x1a, 0x38, 0x1a, 0x78, 0x1a, 0x76, 0x2a, 0xb6,
+			0x2a, 0xb6, 0x2a, 0xf4, 0x3a, 0xf4, 0x63, 0x74,
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+		},
+	},
+	{
+		/* 7680x4320/960X96 rgb 10bpc 12bpp */
+		7680, 4320, 960, 96, 1, 10, 192,
+		{
+			0x12, 0x00, 0x00, 0xad, 0x30, 0xc0, 0x10, 0xe0,
+			0x1e, 0x00, 0x00, 0x60, 0x03, 0xc0, 0x05, 0xa0,
+			0x01, 0x55, 0x03, 0x90, 0x00, 0x0a, 0x05, 0xc9,
+			0x00, 0xa0, 0x00, 0x0f, 0x01, 0x44, 0x01, 0xaa,
+			0x08, 0x00, 0x10, 0xf4, 0x07, 0x10, 0x20, 0x00,
+			0x06, 0x0f, 0x0f, 0x33, 0x0e, 0x1c, 0x2a, 0x38,
+			0x46, 0x54, 0x62, 0x69, 0x70, 0x77, 0x79, 0x7b,
+			0x7d, 0x7e, 0x01, 0x02, 0x11, 0x80, 0x22, 0x00,
+			0x22, 0x7e, 0x32, 0xbc, 0x32, 0xba, 0x3a, 0xf8,
+			0x3b, 0x38, 0x3b, 0x38, 0x3b, 0x76, 0x4b, 0x76,
+			0x4b, 0x76, 0x4b, 0x74, 0x5b, 0xb4, 0x73, 0xf4,
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+		},
+	},
+	{
+		/* 7680x4320/960X96 rgb 10bpc 11bpp */
+		7680, 4320, 960, 96, 1, 10, 176,
+		{
+			0x12, 0x00, 0x00, 0xad, 0x30, 0xb0, 0x10, 0xe0,
+			0x1e, 0x00, 0x00, 0x60, 0x03, 0xc0, 0x05, 0x28,
+			0x01, 0x74, 0x03, 0x40, 0x00, 0x0f, 0x06, 0xe0,
+			0x00, 0x2d, 0x00, 0x0f, 0x01, 0x44, 0x01, 0x33,
+			0x0f, 0x00, 0x10, 0xf4, 0x07, 0x10, 0x20, 0x00,
+			0x06, 0x0f, 0x0f, 0x33, 0x0e, 0x1c, 0x2a, 0x38,
+			0x46, 0x54, 0x62, 0x69, 0x70, 0x77, 0x79, 0x7b,
+			0x7d, 0x7e, 0x01, 0x42, 0x19, 0xc0, 0x2a, 0x40,
+			0x2a, 0xbe, 0x3a, 0xfc, 0x3a, 0xfa, 0x3a, 0xf8,
+			0x3b, 0x38, 0x3b, 0x38, 0x3b, 0x76, 0x4b, 0x76,
+			0x4b, 0x76, 0x4b, 0xb4, 0x5b, 0xb4, 0x73, 0xf4,
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+		},
+	},
+	{
+		/* 7680x4320/960X96 rgb 10bpc 10bpp */
+		7680, 4320, 960, 96, 1, 10, 160,
+		{
+			0x12, 0x00, 0x00, 0xad, 0x30, 0xa0, 0x10, 0xe0,
+			0x1e, 0x00, 0x00, 0x60, 0x03, 0xc0, 0x04, 0xb0,
+			0x01, 0x9a, 0x02, 0xe0, 0x00, 0x19, 0x09, 0xb0,
+			0x00, 0x12, 0x00, 0x0f, 0x01, 0x44, 0x00, 0xbb,
+			0x16, 0x00, 0x10, 0xec, 0x07, 0x10, 0x20, 0x00,
+			0x06, 0x0f, 0x0f, 0x33, 0x0e, 0x1c, 0x2a, 0x38,
+			0x46, 0x54, 0x62, 0x69, 0x70, 0x77, 0x79, 0x7b,
+			0x7d, 0x7e, 0x01, 0xc2, 0x22, 0x00, 0x2a, 0x40,
+			0x2a, 0xbe, 0x3a, 0xfc, 0x3a, 0xfa, 0x3a, 0xf8,
+			0x3b, 0x38, 0x3b, 0x78, 0x3b, 0x76, 0x4b, 0xb6,
+			0x4b, 0xb6, 0x4b, 0xf4, 0x63, 0xf4, 0x7c, 0x34,
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+		},
+	},
+	{
+		/* 7680x4320/960X96 rgb 10bpc 9bpp */
+		7680, 4320, 960, 96, 1, 10, 144,
+		{
+			0x12, 0x00, 0x00, 0xad, 0x30, 0x90, 0x10, 0xe0,
+			0x1e, 0x00, 0x00, 0x60, 0x03, 0xc0, 0x04, 0x38,
+			0x01, 0xc7, 0x03, 0x16, 0x00, 0x1c, 0x08, 0xc7,
+			0x00, 0x10, 0x00, 0x0f, 0x01, 0x44, 0x00, 0xaa,
+			0x17, 0x00, 0x10, 0xf1, 0x07, 0x10, 0x20, 0x00,
+			0x06, 0x0f, 0x0f, 0x33, 0x0e, 0x1c, 0x2a, 0x38,
+			0x46, 0x54, 0x62, 0x69, 0x70, 0x77, 0x79, 0x7b,
+			0x7d, 0x7e, 0x01, 0xc2, 0x22, 0x00, 0x2a, 0x40,
+			0x2a, 0xbe, 0x3a, 0xfc, 0x3a, 0xfa, 0x3a, 0xf8,
+			0x3b, 0x38, 0x3b, 0x78, 0x3b, 0x76, 0x4b, 0xb6,
+			0x4b, 0xb6, 0x4b, 0xf4, 0x63, 0xf4, 0x84, 0x74,
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+		},
+	},
+};
+
+static bool hdmi_bus_fmt_is_rgb(unsigned int bus_format)
+{
+	switch (bus_format) {
+	case MEDIA_BUS_FMT_RGB888_1X24:
+	case MEDIA_BUS_FMT_RGB101010_1X30:
+	case MEDIA_BUS_FMT_RGB121212_1X36:
+	case MEDIA_BUS_FMT_RGB161616_1X48:
+		return true;
+
+	default:
+		return false;
+	}
+}
+
+static bool hdmi_bus_fmt_is_yuv444(unsigned int bus_format)
+{
+	switch (bus_format) {
+	case MEDIA_BUS_FMT_YUV8_1X24:
+	case MEDIA_BUS_FMT_YUV10_1X30:
+	case MEDIA_BUS_FMT_YUV12_1X36:
+	case MEDIA_BUS_FMT_YUV16_1X48:
+		return true;
+
+	default:
+		return false;
+	}
+}
+
+static bool hdmi_bus_fmt_is_yuv422(unsigned int bus_format)
+{
+	switch (bus_format) {
+	case MEDIA_BUS_FMT_UYVY8_1X16:
+	case MEDIA_BUS_FMT_UYVY10_1X20:
+	case MEDIA_BUS_FMT_UYVY12_1X24:
+	case MEDIA_BUS_FMT_YUYV8_1X16:
+	case MEDIA_BUS_FMT_YUYV10_1X20:
+	case MEDIA_BUS_FMT_YUYV12_1X24:
+		return true;
+
+	default:
+		return false;
+	}
+}
+
+static bool hdmi_bus_fmt_is_yuv420(unsigned int bus_format)
+{
+	switch (bus_format) {
+	case MEDIA_BUS_FMT_UYYVYY8_0_5X24:
+	case MEDIA_BUS_FMT_UYYVYY10_0_5X30:
+	case MEDIA_BUS_FMT_UYYVYY12_0_5X36:
+	case MEDIA_BUS_FMT_UYYVYY16_0_5X48:
+		return true;
+
+	default:
+	return false;
+	}
+}
+
+static int hdmi_bus_fmt_color_depth(unsigned int bus_format)
+{
+	switch (bus_format) {
+	case MEDIA_BUS_FMT_RGB888_1X24:
+	case MEDIA_BUS_FMT_YUV8_1X24:
+	case MEDIA_BUS_FMT_UYVY8_1X16:
+	case MEDIA_BUS_FMT_YUYV8_1X16:
+	case MEDIA_BUS_FMT_UYYVYY8_0_5X24:
+		return 8;
+
+	case MEDIA_BUS_FMT_RGB101010_1X30:
+	case MEDIA_BUS_FMT_YUV10_1X30:
+	case MEDIA_BUS_FMT_UYVY10_1X20:
+	case MEDIA_BUS_FMT_YUYV10_1X20:
+	case MEDIA_BUS_FMT_UYYVYY10_0_5X30:
+		return 10;
+
+	case MEDIA_BUS_FMT_RGB121212_1X36:
+	case MEDIA_BUS_FMT_YUV12_1X36:
+	case MEDIA_BUS_FMT_UYVY12_1X24:
+	case MEDIA_BUS_FMT_YUYV12_1X24:
+	case MEDIA_BUS_FMT_UYYVYY12_0_5X36:
+		return 12;
+
+	case MEDIA_BUS_FMT_RGB161616_1X48:
+	case MEDIA_BUS_FMT_YUV16_1X48:
+	case MEDIA_BUS_FMT_UYYVYY16_0_5X48:
+		return 16;
+
+	default:
+		return 0;
+	}
+}
+
+static unsigned int
+hdmi_get_tmdsclock(struct rockchip_hdmi *hdmi, unsigned long pixelclock)
+{
+	unsigned int tmdsclock = pixelclock;
+	unsigned int depth =
+		hdmi_bus_fmt_color_depth(hdmi->output_bus_format);
+
+	if (!hdmi_bus_fmt_is_yuv422(hdmi->output_bus_format)) {
+		switch (depth) {
+		case 16:
+			tmdsclock = pixelclock * 2;
+			break;
+		case 12:
+			tmdsclock = pixelclock * 3 / 2;
+			break;
+		case 10:
+			tmdsclock = pixelclock * 5 / 4;
+			break;
+		default:
+			break;
+		}
+	}
+
+	return tmdsclock;
+}
+
+static void hdmi_select_link_config(struct rockchip_hdmi *hdmi,
+				    struct drm_display_mode *mode,
+				    unsigned int tmdsclk)
+{
+	int max_lanes, max_rate_per_lane;
+	int max_dsc_lanes, max_dsc_rate_per_lane;
+	unsigned long max_frl_rate;
+
+	max_lanes = hdmi->max_lanes;
+	max_rate_per_lane = hdmi->max_frl_rate_per_lane;
+	max_frl_rate = max_lanes * max_rate_per_lane * 1000000;
+
+	hdmi->link_cfg.dsc_mode = false;
+	hdmi->link_cfg.frl_lanes = max_lanes;
+	hdmi->link_cfg.rate_per_lane = max_rate_per_lane;
+	hdmi->link_cfg.allm_en = hdmi->allm_en;
+
+	if (!max_frl_rate ||
+	    (tmdsclk < HDMI20_MAX_RATE && mode->clock < HDMI20_MAX_RATE)) {
+		printf("%s use tmds mode\n", __func__);
+		hdmi->link_cfg.frl_mode = false;
+		return;
+	}
+
+	hdmi->link_cfg.frl_mode = true;
+
+	if (!hdmi->dsc_cap.v_1p2)
+		return;
+
+	max_dsc_lanes = hdmi->dsc_cap.max_lanes;
+	max_dsc_rate_per_lane =
+		hdmi->dsc_cap.max_frl_rate_per_lane;
+
+	if (mode->clock >= HDMI_8K60_RATE &&
+	    !hdmi_bus_fmt_is_yuv420(hdmi->bus_format) &&
+	    !hdmi_bus_fmt_is_yuv422(hdmi->bus_format)) {
+		hdmi->link_cfg.dsc_mode = true;
+		hdmi->link_cfg.frl_lanes = max_dsc_lanes;
+		hdmi->link_cfg.rate_per_lane = max_dsc_rate_per_lane;
+	} else {
+		hdmi->link_cfg.dsc_mode = false;
+		hdmi->link_cfg.frl_lanes = max_lanes;
+		hdmi->link_cfg.rate_per_lane = max_rate_per_lane;
+	}
+}
+
+/////////////////////////////////////////////////////////////////////////////////////
+
+static int hdmi_dsc_get_slice_height(int vactive)
+{
+	int slice_height;
+
+	/*
+	 * Slice Height determination : HDMI2.1 Section 7.7.5.2
+	 * Select smallest slice height >=96, that results in a valid PPS and
+	 * requires minimum padding lines required for final slice.
+	 *
+	 * Assumption : Vactive is even.
+	 */
+	for (slice_height = 96; slice_height <= vactive; slice_height += 2)
+		if (vactive % slice_height == 0)
+			return slice_height;
+
+	return 0;
+}
+
+static int hdmi_dsc_get_num_slices(struct rockchip_hdmi *hdmi,
+				   struct drm_display_mode *mode,
+				   int src_max_slices, int src_max_slice_width,
+				   int hdmi_max_slices, int hdmi_throughput)
+{
+/* Pixel rates in KPixels/sec */
+#define HDMI_DSC_PEAK_PIXEL_RATE		2720000
+/*
+ * Rates at which the source and sink are required to process pixels in each
+ * slice, can be two levels: either at least 340000KHz or at least 40000KHz.
+ */
+#define HDMI_DSC_MAX_ENC_THROUGHPUT_0		340000
+#define HDMI_DSC_MAX_ENC_THROUGHPUT_1		400000
+
+/* Spec limits the slice width to 2720 pixels */
+#define MAX_HDMI_SLICE_WIDTH			2720
+	int kslice_adjust;
+	int adjusted_clk_khz;
+	int min_slices;
+	int target_slices;
+	int max_throughput; /* max clock freq. in khz per slice */
+	int max_slice_width;
+	int slice_width;
+	int pixel_clock = mode->clock;
+
+	if (!hdmi_throughput)
+		return 0;
+
+	/*
+	 * Slice Width determination : HDMI2.1 Section 7.7.5.1
+	 * kslice_adjust factor for 4:2:0, and 4:2:2 formats is 0.5, where as
+	 * for 4:4:4 is 1.0. Multiplying these factors by 10 and later
+	 * dividing adjusted clock value by 10.
+	 */
+	if (hdmi_bus_fmt_is_yuv444(hdmi->output_bus_format) ||
+	    hdmi_bus_fmt_is_rgb(hdmi->output_bus_format))
+		kslice_adjust = 10;
+	else
+		kslice_adjust = 5;
+
+	/*
+	 * As per spec, the rate at which the source and the sink process
+	 * the pixels per slice are at two levels: at least 340Mhz or 400Mhz.
+	 * This depends upon the pixel clock rate and output formats
+	 * (kslice adjust).
+	 * If pixel clock * kslice adjust >= 2720MHz slices can be processed
+	 * at max 340MHz, otherwise they can be processed at max 400MHz.
+	 */
+
+	adjusted_clk_khz = DIV_ROUND_UP(kslice_adjust * pixel_clock, 10);
+
+	if (adjusted_clk_khz <= HDMI_DSC_PEAK_PIXEL_RATE)
+		max_throughput = HDMI_DSC_MAX_ENC_THROUGHPUT_0;
+	else
+		max_throughput = HDMI_DSC_MAX_ENC_THROUGHPUT_1;
+
+	/*
+	 * Taking into account the sink's capability for maximum
+	 * clock per slice (in MHz) as read from HF-VSDB.
+	 */
+	max_throughput = min(max_throughput, hdmi_throughput * 1000);
+
+	min_slices = DIV_ROUND_UP(adjusted_clk_khz, max_throughput);
+	max_slice_width = min(MAX_HDMI_SLICE_WIDTH, src_max_slice_width);
+
+	/*
+	 * Keep on increasing the num of slices/line, starting from min_slices
+	 * per line till we get such a number, for which the slice_width is
+	 * just less than max_slice_width. The slices/line selected should be
+	 * less than or equal to the max horizontal slices that the combination
+	 * of PCON encoder and HDMI decoder can support.
+	 */
+	do {
+		if (min_slices <= 1 && src_max_slices >= 1 && hdmi_max_slices >= 1)
+			target_slices = 1;
+		else if (min_slices <= 2 && src_max_slices >= 2 && hdmi_max_slices >= 2)
+			target_slices = 2;
+		else if (min_slices <= 4 && src_max_slices >= 4 && hdmi_max_slices >= 4)
+			target_slices = 4;
+		else if (min_slices <= 8 && src_max_slices >= 8 && hdmi_max_slices >= 8)
+			target_slices = 8;
+		else if (min_slices <= 12 && src_max_slices >= 12 && hdmi_max_slices >= 12)
+			target_slices = 12;
+		else if (min_slices <= 16 && src_max_slices >= 16 && hdmi_max_slices >= 16)
+			target_slices = 16;
+		else
+			return 0;
+
+		slice_width = DIV_ROUND_UP(mode->hdisplay, target_slices);
+		if (slice_width > max_slice_width)
+			min_slices = target_slices + 1;
+	} while (slice_width > max_slice_width);
+
+	return target_slices;
+}
+
+static int hdmi_dsc_slices(struct rockchip_hdmi *hdmi,
+			   struct drm_display_mode *mode)
+{
+	int hdmi_throughput = hdmi->dsc_cap.clk_per_slice;
+	int hdmi_max_slices = hdmi->dsc_cap.max_slices;
+	int rk_max_slices = 8;
+	int rk_max_slice_width = 2048;
+
+	return hdmi_dsc_get_num_slices(hdmi, mode, rk_max_slices,
+				       rk_max_slice_width,
+				       hdmi_max_slices, hdmi_throughput);
+}
+
+static int
+hdmi_dsc_get_bpp(struct rockchip_hdmi *hdmi, int src_fractional_bpp,
+		 int slice_width, int num_slices, bool hdmi_all_bpp,
+		 int hdmi_max_chunk_bytes)
+{
+	int max_dsc_bpp, min_dsc_bpp;
+	int target_bytes;
+	bool bpp_found = false;
+	int bpp_decrement_x16;
+	int bpp_target;
+	int bpp_target_x16;
+
+	/*
+	 * Get min bpp and max bpp as per Table 7.23, in HDMI2.1 spec
+	 * Start with the max bpp and keep on decrementing with
+	 * fractional bpp, if supported by PCON DSC encoder
+	 *
+	 * for each bpp we check if no of bytes can be supported by HDMI sink
+	 */
+
+	/* only 9\10\12 bpp was tested */
+	min_dsc_bpp = 9;
+	max_dsc_bpp = 12;
+
+	/*
+	 * Taking into account if all dsc_all_bpp supported by HDMI2.1 sink
+	 * Section 7.7.34 : Source shall not enable compressed Video
+	 * Transport with bpp_target settings above 12 bpp unless
+	 * DSC_all_bpp is set to 1.
+	 */
+	if (!hdmi_all_bpp)
+		max_dsc_bpp = min(max_dsc_bpp, 12);
+
+	/*
+	 * The Sink has a limit of compressed data in bytes for a scanline,
+	 * as described in max_chunk_bytes field in HFVSDB block of edid.
+	 * The no. of bytes depend on the target bits per pixel that the
+	 * source configures. So we start with the max_bpp and calculate
+	 * the target_chunk_bytes. We keep on decrementing the target_bpp,
+	 * till we get the target_chunk_bytes just less than what the sink's
+	 * max_chunk_bytes, or else till we reach the min_dsc_bpp.
+	 *
+	 * The decrement is according to the fractional support from PCON DSC
+	 * encoder. For fractional BPP we use bpp_target as a multiple of 16.
+	 *
+	 * bpp_target_x16 = bpp_target * 16
+	 * So we need to decrement by {1, 2, 4, 8, 16} for fractional bpps
+	 * {1/16, 1/8, 1/4, 1/2, 1} respectively.
+	 */
+
+	bpp_target = max_dsc_bpp;
+
+	/* src does not support fractional bpp implies decrement by 16 for bppx16 */
+	if (!src_fractional_bpp)
+		src_fractional_bpp = 1;
+	bpp_decrement_x16 = DIV_ROUND_UP(16, src_fractional_bpp);
+	bpp_target_x16 = bpp_target * 16;
+
+	while (bpp_target_x16 > (min_dsc_bpp * 16)) {
+		int bpp;
+
+		bpp = DIV_ROUND_UP(bpp_target_x16, 16);
+		target_bytes = DIV_ROUND_UP((num_slices * slice_width * bpp), 8);
+		if (target_bytes <= hdmi_max_chunk_bytes) {
+			bpp_found = true;
+			break;
+		}
+		bpp_target_x16 -= bpp_decrement_x16;
+	}
+	if (bpp_found)
+		return bpp_target_x16;
+
+	return 0;
+}
+
+static int
+dw_hdmi_dsc_bpp(struct rockchip_hdmi *hdmi,
+		int num_slices, int slice_width)
+{
+	bool hdmi_all_bpp = hdmi->dsc_cap.all_bpp;
+	int fractional_bpp = 0;
+	int hdmi_max_chunk_bytes = hdmi->dsc_cap.total_chunk_kbytes * 1024;
+
+	return hdmi_dsc_get_bpp(hdmi, fractional_bpp, slice_width,
+				num_slices, hdmi_all_bpp,
+				hdmi_max_chunk_bytes);
+}
+
+static int dw_hdmi_qp_set_link_cfg(struct rockchip_hdmi *hdmi,
+				   u16 pic_width, u16 pic_height,
+				   u16 slice_width, u16 slice_height,
+				   u16 bits_per_pixel, u8 bits_per_component)
+{
+	int i;
+
+	for (i = 0; i < PPS_TABLE_LEN; i++)
+		if (pic_width == pps_datas[i].pic_width &&
+		    pic_height == pps_datas[i].pic_height &&
+		    slice_width == pps_datas[i].slice_width &&
+		    slice_height == pps_datas[i].slice_height &&
+		    bits_per_component == pps_datas[i].bpc &&
+		    bits_per_pixel == pps_datas[i].bpp &&
+		    hdmi_bus_fmt_is_rgb(hdmi->output_bus_format) == pps_datas[i].convert_rgb)
+			break;
+
+	if (i == PPS_TABLE_LEN) {
+		dev_err(hdmi->dev, "can't find pps cfg!\n");
+		return -EINVAL;
+	}
+
+	memcpy(hdmi->link_cfg.pps_payload, pps_datas[i].raw_pps, 128);
+	hdmi->link_cfg.hcactive = DIV_ROUND_UP(slice_width * (bits_per_pixel / 16), 8) *
+		(pic_width / slice_width);
+
+	return 0;
+}
+
+static void dw_hdmi_qp_dsc_configure(struct rockchip_hdmi *hdmi,
+				     struct drm_display_mode *mode)
+{
+	int ret;
+	int slice_height;
+	int slice_width;
+	int bits_per_pixel;
+	int slice_count;
+	bool hdmi_is_dsc_1_2;
+	unsigned int depth = hdmi_bus_fmt_color_depth(hdmi->output_bus_format);
+
+	hdmi_is_dsc_1_2 = hdmi->dsc_cap.v_1p2;
+
+	if (!hdmi_is_dsc_1_2)
+		return;
+
+	slice_height = hdmi_dsc_get_slice_height(mode->vdisplay);
+	if (!slice_height)
+		return;
+
+	slice_count = hdmi_dsc_slices(hdmi, mode);
+	if (!slice_count)
+		return;
+
+	slice_width = DIV_ROUND_UP(mode->hdisplay, slice_count);
+
+	bits_per_pixel = dw_hdmi_dsc_bpp(hdmi, slice_count, slice_width);
+	if (!bits_per_pixel)
+		return;
+
+	ret = dw_hdmi_qp_set_link_cfg(hdmi, mode->hdisplay,
+				      mode->vdisplay, slice_width,
+				      slice_height, bits_per_pixel, depth);
+
+	if (ret) {
+		dev_err(hdmi->dev, "set vdsc cfg failed\n");
+		return;
+	}
+	printf("dsc_enable\n");
+}
+
+static unsigned int drm_rk_select_color(struct hdmi_edid_data *edid_data,
+					struct base_screen_info *screen_info,
+					enum dw_hdmi_devtype dev_type,
+					bool output_bus_format_rgb)
+{
+	struct drm_display_info *info = &edid_data->display_info;
+	struct drm_display_mode *mode = edid_data->preferred_mode;
+	struct drm_hdmi_info *hdmi_info = &edid_data->display_info.hdmi;
+	int max_tmds_clock = info->max_tmds_clock;
+	bool support_dc = false;
+	bool mode_420 = drm_mode_is_420(info, mode);
+	unsigned int color_depth = 8;
+	unsigned int base_color = DRM_HDMI_OUTPUT_YCBCR444;
+	unsigned int color_format = DRM_HDMI_OUTPUT_DEFAULT_RGB;
+	unsigned long tmdsclock, pixclock = mode->clock;
+
+	if (screen_info)
+		base_color = screen_info->format;
+
+	switch (base_color) {
+	case DRM_HDMI_OUTPUT_YCBCR_HQ:
+		if (info->color_formats & DRM_COLOR_FORMAT_YCRCB444)
+			color_format = DRM_HDMI_OUTPUT_YCBCR444;
+		else if (info->color_formats & DRM_COLOR_FORMAT_YCRCB422)
+			color_format = DRM_HDMI_OUTPUT_YCBCR422;
+		else if (mode_420 && pixclock >= 340000)
+			color_format = DRM_HDMI_OUTPUT_YCBCR420;
+		break;
+	case DRM_HDMI_OUTPUT_YCBCR_LQ:
+		if (mode_420 && pixclock >= 340000)
+			color_format = DRM_HDMI_OUTPUT_YCBCR420;
+		else if (info->color_formats & DRM_COLOR_FORMAT_YCRCB422)
+			color_format = DRM_HDMI_OUTPUT_YCBCR422;
+		else if (info->color_formats & DRM_COLOR_FORMAT_YCRCB444)
+			color_format = DRM_HDMI_OUTPUT_YCBCR444;
+		break;
+	case DRM_HDMI_OUTPUT_YCBCR420:
+		if (mode_420 && pixclock >= 340000)
+			color_format = DRM_HDMI_OUTPUT_YCBCR420;
+		break;
+	case DRM_HDMI_OUTPUT_YCBCR422:
+		if (info->color_formats & DRM_COLOR_FORMAT_YCRCB422)
+			color_format = DRM_HDMI_OUTPUT_YCBCR422;
+		break;
+	case DRM_HDMI_OUTPUT_YCBCR444:
+		if (info->color_formats & DRM_COLOR_FORMAT_YCRCB444)
+			color_format = DRM_HDMI_OUTPUT_YCBCR444;
+		break;
+	case DRM_HDMI_OUTPUT_DEFAULT_RGB:
+	default:
+		break;
+	}
+
+	if (output_bus_format_rgb)
+		color_format = DRM_HDMI_OUTPUT_DEFAULT_RGB;
+
+	if (color_format == DRM_HDMI_OUTPUT_DEFAULT_RGB &&
+	    info->edid_hdmi_dc_modes & DRM_EDID_HDMI_DC_30)
+		support_dc = true;
+	if (color_format == DRM_HDMI_OUTPUT_YCBCR444 &&
+	    (info->edid_hdmi_dc_modes &
+	     (DRM_EDID_HDMI_DC_Y444 | DRM_EDID_HDMI_DC_30)))
+		support_dc = true;
+	if (color_format == DRM_HDMI_OUTPUT_YCBCR422)
+		support_dc = true;
+	if (color_format == DRM_HDMI_OUTPUT_YCBCR420 &&
+	    info->hdmi.y420_dc_modes & DRM_EDID_YCBCR420_DC_30)
+		support_dc = true;
+
+	if (mode->flags & DRM_MODE_FLAG_DBLCLK)
+		pixclock *= 2;
+
+	if (screen_info && screen_info->depth == 10)
+		color_depth = screen_info->depth;
+
+	if (mode->clock >= 600000)
+		color_format = DRM_HDMI_OUTPUT_YCBCR420;
+
+	if (color_format == DRM_HDMI_OUTPUT_YCBCR422 || color_depth == 8)
+		tmdsclock = pixclock;
+	else
+		tmdsclock = pixclock * color_depth / 8;
+
+	if (color_format == DRM_HDMI_OUTPUT_YCBCR420)
+		tmdsclock /= 2;
+
+	if (!max_tmds_clock)
+		max_tmds_clock = 340000;
+
+	if (hdmi_info->max_frl_rate_per_lane && mode->clock > 600000)
+		max_tmds_clock =
+			hdmi_info->max_lanes * hdmi_info->max_frl_rate_per_lane *
+				1000000;
+
+	if (tmdsclock > max_tmds_clock) {
+		if (max_tmds_clock >= 594000) {
+			color_depth = 8;
+		} else if (max_tmds_clock > 340000) {
+			if (drm_mode_is_420(info, mode) || tmdsclock >= 594000)
+				color_format = DRM_HDMI_OUTPUT_YCBCR420;
+		} else {
+			color_depth = 8;
+			if (drm_mode_is_420(info, mode) || tmdsclock >= 594000)
+				color_format = DRM_HDMI_OUTPUT_YCBCR420;
+		}
+	}
+
+	printf("color_format:%x\n", color_format);
+	if (color_depth > 8 && support_dc) {
+		switch (color_format) {
+		case DRM_HDMI_OUTPUT_YCBCR444:
+			return MEDIA_BUS_FMT_YUV10_1X30;
+		case DRM_HDMI_OUTPUT_YCBCR422:
+			return MEDIA_BUS_FMT_YUYV10_1X20;
+		case DRM_HDMI_OUTPUT_YCBCR420:
+			return MEDIA_BUS_FMT_UYYVYY10_0_5X30;
+		default:
+			return MEDIA_BUS_FMT_RGB101010_1X30;
+		}
+	} else {
+		switch (color_format) {
+		case DRM_HDMI_OUTPUT_YCBCR444:
+			return MEDIA_BUS_FMT_YUV8_1X24;
+		case DRM_HDMI_OUTPUT_YCBCR422:
+			return MEDIA_BUS_FMT_YUYV8_1X16;
+		case DRM_HDMI_OUTPUT_YCBCR420:
+			return MEDIA_BUS_FMT_UYYVYY8_0_5X24;
+		default:
+			return MEDIA_BUS_FMT_RGB888_1X24;
+		}
+	}
+}
+
+#define SUPPORT_HDMI_ALLM	BIT(1)
+
+void dw_hdmi_qp_selete_output(struct hdmi_edid_data *edid_data,
+			      struct rockchip_connector *conn,
+			      unsigned int *bus_format,
+			      struct overscan *overscan,
+			      enum dw_hdmi_devtype dev_type,
+			      bool output_bus_format_rgb,
+			      void *data, struct display_state *state)
+{
+	struct rockchip_hdmi *hdmi = (struct rockchip_hdmi *)data;
+	struct drm_hdmi_info *hdmi_info = &edid_data->display_info.hdmi;
+	int i, screen_size;
+	struct base2_disp_info *base2_parameter = state->conn_state.disp_info;
+	const struct base_overscan *scan;
+	struct base_screen_info *screen_info = NULL;
+	struct base2_screen_info *screen_info2 = NULL;
+	int max_scan = 100;
+	int min_scan = 51;
+	int color_depth;
+	unsigned int tmdsclk;
+	unsigned int pixel_clk;
+
+	overscan->left_margin = max_scan;
+	overscan->right_margin = max_scan;
+	overscan->top_margin = max_scan;
+	overscan->bottom_margin = max_scan;
+
+	hdmi->max_frl_rate_per_lane = hdmi_info->max_frl_rate_per_lane;
+	hdmi->max_lanes = hdmi_info->max_lanes;
+	memcpy(&hdmi->dsc_cap, &hdmi_info->dsc_cap, sizeof(struct drm_hdmi_dsc_cap));
+
+	if (output_bus_format_rgb)
+		*bus_format = MEDIA_BUS_FMT_RGB888_1X24;
+	else
+		*bus_format = MEDIA_BUS_FMT_YUV8_1X24;
+
+	if (base2_parameter) {
+		bool allm_en = false;
+
+		scan = &base2_parameter->overscan_info;
+		screen_size = sizeof(base2_parameter->screen_info) /
+			sizeof(base2_parameter->screen_info[0]);
+
+		for (i = 0; i < screen_size; i++) {
+			if (base2_parameter->screen_info[i].type ==
+			    DRM_MODE_CONNECTOR_HDMIA) {
+				screen_info2 =
+					&base2_parameter->screen_info[i];
+				break;
+			}
+		}
+		screen_info = malloc(sizeof(*screen_info));
+
+		screen_info->type = screen_info2->type;
+		screen_info->mode = screen_info2->resolution;
+		screen_info->format = screen_info2->format;
+		screen_info->depth = screen_info2->depthc;
+		screen_info->feature = screen_info2->feature;
+
+		/* check if allm is enabled */
+		allm_en = base2_parameter->reserved[0] & BIT(0);
+		if (allm_en && (hdmi_info->add_func & SUPPORT_HDMI_ALLM))
+			hdmi->allm_en = true;
+		else
+			hdmi->allm_en = false;
+	}
+
+	if (scan->leftscale < min_scan && scan->leftscale > 0)
+		overscan->left_margin = min_scan;
+	else if (scan->leftscale < max_scan && scan->leftscale > 0)
+		overscan->left_margin = scan->leftscale;
+
+	if (scan->rightscale < min_scan && scan->rightscale > 0)
+		overscan->right_margin = min_scan;
+	else if (scan->rightscale < max_scan && scan->rightscale > 0)
+		overscan->right_margin = scan->rightscale;
+
+	if (scan->topscale < min_scan && scan->topscale > 0)
+		overscan->top_margin = min_scan;
+	else if (scan->topscale < max_scan && scan->topscale > 0)
+		overscan->top_margin = scan->topscale;
+
+	if (scan->bottomscale < min_scan && scan->bottomscale > 0)
+		overscan->bottom_margin = min_scan;
+	else if (scan->bottomscale < max_scan && scan->bottomscale > 0)
+		overscan->bottom_margin = scan->bottomscale;
+
+	if (screen_info)
+		printf("base_parameter.mode:%dx%d\n",
+		       screen_info->mode.hdisplay,
+		       screen_info->mode.vdisplay);
+	drm_rk_select_mode(edid_data, screen_info);
+
+	*bus_format = drm_rk_select_color(edid_data, screen_info,
+					  dev_type, output_bus_format_rgb);
+
+	if (state->force_output) {
+		memcpy(edid_data->preferred_mode, &state->force_mode,
+		       sizeof(struct drm_display_mode));
+		if (state->force_bus_format)
+			*bus_format = state->force_bus_format;
+	}
+
+	hdmi->bus_format = *bus_format;
+	color_depth = hdmi_bus_fmt_color_depth(*bus_format);
+	pixel_clk = edid_data->preferred_mode->clock;
+	tmdsclk = hdmi_get_tmdsclock(hdmi, pixel_clk);
+	if (hdmi_bus_fmt_is_yuv420(hdmi->output_bus_format))
+		tmdsclk /= 2;
+	hdmi_select_link_config(hdmi, edid_data->preferred_mode, tmdsclk);
+	dw_hdmi_qp_dsc_configure(hdmi, edid_data->preferred_mode);
+	if (hdmi->link_cfg.frl_mode) {
+		if (dm_gpio_is_valid(&hdmi->enable_gpio))
+			dm_gpio_set_value(&hdmi->enable_gpio, 0);
+		/* in the current version, support max 40G frl */
+		if (hdmi->link_cfg.rate_per_lane >= 10) {
+			hdmi->link_cfg.frl_lanes = 4;
+			hdmi->link_cfg.rate_per_lane = 10;
+		}
+		hdmi->bus_width = hdmi->link_cfg.frl_lanes *
+			hdmi->link_cfg.rate_per_lane * 1000000;
+		/* 10 bit color depth and frl mode */
+		if (color_depth == 10)
+			hdmi->bus_width |=
+				COLOR_DEPTH_10BIT | HDMI_FRL_MODE;
+		else
+			hdmi->bus_width |= HDMI_FRL_MODE;
+	} else {
+		if (dm_gpio_is_valid(&hdmi->enable_gpio))
+			dm_gpio_set_value(&hdmi->enable_gpio, 1);
+		hdmi->bus_width =
+			hdmi_get_tmdsclock(hdmi, pixel_clk * 10);
+		if (hdmi_bus_fmt_is_yuv420(*bus_format))
+			hdmi->bus_width /= 2;
+
+		if (color_depth == 10 && !hdmi_bus_fmt_is_yuv422(*bus_format))
+			hdmi->bus_width |= COLOR_DEPTH_10BIT;
+	}
+
+	rockchip_phy_set_bus_width(conn->phy, hdmi->bus_width);
+}
+
+bool dw_hdmi_qp_check_enable_gpio(void *data)
+{
+	struct rockchip_hdmi *hdmi = (struct rockchip_hdmi *)data;
+
+	if (!hdmi->enable_gpio.dev)
+		return false;
+	else
+		return true;
+}
+
+static void rk3588_set_link_mode(struct rockchip_hdmi *hdmi)
+{
+	int val;
+	bool is_hdmi0;
+
+	if (!hdmi->id)
+		is_hdmi0 = true;
+	else
+		is_hdmi0 = false;
+
+	if (!hdmi->link_cfg.frl_mode) {
+		val = HIWORD_UPDATE(0, RK3588_HDMI21_MASK);
+		if (is_hdmi0)
+			writel(val, hdmi->vo1_grf + RK3588_GRF_VO1_CON4);
+		else
+			writel(val, hdmi->vo1_grf + RK3588_GRF_VO1_CON7);
+
+		val = HIWORD_UPDATE(0, RK3588_COMPRESS_MODE_MASK | RK3588_COLOR_FORMAT_MASK);
+		if (is_hdmi0)
+			writel(val, hdmi->vo1_grf + RK3588_GRF_VO1_CON3);
+		else
+			writel(val, hdmi->vo1_grf + RK3588_GRF_VO1_CON6);
+
+		return;
+	}
+
+	val = HIWORD_UPDATE(RK3588_HDMI21_MASK, RK3588_HDMI21_MASK);
+	if (is_hdmi0)
+		writel(val, hdmi->vo1_grf + RK3588_GRF_VO1_CON4);
+	else
+		writel(val, hdmi->vo1_grf + RK3588_GRF_VO1_CON7);
+
+	if (hdmi->link_cfg.dsc_mode) {
+		val = HIWORD_UPDATE(RK3588_COMPRESS_MODE_MASK | RK3588_COMPRESSED_DATA,
+				    RK3588_COMPRESS_MODE_MASK | RK3588_COLOR_FORMAT_MASK);
+		if (is_hdmi0)
+			writel(val, hdmi->vo1_grf + RK3588_GRF_VO1_CON3);
+		else
+			writel(val, hdmi->vo1_grf + RK3588_GRF_VO1_CON6);
+	} else {
+		val = HIWORD_UPDATE(0, RK3588_COMPRESS_MODE_MASK | RK3588_COLOR_FORMAT_MASK);
+		if (is_hdmi0)
+			writel(val, hdmi->vo1_grf + RK3588_GRF_VO1_CON3);
+		else
+			writel(val, hdmi->vo1_grf + RK3588_GRF_VO1_CON6);
+	}
+}
+
+static void rk3588_set_color_format(struct rockchip_hdmi *hdmi, u64 bus_format,
+				    u32 depth)
+{
+	u32 val = 0;
+
+	switch (bus_format) {
+	case MEDIA_BUS_FMT_RGB888_1X24:
+	case MEDIA_BUS_FMT_RGB101010_1X30:
+		val = HIWORD_UPDATE(0, RK3588_COLOR_FORMAT_MASK);
+		break;
+	case MEDIA_BUS_FMT_UYYVYY8_0_5X24:
+	case MEDIA_BUS_FMT_UYYVYY10_0_5X30:
+		val = HIWORD_UPDATE(RK3588_YUV420, RK3588_COLOR_FORMAT_MASK);
+		break;
+	case MEDIA_BUS_FMT_YUV8_1X24:
+	case MEDIA_BUS_FMT_YUV10_1X30:
+		val = HIWORD_UPDATE(RK3588_YUV444, RK3588_COLOR_FORMAT_MASK);
+		break;
+	case MEDIA_BUS_FMT_YUYV10_1X20:
+	case MEDIA_BUS_FMT_YUYV8_1X16:
+		val = HIWORD_UPDATE(RK3588_YUV422, RK3588_COLOR_FORMAT_MASK);
+		break;
+	default:
+		dev_err(hdmi->dev, "can't set correct color format\n");
+		return;
+	}
+
+	if (hdmi->link_cfg.dsc_mode)
+		val = HIWORD_UPDATE(RK3588_COMPRESSED_DATA, RK3588_COLOR_FORMAT_MASK);
+
+	if (depth == 8 || bus_format == MEDIA_BUS_FMT_YUYV10_1X20)
+		val |= HIWORD_UPDATE(RK3588_8BPC, RK3588_COLOR_DEPTH_MASK);
+	else
+		val |= HIWORD_UPDATE(RK3588_10BPC, RK3588_COLOR_DEPTH_MASK);
+
+	if (!hdmi->id)
+		writel(val, hdmi->vo1_grf + RK3588_GRF_VO1_CON3);
+	else
+		writel(val, hdmi->vo1_grf + RK3588_GRF_VO1_CON6);
+}
+
+void rk3588_set_grf_cfg(void *data)
+{
+	struct rockchip_hdmi *hdmi = (struct rockchip_hdmi *)data;
+	int color_depth;
+
+	rk3588_set_link_mode(hdmi);
+	color_depth = hdmi_bus_fmt_color_depth(hdmi->bus_format);
+	rk3588_set_color_format(hdmi, hdmi->bus_format, color_depth);
+}
+
+void dw_hdmi_qp_set_iomux(void *data)
+{
+	struct rockchip_hdmi *hdmi = (struct rockchip_hdmi *)data;
+	u32 val;
+
+	if (!hdmi->id) {
+		val = HIWORD_UPDATE(RK3588_SCLIN_MASK, RK3588_SCLIN_MASK) |
+		      HIWORD_UPDATE(RK3588_SDAIN_MASK, RK3588_SDAIN_MASK) |
+		      HIWORD_UPDATE(RK3588_MODE_MASK, RK3588_MODE_MASK) |
+		      HIWORD_UPDATE(RK3588_I2S_SEL_MASK, RK3588_I2S_SEL_MASK);
+		writel(val, hdmi->vo1_grf + RK3588_GRF_VO1_CON3);
+
+		val = HIWORD_UPDATE(RK3588_SET_HPD_PATH_MASK,
+				    RK3588_SET_HPD_PATH_MASK);
+		writel(val, hdmi->grf + RK3588_GRF_SOC_CON7);
+
+		val = HIWORD_UPDATE(RK3588_HDMI0_GRANT_SEL,
+				    RK3588_HDMI0_GRANT_SEL);
+		writel(val, hdmi->vo1_grf + RK3588_GRF_VO1_CON9);
+	} else {
+		val = HIWORD_UPDATE(RK3588_SCLIN_MASK, RK3588_SCLIN_MASK) |
+		      HIWORD_UPDATE(RK3588_SDAIN_MASK, RK3588_SDAIN_MASK) |
+		      HIWORD_UPDATE(RK3588_MODE_MASK, RK3588_MODE_MASK) |
+		      HIWORD_UPDATE(RK3588_I2S_SEL_MASK, RK3588_I2S_SEL_MASK);
+		writel(val, hdmi->vo1_grf + RK3588_GRF_VO1_CON6);
+
+		val = HIWORD_UPDATE(RK3588_SET_HPD_PATH_MASK,
+				    RK3588_SET_HPD_PATH_MASK);
+		writel(val, hdmi->grf + RK3588_GRF_SOC_CON7);
+
+		val = HIWORD_UPDATE(RK3588_HDMI1_GRANT_SEL,
+				    RK3588_HDMI1_GRANT_SEL);
+		writel(val, hdmi->vo1_grf + RK3588_GRF_VO1_CON9);
+	}
+}
+
+struct dw_hdmi_link_config *dw_hdmi_rockchip_get_link_cfg(void *data)
+{
+	struct rockchip_hdmi *hdmi = (struct rockchip_hdmi *)data;
+
+	return &hdmi->link_cfg;
+}
+
+static void dw_hdmi_qp_rockchip_phy_disable(struct rockchip_connector *conn, void *data,
+					    void *state)
+{
+	rockchip_phy_power_off(conn->phy);
+}
+
+static int dw_hdmi_qp_rockchip_genphy_init(struct rockchip_connector *conn, void *data, void *state)
+{
+	struct rockchip_hdmi *hdmi = (struct rockchip_hdmi *)data;
+
+	dw_hdmi_qp_rockchip_phy_disable(conn, data, state);
+
+	rockchip_phy_set_bus_width(conn->phy, hdmi->bus_width);
+
+	return rockchip_phy_power_on(conn->phy);
+}
+
+static enum drm_connector_status dw_hdmi_rk3588_read_hpd(void *data)
+{
+	u32 val;
+	int ret;
+	struct rockchip_hdmi *hdmi = (struct rockchip_hdmi *)data;
+
+	val = readl(hdmi->grf + RK3588_GRF_SOC_STATUS1);
+
+	if (!hdmi->id) {
+		if (val & RK3588_HDMI0_LEVEL_INT)
+			ret = connector_status_connected;
+		else
+			ret = connector_status_disconnected;
+	} else {
+		if (val & RK3588_HDMI1_LEVEL_INT)
+			ret = connector_status_connected;
+		else
+			ret = connector_status_disconnected;
+	}
+
+	return ret;
+}
+
+static void dw_hdmi_rk3588_set_pll(struct rockchip_connector *conn, void *data, void *state)
+{
+	struct rockchip_hdmi *hdmi = (struct rockchip_hdmi *)data;
+	u32 rate = (hdmi->bus_width & DATA_RATE_MASK) * 100;
+
+	clk_set_rate(&hdmi->link_clk, rate);
+}
+static const struct dw_hdmi_qp_phy_ops rk3588_hdmi_phy_ops = {
+	.init = dw_hdmi_qp_rockchip_genphy_init,
+	.disable = dw_hdmi_qp_rockchip_phy_disable,
+	.read_hpd = dw_hdmi_rk3588_read_hpd,
+	.set_pll = dw_hdmi_rk3588_set_pll,
+};
+
+static const struct rockchip_connector_funcs rockchip_dw_hdmi_qp_funcs = {
+	.init = rockchip_dw_hdmi_qp_init,
+	.deinit = rockchip_dw_hdmi_qp_deinit,
+	.prepare = rockchip_dw_hdmi_qp_prepare,
+	.check = rockchip_dw_hdmi_qp_check,
+	.enable = rockchip_dw_hdmi_qp_enable,
+	.disable = rockchip_dw_hdmi_qp_disable,
+	.get_timing = rockchip_dw_hdmi_qp_get_timing,
+	.detect = rockchip_dw_hdmi_qp_detect,
+	.get_edid = rockchip_dw_hdmi_qp_get_edid,
+};
+
+const struct dw_hdmi_plat_data rk3588_hdmi_drv_data = {
+	.qp_phy_ops    = &rk3588_hdmi_phy_ops,
+	.phy_name   = "samsung_hdptx_phy",
+	.dev_type   = RK3588_HDMI,
+};
+
+static int rockchip_dw_hdmi_qp_probe(struct udevice *dev)
+{
+	int ret;
+	struct regmap *map;
+	struct rockchip_hdmi *hdmi = dev_get_priv(dev);
+
+	hdmi->dev = dev;
+
+	hdmi->id = of_alias_get_id(ofnode_to_np(dev->node_), "hdmi");
+	if (hdmi->id < 0)
+		hdmi->id = 0;
+
+	hdmi->grf = syscon_get_first_range(ROCKCHIP_SYSCON_GRF);
+
+	if (hdmi->grf <= 0) {
+		dev_err(dev, "%s: Get syscon grf failed (ret=%p)\n",
+			__func__, hdmi->grf);
+		return -ENXIO;
+	}
+
+	map = syscon_regmap_lookup_by_phandle(dev, "rockchip,vo1_grf");
+	hdmi->vo1_grf = regmap_get_range(map, 0);
+
+	if (hdmi->vo1_grf <= 0) {
+		dev_err(dev, "%s: Get syscon vo1 grf failed (ret=%p)\n",
+			__func__, hdmi->vo1_grf);
+		return -ENXIO;
+	}
+
+	ret = gpio_request_by_name(dev, "enable-gpios", 0,
+				   &hdmi->enable_gpio, GPIOD_IS_OUT);
+	if (ret && ret != -ENOENT) {
+		dev_err(dev, "Cannot get enable GPIO: %d\n", ret);
+		return ret;
+	}
+
+	ret = clk_get_by_name(dev, "link_clk", &hdmi->link_clk);
+	if (ret) {
+		printf("%s: can't get link_clk\n", __func__);
+		return ret;
+	}
+
+	rockchip_connector_bind(&hdmi->connector, dev, hdmi->id, &rockchip_dw_hdmi_qp_funcs,
+				NULL, DRM_MODE_CONNECTOR_HDMIA);
+
+	return 0;
+}
+
+static const struct udevice_id rockchip_dw_hdmi_qp_ids[] = {
+	{
+	 .compatible = "rockchip,rk3588-dw-hdmi",
+	 .data = (ulong)&rk3588_hdmi_drv_data,
+	}, {}
+};
+
+U_BOOT_DRIVER(rockchip_dw_hdmi_qp) = {
+	.name = "rockchip_dw_hdmi_qp",
+	.id = UCLASS_DISPLAY,
+	.of_match = rockchip_dw_hdmi_qp_ids,
+	.probe	= rockchip_dw_hdmi_qp_probe,
+	.priv_auto = sizeof(struct rockchip_hdmi),
+};
diff --git a/drivers/video/drm/rockchip_dw_hdmi_qp.h b/drivers/video/drm/rockchip_dw_hdmi_qp.h
new file mode 100644
index 0000000000..b7a2e5e04d
--- /dev/null
+++ b/drivers/video/drm/rockchip_dw_hdmi_qp.h
@@ -0,0 +1,22 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * (C) Copyright 2022 Fuzhou Rockchip Electronics Co., Ltd
+ */
+#ifndef _ROCKCHIP_DW_HDMI_QP_H_
+#define _ROCKCHIP_DW_HDMI_QP_H_
+
+/*
+ * Rockchip connector callbacks.
+ * If you want to know the details, please refer to rockchip_connector.h
+ */
+int rockchip_dw_hdmi_qp_init(struct rockchip_connector *conn, struct display_state *state);
+void rockchip_dw_hdmi_qp_deinit(struct rockchip_connector *conn, struct display_state *state);
+int rockchip_dw_hdmi_qp_prepare(struct rockchip_connector *conn, struct display_state *state);
+int rockchip_dw_hdmi_qp_enable(struct rockchip_connector *conn, struct display_state *state);
+int rockchip_dw_hdmi_qp_disable(struct rockchip_connector *conn, struct display_state *state);
+int rockchip_dw_hdmi_qp_get_timing(struct rockchip_connector *conn, struct display_state *state);
+int rockchip_dw_hdmi_qp_detect(struct rockchip_connector *conn, struct display_state *state);
+int rockchip_dw_hdmi_qp_get_edid(struct rockchip_connector *conn, struct display_state *state);
+int rockchip_dw_hdmi_qp_check(struct rockchip_connector *conn, struct display_state *state);
+
+#endif /* _ROCKCHIP_DW_HDMI_QP_H_ */
diff --git a/drivers/video/drm/rockchip_lvds.c b/drivers/video/drm/rockchip_lvds.c
new file mode 100644
index 0000000000..d930de7009
--- /dev/null
+++ b/drivers/video/drm/rockchip_lvds.c
@@ -0,0 +1,476 @@
+/*
+ * (C) Copyright 2008-2017 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <config.h>
+#include <common.h>
+#include <errno.h>
+#include <dm/device.h>
+#include <dm/read.h>
+#include <dm/ofnode.h>
+#include <dm/of_access.h>
+#include <syscon.h>
+#include <regmap.h>
+#include <dm/device.h>
+#include <dm/read.h>
+#include <linux/media-bus-format.h>
+
+#include "rockchip_display.h"
+#include "rockchip_connector.h"
+#include "rockchip_phy.h"
+#include "rockchip_panel.h"
+#include "drm_of.h"
+
+#define HIWORD_UPDATE(v, h, l)		(((v) << (l)) | (GENMASK(h, l) << 16))
+
+#define PX30_GRF_PD_VO_CON1		0x0438
+#define PX30_LVDS_SELECT(x)		HIWORD_UPDATE(x, 14, 13)
+#define PX30_LVDS_MODE_EN(x)		HIWORD_UPDATE(x, 12, 12)
+#define PX30_LVDS_MSBSEL(x)		HIWORD_UPDATE(x, 11, 11)
+#define PX30_LVDS_P2S_EN(x)		HIWORD_UPDATE(x,  6,  6)
+#define PX30_LVDS_VOP_SEL(x)		HIWORD_UPDATE(x,  1,  1)
+
+#define RK3126_GRF_LVDS_CON0		0x0150
+#define RK3126_LVDS_P2S_EN(x)		HIWORD_UPDATE(x,  9,  9)
+#define RK3126_LVDS_MODE_EN(x)		HIWORD_UPDATE(x,  6,  6)
+#define RK3126_LVDS_MSBSEL(x)		HIWORD_UPDATE(x,  3,  3)
+#define RK3126_LVDS_SELECT(x)		HIWORD_UPDATE(x,  2,  1)
+
+#define RK3288_GRF_SOC_CON6		0x025c
+#define RK3288_LVDS_LCDC_SEL(x)		HIWORD_UPDATE(x,  3,  3)
+#define RK3288_GRF_SOC_CON7		0x0260
+#define RK3288_LVDS_PWRDWN(x)		HIWORD_UPDATE(x, 15, 15)
+#define RK3288_LVDS_CON_ENABLE_2(x)	HIWORD_UPDATE(x, 12, 12)
+#define RK3288_LVDS_CON_ENABLE_1(x)	HIWORD_UPDATE(x, 11, 11)
+#define RK3288_LVDS_CON_DEN_POL(x)	HIWORD_UPDATE(x, 10, 10)
+#define RK3288_LVDS_CON_HS_POL(x)	HIWORD_UPDATE(x,  9,  9)
+#define RK3288_LVDS_CON_CLKINV(x)	HIWORD_UPDATE(x,  8,  8)
+#define RK3288_LVDS_CON_STARTPHASE(x)	HIWORD_UPDATE(x,  7,  7)
+#define RK3288_LVDS_CON_TTL_EN(x)	HIWORD_UPDATE(x,  6,  6)
+#define RK3288_LVDS_CON_STARTSEL(x)	HIWORD_UPDATE(x,  5,  5)
+#define RK3288_LVDS_CON_CHASEL(x)	HIWORD_UPDATE(x,  4,  4)
+#define RK3288_LVDS_CON_MSBSEL(x)	HIWORD_UPDATE(x,  3,  3)
+#define RK3288_LVDS_CON_SELECT(x)	HIWORD_UPDATE(x,  2,  0)
+
+#define RK3368_GRF_SOC_CON7		0x041c
+#define RK3368_LVDS_SELECT(x)		HIWORD_UPDATE(x, 14, 13)
+#define RK3368_LVDS_MODE_EN(x)		HIWORD_UPDATE(x, 12, 12)
+#define RK3368_LVDS_MSBSEL(x)		HIWORD_UPDATE(x, 11, 11)
+#define RK3368_LVDS_P2S_EN(x)		HIWORD_UPDATE(x,  6,  6)
+
+#define RK3562_GRF_VO_CON0		0x05d0
+#define RK3562_GRF_VO_CON1		0x05d4
+
+#define RK3568_GRF_VO_CON0		0x0360
+#define RK3568_LVDS1_SELECT(x)		HIWORD_UPDATE(x, 13, 12)
+#define RK3568_LVDS1_MSBSEL(x)		HIWORD_UPDATE(x, 11, 11)
+#define RK3568_LVDS0_SELECT(x)		HIWORD_UPDATE(x,  5,  4)
+#define RK3568_LVDS0_MSBSEL(x)		HIWORD_UPDATE(x,  3,  3)
+#define RK3568_GRF_VO_CON2		0x0368
+#define RK3568_LVDS0_DCLK_INV_SEL(x)	HIWORD_UPDATE(x,  9,  9)
+#define RK3568_LVDS0_DCLK_DIV2_SEL(x)	HIWORD_UPDATE(x,  8,  8)
+#define RK3568_LVDS0_MODE_EN(x)		HIWORD_UPDATE(x,  1,  1)
+#define RK3568_LVDS0_P2S_EN(x)		HIWORD_UPDATE(x,  0,  0)
+#define RK3568_GRF_VO_CON3		0x036c
+#define RK3568_LVDS1_DCLK_INV_SEL(x)	HIWORD_UPDATE(x,  9,  9)
+#define RK3568_LVDS1_DCLK_DIV2_SEL(x)	HIWORD_UPDATE(x,  8,  8)
+#define RK3568_LVDS1_MODE_EN(x)		HIWORD_UPDATE(x,  1,  1)
+#define RK3568_LVDS1_P2S_EN(x)		HIWORD_UPDATE(x,  0,  0)
+
+enum lvds_format {
+	LVDS_8BIT_MODE_FORMAT_1,
+	LVDS_8BIT_MODE_FORMAT_2,
+	LVDS_8BIT_MODE_FORMAT_3,
+	LVDS_6BIT_MODE,
+	LVDS_10BIT_MODE_FORMAT_1,
+	LVDS_10BIT_MODE_FORMAT_2,
+};
+
+struct rockchip_lvds;
+
+struct rockchip_lvds_funcs {
+	int (*probe)(struct rockchip_lvds *lvds);
+	void (*enable)(struct rockchip_lvds *lvds, int pipe);
+	void (*disable)(struct rockchip_lvds *lvds);
+};
+
+struct rockchip_lvds {
+	struct rockchip_connector connector;
+	int id;
+	struct udevice *dev;
+	struct regmap *grf;
+	struct rockchip_phy *phy;
+	const struct drm_display_mode *mode;
+	const struct rockchip_lvds_funcs *funcs;
+	enum lvds_format format;
+	bool data_swap;
+	bool dual_channel;
+	enum drm_lvds_dual_link_pixels pixel_order;
+};
+
+static int rockchip_lvds_connector_init(struct rockchip_connector *conn,
+					struct display_state *state)
+{
+	struct rockchip_lvds *lvds = dev_get_priv(conn->dev);
+	struct rockchip_lvds *primary_lvds = NULL;
+	struct connector_state *conn_state = &state->conn_state;
+	struct rockchip_panel *panel = conn->panel;
+
+	lvds->mode = &conn_state->mode;
+	lvds->phy = conn->phy;
+	conn_state->disp_info  = rockchip_get_disp_info(conn_state->type, lvds->id);
+
+	if (conn_state->secondary)
+		primary_lvds = dev_get_priv(conn_state->connector->dev);
+
+	switch (panel->bus_format) {
+	case MEDIA_BUS_FMT_RGB666_1X7X3_JEIDA:	/* jeida-18 */
+		lvds->format = LVDS_6BIT_MODE;
+		break;
+	case MEDIA_BUS_FMT_RGB888_1X7X4_JEIDA:	/* jeida-24 */
+		lvds->format = LVDS_8BIT_MODE_FORMAT_2;
+		break;
+	case MEDIA_BUS_FMT_RGB101010_1X7X5_JEIDA: /* jeida-30 */
+		lvds->format = LVDS_10BIT_MODE_FORMAT_1;
+	case MEDIA_BUS_FMT_RGB666_1X7X3_SPWG:	/* vesa-18 */
+		lvds->format = LVDS_8BIT_MODE_FORMAT_3;
+		break;
+	case MEDIA_BUS_FMT_RGB101010_1X7X5_SPWG: /* vesa-30 */
+		lvds->format = LVDS_10BIT_MODE_FORMAT_2;
+		break;
+	case MEDIA_BUS_FMT_RGB888_1X7X4_SPWG:	/* vesa-24 */
+	default:
+		lvds->format = LVDS_8BIT_MODE_FORMAT_1;
+		break;
+	}
+
+	conn_state->bus_format = panel->bus_format;
+	conn_state->output_mode = ROCKCHIP_OUT_MODE_P888;
+
+	if ((lvds->format == LVDS_10BIT_MODE_FORMAT_1) ||
+		(lvds->format == LVDS_10BIT_MODE_FORMAT_2))
+		conn_state->output_mode = ROCKCHIP_OUT_MODE_AAAA;
+
+	conn_state->color_space = V4L2_COLORSPACE_DEFAULT;
+	if (primary_lvds) {
+		conn_state->output_flags = 0;
+		conn_state->output_if = 0;
+
+		switch (primary_lvds->pixel_order) {
+		case DRM_LVDS_DUAL_LINK_ODD_EVEN_PIXELS:
+			conn_state->output_flags |=
+				ROCKCHIP_OUTPUT_DUAL_CHANNEL_ODD_EVEN_MODE;
+			conn_state->output_if |=
+				VOP_OUTPUT_IF_LVDS1 | VOP_OUTPUT_IF_LVDS0;
+			break;
+		case DRM_LVDS_DUAL_LINK_EVEN_ODD_PIXELS:
+			conn_state->output_flags |=
+				ROCKCHIP_OUTPUT_DUAL_CHANNEL_ODD_EVEN_MODE;
+			conn_state->output_flags |= ROCKCHIP_OUTPUT_DATA_SWAP;
+			conn_state->output_if |=
+				VOP_OUTPUT_IF_LVDS1 | VOP_OUTPUT_IF_LVDS0;
+			break;
+		case DRM_LVDS_DUAL_LINK_LEFT_RIGHT_PIXELS:
+			conn_state->output_flags |=
+				ROCKCHIP_OUTPUT_DUAL_CHANNEL_LEFT_RIGHT_MODE;
+			conn_state->output_if |=
+				VOP_OUTPUT_IF_LVDS1 | VOP_OUTPUT_IF_LVDS0;
+			break;
+		case DRM_LVDS_DUAL_LINK_RIGHT_LEFT_PIXELS:
+			conn_state->output_flags |=
+				ROCKCHIP_OUTPUT_DUAL_CHANNEL_LEFT_RIGHT_MODE;
+			conn_state->output_flags |= ROCKCHIP_OUTPUT_DATA_SWAP;
+			conn_state->output_if |=
+				VOP_OUTPUT_IF_LVDS1 | VOP_OUTPUT_IF_LVDS0;
+			break;
+		default:
+			break;
+		}
+	}
+
+	if (lvds->id)
+		conn_state->output_if |= VOP_OUTPUT_IF_LVDS1;
+	else
+		conn_state->output_if |= VOP_OUTPUT_IF_LVDS0;
+
+	return 0;
+}
+
+static int rockchip_lvds_connector_enable(struct rockchip_connector *conn,
+					  struct display_state *state)
+{
+	struct rockchip_lvds *lvds = dev_get_priv(conn->dev);
+	struct crtc_state *crtc_state = &state->crtc_state;
+	int pipe = crtc_state->crtc_id;
+	int ret;
+
+	if (lvds->funcs->enable)
+		lvds->funcs->enable(lvds, pipe);
+
+	ret = rockchip_phy_set_mode(lvds->phy, PHY_MODE_VIDEO_LVDS);
+	if (ret) {
+		dev_err(lvds->dev, "failed to set phy mode: %d\n", ret);
+		return ret;
+	}
+
+	rockchip_phy_power_on(lvds->phy);
+
+	return 0;
+}
+
+static int rockchip_lvds_connector_disable(struct rockchip_connector *conn,
+					   struct display_state *state)
+{
+	struct rockchip_lvds *lvds = dev_get_priv(conn->dev);
+
+	rockchip_phy_power_off(lvds->phy);
+
+	if (lvds->funcs->disable)
+		lvds->funcs->disable(lvds);
+
+	return 0;
+}
+
+static const struct rockchip_connector_funcs rockchip_lvds_connector_funcs = {
+	.init = rockchip_lvds_connector_init,
+	.enable = rockchip_lvds_connector_enable,
+	.disable = rockchip_lvds_connector_disable,
+};
+
+static int rockchip_lvds_probe(struct udevice *dev)
+{
+	struct rockchip_lvds *lvds = dev_get_priv(dev);
+
+	lvds->dev = dev;
+	lvds->funcs = (const struct rockchip_lvds_funcs *)dev_get_driver_data(dev);
+	lvds->grf = syscon_get_regmap(dev_get_parent(dev));
+	lvds->dual_channel = dev_read_bool(dev, "dual-channel");
+	lvds->data_swap = dev_read_bool(dev, "rockchip,data-swap");
+	lvds->id = of_alias_get_id(ofnode_to_np(dev->node), "lvds");
+	if (lvds->id < 0)
+		lvds->id = 0;
+
+	lvds->pixel_order = -1;
+	if (lvds->funcs->probe)
+		lvds->funcs->probe(lvds);
+
+	rockchip_connector_bind(&lvds->connector, dev, lvds->id, &rockchip_lvds_connector_funcs,
+				NULL, DRM_MODE_CONNECTOR_LVDS);
+
+	return 0;
+}
+
+static void px30_lvds_enable(struct rockchip_lvds *lvds, int pipe)
+{
+	regmap_write(lvds->grf, PX30_GRF_PD_VO_CON1,
+		     PX30_LVDS_SELECT(lvds->format) |
+		     PX30_LVDS_MODE_EN(1) | PX30_LVDS_MSBSEL(1) |
+		     PX30_LVDS_P2S_EN(1) | PX30_LVDS_VOP_SEL(pipe));
+}
+
+static void px30_lvds_disable(struct rockchip_lvds *lvds)
+{
+	regmap_write(lvds->grf, PX30_GRF_PD_VO_CON1,
+		     PX30_LVDS_MODE_EN(0) | PX30_LVDS_P2S_EN(0));
+}
+
+static const struct rockchip_lvds_funcs px30_lvds_funcs = {
+	.enable = px30_lvds_enable,
+	.disable = px30_lvds_disable,
+};
+
+static void rk3126_lvds_enable(struct rockchip_lvds *lvds, int pipe)
+{
+	regmap_write(lvds->grf, RK3126_GRF_LVDS_CON0,
+		     RK3126_LVDS_P2S_EN(1) | RK3126_LVDS_MODE_EN(1) |
+		     RK3126_LVDS_MSBSEL(1) | RK3126_LVDS_SELECT(lvds->format));
+}
+
+static void rk3126_lvds_disable(struct rockchip_lvds *lvds)
+{
+	regmap_write(lvds->grf, RK3126_GRF_LVDS_CON0,
+		     RK3126_LVDS_P2S_EN(0) | RK3126_LVDS_MODE_EN(0));
+}
+
+static const struct rockchip_lvds_funcs rk3126_lvds_funcs = {
+	.enable = rk3126_lvds_enable,
+	.disable = rk3126_lvds_disable,
+};
+
+static void rk3288_lvds_enable(struct rockchip_lvds *lvds, int pipe)
+{
+	const struct drm_display_mode *mode = lvds->mode;
+	u32 val;
+
+	regmap_write(lvds->grf, RK3288_GRF_SOC_CON6,
+		     RK3288_LVDS_LCDC_SEL(pipe));
+
+	val = RK3288_LVDS_PWRDWN(0) | RK3288_LVDS_CON_CLKINV(0) |
+	      RK3288_LVDS_CON_CHASEL(lvds->dual_channel) |
+	      RK3288_LVDS_CON_SELECT(lvds->format);
+
+	if (lvds->dual_channel) {
+		u32 h_bp = mode->htotal - mode->hsync_start;
+
+		val |= RK3288_LVDS_CON_ENABLE_2(1) |
+		       RK3288_LVDS_CON_ENABLE_1(1) |
+		       RK3288_LVDS_CON_STARTSEL(lvds->data_swap);
+
+		if (h_bp % 2)
+			val |= RK3288_LVDS_CON_STARTPHASE(1);
+		else
+			val |= RK3288_LVDS_CON_STARTPHASE(0);
+	} else {
+		val |= RK3288_LVDS_CON_ENABLE_2(0) |
+		       RK3288_LVDS_CON_ENABLE_1(1);
+	}
+
+	regmap_write(lvds->grf, RK3288_GRF_SOC_CON7, val);
+
+	rockchip_phy_set_bus_width(lvds->phy, lvds->dual_channel ? 2 : 1);
+}
+
+static void rk3288_lvds_disable(struct rockchip_lvds *lvds)
+{
+	regmap_write(lvds->grf, RK3288_GRF_SOC_CON7, RK3288_LVDS_PWRDWN(1));
+}
+
+static const struct rockchip_lvds_funcs rk3288_lvds_funcs = {
+	.enable = rk3288_lvds_enable,
+	.disable = rk3288_lvds_disable,
+};
+
+static void rk3368_lvds_enable(struct rockchip_lvds *lvds, int pipe)
+{
+	regmap_write(lvds->grf, RK3368_GRF_SOC_CON7,
+		     RK3368_LVDS_SELECT(lvds->format) |
+		     RK3368_LVDS_MODE_EN(1) | RK3368_LVDS_MSBSEL(1) |
+		     RK3368_LVDS_P2S_EN(1));
+}
+
+static void rk3368_lvds_disable(struct rockchip_lvds *lvds)
+{
+	regmap_write(lvds->grf, RK3368_GRF_SOC_CON7,
+		     RK3368_LVDS_MODE_EN(0) | RK3368_LVDS_P2S_EN(0));
+}
+
+static const struct rockchip_lvds_funcs rk3368_lvds_funcs = {
+	.enable = rk3368_lvds_enable,
+	.disable = rk3368_lvds_disable,
+};
+
+static void rk3562_lvds_enable(struct rockchip_lvds *lvds, int pipe)
+{
+	regmap_write(lvds->grf, RK3562_GRF_VO_CON1,
+		     RK3568_LVDS0_MODE_EN(1) | RK3568_LVDS0_P2S_EN(1) |
+		     RK3568_LVDS0_DCLK_INV_SEL(1));
+	regmap_write(lvds->grf, RK3562_GRF_VO_CON0,
+		     RK3568_LVDS0_SELECT(lvds->format) | RK3568_LVDS0_MSBSEL(1));
+}
+
+static void rk3562_lvds_disable(struct rockchip_lvds *lvds)
+{
+	regmap_write(lvds->grf, RK3562_GRF_VO_CON1, RK3568_LVDS0_MODE_EN(0));
+}
+
+static const struct rockchip_lvds_funcs rk3562_lvds_funcs = {
+	.enable = rk3562_lvds_enable,
+	.disable = rk3562_lvds_disable,
+};
+
+static int rk3568_lvds_probe(struct rockchip_lvds *lvds)
+{
+	if (lvds->dual_channel) {
+		const struct device_node *port0, *port1;
+		int pixel_order;
+
+		port1 = of_alias_get_dev("lvds", 1);
+		if (!port1 || !of_device_is_available(port1)) {
+			lvds->pixel_order = 0;
+			return 0;
+		}
+
+		port0 = rockchip_of_graph_get_port_by_id(lvds->dev->node, 1);
+		port1 = rockchip_of_graph_get_port_by_id(np_to_ofnode(port1),
+							 1);
+		pixel_order =
+			drm_of_lvds_get_dual_link_pixel_order(port0, port1);
+
+		lvds->pixel_order = pixel_order >= 0 ? pixel_order : 0;
+	}
+
+	return 0;
+}
+
+static void rk3568_lvds_enable(struct rockchip_lvds *lvds, int pipe)
+{
+	if (lvds->id) {
+		regmap_write(lvds->grf, RK3568_GRF_VO_CON3,
+			     RK3568_LVDS1_MODE_EN(1) | RK3568_LVDS1_P2S_EN(1) |
+				     RK3568_LVDS1_DCLK_INV_SEL(1));
+		regmap_write(lvds->grf, RK3568_GRF_VO_CON0,
+			     RK3568_LVDS1_SELECT(lvds->format) |
+				     RK3568_LVDS1_MSBSEL(1));
+	} else {
+		regmap_write(lvds->grf, RK3568_GRF_VO_CON2,
+			     RK3568_LVDS0_MODE_EN(1) | RK3568_LVDS0_P2S_EN(1) |
+				     RK3568_LVDS0_DCLK_INV_SEL(1));
+		regmap_write(lvds->grf, RK3568_GRF_VO_CON0,
+			     RK3568_LVDS0_SELECT(lvds->format) |
+				     RK3568_LVDS0_MSBSEL(1));
+	}
+}
+
+static void rk3568_lvds_disable(struct rockchip_lvds *lvds)
+{
+	if (lvds->id)
+		regmap_write(lvds->grf, RK3568_GRF_VO_CON3,
+			     RK3568_LVDS1_MODE_EN(0));
+	else
+		regmap_write(lvds->grf, RK3568_GRF_VO_CON2,
+			     RK3568_LVDS0_MODE_EN(0));
+}
+
+static const struct rockchip_lvds_funcs rk3568_lvds_funcs = {
+	.probe = rk3568_lvds_probe,
+	.enable = rk3568_lvds_enable,
+	.disable = rk3568_lvds_disable,
+};
+
+static const struct udevice_id rockchip_lvds_ids[] = {
+	{
+		.compatible = "rockchip,px30-lvds",
+		.data = (ulong)&px30_lvds_funcs,
+	},
+	{
+		.compatible = "rockchip,rk3126-lvds",
+		.data = (ulong)&rk3126_lvds_funcs,
+	},
+	{
+		.compatible = "rockchip,rk3288-lvds",
+		.data = (ulong)&rk3288_lvds_funcs,
+	},
+	{
+		.compatible = "rockchip,rk3368-lvds",
+		.data = (ulong)&rk3368_lvds_funcs,
+	},
+	{
+		.compatible = "rockchip,rk3562-lvds",
+		.data = (ulong)&rk3562_lvds_funcs,
+	},
+	{
+		.compatible = "rockchip,rk3568-lvds",
+		.data = (ulong)&rk3568_lvds_funcs,
+	},
+	{}
+};
+
+U_BOOT_DRIVER(rockchip_lvds) = {
+	.name = "rockchip_lvds",
+	.id = UCLASS_DISPLAY,
+	.of_match = rockchip_lvds_ids,
+	.probe = rockchip_lvds_probe,
+	.priv_auto_alloc_size = sizeof(struct rockchip_lvds),
+};
diff --git a/drivers/video/drm/rockchip_panel.c b/drivers/video/drm/rockchip_panel.c
new file mode 100644
index 0000000000..9ddb4d8196
--- /dev/null
+++ b/drivers/video/drm/rockchip_panel.c
@@ -0,0 +1,592 @@
+/*
+ * (C) Copyright 2008-2017 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <drm/drm_mipi_dsi.h>
+
+#include <config.h>
+#include <common.h>
+#include <errno.h>
+#include <malloc.h>
+#include <video.h>
+#include <backlight.h>
+#include <spi.h>
+#include <asm/gpio.h>
+#include <dm/device.h>
+#include <dm/read.h>
+#include <dm/uclass.h>
+#include <dm/uclass-id.h>
+#include <linux/media-bus-format.h>
+#include <power/regulator.h>
+
+#include "rockchip_display.h"
+#include "rockchip_crtc.h"
+#include "rockchip_connector.h"
+#include "rockchip_panel.h"
+
+struct rockchip_cmd_header {
+	u8 data_type;
+	u8 delay_ms;
+	u8 payload_length;
+} __packed;
+
+struct rockchip_cmd_desc {
+	struct rockchip_cmd_header header;
+	const u8 *payload;
+};
+
+struct rockchip_panel_cmds {
+	struct rockchip_cmd_desc *cmds;
+	int cmd_cnt;
+};
+
+struct rockchip_panel_plat {
+	bool power_invert;
+	u32 bus_format;
+	unsigned int bpc;
+
+	struct {
+		unsigned int prepare;
+		unsigned int unprepare;
+		unsigned int enable;
+		unsigned int disable;
+		unsigned int reset;
+		unsigned int init;
+	} delay;
+
+	struct rockchip_panel_cmds *on_cmds;
+	struct rockchip_panel_cmds *off_cmds;
+};
+
+struct rockchip_panel_priv {
+	bool prepared;
+	bool enabled;
+	struct udevice *power_supply;
+	struct udevice *backlight;
+	struct spi_slave *spi_slave;
+	struct gpio_desc enable_gpio;
+	struct gpio_desc reset_gpio;
+
+	int cmd_type;
+	struct gpio_desc spi_sdi_gpio;
+	struct gpio_desc spi_scl_gpio;
+	struct gpio_desc spi_cs_gpio;
+};
+
+static inline int get_panel_cmd_type(const char *s)
+{
+	if (!s)
+		return -EINVAL;
+
+	if (strncmp(s, "spi", 3) == 0)
+		return CMD_TYPE_SPI;
+	else if (strncmp(s, "mcu", 3) == 0)
+		return CMD_TYPE_MCU;
+
+	return CMD_TYPE_DEFAULT;
+}
+
+static int rockchip_panel_parse_cmds(const u8 *data, int length,
+				     struct rockchip_panel_cmds *pcmds)
+{
+	int len;
+	const u8 *buf;
+	const struct rockchip_cmd_header *header;
+	int i, cnt = 0;
+
+	/* scan commands */
+	cnt = 0;
+	buf = data;
+	len = length;
+	while (len > sizeof(*header)) {
+		header = (const struct rockchip_cmd_header *)buf;
+		buf += sizeof(*header) + header->payload_length;
+		len -= sizeof(*header) + header->payload_length;
+		cnt++;
+	}
+
+	pcmds->cmds = calloc(cnt, sizeof(struct rockchip_cmd_desc));
+	if (!pcmds->cmds)
+		return -ENOMEM;
+
+	pcmds->cmd_cnt = cnt;
+
+	buf = data;
+	len = length;
+	for (i = 0; i < cnt; i++) {
+		struct rockchip_cmd_desc *desc = &pcmds->cmds[i];
+
+		header = (const struct rockchip_cmd_header *)buf;
+		length -= sizeof(*header);
+		buf += sizeof(*header);
+		desc->header.data_type = header->data_type;
+		desc->header.delay_ms = header->delay_ms;
+		desc->header.payload_length = header->payload_length;
+		desc->payload = buf;
+		buf += header->payload_length;
+		length -= header->payload_length;
+	}
+
+	return 0;
+}
+
+static void rockchip_panel_write_spi_cmds(struct rockchip_panel_priv *priv,
+					  u8 type, int value)
+{
+	int i;
+
+	dm_gpio_set_value(&priv->spi_cs_gpio, 0);
+
+	if (type == 0)
+		value &= (~(1 << 8));
+	else
+		value |= (1 << 8);
+
+	for (i = 0; i < 9; i++) {
+		if (value & 0x100)
+			dm_gpio_set_value(&priv->spi_sdi_gpio, 1);
+		else
+			dm_gpio_set_value(&priv->spi_sdi_gpio, 0);
+
+		dm_gpio_set_value(&priv->spi_scl_gpio, 0);
+		udelay(10);
+		dm_gpio_set_value(&priv->spi_scl_gpio, 1);
+		value <<= 1;
+		udelay(10);
+	}
+
+	dm_gpio_set_value(&priv->spi_cs_gpio, 1);
+}
+
+static int rockchip_panel_send_mcu_cmds(struct rockchip_panel *panel, struct display_state *state,
+					struct rockchip_panel_cmds *cmds)
+{
+	int i;
+
+	if (!cmds)
+		return -EINVAL;
+
+	display_send_mcu_cmd(state, MCU_SETBYPASS, 1);
+	for (i = 0; i < cmds->cmd_cnt; i++) {
+		struct rockchip_cmd_desc *desc = &cmds->cmds[i];
+		int value = 0;
+
+		value = desc->payload[0];
+		display_send_mcu_cmd(state, desc->header.data_type, value);
+
+		if (desc->header.delay_ms)
+			mdelay(desc->header.delay_ms);
+	}
+	display_send_mcu_cmd(state, MCU_SETBYPASS, 0);
+
+	return 0;
+}
+
+static int rockchip_panel_send_spi_cmds(struct rockchip_panel *panel, struct display_state *state,
+					struct rockchip_panel_cmds *cmds)
+{
+	struct rockchip_panel_priv *priv = dev_get_priv(panel->dev);
+	int i;
+	int ret;
+
+	if (!cmds)
+		return -EINVAL;
+
+	if (priv->spi_slave) {
+		ret = spi_claim_bus(priv->spi_slave);
+		if (ret) {
+			printf("%s: Failed to claim spi bus: %d\n", __func__, ret);
+			return -EINVAL;
+		}
+	}
+
+	for (i = 0; i < cmds->cmd_cnt; i++) {
+		struct rockchip_cmd_desc *desc = &cmds->cmds[i];
+		int value = 0;
+		u16 mask = 0;
+		u16 data = 0;
+
+		if (priv->spi_slave) {
+			mask = desc->header.data_type ? 0x100 : 0;
+			data = (mask | desc->payload[0]) << 7;;
+			data = ((data & 0xff) << 8) | (data >> 8);
+			value = mask | desc->payload[0];
+			ret = spi_xfer(priv->spi_slave, 9, &data, NULL, SPI_XFER_ONCE);
+			if (ret)
+				printf("%s: Failed to xfer spi cmd 0x%x: %d\n",
+				       __func__, desc->payload[0], ret);
+		} else {
+			if (desc->header.payload_length == 2)
+				value = (desc->payload[0] << 8) | desc->payload[1];
+			else
+				value = desc->payload[0];
+			rockchip_panel_write_spi_cmds(priv, desc->header.data_type, value);
+		}
+
+		if (desc->header.delay_ms)
+			mdelay(desc->header.delay_ms);
+	}
+
+	if (priv->spi_slave)
+		spi_release_bus(priv->spi_slave);
+
+	return 0;
+}
+
+static int rockchip_panel_send_dsi_cmds(struct mipi_dsi_device *dsi,
+					struct rockchip_panel_cmds *cmds)
+{
+	int i, ret;
+	struct drm_dsc_picture_parameter_set *pps = NULL;
+
+	if (!cmds)
+		return -EINVAL;
+
+	for (i = 0; i < cmds->cmd_cnt; i++) {
+		struct rockchip_cmd_desc *desc = &cmds->cmds[i];
+		const struct rockchip_cmd_header *header = &desc->header;
+
+		switch (header->data_type) {
+		case MIPI_DSI_COMPRESSION_MODE:
+			ret = mipi_dsi_compression_mode(dsi, desc->payload[0]);
+			break;
+		case MIPI_DSI_GENERIC_SHORT_WRITE_0_PARAM:
+		case MIPI_DSI_GENERIC_SHORT_WRITE_1_PARAM:
+		case MIPI_DSI_GENERIC_SHORT_WRITE_2_PARAM:
+		case MIPI_DSI_GENERIC_LONG_WRITE:
+			ret = mipi_dsi_generic_write(dsi, desc->payload,
+						     header->payload_length);
+			break;
+		case MIPI_DSI_DCS_SHORT_WRITE:
+		case MIPI_DSI_DCS_SHORT_WRITE_PARAM:
+		case MIPI_DSI_DCS_LONG_WRITE:
+			ret = mipi_dsi_dcs_write_buffer(dsi, desc->payload,
+							header->payload_length);
+			break;
+		case MIPI_DSI_PICTURE_PARAMETER_SET:
+			pps = kzalloc(sizeof(*pps), GFP_KERNEL);
+			if (!pps)
+				return -ENOMEM;
+
+			memcpy(pps, desc->payload, header->payload_length);
+			ret = mipi_dsi_picture_parameter_set(dsi, pps);
+			kfree(pps);
+			break;
+		default:
+			printf("unsupport command data type: %d\n",
+			       header->data_type);
+			return -EINVAL;
+		}
+
+		if (ret < 0) {
+			printf("failed to write cmd%d: %d\n", i, ret);
+			return ret;
+		}
+
+		if (header->delay_ms)
+			mdelay(header->delay_ms);
+	}
+
+	return 0;
+}
+
+static void panel_simple_prepare(struct rockchip_panel *panel)
+{
+	struct rockchip_panel_plat *plat = dev_get_platdata(panel->dev);
+	struct rockchip_panel_priv *priv = dev_get_priv(panel->dev);
+	struct mipi_dsi_device *dsi = dev_get_parent_platdata(panel->dev);
+	int ret;
+
+	if (priv->prepared)
+		return;
+
+	if (priv->power_supply)
+		regulator_set_enable(priv->power_supply, !plat->power_invert);
+
+	if (dm_gpio_is_valid(&priv->enable_gpio))
+		dm_gpio_set_value(&priv->enable_gpio, 1);
+
+	if (plat->delay.prepare)
+		mdelay(plat->delay.prepare);
+
+	if (dm_gpio_is_valid(&priv->reset_gpio))
+		dm_gpio_set_value(&priv->reset_gpio, 1);
+
+	if (plat->delay.reset)
+		mdelay(plat->delay.reset);
+
+	if (dm_gpio_is_valid(&priv->reset_gpio))
+		dm_gpio_set_value(&priv->reset_gpio, 0);
+
+	if (plat->delay.init)
+		mdelay(plat->delay.init);
+
+	if (plat->on_cmds) {
+		if (priv->cmd_type == CMD_TYPE_SPI)
+			ret = rockchip_panel_send_spi_cmds(panel, panel->state,
+							   plat->on_cmds);
+		else if (priv->cmd_type == CMD_TYPE_MCU)
+			ret = rockchip_panel_send_mcu_cmds(panel, panel->state,
+							   plat->on_cmds);
+		else
+			ret = rockchip_panel_send_dsi_cmds(dsi, plat->on_cmds);
+		if (ret)
+			printf("failed to send on cmds: %d\n", ret);
+	}
+
+	priv->prepared = true;
+}
+
+static void panel_simple_unprepare(struct rockchip_panel *panel)
+{
+	struct rockchip_panel_plat *plat = dev_get_platdata(panel->dev);
+	struct rockchip_panel_priv *priv = dev_get_priv(panel->dev);
+	struct mipi_dsi_device *dsi = dev_get_parent_platdata(panel->dev);
+	int ret;
+
+	if (!priv->prepared)
+		return;
+
+	if (plat->off_cmds) {
+		if (priv->cmd_type == CMD_TYPE_SPI)
+			ret = rockchip_panel_send_spi_cmds(panel, panel->state,
+							   plat->off_cmds);
+		else if (priv->cmd_type == CMD_TYPE_MCU)
+			ret = rockchip_panel_send_mcu_cmds(panel, panel->state,
+							   plat->off_cmds);
+		else
+			ret = rockchip_panel_send_dsi_cmds(dsi, plat->off_cmds);
+		if (ret)
+			printf("failed to send off cmds: %d\n", ret);
+	}
+
+	if (dm_gpio_is_valid(&priv->reset_gpio))
+		dm_gpio_set_value(&priv->reset_gpio, 1);
+
+	if (dm_gpio_is_valid(&priv->enable_gpio))
+		dm_gpio_set_value(&priv->enable_gpio, 0);
+
+	if (priv->power_supply)
+		regulator_set_enable(priv->power_supply, plat->power_invert);
+
+	if (plat->delay.unprepare)
+		mdelay(plat->delay.unprepare);
+
+	priv->prepared = false;
+}
+
+static void panel_simple_enable(struct rockchip_panel *panel)
+{
+	struct rockchip_panel_plat *plat = dev_get_platdata(panel->dev);
+	struct rockchip_panel_priv *priv = dev_get_priv(panel->dev);
+
+	if (priv->enabled)
+		return;
+
+	if (plat->delay.enable)
+		mdelay(plat->delay.enable);
+
+	if (priv->backlight)
+		backlight_enable(priv->backlight);
+
+	priv->enabled = true;
+}
+
+static void panel_simple_disable(struct rockchip_panel *panel)
+{
+	struct rockchip_panel_plat *plat = dev_get_platdata(panel->dev);
+	struct rockchip_panel_priv *priv = dev_get_priv(panel->dev);
+
+	if (!priv->enabled)
+		return;
+
+	if (priv->backlight)
+		backlight_disable(priv->backlight);
+
+	if (plat->delay.disable)
+		mdelay(plat->delay.disable);
+
+	priv->enabled = false;
+}
+
+static const struct rockchip_panel_funcs rockchip_panel_funcs = {
+	.prepare = panel_simple_prepare,
+	.unprepare = panel_simple_unprepare,
+	.enable = panel_simple_enable,
+	.disable = panel_simple_disable,
+};
+
+static int rockchip_panel_ofdata_to_platdata(struct udevice *dev)
+{
+	struct rockchip_panel_plat *plat = dev_get_platdata(dev);
+	const void *data;
+	int len = 0;
+	int ret;
+
+	plat->power_invert = dev_read_bool(dev, "power-invert");
+
+	plat->delay.prepare = dev_read_u32_default(dev, "prepare-delay-ms", 0);
+	plat->delay.unprepare = dev_read_u32_default(dev, "unprepare-delay-ms", 0);
+	plat->delay.enable = dev_read_u32_default(dev, "enable-delay-ms", 0);
+	plat->delay.disable = dev_read_u32_default(dev, "disable-delay-ms", 0);
+	plat->delay.init = dev_read_u32_default(dev, "init-delay-ms", 0);
+	plat->delay.reset = dev_read_u32_default(dev, "reset-delay-ms", 0);
+
+	plat->bus_format = dev_read_u32_default(dev, "bus-format",
+						MEDIA_BUS_FMT_RBG888_1X24);
+	plat->bpc = dev_read_u32_default(dev, "bpc", 8);
+
+	data = dev_read_prop(dev, "panel-init-sequence", &len);
+	if (data) {
+		plat->on_cmds = calloc(1, sizeof(*plat->on_cmds));
+		if (!plat->on_cmds)
+			return -ENOMEM;
+
+		ret = rockchip_panel_parse_cmds(data, len, plat->on_cmds);
+		if (ret) {
+			printf("failed to parse panel init sequence\n");
+			goto free_on_cmds;
+		}
+	}
+
+	data = dev_read_prop(dev, "panel-exit-sequence", &len);
+	if (data) {
+		plat->off_cmds = calloc(1, sizeof(*plat->off_cmds));
+		if (!plat->off_cmds) {
+			ret = -ENOMEM;
+			goto free_on_cmds;
+		}
+
+		ret = rockchip_panel_parse_cmds(data, len, plat->off_cmds);
+		if (ret) {
+			printf("failed to parse panel exit sequence\n");
+			goto free_cmds;
+		}
+	}
+
+	return 0;
+
+free_cmds:
+	free(plat->off_cmds);
+free_on_cmds:
+	free(plat->on_cmds);
+	return ret;
+}
+
+static int rockchip_panel_probe(struct udevice *dev)
+{
+	struct rockchip_panel_priv *priv = dev_get_priv(dev);
+	struct rockchip_panel_plat *plat = dev_get_platdata(dev);
+	struct rockchip_panel *panel;
+	int ret;
+	const char *cmd_type;
+
+	ret = gpio_request_by_name(dev, "enable-gpios", 0,
+				   &priv->enable_gpio, GPIOD_IS_OUT);
+	if (ret && ret != -ENOENT) {
+		printf("%s: Cannot get enable GPIO: %d\n", __func__, ret);
+		return ret;
+	}
+
+	ret = gpio_request_by_name(dev, "reset-gpios", 0,
+				   &priv->reset_gpio, GPIOD_IS_OUT);
+	if (ret && ret != -ENOENT) {
+		printf("%s: Cannot get reset GPIO: %d\n", __func__, ret);
+		return ret;
+	}
+
+	ret = uclass_get_device_by_phandle(UCLASS_PANEL_BACKLIGHT, dev,
+					   "backlight", &priv->backlight);
+	if (ret && ret != -ENOENT) {
+		printf("%s: Cannot get backlight: %d\n", __func__, ret);
+		return ret;
+	}
+
+	ret = uclass_get_device_by_phandle(UCLASS_REGULATOR, dev,
+					   "power-supply", &priv->power_supply);
+	if (ret && ret != -ENOENT) {
+		printf("%s: Cannot get power supply: %d\n", __func__, ret);
+		return ret;
+	}
+
+	ret = dev_read_string_index(dev, "rockchip,cmd-type", 0, &cmd_type);
+	if (ret)
+		priv->cmd_type = CMD_TYPE_DEFAULT;
+	else
+		priv->cmd_type = get_panel_cmd_type(cmd_type);
+
+	if (priv->cmd_type == CMD_TYPE_SPI) {
+		ofnode parent = ofnode_get_parent(dev->node);
+
+		if (ofnode_valid(parent)) {
+			struct dm_spi_slave_platdata *plat = dev_get_parent_platdata(dev);
+			struct udevice *spi = dev_get_parent(dev);
+
+			if (spi->seq < 0) {
+				printf("%s: Failed to get spi bus num\n", __func__);
+				return -EINVAL;
+			}
+
+			priv->spi_slave = spi_setup_slave(spi->seq, plat->cs, plat->max_hz,
+							  plat->mode);
+			if (!priv->spi_slave) {
+				printf("%s: Failed to setup spi slave: %d\n", __func__, ret);
+				return -EINVAL;
+			}
+		} else {
+			ret = gpio_request_by_name(dev, "spi-sdi-gpios", 0,
+						   &priv->spi_sdi_gpio, GPIOD_IS_OUT);
+			if (ret && ret != -ENOENT) {
+				printf("%s: Cannot get spi sdi GPIO: %d\n", __func__, ret);
+				return ret;
+			}
+			ret = gpio_request_by_name(dev, "spi-scl-gpios", 0,
+						   &priv->spi_scl_gpio, GPIOD_IS_OUT);
+			if (ret && ret != -ENOENT) {
+				printf("%s: Cannot get spi scl GPIO: %d\n", __func__, ret);
+				return ret;
+			}
+			ret = gpio_request_by_name(dev, "spi-cs-gpios", 0,
+						   &priv->spi_cs_gpio, GPIOD_IS_OUT);
+			if (ret && ret != -ENOENT) {
+				printf("%s: Cannot get spi cs GPIO: %d\n", __func__, ret);
+				return ret;
+			}
+			dm_gpio_set_value(&priv->spi_sdi_gpio, 1);
+			dm_gpio_set_value(&priv->spi_scl_gpio, 1);
+			dm_gpio_set_value(&priv->spi_cs_gpio, 1);
+			dm_gpio_set_value(&priv->reset_gpio, 0);
+		}
+	}
+
+	panel = calloc(1, sizeof(*panel));
+	if (!panel)
+		return -ENOMEM;
+
+	dev->driver_data = (ulong)panel;
+	panel->dev = dev;
+	panel->bus_format = plat->bus_format;
+	panel->bpc = plat->bpc;
+	panel->funcs = &rockchip_panel_funcs;
+
+	return 0;
+}
+
+static const struct udevice_id rockchip_panel_ids[] = {
+	{ .compatible = "simple-panel", },
+	{ .compatible = "simple-panel-dsi", },
+	{ .compatible = "simple-panel-spi", },
+	{}
+};
+
+U_BOOT_DRIVER(rockchip_panel) = {
+	.name = "rockchip_panel",
+	.id = UCLASS_PANEL,
+	.of_match = rockchip_panel_ids,
+	.ofdata_to_platdata = rockchip_panel_ofdata_to_platdata,
+	.probe = rockchip_panel_probe,
+	.priv_auto_alloc_size = sizeof(struct rockchip_panel_priv),
+	.platdata_auto_alloc_size = sizeof(struct rockchip_panel_plat),
+};
diff --git a/drivers/video/drm/rockchip_panel.h b/drivers/video/drm/rockchip_panel.h
new file mode 100644
index 0000000000..5e49fe3d1b
--- /dev/null
+++ b/drivers/video/drm/rockchip_panel.h
@@ -0,0 +1,87 @@
+/*
+ * (C) Copyright 2008-2017 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _ROCKCHIP_PANEL_H_
+#define _ROCKCHIP_PANEL_H_
+
+struct display_state;
+struct rockchip_panel;
+struct rockchip_conn;
+
+struct rockchip_panel_funcs {
+	void (*prepare)(struct rockchip_panel *panel);
+	void (*unprepare)(struct rockchip_panel *panel);
+	void (*enable)(struct rockchip_panel *panel);
+	void (*disable)(struct rockchip_panel *panel);
+	int (*get_mode)(struct rockchip_panel *panel,
+			struct drm_display_mode *mode);
+};
+
+struct rockchip_panel {
+	struct udevice *dev;
+	u32 bus_format;
+	unsigned int bpc;
+	const struct rockchip_panel_funcs *funcs;
+	const void *data;
+
+	struct rockchip_connector *conn;
+	struct display_state *state;
+};
+
+static inline void rockchip_panel_init(struct rockchip_panel *panel,
+				       struct rockchip_connector *conn,
+				       struct display_state *state)
+{
+	if (!panel)
+		return;
+
+	panel->conn = conn;
+	panel->state = state;
+
+	if (panel->bus_format)
+		state->conn_state.bus_format = panel->bus_format;
+
+	if (panel->bpc)
+		state->conn_state.bpc = panel->bpc;
+}
+
+static inline void rockchip_panel_prepare(struct rockchip_panel *panel)
+{
+	if (!panel)
+		return;
+
+	if (panel->funcs && panel->funcs->prepare)
+		panel->funcs->prepare(panel);
+}
+
+static inline void rockchip_panel_enable(struct rockchip_panel *panel)
+{
+	if (!panel)
+		return;
+
+	if (panel->funcs && panel->funcs->enable)
+		panel->funcs->enable(panel);
+}
+
+static inline void rockchip_panel_unprepare(struct rockchip_panel *panel)
+{
+	if (!panel)
+		return;
+
+	if (panel->funcs && panel->funcs->unprepare)
+		panel->funcs->unprepare(panel);
+}
+
+static inline void rockchip_panel_disable(struct rockchip_panel *panel)
+{
+	if (!panel)
+		return;
+
+	if (panel->funcs && panel->funcs->disable)
+		panel->funcs->disable(panel);
+}
+
+#endif	/* _ROCKCHIP_PANEL_H_ */
diff --git a/drivers/video/drm/rockchip_phy.c b/drivers/video/drm/rockchip_phy.c
new file mode 100644
index 0000000000..2f5d275d96
--- /dev/null
+++ b/drivers/video/drm/rockchip_phy.c
@@ -0,0 +1,86 @@
+/*
+ * (C) Copyright 2008-2017 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include "rockchip_phy.h"
+
+int rockchip_phy_init(struct rockchip_phy *phy)
+{
+	if (!phy)
+		return -ENODEV;
+
+	if (phy->funcs && phy->funcs->init)
+		return phy->funcs->init(phy);
+
+	return 0;
+}
+
+int rockchip_phy_power_on(struct rockchip_phy *phy)
+{
+	if (!phy)
+		return -ENODEV;
+
+	if (phy->funcs && phy->funcs->power_on)
+		return phy->funcs->power_on(phy);
+
+	return 0;
+}
+
+int rockchip_phy_power_off(struct rockchip_phy *phy)
+{
+	if (!phy)
+		return -ENODEV;
+
+	if (phy->funcs && phy->funcs->power_off)
+		return phy->funcs->power_off(phy);
+
+	return 0;
+}
+
+unsigned long rockchip_phy_set_pll(struct rockchip_phy *phy,
+				   unsigned long rate)
+{
+	if (!phy)
+		return -ENODEV;
+
+	if (phy->funcs && phy->funcs->set_pll)
+		return phy->funcs->set_pll(phy, rate);
+
+	return 0;
+}
+
+int rockchip_phy_set_bus_width(struct rockchip_phy *phy, u32 bus_width)
+{
+	if (!phy)
+		return -ENODEV;
+
+	if (phy->funcs && phy->funcs->set_bus_width)
+		return phy->funcs->set_bus_width(phy, bus_width);
+
+	return 0;
+}
+
+long rockchip_phy_round_rate(struct rockchip_phy *phy, unsigned long rate)
+{
+	if (!phy)
+		return -ENODEV;
+
+	if (phy->funcs && phy->funcs->round_rate)
+		return phy->funcs->round_rate(phy, rate);
+
+	return 0;
+}
+
+int rockchip_phy_set_mode(struct rockchip_phy *phy, enum phy_mode mode)
+{
+	if (!phy)
+		return -ENODEV;
+
+	if (phy->funcs && phy->funcs->set_mode)
+		return phy->funcs->set_mode(phy, mode);
+
+	return 0;
+}
diff --git a/drivers/video/drm/rockchip_phy.h b/drivers/video/drm/rockchip_phy.h
new file mode 100644
index 0000000000..b9091b7ae8
--- /dev/null
+++ b/drivers/video/drm/rockchip_phy.h
@@ -0,0 +1,45 @@
+/*
+ * (C) Copyright 2008-2017 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _ROCKCHIP_PHY_H_
+#define _ROCKCHIP_PHY_H_
+
+enum phy_mode {
+	PHY_MODE_INVALID,
+	PHY_MODE_MIPI_DPHY,
+	PHY_MODE_VIDEO_LVDS,
+	PHY_MODE_VIDEO_TTL,
+};
+
+struct rockchip_phy;
+
+struct rockchip_phy_funcs {
+	int (*init)(struct rockchip_phy *phy);
+	int (*power_on)(struct rockchip_phy *phy);
+	int (*power_off)(struct rockchip_phy *phy);
+	unsigned long (*set_pll)(struct rockchip_phy *phy, unsigned long rate);
+	int (*set_bus_width)(struct rockchip_phy *phy, u32 bus_width);
+	long (*round_rate)(struct rockchip_phy *phy, unsigned long rate);
+	int (*set_mode)(struct rockchip_phy *phy, enum phy_mode mode);
+};
+
+struct rockchip_phy {
+	struct udevice *dev;
+	const struct rockchip_phy_funcs *funcs;
+	const void *data;
+	int soc_type;
+};
+
+int rockchip_phy_init(struct rockchip_phy *phy);
+int rockchip_phy_power_off(struct rockchip_phy *phy);
+int rockchip_phy_power_on(struct rockchip_phy *phy);
+unsigned long rockchip_phy_set_pll(struct rockchip_phy *phy,
+				   unsigned long rate);
+int rockchip_phy_set_bus_width(struct rockchip_phy *phy, u32 bus_width);
+long rockchip_phy_round_rate(struct rockchip_phy *phy, unsigned long rate);
+int rockchip_phy_set_mode(struct rockchip_phy *phy, enum phy_mode mode);
+
+#endif
diff --git a/drivers/video/drm/rockchip_post_csc.c b/drivers/video/drm/rockchip_post_csc.c
new file mode 100755
index 0000000000..2409103957
--- /dev/null
+++ b/drivers/video/drm/rockchip_post_csc.c
@@ -0,0 +1,1587 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2022 Rockchip Electronics Co., Ltd.
+ * Author: Zhang yubing <yubing.zhang@rock-chips.com>
+ */
+
+#include <stdio.h>
+#include <linux/errno.h>
+
+#include "rockchip_post_csc.h"
+
+#define PQ_CSC_HUE_TABLE_NUM			256
+#define PQ_CSC_MODE_COEF_COMMENT_LEN		32
+#define PQ_CSC_SIMPLE_MAT_PARAM_FIX_BIT_WIDTH	10
+#define PQ_CSC_SIMPLE_MAT_PARAM_FIX_NUM		(1 << PQ_CSC_SIMPLE_MAT_PARAM_FIX_BIT_WIDTH)
+
+#define PQ_CALC_ENHANCE_BIT			6
+/* csc convert coef fixed-point num bit width */
+#define PQ_CSC_PARAM_FIX_BIT_WIDTH		10
+/* csc convert coef half fixed-point num bit width */
+#define PQ_CSC_PARAM_HALF_FIX_BIT_WIDTH		(PQ_CSC_PARAM_FIX_BIT_WIDTH - 1)
+/* csc convert coef fixed-point num */
+#define PQ_CSC_PARAM_FIX_NUM			(1 << PQ_CSC_PARAM_FIX_BIT_WIDTH)
+#define PQ_CSC_PARAM_HALF_FIX_NUM		(1 << PQ_CSC_PARAM_HALF_FIX_BIT_WIDTH)
+/* csc input param bit width */
+#define PQ_CSC_IN_PARAM_NORM_BIT_WIDTH		9
+/* csc input param normalization coef */
+#define PQ_CSC_IN_PARAM_NORM_COEF		(1 << PQ_CSC_IN_PARAM_NORM_BIT_WIDTH)
+
+/* csc hue table range [0,255] */
+#define PQ_CSC_HUE_TABLE_DIV_COEF		2
+/* csc brightness offset */
+#define PQ_CSC_BRIGHTNESS_OFFSET		256
+
+/* dc coef base bit width */
+#define PQ_CSC_DC_COEF_BASE_BIT_WIDTH		10
+/* input dc coef offset for 10bit data */
+#define PQ_CSC_DC_IN_OFFSET			64
+/* input and output dc coef offset for 10bit data u,v */
+#define PQ_CSC_DC_IN_OUT_DEFAULT		512
+/* r,g,b color temp div coef, range [-128,128] for 10bit data */
+#define PQ_CSC_TEMP_OFFSET_DIV_COEF		2
+
+#define	MAX(a, b)				((a) > (b) ? (a) : (b))
+#define	MIN(a, b)				((a) < (b) ? (a) : (b))
+#define	CLIP(x, min_v, max_v)			MIN(MAX(x, min_v), max_v)
+
+enum rk_pq_csc_mode {
+	RK_PQ_CSC_YUV2RGB_601 = 0,             /* YCbCr_601 LIMIT-> RGB FULL */
+	RK_PQ_CSC_YUV2RGB_709,                 /* YCbCr_709 LIMIT-> RGB FULL */
+	RK_PQ_CSC_RGB2YUV_601,                 /* RGB FULL->YCbCr_601 LIMIT */
+	RK_PQ_CSC_RGB2YUV_709,                 /* RGB FULL->YCbCr_709 LIMIT */
+	RK_PQ_CSC_YUV2YUV_709_601,             /* YCbCr_709 LIMIT->YCbCr_601 LIMIT */
+	RK_PQ_CSC_YUV2YUV_601_709,             /* YCbCr_601 LIMIT->YCbCr_709 LIMIT */
+	RK_PQ_CSC_YUV2YUV,                     /* YCbCr LIMIT->YCbCr LIMIT */
+	RK_PQ_CSC_YUV2RGB_601_FULL,            /* YCbCr_601 FULL-> RGB FULL */
+	RK_PQ_CSC_YUV2RGB_709_FULL,            /* YCbCr_709 FULL-> RGB FULL */
+	RK_PQ_CSC_RGB2YUV_601_FULL,            /* RGB FULL->YCbCr_601 FULL */
+	RK_PQ_CSC_RGB2YUV_709_FULL,            /* RGB FULL->YCbCr_709 FULL */
+	RK_PQ_CSC_YUV2YUV_709_601_FULL,        /* YCbCr_709 FULL->YCbCr_601 FULL */
+	RK_PQ_CSC_YUV2YUV_601_709_FULL,        /* YCbCr_601 FULL->YCbCr_709 FULL */
+	RK_PQ_CSC_YUV2YUV_FULL,                /* YCbCr FULL->YCbCr FULL */
+	RK_PQ_CSC_YUV2YUV_LIMIT2FULL,          /* YCbCr  LIMIT->YCbCr  FULL */
+	RK_PQ_CSC_YUV2YUV_601_709_LIMIT2FULL,  /* YCbCr 601 LIMIT->YCbCr 709 FULL */
+	RK_PQ_CSC_YUV2YUV_709_601_LIMIT2FULL,  /* YCbCr 709 LIMIT->YCbCr 601 FULL */
+	RK_PQ_CSC_YUV2YUV_FULL2LIMIT,          /* YCbCr  FULL->YCbCr  LIMIT */
+	RK_PQ_CSC_YUV2YUV_601_709_FULL2LIMIT,  /* YCbCr 601 FULL->YCbCr 709 LIMIT */
+	RK_PQ_CSC_YUV2YUV_709_601_FULL2LIMIT,  /* YCbCr 709 FULL->YCbCr 601 LIMIT */
+	RK_PQ_CSC_YUV2RGBL_601,                /* YCbCr_601 LIMIT-> RGB LIMIT */
+	RK_PQ_CSC_YUV2RGBL_709,                /* YCbCr_709 LIMIT-> RGB LIMIT */
+	RK_PQ_CSC_RGBL2YUV_601,                /* RGB LIMIT->YCbCr_601 LIMIT */
+	RK_PQ_CSC_RGBL2YUV_709,                /* RGB LIMIT->YCbCr_709 LIMIT */
+	RK_PQ_CSC_YUV2RGBL_601_FULL,           /* YCbCr_601 FULL-> RGB LIMIT */
+	RK_PQ_CSC_YUV2RGBL_709_FULL,           /* YCbCr_709 FULL-> RGB LIMIT */
+	RK_PQ_CSC_RGBL2YUV_601_FULL,           /* RGB LIMIT->YCbCr_601 FULL */
+	RK_PQ_CSC_RGBL2YUV_709_FULL,           /* RGB LIMIT->YCbCr_709 FULL */
+	RK_PQ_CSC_RGB2RGBL,                    /* RGB FULL->RGB LIMIT */
+	RK_PQ_CSC_RGBL2RGB,                    /* RGB LIMIT->RGB FULL */
+	RK_PQ_CSC_RGBL2RGBL,                   /* RGB LIMIT->RGB LIMIT */
+	RK_PQ_CSC_RGB2RGB,                     /* RGB FULL->RGB FULL */
+	RK_PQ_CSC_YUV2RGB_2020,                /* YUV 2020 FULL->RGB  2020 FULL */
+	RK_PQ_CSC_RGB2YUV2020_LIMIT2FULL,      /* BT2020RGBLIMIT -> BT2020YUVFULL */
+	RK_PQ_CSC_RGB2YUV2020_LIMIT,           /* BT2020RGBLIMIT -> BT2020YUVLIMIT */
+	RK_PQ_CSC_RGB2YUV2020_FULL2LIMIT,      /* BT2020RGBFULL -> BT2020YUVLIMIT */
+	RK_PQ_CSC_RGB2YUV2020_FULL,            /* BT2020RGBFULL -> BT2020YUVFULL */
+};
+
+enum color_space_type {
+	OPTM_CS_E_UNKNOWN = 0,
+	OPTM_CS_E_ITU_R_BT_709 = 1,
+	OPTM_CS_E_FCC = 4,
+	OPTM_CS_E_ITU_R_BT_470_2_BG = 5,
+	OPTM_CS_E_SMPTE_170_M = 6,
+	OPTM_CS_E_SMPTE_240_M = 7,
+	OPTM_CS_E_XV_YCC_709 = OPTM_CS_E_ITU_R_BT_709,
+	OPTM_CS_E_XV_YCC_601 = 8,
+	OPTM_CS_E_RGB = 9,
+	OPTM_CS_E_XV_YCC_2020 = 10,
+	OPTM_CS_E_RGB_2020 = 11,
+};
+
+enum vop_csc_format {
+	CSC_BT601L,
+	CSC_BT709L,
+	CSC_BT601F,
+	CSC_BT2020,
+	CSC_BT709L_13BIT,
+	CSC_BT709F_13BIT,
+	CSC_BT2020L_13BIT,
+	CSC_BT2020F_13BIT,
+};
+
+struct rk_pq_csc_coef {
+	s32 csc_coef00;
+	s32 csc_coef01;
+	s32 csc_coef02;
+	s32 csc_coef10;
+	s32 csc_coef11;
+	s32 csc_coef12;
+	s32 csc_coef20;
+	s32 csc_coef21;
+	s32 csc_coef22;
+};
+
+struct rk_pq_csc_ventor {
+	s32 csc_offset0;
+	s32 csc_offset1;
+	s32 csc_offset2;
+};
+
+struct rk_pq_csc_dc_coef {
+	s32 csc_in_dc0;
+	s32 csc_in_dc1;
+	s32 csc_in_dc2;
+	s32 csc_out_dc0;
+	s32 csc_out_dc1;
+	s32 csc_out_dc2;
+};
+
+/* color space param */
+struct rk_csc_colorspace_info {
+	enum color_space_type input_color_space;
+	enum color_space_type output_color_space;
+	bool in_full_range;
+	bool out_full_range;
+};
+
+struct rk_csc_mode_coef {
+	enum rk_pq_csc_mode csc_mode;
+	char c_csc_comment[PQ_CSC_MODE_COEF_COMMENT_LEN];
+	const struct rk_pq_csc_coef *pst_csc_coef;
+	const struct rk_pq_csc_dc_coef *pst_csc_dc_coef;
+	struct rk_csc_colorspace_info st_csc_color_info;
+};
+
+/*
+ *CSC matrix
+ */
+/* xv_ycc BT.601 limit(i.e. SD) -> RGB full */
+static const struct rk_pq_csc_coef rk_csc_table_xv_yccsdy_cb_cr_limit_to_rgb_full = {
+	1196, 0, 1639,
+	1196, -402, -835,
+	1196, 2072, 0
+};
+
+static const struct rk_pq_csc_dc_coef rk_dc_csc_table_xv_yccsdy_cb_cr_limit_to_rgb_full = {
+	-64, -512, -512,
+	0, 0, 0
+};
+
+/* BT.709 limit(i.e. HD) -> RGB full */
+static const struct rk_pq_csc_coef rk_csc_table_hdy_cb_cr_limit_to_rgb_full = {
+	1196, 0, 1841,
+	1196, -219, -547,
+	1196, 2169, 0
+};
+
+static const struct rk_pq_csc_dc_coef rk_dc_csc_table_hdy_cb_cr_limit_to_rgb_full = {
+	-64, -512, -512,
+	0, 0, 0
+};
+
+/* RGB full-> YUV601 (i.e. SD) limit */
+static const struct rk_pq_csc_coef rk_csc_table_rgb_to_xv_yccsdy_cb_cr = {
+	262, 515, 100,
+	-151, -297, 448,
+	448, -376, -73
+};
+
+static const struct rk_pq_csc_dc_coef rk_dc_csc_table_rgb_to_xv_yccsdy_cb_cr = {
+	0, 0, 0,
+	64, 512, 512
+};
+
+/* RGB full-> YUV709 (i.e. SD) limit */
+static const struct rk_pq_csc_coef rk_csc_table_rgb_to_hdy_cb_cr = {
+	186, 627, 63,
+	-103, -346, 448,
+	448, -407, -41
+};
+
+static const struct rk_pq_csc_dc_coef rk_dc_csc_table_rgb_to_hdy_cb_cr = {
+	0, 0, 0,
+	64, 512, 512
+};
+
+/* BT.709 (i.e. HD) -> to xv_ycc BT.601 (i.e. SD) */
+static const struct rk_pq_csc_coef rk_csc_table_hdy_cb_cr_to_xv_yccsdy_cb_cr = {
+	1024, 104, 201,
+	0, 1014, -113,
+	0, -74, 1007
+};
+static const struct rk_pq_csc_dc_coef rk_dc_csc_table_hdy_cb_cr_to_xv_yccsdy_cb_cr = {
+	-64, -512, -512,
+	64, 512, 512
+};
+static const struct rk_pq_csc_dc_coef rk_dc_csc_table_hdy_cb_cr_full_to_xv_yccsdy_cb_cr_full = {
+	0, -512, -512,
+	0, 512, 512
+};
+
+/* xv_ycc BT.601 (i.e. SD) -> to BT.709 (i.e. HD) */
+static const struct rk_pq_csc_coef rk_csc_table_xv_yccsdy_cb_cr_to_hdy_cb_cr = {
+	1024, -121, -218,
+	0, 1043, 117,
+	0, 77, 1050
+};
+
+static const struct rk_pq_csc_dc_coef rk_dc_csc_table_xv_yccsdy_cb_cr_to_hdy_cb_cr = {
+	-64, -512, -512,
+	64, 512, 512
+};
+
+/* xv_ycc BT.601 full(i.e. SD) -> RGB full */
+static const struct rk_pq_csc_coef rk_csc_table_xv_yccsdy_cb_cr_to_rgb_full = {
+	1024, 0, 1436,
+	1024, -352, -731,
+	1024, 1815, 0
+};
+static const struct rk_pq_csc_dc_coef rk_dc_csc_table_xv_yccsdy_cb_cr_to_rgb_full = {
+	0, -512, -512,
+	0, 0, 0
+};
+
+/* BT.709 full(i.e. HD) -> RGB full */
+static const struct rk_pq_csc_coef rk_csc_table_hdy_cb_cr_to_rgb_full = {
+	1024, 0, 1613,
+	1024, -192, -479,
+	1024, 1900, 0
+};
+static const struct rk_pq_csc_dc_coef rk_dc_csc_table_hdy_cb_cr_to_rgb_full = {
+	0, -512, -512,
+	0, 0, 0
+};
+
+/* RGB full-> YUV601 full(i.e. SD) */
+static const struct rk_pq_csc_coef rk_csc_table_rgb_to_xv_yccsdy_cb_cr_full = {
+	306, 601, 117,
+	-173, -339, 512,
+	512, -429, -83
+};
+static const struct rk_pq_csc_dc_coef rk_dc_csc_table_rgb_to_xv_yccsdy_cb_cr_full = {
+	0, 0, 0,
+	0, 512, 512
+};
+
+/* RGB full-> YUV709 full (i.e. SD) */
+static const struct rk_pq_csc_coef rk_csc_table_rgb_to_hdy_cb_cr_full = {
+	218, 732, 74,
+	-117, -395, 512,
+	512, -465, -47
+};
+static const struct rk_pq_csc_dc_coef rk_dc_csc_table_rgb_to_hdy_cb_cr_full = {
+	0, 0, 0,
+	0, 512, 512
+};
+
+/* limit -> full */
+static const struct rk_pq_csc_coef rk_csc_table_identity_y_cb_cr_limit_to_y_cb_cr_full = {
+	1196, 0, 0,
+	0, 1169, 0,
+	0, 0, 1169
+};
+static const struct rk_pq_csc_dc_coef rk_dc_csc_table_identity_y_cb_cr_limit_to_y_cb_cr_full = {
+	-64, -512, -512,
+	0, 512, 512
+};
+
+/* 601 limit -> 709 full */
+static const struct rk_pq_csc_coef rk_csc_table_identity_601_limit_to_709_full = {
+	1196, -138, -249,
+	0, 1191, 134,
+	0, 88, 1199
+};
+static const struct rk_pq_csc_dc_coef rk_dc_csc_table_identity_601_limit_to_709_full = {
+	-64, -512, -512,
+	0, 512, 512
+};
+
+/* 709 limit -> 601 full */
+static const struct rk_pq_csc_coef rk_csc_table_identity_709_limit_to_601_full = {
+	1196, 119, 229,
+	0, 1157, -129,
+	0, -85, 1150
+};
+static const struct rk_pq_csc_dc_coef rk_dc_csc_table_identity_709_limit_to_601_full = {
+	-64, -512, -512,
+	0, 512, 512
+};
+
+/* full ->   limit */
+static const struct rk_pq_csc_coef rk_csc_table_identity_y_cb_cr_full_to_y_cb_cr_limit = {
+	877, 0, 0,
+	0, 897, 0,
+	0, 0, 897
+};
+static const struct rk_pq_csc_dc_coef rk_dc_csc_table_identity_y_cb_cr_full_to_y_cb_cr_limit = {
+	0, -512, -512,
+	64, 512, 512
+};
+
+/* 601 full ->  709 limit */
+static const struct rk_pq_csc_coef rk_csc_table_identity_y_cb_cr_601_full_to_y_cb_cr_709_limit = {
+	877, -106, -191,
+	0, 914, 103,
+	0, 67, 920
+};
+static const struct rk_pq_csc_dc_coef
+rk_dc_csc_table_identity_y_cb_cr_601_full_to_y_cb_cr_709_limit = {
+	0, -512, -512,
+	64, 512, 512
+};
+
+/* 709 full ->  601 limit */
+static const struct rk_pq_csc_coef rk_csc_table_identity_y_cb_cr_709_full_to_y_cb_cr_601_limit = {
+	877, 91, 176,
+	0, 888, -99,
+	0, -65, 882
+};
+static const struct rk_pq_csc_dc_coef
+rk_dc_csc_table_identity_y_cb_cr_709_full_to_y_cb_cr_601_limit = {
+	0, -512, -512,
+	64, 512, 512
+};
+
+/* xv_ycc BT.601 limit(i.e. SD) -> RGB limit */
+static const struct rk_pq_csc_coef rk_csc_table_xv_yccsdy_cb_cr_limit_to_rgb_limit = {
+	1024, 0, 1404,
+	1024, -344, -715,
+	1024, 1774, 0
+};
+static const struct rk_pq_csc_dc_coef rk_dc_csc_table_xv_yccsdy_cb_cr_limit_to_rgb_limit = {
+	-64, -512, -512,
+	64, 64, 64
+};
+
+/* BT.709 limit(i.e. HD) -> RGB limit */
+static const struct rk_pq_csc_coef rk_csc_table_hdy_cb_cr_limit_to_rgb_limit = {
+	1024, 0, 1577,
+	1024, -188, -469,
+	1024, 1858, 0
+};
+static const struct rk_pq_csc_dc_coef rk_dc_csc_table_hdy_cb_cr_limit_to_rgb_limit = {
+	-64, -512, -512,
+	64, 64, 64
+};
+
+/* RGB limit-> YUV601 (i.e. SD) limit */
+static const struct rk_pq_csc_coef rk_csc_table_rgb_limit_to_xv_yccsdy_cb_cr = {
+	306, 601, 117,
+	-177, -347, 524,
+	524, -439, -85
+};
+static const struct rk_pq_csc_dc_coef rk_dc_csc_table_rgb_limit_to_xv_yccsdy_cb_cr = {
+	-64, -64, -64,
+	64, 512, 512
+};
+
+/* RGB limit -> YUV709 (i.e. SD) limit */
+static const struct rk_pq_csc_coef rk_csc_table_rgb_limit_to_hdy_cb_cr = {
+	218, 732, 74,
+	-120, -404, 524,
+	524, -476, -48
+};
+static const struct rk_pq_csc_dc_coef rk_dc_csc_table_rgb_limit_to_hdy_cb_cr = {
+	-64, -64, -64,
+	64, 512, 512
+};
+
+/* xv_ycc BT.601 full(i.e. SD) -> RGB limit */
+static const struct rk_pq_csc_coef rk_csc_table_xv_yccsdy_cb_cr_to_rgb_limit = {
+	877, 0, 1229,
+	877, -302, -626,
+	877, 1554, 0
+};
+static const struct rk_pq_csc_dc_coef rk_dc_csc_table_xv_yccsdy_cb_cr_to_rgb_limit = {
+	0, -512, -512,
+	64, 64, 64
+};
+
+/* BT.709 full(i.e. HD) -> RGB limit */
+static const struct rk_pq_csc_coef rk_csc_table_hdy_cb_cr_to_rgb_limit = {
+	877, 0, 1381,
+	877, -164, -410,
+	877, 1627, 0
+};
+static const struct rk_pq_csc_dc_coef rk_dc_csc_table_hdy_cb_cr_to_rgb_limit = {
+	0, -512, -512,
+	64, 64, 64
+};
+
+/* RGB limit-> YUV601 full(i.e. SD) */
+static const struct rk_pq_csc_coef rk_csc_table_rgb_limit_to_xv_yccsdy_cb_cr_full = {
+	358, 702, 136,
+	-202, -396, 598,
+	598, -501, -97
+};
+static const struct rk_pq_csc_dc_coef rk_dc_csc_table_rgb_limit_to_xv_yccsdy_cb_cr_full = {
+	-64, -64, -64,
+	0, 512, 512
+};
+
+/* RGB limit-> YUV709 full (i.e. SD) */
+static const struct rk_pq_csc_coef rk_csc_table_rgb_limit_to_hdy_cb_cr_full = {
+	254, 855, 86,
+	-137, -461, 598,
+	598, -543, -55
+};
+static const struct rk_pq_csc_dc_coef rk_dc_csc_table_rgb_limit_to_hdy_cb_cr_full = {
+	-64, -64, -64,
+	0, 512, 512
+};
+
+/* RGB full -> RGB limit */
+static const struct rk_pq_csc_coef rk_csc_table_identity_rgb_to_rgb_limit = {
+	877, 0, 0,
+	0, 877, 0,
+	0, 0, 877
+};
+static const struct rk_pq_csc_dc_coef rk_dc_csc_table_identity_rgb_to_rgb_limit = {
+	0, 0, 0,
+	64, 64, 64
+};
+
+/* RGB limit -> RGB full */
+static const struct rk_pq_csc_coef rk_csc_table_identity_rgb_limit_to_rgb = {
+	1196, 0, 0,
+	0, 1196, 0,
+	0, 0, 1196
+};
+static const struct rk_pq_csc_dc_coef rk_dc_csc_table_identity_rgb_limit_to_rgb = {
+	-64, -64, -64,
+	0, 0, 0
+};
+
+/* RGB limit/full -> RGB limit/full */
+static const struct rk_pq_csc_coef rk_csc_table_identity_rgb_to_rgb = {
+	1024, 0, 0,
+	0, 1024, 0,
+	0, 0, 1024
+};
+static const struct rk_pq_csc_dc_coef rk_dc_csc_table_identity_rgb_to_rgb1 = {
+	-64, -64, -64,
+	64, 64, 64
+};
+
+static const struct rk_pq_csc_dc_coef rk_dc_csc_table_identity_rgb_to_rgb2 = {
+	0, 0, 0,
+	0, 0, 0
+};
+
+static const struct rk_pq_csc_coef rk_csc_table_identity_yuv_to_rgb_2020 = {
+	1024, 0, 1510,
+	1024, -169, -585,
+	1024, 1927, 0
+};
+static const struct rk_pq_csc_dc_coef rk_dc_csc_table_identity_yuv_to_rgb_2020 = {
+	0, -512, -512,
+	0, 0, 0
+};
+
+/* 2020 RGB LIMIT ->YUV LIMIT */
+static const struct rk_pq_csc_coef rk_csc_table_identity_rgb_limit_to_yuv_limit_2020 = {
+	269, 694, 61,
+	-146, -377, 524,
+	524, -482, -42
+};
+static const struct rk_pq_csc_dc_coef rk_dc_csc_table_identity_rgb_limit_to_yuv_limit_2020 = {
+	-64, -64, -64,
+	64, 512, 512
+};
+
+/* 2020 RGB LIMIT ->YUV FULL */
+static const struct rk_pq_csc_coef rk_csc_table_identity_rgb_limit_to_yuv_full_2020 = {
+	314, 811, 71,
+	-167, -431, 598,
+	598, -550, -48
+};
+static const struct rk_pq_csc_dc_coef rk_dc_csc_table_identity_rgb_limit_to_yuv_full_2020 = {
+	-64, -64, -64,
+	0, 512, 512
+};
+
+/* 2020 RGB FULL ->YUV LIMIT */
+static const struct rk_pq_csc_coef rk_csc_table_identity_rgb_full_to_yuv_limit_2020 = {
+	230, 595, 52,
+	-125, -323, 448,
+	448, -412, -36
+};
+static const struct rk_pq_csc_dc_coef rk_dc_csc_table_identity_rgb_full_to_yuv_limit_2020 = {
+	0, 0, 0,
+	64, 512, 512
+};
+
+/* 2020 RGB FULL ->YUV FULL */
+static const struct rk_pq_csc_coef rk_csc_table_identity_rgb_full_to_yuv_full_2020 = {
+	269, 694, 61,
+	-143, -369, 512,
+	512, -471, -41
+};
+static const struct rk_pq_csc_dc_coef rk_dc_csc_table_identity_rgb_full_to_yuv_full_2020 = {
+	0, 0, 0,
+	0, 512, 512
+};
+
+/* identity matrix */
+static const struct rk_pq_csc_coef rk_csc_table_identity_y_cb_cr_to_y_cb_cr = {
+	1024, 0, 0,
+	0, 1024, 0,
+	0, 0, 1024
+};
+
+/* 10bit Hue Sin Look Up Table -> range[-30, 30] */
+static const s32 g_hue_sin_table[PQ_CSC_HUE_TABLE_NUM] = {
+	512, 508, 505, 501, 497, 494, 490, 486,
+	483, 479, 475, 472, 468, 464, 460, 457,
+	453, 449, 445, 442, 438, 434, 430, 426,
+	423, 419, 415, 411, 407, 403, 400, 396,
+	392, 388, 384, 380, 376, 372, 369, 365,
+	361, 357, 353, 349, 345, 341, 337, 333,
+	329, 325, 321, 317, 313, 309, 305, 301,
+	297, 293, 289, 285, 281, 277, 273, 269,
+	265, 261, 257, 253, 249, 245, 241, 237,
+	233, 228, 224, 220, 216, 212, 208, 204,
+	200, 196, 192, 187, 183, 179, 175, 171,
+	167, 163, 159, 154, 150, 146, 142, 138,
+	134, 130, 125, 121, 117, 113, 109, 105,
+	100, 96, 92, 88, 84, 80, 75, 71,
+	67, 63, 59, 54, 50, 46, 42, 38,
+	34, 29, 25, 21, 17, 13, 8, 4,
+	0, -4, -8, -13, -17, -21, -25, -29,
+	-34, -38, -42, -46, -50, -54, -59, -63,
+	-67, -71, -75, -80, -84, -88, -92, -96,
+	-100, -105, -109, -113, -117, -121, -125, -130,
+	-134, -138, -142, -146, -150, -154, -159, -163,
+	-167, -171, -175, -179, -183, -187, -192, -196,
+	-200, -204, -208, -212, -216, -220, -224, -228,
+	-233, -237, -241, -245, -249, -253, -257, -261,
+	-265, -269, -273, -277, -281, -285, -289, -293,
+	-297, -301, -305, -309, -313, -317, -321, -325,
+	-329, -333, -337, -341, -345, -349, -353, -357,
+	-361, -365, -369, -372, -376, -380, -384, -388,
+	-392, -396, -400, -403, -407, -411, -415, -419,
+	-423, -426, -430, -434, -438, -442, -445, -449,
+	-453, -457, -460, -464, -468, -472, -475, -479,
+	-483, -486, -490, -494, -497, -501, -505, -508,
+};
+
+/* 10bit Hue Cos Look Up Table  -> range[-30, 30] */
+static const s32 g_hue_cos_table[PQ_CSC_HUE_TABLE_NUM] = {
+	887, 889, 891, 893, 895, 897, 899, 901,
+	903, 905, 907, 909, 911, 913, 915, 917,
+	919, 920, 922, 924, 926, 928, 929, 931,
+	933, 935, 936, 938, 940, 941, 943, 945,
+	946, 948, 949, 951, 953, 954, 956, 957,
+	959, 960, 962, 963, 964, 966, 967, 969,
+	970, 971, 973, 974, 975, 976, 978, 979,
+	980, 981, 983, 984, 985, 986, 987, 988,
+	989, 990, 992, 993, 994, 995, 996, 997,
+	998, 998, 999, 1000, 1001, 1002, 1003, 1004,
+	1005, 1005, 1006, 1007, 1008, 1008, 1009, 1010,
+	1011, 1011, 1012, 1013, 1013, 1014, 1014, 1015,
+	1015, 1016, 1016, 1017, 1017, 1018, 1018, 1019,
+	1019, 1020, 1020, 1020, 1021, 1021, 1021, 1022,
+	1022, 1022, 1022, 1023, 1023, 1023, 1023, 1023,
+	1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024,
+	1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024,
+	1023, 1023, 1023, 1023, 1023, 1022, 1022, 1022,
+	1022, 1021, 1021, 1021, 1020, 1020, 1020, 1019,
+	1019, 1018, 1018, 1017, 1017, 1016, 1016, 1015,
+	1015, 1014, 1014, 1013, 1013, 1012, 1011, 1011,
+	1010, 1009, 1008, 1008, 1007, 1006, 1005, 1005,
+	1004, 1003, 1002, 1001, 1000, 999, 998, 998,
+	997, 996, 995, 994, 993, 992, 990, 989,
+	988, 987, 986, 985, 984, 983, 981, 980,
+	979, 978, 976, 975, 974, 973, 971, 970,
+	969, 967, 966, 964, 963, 962, 960, 959,
+	957, 956, 954, 953, 951, 949, 948, 946,
+	945, 943, 941, 940, 938, 936, 935, 933,
+	931, 929, 928, 926, 924, 922, 920, 919,
+	917, 915, 913, 911, 909, 907, 905, 903,
+	901, 899, 897, 895, 893, 891, 889, 887
+};
+
+/*
+ *CSC Param Struct
+ */
+static const struct rk_csc_mode_coef g_mode_csc_coef[] = {
+	{
+		RK_PQ_CSC_YUV2RGB_601, "YUV601 L->RGB F",
+		&rk_csc_table_xv_yccsdy_cb_cr_limit_to_rgb_full,
+		&rk_dc_csc_table_xv_yccsdy_cb_cr_limit_to_rgb_full,
+		{
+			OPTM_CS_E_XV_YCC_601, OPTM_CS_E_RGB, false, true
+		}
+	},
+	{
+		RK_PQ_CSC_YUV2RGB_709, "YUV709 L->RGB F",
+		&rk_csc_table_hdy_cb_cr_limit_to_rgb_full,
+		&rk_dc_csc_table_hdy_cb_cr_limit_to_rgb_full,
+		{
+			OPTM_CS_E_ITU_R_BT_709, OPTM_CS_E_RGB, false, true
+		}
+	},
+	{
+		RK_PQ_CSC_RGB2YUV_601, "RGB F->YUV601 L",
+		&rk_csc_table_rgb_to_xv_yccsdy_cb_cr,
+		&rk_dc_csc_table_rgb_to_xv_yccsdy_cb_cr,
+		{
+			OPTM_CS_E_RGB, OPTM_CS_E_XV_YCC_601, true, false
+		}
+	},
+	{
+		RK_PQ_CSC_RGB2YUV_709, "RGB F->YUV709 L",
+		&rk_csc_table_rgb_to_hdy_cb_cr,
+		&rk_dc_csc_table_rgb_to_hdy_cb_cr,
+		{
+			OPTM_CS_E_RGB, OPTM_CS_E_ITU_R_BT_709, true, false
+		}
+	},
+	{
+		RK_PQ_CSC_YUV2YUV_709_601, "YUV709 L->YUV601 L",
+		&rk_csc_table_hdy_cb_cr_to_xv_yccsdy_cb_cr,
+		&rk_dc_csc_table_hdy_cb_cr_to_xv_yccsdy_cb_cr,
+		{
+			OPTM_CS_E_ITU_R_BT_709, OPTM_CS_E_XV_YCC_601, false, false
+		}
+	},
+	{
+		RK_PQ_CSC_YUV2YUV_601_709, "YUV601 L->YUV709 L",
+		&rk_csc_table_xv_yccsdy_cb_cr_to_hdy_cb_cr,
+		&rk_dc_csc_table_xv_yccsdy_cb_cr_to_hdy_cb_cr,
+		{
+			OPTM_CS_E_XV_YCC_601, OPTM_CS_E_ITU_R_BT_709, false, false
+		}
+	},
+	{
+		RK_PQ_CSC_YUV2YUV, "YUV L->YUV L",
+		&rk_csc_table_xv_yccsdy_cb_cr_to_hdy_cb_cr,
+		&rk_dc_csc_table_xv_yccsdy_cb_cr_to_hdy_cb_cr,
+		{
+			OPTM_CS_E_ITU_R_BT_709, OPTM_CS_E_ITU_R_BT_709, false, false
+		}
+	},
+	{
+		RK_PQ_CSC_YUV2RGB_601_FULL, "YUV601 F->RGB F",
+		&rk_csc_table_xv_yccsdy_cb_cr_to_rgb_full,
+		&rk_dc_csc_table_xv_yccsdy_cb_cr_to_rgb_full,
+		{
+			OPTM_CS_E_XV_YCC_601, OPTM_CS_E_RGB, true, true
+		}
+	},
+		{
+		RK_PQ_CSC_YUV2RGB_709_FULL, "YUV709 F->RGB F",
+		&rk_csc_table_hdy_cb_cr_to_rgb_full,
+		&rk_dc_csc_table_hdy_cb_cr_to_rgb_full,
+		{
+			OPTM_CS_E_ITU_R_BT_709, OPTM_CS_E_RGB, true, true
+		}
+	},
+	{
+		RK_PQ_CSC_RGB2YUV_601_FULL, "RGB F->YUV601 F",
+		&rk_csc_table_rgb_to_xv_yccsdy_cb_cr_full,
+		&rk_dc_csc_table_rgb_to_xv_yccsdy_cb_cr_full,
+		{
+			OPTM_CS_E_RGB, OPTM_CS_E_XV_YCC_601, true, true
+		}
+	},
+	{
+		RK_PQ_CSC_RGB2YUV_709_FULL, "RGB F->YUV709 F",
+		&rk_csc_table_rgb_to_hdy_cb_cr_full,
+		&rk_dc_csc_table_rgb_to_hdy_cb_cr_full,
+		{
+			OPTM_CS_E_RGB, OPTM_CS_E_ITU_R_BT_709, true, true
+		}
+	},
+	{
+		RK_PQ_CSC_YUV2YUV_709_601_FULL, "YUV709 F->YUV601 F",
+		&rk_csc_table_hdy_cb_cr_to_xv_yccsdy_cb_cr,
+		&rk_dc_csc_table_hdy_cb_cr_full_to_xv_yccsdy_cb_cr_full,
+		{
+			OPTM_CS_E_ITU_R_BT_709, OPTM_CS_E_XV_YCC_601, true, true
+		}
+	},
+	{
+		RK_PQ_CSC_YUV2YUV_601_709_FULL, "YUV601 F->YUV709 F",
+		&rk_csc_table_xv_yccsdy_cb_cr_to_hdy_cb_cr,
+		&rk_dc_csc_table_hdy_cb_cr_full_to_xv_yccsdy_cb_cr_full,
+		{
+			OPTM_CS_E_XV_YCC_601, OPTM_CS_E_ITU_R_BT_709, true, true
+		}
+	},
+	{
+		RK_PQ_CSC_YUV2YUV_FULL, "YUV F->YUV F",
+		&rk_csc_table_identity_y_cb_cr_to_y_cb_cr,
+		&rk_dc_csc_table_hdy_cb_cr_full_to_xv_yccsdy_cb_cr_full,
+		{
+			OPTM_CS_E_ITU_R_BT_709, OPTM_CS_E_ITU_R_BT_709, true, true
+		}
+	},
+	{
+		RK_PQ_CSC_YUV2YUV_LIMIT2FULL, "YUV L->YUV F",
+		&rk_csc_table_identity_y_cb_cr_limit_to_y_cb_cr_full,
+		&rk_dc_csc_table_identity_y_cb_cr_limit_to_y_cb_cr_full,
+		{
+			OPTM_CS_E_ITU_R_BT_709, OPTM_CS_E_ITU_R_BT_709, false, true
+		}
+	},
+	{
+		RK_PQ_CSC_YUV2YUV_601_709_LIMIT2FULL, "YUV601 L->YUV709 F",
+		&rk_csc_table_identity_601_limit_to_709_full,
+		&rk_dc_csc_table_identity_601_limit_to_709_full,
+		{
+			OPTM_CS_E_XV_YCC_601, OPTM_CS_E_ITU_R_BT_709, false, true
+		}
+	},
+	{
+		RK_PQ_CSC_YUV2YUV_709_601_LIMIT2FULL, "YUV709 L->YUV601 F",
+		&rk_csc_table_identity_709_limit_to_601_full,
+		&rk_dc_csc_table_identity_709_limit_to_601_full,
+		{
+			OPTM_CS_E_ITU_R_BT_709, OPTM_CS_E_XV_YCC_601, false, true
+		}
+	},
+	{
+		RK_PQ_CSC_YUV2YUV_FULL2LIMIT, "YUV F->YUV L",
+		&rk_csc_table_identity_y_cb_cr_full_to_y_cb_cr_limit,
+		&rk_dc_csc_table_identity_y_cb_cr_full_to_y_cb_cr_limit,
+		{
+			OPTM_CS_E_ITU_R_BT_709, OPTM_CS_E_ITU_R_BT_709, true, false
+		}
+	},
+	{
+		RK_PQ_CSC_YUV2YUV_601_709_FULL2LIMIT, "YUV601 F->YUV709 L",
+		&rk_csc_table_identity_y_cb_cr_601_full_to_y_cb_cr_709_limit,
+		&rk_dc_csc_table_identity_y_cb_cr_601_full_to_y_cb_cr_709_limit,
+		{
+			OPTM_CS_E_XV_YCC_601, OPTM_CS_E_ITU_R_BT_709, true, false
+		}
+	},
+	{
+		RK_PQ_CSC_YUV2YUV_709_601_FULL2LIMIT, "YUV709 F->YUV601 L",
+		&rk_csc_table_identity_y_cb_cr_709_full_to_y_cb_cr_601_limit,
+		&rk_dc_csc_table_identity_y_cb_cr_709_full_to_y_cb_cr_601_limit,
+		{
+			OPTM_CS_E_ITU_R_BT_709, OPTM_CS_E_XV_YCC_601, true, false
+		}
+	},
+	{
+		RK_PQ_CSC_YUV2RGBL_601, "YUV601 L->RGB L",
+		&rk_csc_table_xv_yccsdy_cb_cr_limit_to_rgb_limit,
+		&rk_dc_csc_table_xv_yccsdy_cb_cr_limit_to_rgb_limit,
+		{
+			OPTM_CS_E_XV_YCC_601, OPTM_CS_E_RGB, false, false
+		}
+	},
+	{
+		RK_PQ_CSC_YUV2RGBL_709, "YUV709 L->RGB L",
+		&rk_csc_table_hdy_cb_cr_limit_to_rgb_limit,
+		&rk_dc_csc_table_hdy_cb_cr_limit_to_rgb_limit,
+		{
+			OPTM_CS_E_ITU_R_BT_709, OPTM_CS_E_RGB, false, false
+		}
+	},
+	{
+		RK_PQ_CSC_RGBL2YUV_601, "RGB L->YUV601 L",
+		&rk_csc_table_rgb_limit_to_xv_yccsdy_cb_cr,
+		&rk_dc_csc_table_rgb_limit_to_xv_yccsdy_cb_cr,
+		{
+			OPTM_CS_E_RGB, OPTM_CS_E_XV_YCC_601, false, false
+		}
+	},
+	{
+		RK_PQ_CSC_RGBL2YUV_709, "RGB L->YUV709 L",
+		&rk_csc_table_rgb_limit_to_hdy_cb_cr,
+		&rk_dc_csc_table_rgb_limit_to_hdy_cb_cr,
+		{
+			OPTM_CS_E_RGB, OPTM_CS_E_ITU_R_BT_709, false, false
+		}
+	},
+	{
+		RK_PQ_CSC_YUV2RGBL_601_FULL, "YUV601 F->RGB L",
+		&rk_csc_table_xv_yccsdy_cb_cr_to_rgb_limit,
+		&rk_dc_csc_table_xv_yccsdy_cb_cr_to_rgb_limit,
+		{
+			OPTM_CS_E_XV_YCC_601, OPTM_CS_E_RGB, true, false
+		}
+	},
+	{
+		RK_PQ_CSC_YUV2RGBL_709_FULL, "YUV709 F->RGB L",
+		&rk_csc_table_hdy_cb_cr_to_rgb_limit,
+		&rk_dc_csc_table_hdy_cb_cr_to_rgb_limit,
+		{
+			OPTM_CS_E_ITU_R_BT_709, OPTM_CS_E_RGB, true, false
+		}
+	},
+	{
+		RK_PQ_CSC_RGBL2YUV_601_FULL, "RGB L->YUV601 F",
+		&rk_csc_table_rgb_limit_to_xv_yccsdy_cb_cr_full,
+		&rk_dc_csc_table_rgb_limit_to_xv_yccsdy_cb_cr_full,
+		{
+			OPTM_CS_E_RGB, OPTM_CS_E_XV_YCC_601, false, true
+		}
+	},
+	{
+		RK_PQ_CSC_RGBL2YUV_709_FULL, "RGB L->YUV709 F",
+		&rk_csc_table_rgb_limit_to_hdy_cb_cr_full,
+		&rk_dc_csc_table_rgb_limit_to_hdy_cb_cr_full,
+		{
+			OPTM_CS_E_RGB, OPTM_CS_E_ITU_R_BT_709, false, true
+		}
+	},
+	{
+		RK_PQ_CSC_RGB2RGBL, "RGB F->RGB L",
+		&rk_csc_table_identity_rgb_to_rgb_limit,
+		&rk_dc_csc_table_identity_rgb_to_rgb_limit,
+		{
+			OPTM_CS_E_RGB, OPTM_CS_E_RGB, true, false
+		}
+	},
+	{
+		RK_PQ_CSC_RGBL2RGB, "RGB L->RGB F",
+		&rk_csc_table_identity_rgb_limit_to_rgb,
+		&rk_dc_csc_table_identity_rgb_limit_to_rgb,
+		{
+			OPTM_CS_E_RGB, OPTM_CS_E_RGB, false, true
+		}
+	},
+	{
+		RK_PQ_CSC_RGBL2RGBL, "RGB L->RGB L",
+		&rk_csc_table_identity_rgb_to_rgb,
+		&rk_dc_csc_table_identity_rgb_to_rgb1,
+		{
+			OPTM_CS_E_RGB, OPTM_CS_E_RGB, false, false
+		}
+	},
+	{
+		RK_PQ_CSC_RGB2RGB, "RGB F->RGB F",
+		&rk_csc_table_identity_rgb_to_rgb,
+		&rk_dc_csc_table_identity_rgb_to_rgb2,
+		{
+			OPTM_CS_E_RGB, OPTM_CS_E_RGB, true, true
+		}
+	},
+	{
+		RK_PQ_CSC_YUV2RGB_2020, "YUV2020 F->RGB2020 F",
+		&rk_csc_table_identity_yuv_to_rgb_2020,
+		&rk_dc_csc_table_identity_yuv_to_rgb_2020,
+		{
+			OPTM_CS_E_XV_YCC_2020, OPTM_CS_E_RGB_2020, true, true
+		}
+	},
+	{
+		RK_PQ_CSC_RGB2YUV2020_LIMIT2FULL, "RGB2020 L->YUV2020 F",
+		&rk_csc_table_identity_rgb_limit_to_yuv_full_2020,
+		&rk_dc_csc_table_identity_rgb_limit_to_yuv_full_2020,
+		{
+			OPTM_CS_E_RGB_2020, OPTM_CS_E_XV_YCC_2020, false, true
+		}
+	},
+	{
+		RK_PQ_CSC_RGB2YUV2020_LIMIT, "RGB2020 L->YUV2020 L",
+		&rk_csc_table_identity_rgb_limit_to_yuv_limit_2020,
+		&rk_dc_csc_table_identity_rgb_limit_to_yuv_limit_2020,
+		{
+			OPTM_CS_E_RGB_2020, OPTM_CS_E_XV_YCC_2020, false, false
+		}
+	},
+	{
+		RK_PQ_CSC_RGB2YUV2020_FULL2LIMIT, "RGB2020 F->YUV2020 L",
+		&rk_csc_table_identity_rgb_full_to_yuv_limit_2020,
+		&rk_dc_csc_table_identity_rgb_full_to_yuv_limit_2020,
+		{
+			OPTM_CS_E_RGB_2020, OPTM_CS_E_XV_YCC_2020, true, false
+		}
+	},
+	{
+		RK_PQ_CSC_RGB2YUV2020_FULL, "RGB2020 F->YUV2020 F",
+		&rk_csc_table_identity_rgb_full_to_yuv_full_2020,
+		&rk_dc_csc_table_identity_rgb_full_to_yuv_full_2020,
+		{
+			OPTM_CS_E_RGB_2020, OPTM_CS_E_XV_YCC_2020, true, true
+		}
+	},
+	{
+		RK_PQ_CSC_YUV2YUV, "YUV 601 L->YUV 601 L",
+		&rk_csc_table_xv_yccsdy_cb_cr_to_hdy_cb_cr,
+		&rk_dc_csc_table_xv_yccsdy_cb_cr_to_hdy_cb_cr,
+		{
+			OPTM_CS_E_XV_YCC_601, OPTM_CS_E_XV_YCC_601, false, false
+		}
+	},
+	{
+		RK_PQ_CSC_YUV2YUV_FULL, "YUV 601 F->YUV 601 F",
+		&rk_csc_table_identity_y_cb_cr_to_y_cb_cr,
+		&rk_dc_csc_table_hdy_cb_cr_full_to_xv_yccsdy_cb_cr_full,
+		{
+			OPTM_CS_E_XV_YCC_601, OPTM_CS_E_XV_YCC_601, true, true
+		}
+	},
+	{
+		RK_PQ_CSC_YUV2YUV_LIMIT2FULL, "YUV 601 L->YUV 601 F",
+		&rk_csc_table_identity_y_cb_cr_limit_to_y_cb_cr_full,
+		&rk_dc_csc_table_identity_y_cb_cr_limit_to_y_cb_cr_full,
+		{
+			OPTM_CS_E_XV_YCC_601, OPTM_CS_E_XV_YCC_601,  false, true
+		}
+	},
+	{
+		RK_PQ_CSC_YUV2YUV_FULL2LIMIT, "YUV 601 F->YUV 601 L",
+		&rk_csc_table_identity_y_cb_cr_full_to_y_cb_cr_limit,
+		&rk_dc_csc_table_identity_y_cb_cr_full_to_y_cb_cr_limit,
+		{
+			OPTM_CS_E_XV_YCC_601, OPTM_CS_E_XV_YCC_601, true, false
+		}
+	},
+	{
+		RK_PQ_CSC_YUV2YUV, "YUV 2020 L->YUV 2020 L",
+		&rk_csc_table_xv_yccsdy_cb_cr_to_hdy_cb_cr,
+		&rk_dc_csc_table_xv_yccsdy_cb_cr_to_hdy_cb_cr,
+		{
+			OPTM_CS_E_XV_YCC_2020, OPTM_CS_E_XV_YCC_2020, false, false
+		}
+	},
+	{
+		RK_PQ_CSC_YUV2YUV_FULL, "YUV 2020 F->YUV 2020 F",
+		&rk_csc_table_identity_y_cb_cr_to_y_cb_cr,
+		&rk_dc_csc_table_hdy_cb_cr_full_to_xv_yccsdy_cb_cr_full,
+		{
+			OPTM_CS_E_XV_YCC_2020, OPTM_CS_E_XV_YCC_2020, true, true
+		}
+	},
+	{
+		RK_PQ_CSC_YUV2YUV_LIMIT2FULL, "YUV 2020 L->YUV 2020 F",
+		&rk_csc_table_identity_y_cb_cr_limit_to_y_cb_cr_full,
+		&rk_dc_csc_table_identity_y_cb_cr_limit_to_y_cb_cr_full,
+		{
+			OPTM_CS_E_XV_YCC_2020, OPTM_CS_E_XV_YCC_2020, false, true
+		}
+	},
+	{
+		RK_PQ_CSC_YUV2YUV_FULL2LIMIT, "YUV 2020 F->YUV 2020 L",
+		&rk_csc_table_identity_y_cb_cr_full_to_y_cb_cr_limit,
+		&rk_dc_csc_table_identity_y_cb_cr_full_to_y_cb_cr_limit,
+		{
+			OPTM_CS_E_XV_YCC_2020, OPTM_CS_E_XV_YCC_2020, true, false
+		}
+	},
+	{
+		RK_PQ_CSC_RGB2RGBL, "RGB 2020 F->RGB 2020 L",
+		&rk_csc_table_identity_rgb_to_rgb_limit,
+		&rk_dc_csc_table_identity_rgb_to_rgb_limit,
+		{
+			OPTM_CS_E_RGB_2020, OPTM_CS_E_RGB_2020, true, false
+		}
+	},
+	{
+		RK_PQ_CSC_RGBL2RGB, "RGB 2020 L->RGB 2020 F",
+		&rk_csc_table_identity_rgb_limit_to_rgb,
+		&rk_dc_csc_table_identity_rgb_limit_to_rgb,
+		{
+			OPTM_CS_E_RGB_2020, OPTM_CS_E_RGB_2020, false, true
+		}
+	},
+	{
+		RK_PQ_CSC_RGBL2RGBL, "RGB 2020 L->RGB 2020 L",
+		&rk_csc_table_identity_rgb_to_rgb,
+		&rk_dc_csc_table_identity_rgb_to_rgb1,
+		{
+			OPTM_CS_E_RGB_2020, OPTM_CS_E_RGB_2020, false, false
+		}
+	},
+	{
+		RK_PQ_CSC_RGB2RGB, "RGB 2020 F->RGB 2020 F",
+		&rk_csc_table_identity_rgb_to_rgb,
+		&rk_dc_csc_table_identity_rgb_to_rgb2,
+		{
+			OPTM_CS_E_RGB_2020, OPTM_CS_E_RGB_2020, true, true
+		}
+	},
+};
+
+struct csc_mapping {
+	enum vop_csc_format csc_format;
+	enum color_space_type rgb_color_space;
+	enum color_space_type yuv_color_space;
+	bool rgb_full_range;
+	bool yuv_full_range;
+};
+
+static const struct csc_mapping csc_mapping_table[] = {
+	{
+		CSC_BT601L,
+		OPTM_CS_E_RGB,
+		OPTM_CS_E_XV_YCC_601,
+		true,
+		false,
+	},
+	{
+		CSC_BT709L,
+		OPTM_CS_E_RGB,
+		OPTM_CS_E_XV_YCC_709,
+		true,
+		false,
+	},
+	{
+		CSC_BT601F,
+		OPTM_CS_E_RGB,
+		OPTM_CS_E_XV_YCC_601,
+		true,
+		true,
+	},
+	{
+		CSC_BT2020,
+		OPTM_CS_E_RGB_2020,
+		OPTM_CS_E_XV_YCC_2020,
+		true,
+		true,
+	},
+	{
+		CSC_BT709L_13BIT,
+		OPTM_CS_E_RGB,
+		OPTM_CS_E_XV_YCC_709,
+		true,
+		false,
+	},
+	{
+		CSC_BT709F_13BIT,
+		OPTM_CS_E_RGB,
+		OPTM_CS_E_XV_YCC_709,
+		true,
+		true,
+	},
+	{
+		CSC_BT2020L_13BIT,
+		OPTM_CS_E_RGB_2020,
+		OPTM_CS_E_XV_YCC_2020,
+		true,
+		false,
+	},
+	{
+		CSC_BT2020F_13BIT,
+		OPTM_CS_E_RGB_2020,
+		OPTM_CS_E_XV_YCC_2020,
+		true,
+		true,
+	},
+};
+
+static const struct rk_pq_csc_coef r2y_for_y2y = {
+	306, 601, 117,
+	-151, -296, 446,
+	630, -527, -102,
+};
+
+static const struct rk_pq_csc_coef y2r_for_y2y = {
+	1024, -0, 1167,
+	1024, -404, -594,
+	1024, 2081, -1,
+};
+
+static const struct rk_pq_csc_coef rgb_input_swap_matrix = {
+	0, 0, 1,
+	1, 0, 0,
+	0, 1, 0,
+};
+
+static const struct rk_pq_csc_coef yuv_output_swap_matrix = {
+	0, 0, 1,
+	1, 0, 0,
+	0, 1, 0,
+};
+
+static int csc_get_mode_index(int post_csc_mode, bool is_input_yuv, bool is_output_yuv)
+{
+	const struct rk_csc_colorspace_info *colorspace_info;
+	enum color_space_type input_color_space;
+	enum color_space_type output_color_space;
+	bool is_input_full_range;
+	bool is_output_full_range;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(csc_mapping_table); i++) {
+		if (post_csc_mode == csc_mapping_table[i].csc_format) {
+			input_color_space = is_input_yuv ? csc_mapping_table[i].yuv_color_space :
+					    csc_mapping_table[i].rgb_color_space;
+			is_input_full_range = is_input_yuv ? csc_mapping_table[i].yuv_full_range :
+					      csc_mapping_table[i].rgb_full_range;
+			output_color_space = is_output_yuv ? csc_mapping_table[i].yuv_color_space :
+					     csc_mapping_table[i].rgb_color_space;
+			is_output_full_range = is_output_yuv ? csc_mapping_table[i].yuv_full_range :
+					       csc_mapping_table[i].rgb_full_range;
+			break;
+		}
+	}
+	if (i >= ARRAY_SIZE(csc_mapping_table))
+		return -EINVAL;
+
+	for (i = 0; i < ARRAY_SIZE(g_mode_csc_coef); i++) {
+		colorspace_info = &g_mode_csc_coef[i].st_csc_color_info;
+		if (colorspace_info->input_color_space == input_color_space &&
+		    colorspace_info->output_color_space == output_color_space &&
+		    colorspace_info->in_full_range == is_input_full_range &&
+		    colorspace_info->out_full_range == is_output_full_range)
+			return i;
+	}
+
+	return -EINVAL;
+}
+
+static void csc_matrix_multiply(struct rk_pq_csc_coef *dst, const struct rk_pq_csc_coef *m0,
+				const struct rk_pq_csc_coef *m1)
+{
+	dst->csc_coef00 = m0->csc_coef00 * m1->csc_coef00 +
+			  m0->csc_coef01 * m1->csc_coef10 +
+			  m0->csc_coef02 * m1->csc_coef20;
+
+	dst->csc_coef01 = m0->csc_coef00 * m1->csc_coef01 +
+			  m0->csc_coef01 * m1->csc_coef11 +
+			  m0->csc_coef02 * m1->csc_coef21;
+
+	dst->csc_coef02 = m0->csc_coef00 * m1->csc_coef02 +
+			  m0->csc_coef01 * m1->csc_coef12 +
+			  m0->csc_coef02 * m1->csc_coef22;
+
+	dst->csc_coef10 = m0->csc_coef10 * m1->csc_coef00 +
+			  m0->csc_coef11 * m1->csc_coef10 +
+			  m0->csc_coef12 * m1->csc_coef20;
+
+	dst->csc_coef11 = m0->csc_coef10 * m1->csc_coef01 +
+			  m0->csc_coef11 * m1->csc_coef11 +
+			  m0->csc_coef12 * m1->csc_coef21;
+
+	dst->csc_coef12 = m0->csc_coef10 * m1->csc_coef02 +
+			  m0->csc_coef11 * m1->csc_coef12 +
+			  m0->csc_coef12 * m1->csc_coef22;
+
+	dst->csc_coef20 = m0->csc_coef20 * m1->csc_coef00 +
+			  m0->csc_coef21 * m1->csc_coef10 +
+			  m0->csc_coef22 * m1->csc_coef20;
+
+	dst->csc_coef21 = m0->csc_coef20 * m1->csc_coef01 +
+			  m0->csc_coef21 * m1->csc_coef11 +
+			  m0->csc_coef22 * m1->csc_coef21;
+
+	dst->csc_coef22 = m0->csc_coef20 * m1->csc_coef02 +
+			  m0->csc_coef21 * m1->csc_coef12 +
+			  m0->csc_coef22 * m1->csc_coef22;
+}
+
+static void csc_matrix_ventor_multiply(struct rk_pq_csc_ventor *dst,
+				       const struct rk_pq_csc_coef *m0,
+				       const struct rk_pq_csc_ventor *v0)
+{
+	dst->csc_offset0 = m0->csc_coef00 * v0->csc_offset0 +
+			   m0->csc_coef01 * v0->csc_offset1 +
+			   m0->csc_coef02 * v0->csc_offset2;
+
+	dst->csc_offset1 = m0->csc_coef10 * v0->csc_offset0 +
+			   m0->csc_coef11 * v0->csc_offset1 +
+			   m0->csc_coef12 * v0->csc_offset2;
+
+	dst->csc_offset2 = m0->csc_coef20 * v0->csc_offset0 +
+			   m0->csc_coef21 * v0->csc_offset1 +
+			   m0->csc_coef22 * v0->csc_offset2;
+}
+
+static void csc_matrix_element_left_shift(struct rk_pq_csc_coef *m, int n)
+{
+	m->csc_coef00 = m->csc_coef00 >> n;
+	m->csc_coef01 = m->csc_coef01 >> n;
+	m->csc_coef02 = m->csc_coef02 >> n;
+	m->csc_coef10 = m->csc_coef10 >> n;
+	m->csc_coef11 = m->csc_coef11 >> n;
+	m->csc_coef12 = m->csc_coef12 >> n;
+	m->csc_coef20 = m->csc_coef20 >> n;
+	m->csc_coef21 = m->csc_coef21 >> n;
+	m->csc_coef22 = m->csc_coef22 >> n;
+}
+
+static struct rk_pq_csc_coef create_rgb_gain_matrix(s32 r_gain, s32 g_gain, s32 b_gain)
+{
+	struct rk_pq_csc_coef m;
+
+	m.csc_coef00 = r_gain;
+	m.csc_coef01 = 0;
+	m.csc_coef02 = 0;
+
+	m.csc_coef10 = 0;
+	m.csc_coef11 = g_gain;
+	m.csc_coef12 = 0;
+
+	m.csc_coef20 = 0;
+	m.csc_coef21 = 0;
+	m.csc_coef22 = b_gain;
+
+	return m;
+}
+
+static struct rk_pq_csc_coef create_contrast_matrix(s32 contrast)
+{
+	struct rk_pq_csc_coef m;
+
+	m.csc_coef00 = contrast;
+	m.csc_coef01 = 0;
+	m.csc_coef02 = 0;
+
+	m.csc_coef10 = 0;
+	m.csc_coef11 = contrast;
+	m.csc_coef12 = 0;
+
+	m.csc_coef20 = 0;
+	m.csc_coef21 = 0;
+	m.csc_coef22 = contrast;
+
+	return m;
+}
+
+static struct rk_pq_csc_coef create_hue_matrix(s32 hue)
+{
+	struct rk_pq_csc_coef m;
+	s32 hue_idx;
+	s32 sin_hue;
+	s32 cos_hue;
+
+	hue_idx = CLIP(hue / PQ_CSC_HUE_TABLE_DIV_COEF, 0, PQ_CSC_HUE_TABLE_NUM - 1);
+	sin_hue = g_hue_sin_table[hue_idx];
+	cos_hue = g_hue_cos_table[hue_idx];
+
+	m.csc_coef00 = 1024;
+	m.csc_coef01 = 0;
+	m.csc_coef02 = 0;
+
+	m.csc_coef10 = 0;
+	m.csc_coef11 = cos_hue;
+	m.csc_coef12 = sin_hue;
+
+	m.csc_coef20 = 0;
+	m.csc_coef21 = -sin_hue;
+	m.csc_coef22 = cos_hue;
+
+	return m;
+}
+
+static struct rk_pq_csc_coef create_saturation_matrix(s32 saturation)
+{
+	struct rk_pq_csc_coef m;
+
+	m.csc_coef00 = 512;
+	m.csc_coef01 = 0;
+	m.csc_coef02 = 0;
+
+	m.csc_coef10 = 0;
+	m.csc_coef11 = saturation;
+	m.csc_coef12 = 0;
+
+	m.csc_coef20 = 0;
+	m.csc_coef21 = 0;
+	m.csc_coef22 = saturation;
+
+	return m;
+}
+
+static int csc_calc_adjust_output_coef(bool is_input_yuv, bool is_output_yuv,
+				       struct csc_info *csc_input_cfg,
+				       const struct rk_csc_mode_coef *csc_mode_cfg,
+				       struct rk_pq_csc_coef *out_matrix,
+				       struct rk_pq_csc_ventor *out_dc)
+{
+	struct rk_pq_csc_coef gain_matrix;
+	struct rk_pq_csc_coef contrast_matrix;
+	struct rk_pq_csc_coef hue_matrix;
+	struct rk_pq_csc_coef saturation_matrix;
+	struct rk_pq_csc_coef temp0, temp1;
+	const struct rk_pq_csc_coef *r2y_matrix;
+	const struct rk_pq_csc_coef *y2r_matrix;
+	struct rk_pq_csc_ventor dc_in_ventor;
+	struct rk_pq_csc_ventor dc_out_ventor;
+	struct rk_pq_csc_ventor v;
+	const struct rk_csc_colorspace_info *color_info;
+	s32 contrast, saturation, brightness;
+	s32 r_gain, g_gain, b_gain;
+	s32 r_offset, g_offset, b_offset;
+	s32 dc_in_offset, dc_out_offset;
+
+	contrast = csc_input_cfg->contrast * PQ_CSC_PARAM_FIX_NUM / PQ_CSC_IN_PARAM_NORM_COEF;
+	saturation = csc_input_cfg->saturation  * PQ_CSC_PARAM_FIX_NUM / PQ_CSC_IN_PARAM_NORM_COEF;
+	r_gain = csc_input_cfg->r_gain * PQ_CSC_PARAM_FIX_NUM / PQ_CSC_IN_PARAM_NORM_COEF;
+	g_gain = csc_input_cfg->g_gain * PQ_CSC_PARAM_FIX_NUM / PQ_CSC_IN_PARAM_NORM_COEF;
+	b_gain = csc_input_cfg->b_gain * PQ_CSC_PARAM_FIX_NUM / PQ_CSC_IN_PARAM_NORM_COEF;
+	r_offset = ((s32)csc_input_cfg->r_offset - PQ_CSC_BRIGHTNESS_OFFSET) /
+		   PQ_CSC_TEMP_OFFSET_DIV_COEF;
+	g_offset = ((s32)csc_input_cfg->g_offset - PQ_CSC_BRIGHTNESS_OFFSET) /
+		   PQ_CSC_TEMP_OFFSET_DIV_COEF;
+	b_offset = ((s32)csc_input_cfg->b_offset - PQ_CSC_BRIGHTNESS_OFFSET) /
+		   PQ_CSC_TEMP_OFFSET_DIV_COEF;
+
+	gain_matrix = create_rgb_gain_matrix(r_gain, g_gain, b_gain);
+	contrast_matrix = create_contrast_matrix(contrast);
+	hue_matrix = create_hue_matrix(csc_input_cfg->hue);
+	saturation_matrix = create_saturation_matrix(saturation);
+
+	color_info = &csc_mode_cfg->st_csc_color_info;
+	brightness = (s32)csc_input_cfg->brightness - PQ_CSC_BRIGHTNESS_OFFSET;
+	dc_in_offset = color_info->in_full_range ? 0 : -PQ_CSC_DC_IN_OFFSET;
+	dc_out_offset = color_info->out_full_range ? 0 : PQ_CSC_DC_IN_OFFSET;
+
+	/*
+	 * M0 = hue_matrix * saturation_matrix,
+	 * M1 = gain_matrix * constrast_matrix,
+	 */
+
+	if (is_input_yuv && is_output_yuv) {
+		/*
+		 * yuv2yuv: output = T * M0 * N_r2y * M1 * N_y2r,
+		 * so output = T * hue_matrix * saturation_matrix *
+		 * N_r2y * gain_matrix * contrast_matrix * N_y2r
+		 */
+		r2y_matrix = &r2y_for_y2y;
+		y2r_matrix = &y2r_for_y2y;
+		csc_matrix_multiply(&temp0, csc_mode_cfg->pst_csc_coef, &hue_matrix);
+		/*
+		 * The value bits width is 32 bit, so every time 2 matirx multifly,
+		 * left shift is necessary to avoid overflow. For enhancing the
+		 * calculator precision, PQ_CALC_ENHANCE_BIT bits is reserved and
+		 * left shift before get the final result.
+		 */
+		csc_matrix_element_left_shift(&temp0, PQ_CSC_PARAM_FIX_BIT_WIDTH -
+					      PQ_CALC_ENHANCE_BIT);
+		csc_matrix_multiply(&temp1, &temp0, &saturation_matrix);
+		csc_matrix_element_left_shift(&temp1, PQ_CSC_PARAM_HALF_FIX_BIT_WIDTH);
+		csc_matrix_multiply(&temp0, &temp1, r2y_matrix);
+		csc_matrix_element_left_shift(&temp0, PQ_CSC_PARAM_FIX_BIT_WIDTH);
+		csc_matrix_multiply(&temp1, &temp0, &gain_matrix);
+		csc_matrix_element_left_shift(&temp1, PQ_CSC_PARAM_HALF_FIX_BIT_WIDTH);
+		csc_matrix_multiply(&temp0, &temp1, &contrast_matrix);
+		csc_matrix_element_left_shift(&temp0, PQ_CSC_PARAM_HALF_FIX_BIT_WIDTH);
+		csc_matrix_multiply(out_matrix, &temp0, y2r_matrix);
+		csc_matrix_element_left_shift(out_matrix, PQ_CSC_PARAM_FIX_BIT_WIDTH +
+					      PQ_CALC_ENHANCE_BIT);
+
+		dc_in_ventor.csc_offset0 = dc_in_offset;
+		dc_in_ventor.csc_offset1 = -PQ_CSC_DC_IN_OUT_DEFAULT;
+		dc_in_ventor.csc_offset2 = -PQ_CSC_DC_IN_OUT_DEFAULT;
+		dc_out_ventor.csc_offset0 = brightness + dc_out_offset;
+		dc_out_ventor.csc_offset1 = PQ_CSC_DC_IN_OUT_DEFAULT;
+		dc_out_ventor.csc_offset2 = PQ_CSC_DC_IN_OUT_DEFAULT;
+	} else if (is_input_yuv && !is_output_yuv) {
+		/*
+		 * yuv2rgb: output = M1 * T * M0,
+		 * so output = gain_matrix * contrast_matrix * T *
+		 * hue_matrix * saturation_matrix
+		 */
+		csc_matrix_multiply(&temp0, csc_mode_cfg->pst_csc_coef, &hue_matrix);
+		csc_matrix_element_left_shift(&temp0, PQ_CSC_PARAM_FIX_BIT_WIDTH -
+					      PQ_CALC_ENHANCE_BIT);
+		csc_matrix_multiply(&temp1, &temp0, &saturation_matrix);
+		csc_matrix_element_left_shift(&temp1, PQ_CSC_PARAM_HALF_FIX_BIT_WIDTH);
+		csc_matrix_multiply(&temp0, &contrast_matrix, &temp1);
+		csc_matrix_element_left_shift(&temp0, PQ_CSC_PARAM_HALF_FIX_BIT_WIDTH);
+		csc_matrix_multiply(out_matrix, &gain_matrix, &temp0);
+		csc_matrix_element_left_shift(out_matrix, PQ_CSC_PARAM_HALF_FIX_BIT_WIDTH +
+					      PQ_CALC_ENHANCE_BIT);
+
+		dc_in_ventor.csc_offset0 = dc_in_offset;
+		dc_in_ventor.csc_offset1 = -PQ_CSC_DC_IN_OUT_DEFAULT;
+		dc_in_ventor.csc_offset2 = -PQ_CSC_DC_IN_OUT_DEFAULT;
+		dc_out_ventor.csc_offset0 = brightness + dc_out_offset + r_offset;
+		dc_out_ventor.csc_offset1 = brightness + dc_out_offset + g_offset;
+		dc_out_ventor.csc_offset2 = brightness + dc_out_offset + b_offset;
+	} else if (!is_input_yuv && is_output_yuv) {
+		/*
+		 * rgb2yuv: output = M0 * T * M1,
+		 * so output = hue_matrix * saturation_matrix * T *
+		 * gain_matrix * contrast_matrix
+		 */
+		csc_matrix_multiply(&temp0, csc_mode_cfg->pst_csc_coef, &gain_matrix);
+		csc_matrix_element_left_shift(&temp0, PQ_CSC_PARAM_HALF_FIX_BIT_WIDTH -
+					      PQ_CALC_ENHANCE_BIT);
+		csc_matrix_multiply(&temp1, &temp0, &contrast_matrix);
+		csc_matrix_element_left_shift(&temp1, PQ_CSC_PARAM_HALF_FIX_BIT_WIDTH);
+		csc_matrix_multiply(&temp0, &saturation_matrix, &temp1);
+		csc_matrix_element_left_shift(&temp0, PQ_CSC_PARAM_HALF_FIX_BIT_WIDTH);
+		csc_matrix_multiply(out_matrix, &hue_matrix, &temp0);
+		csc_matrix_element_left_shift(out_matrix, PQ_CSC_PARAM_FIX_BIT_WIDTH +
+					      PQ_CALC_ENHANCE_BIT);
+
+		dc_in_ventor.csc_offset0 = dc_in_offset;
+		dc_in_ventor.csc_offset1 = dc_in_offset;
+		dc_in_ventor.csc_offset2 = dc_in_offset;
+		dc_out_ventor.csc_offset0 = brightness + dc_out_offset;
+		dc_out_ventor.csc_offset1 = PQ_CSC_DC_IN_OUT_DEFAULT;
+		dc_out_ventor.csc_offset2 = PQ_CSC_DC_IN_OUT_DEFAULT;
+	} else {
+		/*
+		 * rgb2rgb: output = T * M1 * N_y2r * M0 * N_r2y,
+		 * so output = T * gain_matrix * contrast_matrix *
+		 * N_y2r * hue_matrix * saturation_matrix * N_r2y
+		 */
+		if (!color_info->in_full_range && color_info->out_full_range) {
+			r2y_matrix = &rk_csc_table_rgb_limit_to_hdy_cb_cr;
+			y2r_matrix = &rk_csc_table_hdy_cb_cr_limit_to_rgb_full;
+		} else if (color_info->in_full_range && !color_info->out_full_range) {
+			r2y_matrix = &rk_csc_table_rgb_to_hdy_cb_cr;
+			y2r_matrix = &rk_csc_table_hdy_cb_cr_limit_to_rgb_limit;
+		} else if (color_info->in_full_range && color_info->out_full_range) {
+			r2y_matrix = &rk_csc_table_rgb_to_hdy_cb_cr_full;
+			y2r_matrix = &rk_csc_table_hdy_cb_cr_to_rgb_full;
+		} else {
+			r2y_matrix = &rk_csc_table_rgb_limit_to_hdy_cb_cr;
+			y2r_matrix = &rk_csc_table_hdy_cb_cr_limit_to_rgb_limit;
+		}
+
+		csc_matrix_multiply(&temp0, &contrast_matrix, y2r_matrix);
+		csc_matrix_element_left_shift(&temp0, PQ_CSC_PARAM_HALF_FIX_BIT_WIDTH -
+					      PQ_CALC_ENHANCE_BIT);
+		csc_matrix_multiply(&temp1, &gain_matrix, &temp0);
+		csc_matrix_element_left_shift(&temp1, PQ_CSC_PARAM_HALF_FIX_BIT_WIDTH);
+		csc_matrix_multiply(&temp0, &temp1, &hue_matrix);
+		csc_matrix_element_left_shift(&temp0, PQ_CSC_PARAM_FIX_BIT_WIDTH);
+		csc_matrix_multiply(&temp1, &temp0, &saturation_matrix);
+		csc_matrix_element_left_shift(&temp1, PQ_CSC_PARAM_HALF_FIX_BIT_WIDTH);
+		csc_matrix_multiply(out_matrix, &temp1, r2y_matrix);
+		csc_matrix_element_left_shift(out_matrix, PQ_CSC_PARAM_FIX_BIT_WIDTH +
+					      PQ_CALC_ENHANCE_BIT);
+
+		if (color_info->in_full_range && color_info->out_full_range)
+			out_matrix->csc_coef00 += 1;
+
+		dc_in_ventor.csc_offset0 = dc_in_offset;
+		dc_in_ventor.csc_offset1 = dc_in_offset;
+		dc_in_ventor.csc_offset2 = dc_in_offset;
+		dc_out_ventor.csc_offset0 = brightness + dc_out_offset + r_offset;
+		dc_out_ventor.csc_offset1 = brightness + dc_out_offset + g_offset;
+		dc_out_ventor.csc_offset2 = brightness + dc_out_offset + b_offset;
+	}
+
+	csc_matrix_ventor_multiply(&v, out_matrix, &dc_in_ventor);
+	out_dc->csc_offset0 = v.csc_offset0 + dc_out_ventor.csc_offset0 *
+			  PQ_CSC_SIMPLE_MAT_PARAM_FIX_NUM;
+	out_dc->csc_offset1 = v.csc_offset1 + dc_out_ventor.csc_offset1 *
+			  PQ_CSC_SIMPLE_MAT_PARAM_FIX_NUM;
+	out_dc->csc_offset2 = v.csc_offset2 + dc_out_ventor.csc_offset2 *
+			  PQ_CSC_SIMPLE_MAT_PARAM_FIX_NUM;
+
+	return 0;
+}
+
+static int csc_calc_default_output_coef(const struct rk_csc_mode_coef *csc_mode_cfg,
+					struct rk_pq_csc_coef *out_matrix,
+					struct rk_pq_csc_ventor *out_dc)
+{
+	const struct rk_pq_csc_coef *csc_coef;
+	const struct rk_pq_csc_dc_coef *csc_dc_coef;
+	struct rk_pq_csc_ventor dc_in_ventor;
+	struct rk_pq_csc_ventor dc_out_ventor;
+	struct rk_pq_csc_ventor v;
+
+	csc_coef = csc_mode_cfg->pst_csc_coef;
+	csc_dc_coef = csc_mode_cfg->pst_csc_dc_coef;
+
+	out_matrix->csc_coef00 = csc_coef->csc_coef00;
+	out_matrix->csc_coef01 = csc_coef->csc_coef01;
+	out_matrix->csc_coef02 = csc_coef->csc_coef02;
+	out_matrix->csc_coef10 = csc_coef->csc_coef10;
+	out_matrix->csc_coef11 = csc_coef->csc_coef11;
+	out_matrix->csc_coef12 = csc_coef->csc_coef12;
+	out_matrix->csc_coef20 = csc_coef->csc_coef20;
+	out_matrix->csc_coef21 = csc_coef->csc_coef21;
+	out_matrix->csc_coef22 = csc_coef->csc_coef22;
+
+	dc_in_ventor.csc_offset0 = csc_dc_coef->csc_in_dc0;
+	dc_in_ventor.csc_offset1 = csc_dc_coef->csc_in_dc1;
+	dc_in_ventor.csc_offset2 = csc_dc_coef->csc_in_dc2;
+	dc_out_ventor.csc_offset0 = csc_dc_coef->csc_out_dc0;
+	dc_out_ventor.csc_offset1 = csc_dc_coef->csc_out_dc1;
+	dc_out_ventor.csc_offset2 = csc_dc_coef->csc_out_dc2;
+
+	csc_matrix_ventor_multiply(&v, csc_coef, &dc_in_ventor);
+	out_dc->csc_offset0 = v.csc_offset0 + dc_out_ventor.csc_offset0 *
+			      PQ_CSC_SIMPLE_MAT_PARAM_FIX_NUM;
+	out_dc->csc_offset1 = v.csc_offset1 + dc_out_ventor.csc_offset1 *
+			      PQ_CSC_SIMPLE_MAT_PARAM_FIX_NUM;
+	out_dc->csc_offset2 = v.csc_offset2 + dc_out_ventor.csc_offset2 *
+			      PQ_CSC_SIMPLE_MAT_PARAM_FIX_NUM;
+
+	return 0;
+}
+
+static inline s32 pq_csc_simple_round(s32 x, s32 n)
+{
+	s32 value = 0;
+
+	if (n == 0)
+		return x;
+
+	value = (abs(x) + (1 << (n - 1))) >> (n);
+	return (((x) >= 0) ? value : -value);
+}
+
+static void rockchip_swap_color_channel(bool is_input_yuv, bool is_output_yuv,
+					struct post_csc_coef *csc_simple_coef,
+					struct rk_pq_csc_coef *out_matrix,
+					struct rk_pq_csc_ventor *out_dc)
+{
+	struct rk_pq_csc_coef tmp_matrix;
+	struct rk_pq_csc_ventor tmp_v;
+
+	if (!is_input_yuv) {
+		memcpy(&tmp_matrix, out_matrix, sizeof(struct rk_pq_csc_coef));
+		csc_matrix_multiply(out_matrix, &tmp_matrix, &rgb_input_swap_matrix);
+	}
+
+	if (is_output_yuv) {
+		memcpy(&tmp_matrix, out_matrix, sizeof(struct rk_pq_csc_coef));
+		memcpy(&tmp_v, out_dc, sizeof(struct rk_pq_csc_ventor));
+		csc_matrix_multiply(out_matrix, &yuv_output_swap_matrix, &tmp_matrix);
+		csc_matrix_ventor_multiply(out_dc, &yuv_output_swap_matrix, &tmp_v);
+	}
+
+	csc_simple_coef->csc_coef00 = out_matrix->csc_coef00;
+	csc_simple_coef->csc_coef01 = out_matrix->csc_coef01;
+	csc_simple_coef->csc_coef02 = out_matrix->csc_coef02;
+	csc_simple_coef->csc_coef10 = out_matrix->csc_coef10;
+	csc_simple_coef->csc_coef11 = out_matrix->csc_coef11;
+	csc_simple_coef->csc_coef12 = out_matrix->csc_coef12;
+	csc_simple_coef->csc_coef20 = out_matrix->csc_coef20;
+	csc_simple_coef->csc_coef21 = out_matrix->csc_coef21;
+	csc_simple_coef->csc_coef22 = out_matrix->csc_coef22;
+	csc_simple_coef->csc_dc0 = out_dc->csc_offset0;
+	csc_simple_coef->csc_dc1 = out_dc->csc_offset1;
+	csc_simple_coef->csc_dc2 = out_dc->csc_offset2;
+}
+
+int rockchip_calc_post_csc(struct csc_info *csc_cfg, struct post_csc_coef *csc_simple_coef,
+			   int csc_mode, bool is_input_yuv, bool is_output_yuv)
+{
+	int ret = 0;
+	struct rk_pq_csc_coef out_matrix;
+	struct rk_pq_csc_ventor out_dc;
+	const struct rk_csc_mode_coef *csc_mode_cfg;
+	int bit_num = PQ_CSC_SIMPLE_MAT_PARAM_FIX_BIT_WIDTH;
+
+	ret = csc_get_mode_index(csc_mode, is_input_yuv, is_output_yuv);
+	if (ret < 0) {
+		printf("invalid csc_mode:%d\n", csc_mode);
+		return ret;
+	}
+
+	csc_mode_cfg = &g_mode_csc_coef[ret];
+
+	if (csc_cfg)
+		ret = csc_calc_adjust_output_coef(is_input_yuv, is_output_yuv, csc_cfg,
+						  csc_mode_cfg, &out_matrix, &out_dc);
+	else
+		ret = csc_calc_default_output_coef(csc_mode_cfg, &out_matrix, &out_dc);
+
+	rockchip_swap_color_channel(is_input_yuv, is_output_yuv, csc_simple_coef, &out_matrix,
+				    &out_dc);
+
+	csc_simple_coef->csc_dc0 = pq_csc_simple_round(csc_simple_coef->csc_dc0, bit_num);
+	csc_simple_coef->csc_dc1 = pq_csc_simple_round(csc_simple_coef->csc_dc1, bit_num);
+	csc_simple_coef->csc_dc2 = pq_csc_simple_round(csc_simple_coef->csc_dc2, bit_num);
+	csc_simple_coef->range_type = csc_mode_cfg->st_csc_color_info.out_full_range;
+
+	return ret;
+}
diff --git a/drivers/video/drm/rockchip_post_csc.h b/drivers/video/drm/rockchip_post_csc.h
new file mode 100755
index 0000000000..f11e808d7d
--- /dev/null
+++ b/drivers/video/drm/rockchip_post_csc.h
@@ -0,0 +1,35 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (C) Rockchip Electronics Co.Ltd
+ * Author:
+ *      Zhang Yubing <yubing.zhang@rock-chips.com>
+ */
+
+#ifndef _ROCKCHIP_POST_CSC_H
+#define _ROCKCHIP_POST_CSC_H
+
+#include <linux/kernel.h>
+#include <edid.h>
+
+struct post_csc_coef {
+	s32 csc_coef00;
+	s32 csc_coef01;
+	s32 csc_coef02;
+	s32 csc_coef10;
+	s32 csc_coef11;
+	s32 csc_coef12;
+	s32 csc_coef20;
+	s32 csc_coef21;
+	s32 csc_coef22;
+
+	s32 csc_dc0;
+	s32 csc_dc1;
+	s32 csc_dc2;
+
+	u32 range_type;
+};
+
+int rockchip_calc_post_csc(struct csc_info *csc, struct post_csc_coef *csc_coef,
+			   int csc_mode, bool is_input_yuv, bool is_output_yuv);
+
+#endif
diff --git a/drivers/video/drm/rockchip_rgb.c b/drivers/video/drm/rockchip_rgb.c
new file mode 100644
index 0000000000..432255f537
--- /dev/null
+++ b/drivers/video/drm/rockchip_rgb.c
@@ -0,0 +1,685 @@
+/*
+ * (C) Copyright 2008-2017 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <dm/of_access.h>
+#include <errno.h>
+#include <syscon.h>
+#include <regmap.h>
+#include <dm/device.h>
+#include <dm/read.h>
+#include <dm/pinctrl.h>
+#include <linux/media-bus-format.h>
+#include <asm/gpio.h>
+#include <backlight.h>
+
+#include "rockchip_display.h"
+#include "rockchip_crtc.h"
+#include "rockchip_connector.h"
+#include "rockchip_phy.h"
+#include "rockchip_panel.h"
+
+#define HIWORD_UPDATE(v, h, l)		(((v) << (l)) | (GENMASK(h, l) << 16))
+
+#define PX30_GRF_PD_VO_CON1		0x0438
+#define PX30_RGB_DATA_SYNC_BYPASS(v)	HIWORD_UPDATE(v, 3, 3)
+#define PX30_RGB_VOP_SEL(v)		HIWORD_UPDATE(v, 2, 2)
+
+#define RK1808_GRF_PD_VO_CON1		0x0444
+#define RK1808_RGB_DATA_SYNC_BYPASS(v)	HIWORD_UPDATE(v, 3, 3)
+
+#define RV1106_VENC_GRF_VOP_IO_WRAPPER	0x1000c
+#define RV1106_IO_BYPASS_SEL(v)		HIWORD_UPDATE(v, 0, 1)
+#define RV1106_VOGRF_VOP_PIPE_BYPASS	0x60034
+#define RV1106_VOP_PIPE_BYPASS(v)	HIWORD_UPDATE(v, 0, 1)
+
+#define RV1126_GRF_IOFUNC_CON3          0x1026c
+#define RV1126_LCDC_IO_BYPASS(v)        HIWORD_UPDATE(v, 0, 0)
+
+#define RK3288_GRF_SOC_CON6		0x025c
+#define RK3288_LVDS_LCDC_SEL(v)		HIWORD_UPDATE(v,  3,  3)
+#define RK3288_GRF_SOC_CON7		0x0260
+#define RK3288_LVDS_PWRDWN(v)		HIWORD_UPDATE(v, 15, 15)
+#define RK3288_LVDS_CON_ENABLE_2(v)	HIWORD_UPDATE(v, 12, 12)
+#define RK3288_LVDS_CON_ENABLE_1(v)	HIWORD_UPDATE(v, 11, 11)
+#define RK3288_LVDS_CON_CLKINV(v)	HIWORD_UPDATE(v,  8,  8)
+#define RK3288_LVDS_CON_TTL_EN(v)	HIWORD_UPDATE(v,  6,  6)
+
+#define RK3368_GRF_SOC_CON15		0x043c
+#define RK3368_FORCE_JETAG(v)		HIWORD_UPDATE(v,  13,  13)
+
+#define RK3562_GRF_IOC_VO_IO_CON	0x10500
+#define RK3562_RGB_DATA_BYPASS(v)	HIWORD_UPDATE(v, 6, 6)
+
+#define RK3568_GRF_VO_CON1		0X0364
+#define RK3568_RGB_DATA_BYPASS(v)	HIWORD_UPDATE(v, 6, 6)
+
+struct rockchip_rgb;
+
+struct rockchip_rgb_funcs {
+	void (*prepare)(struct rockchip_rgb *rgb, int pipe);
+	void (*unprepare)(struct rockchip_rgb *rgb);
+};
+
+struct rockchip_rgb {
+	struct rockchip_connector connector;
+	int id;
+	struct udevice *dev;
+	struct regmap *grf;
+	bool data_sync_bypass;
+	struct rockchip_phy *phy;
+	const struct rockchip_rgb_funcs *funcs;
+};
+
+struct mcu_cmd_header {
+	u8 data_type;
+	u8 delay;
+	u8 payload_length;
+} __packed;
+
+struct mcu_cmd_desc {
+	struct mcu_cmd_header header;
+	const u8 *payload;
+};
+
+struct mcu_cmd_seq {
+	struct mcu_cmd_desc *cmds;
+	unsigned int cmd_cnt;
+};
+
+struct rockchip_mcu_panel_desc {
+	struct mcu_cmd_seq *init_seq;
+	struct mcu_cmd_seq *exit_seq;
+
+	struct {
+		unsigned int width;
+		unsigned int height;
+	} size;
+
+	struct {
+		unsigned int prepare;
+		unsigned int enable;
+		unsigned int disable;
+		unsigned int unprepare;
+		unsigned int reset;
+		unsigned int init;
+	} delay;
+
+	unsigned int bpc;
+	u32 bus_format;
+	u32 bus_flags;
+	bool power_invert;
+};
+
+struct rockchip_mcu_panel {
+	struct rockchip_panel base;
+	struct rockchip_mcu_panel_desc *desc;
+	struct udevice *power_supply;
+	struct udevice *backlight;
+
+	struct gpio_desc enable_gpio;
+	struct gpio_desc reset_gpio;
+
+	bool prepared;
+	bool enabled;
+};
+
+static inline struct rockchip_mcu_panel *to_rockchip_mcu_panel(struct rockchip_panel *panel)
+{
+	return container_of(panel, struct rockchip_mcu_panel, base);
+}
+
+static int rockchip_rgb_connector_prepare(struct rockchip_connector *conn,
+					  struct display_state *state)
+{
+	struct rockchip_rgb *rgb = dev_get_priv(conn->dev);
+	struct crtc_state *crtc_state = &state->crtc_state;
+	int pipe = crtc_state->crtc_id;
+	int ret;
+
+	pinctrl_select_state(rgb->dev, "default");
+
+	if (rgb->funcs && rgb->funcs->prepare)
+		rgb->funcs->prepare(rgb, pipe);
+
+	if (rgb->phy) {
+		ret = rockchip_phy_set_mode(rgb->phy, PHY_MODE_VIDEO_TTL);
+		if (ret) {
+			dev_err(rgb->dev, "failed to set phy mode: %d\n", ret);
+			return ret;
+		}
+
+		rockchip_phy_power_on(rgb->phy);
+	}
+
+	return 0;
+}
+
+static void rockchip_rgb_connector_unprepare(struct rockchip_connector *conn,
+					     struct display_state *state)
+{
+	struct rockchip_rgb *rgb = dev_get_priv(conn->dev);
+
+	if (rgb->phy)
+		rockchip_phy_power_off(rgb->phy);
+
+	if (rgb->funcs && rgb->funcs->unprepare)
+		rgb->funcs->unprepare(rgb);
+
+	pinctrl_select_state(rgb->dev, "sleep");
+}
+
+static int rockchip_rgb_connector_init(struct rockchip_connector *conn, struct display_state *state)
+{
+	struct rockchip_rgb *rgb = dev_get_priv(conn->dev);
+	struct connector_state *conn_state = &state->conn_state;
+
+	rgb->phy = conn->phy;
+
+	conn_state->color_space = V4L2_COLORSPACE_DEFAULT;
+	conn_state->disp_info  = rockchip_get_disp_info(conn_state->type, rgb->id);
+
+	switch (conn_state->bus_format) {
+	case MEDIA_BUS_FMT_RGB666_1X18:
+		conn_state->output_mode = ROCKCHIP_OUT_MODE_P666;
+		conn_state->output_if = VOP_OUTPUT_IF_RGB;
+		break;
+	case MEDIA_BUS_FMT_RGB565_1X16:
+		conn_state->output_mode = ROCKCHIP_OUT_MODE_P565;
+		conn_state->output_if = VOP_OUTPUT_IF_RGB;
+		break;
+	case MEDIA_BUS_FMT_RGB888_3X8:
+	case MEDIA_BUS_FMT_BGR888_3X8:
+		conn_state->output_mode = ROCKCHIP_OUT_MODE_S888;
+		conn_state->output_if = VOP_OUTPUT_IF_RGB;
+		break;
+	case MEDIA_BUS_FMT_RGB888_DUMMY_4X8:
+	case MEDIA_BUS_FMT_BGR888_DUMMY_4X8:
+		conn_state->output_mode = ROCKCHIP_OUT_MODE_S888_DUMMY;
+		conn_state->output_if = VOP_OUTPUT_IF_RGB;
+		break;
+	case MEDIA_BUS_FMT_YUYV8_2X8:
+	case MEDIA_BUS_FMT_YVYU8_2X8:
+	case MEDIA_BUS_FMT_UYVY8_2X8:
+	case MEDIA_BUS_FMT_VYUY8_2X8:
+		conn_state->output_mode = ROCKCHIP_OUT_MODE_BT656;
+		conn_state->output_if = VOP_OUTPUT_IF_BT656;
+		break;
+	case MEDIA_BUS_FMT_YUYV8_1X16:
+	case MEDIA_BUS_FMT_YVYU8_1X16:
+	case MEDIA_BUS_FMT_UYVY8_1X16:
+	case MEDIA_BUS_FMT_VYUY8_1X16:
+		conn_state->output_mode = ROCKCHIP_OUT_MODE_BT1120;
+		conn_state->output_if = VOP_OUTPUT_IF_BT1120;
+		break;
+	case MEDIA_BUS_FMT_RGB888_1X24:
+	case MEDIA_BUS_FMT_RGB666_1X24_CPADHI:
+	default:
+		conn_state->output_mode = ROCKCHIP_OUT_MODE_P888;
+		conn_state->output_if = VOP_OUTPUT_IF_RGB;
+		break;
+	}
+
+	return 0;
+}
+
+static const struct rockchip_connector_funcs rockchip_rgb_connector_funcs = {
+	.init = rockchip_rgb_connector_init,
+	.prepare = rockchip_rgb_connector_prepare,
+	.unprepare = rockchip_rgb_connector_unprepare,
+};
+
+static int rockchip_mcu_panel_send_cmds(struct display_state *state,
+					struct mcu_cmd_seq *cmds)
+{
+	int i;
+
+	if (!cmds)
+		return -EINVAL;
+
+	display_send_mcu_cmd(state, MCU_SETBYPASS, 1);
+	for (i = 0; i < cmds->cmd_cnt; i++) {
+		struct mcu_cmd_desc *desc = &cmds->cmds[i];
+		int value = 0;
+
+		value = desc->payload[0];
+		display_send_mcu_cmd(state, desc->header.data_type, value);
+
+		if (desc->header.delay)
+			mdelay(desc->header.delay);
+	}
+	display_send_mcu_cmd(state, MCU_SETBYPASS, 0);
+
+	return 0;
+}
+
+static void rockchip_mcu_panel_prepare(struct rockchip_panel *panel)
+{
+	struct rockchip_mcu_panel *mcu_panel = to_rockchip_mcu_panel(panel);
+	int ret;
+
+	if (mcu_panel->prepared)
+		return;
+
+	if (dm_gpio_is_valid(&mcu_panel->enable_gpio))
+		dm_gpio_set_value(&mcu_panel->enable_gpio, 1);
+
+	if (mcu_panel->desc->delay.prepare)
+		mdelay(mcu_panel->desc->delay.prepare);
+
+	if (dm_gpio_is_valid(&mcu_panel->reset_gpio))
+		dm_gpio_set_value(&mcu_panel->reset_gpio, 1);
+
+	if (mcu_panel->desc->delay.reset)
+		mdelay(mcu_panel->desc->delay.reset);
+
+	if (dm_gpio_is_valid(&mcu_panel->reset_gpio))
+		dm_gpio_set_value(&mcu_panel->reset_gpio, 0);
+
+	if (mcu_panel->desc->delay.init)
+		mdelay(mcu_panel->desc->delay.init);
+
+	if (mcu_panel->desc->init_seq) {
+		ret = rockchip_mcu_panel_send_cmds(panel->state, mcu_panel->desc->init_seq);
+		if (ret)
+			printf("failed to send mcu panel init cmds: %d\n", ret);
+	}
+
+	mcu_panel->prepared = true;
+}
+
+static void rockchip_mcu_panel_unprepare(struct rockchip_panel *panel)
+{
+	struct rockchip_mcu_panel *mcu_panel = to_rockchip_mcu_panel(panel);
+	int ret;
+
+	if (!mcu_panel->prepared)
+		return;
+
+	if (mcu_panel->desc->exit_seq) {
+		ret = rockchip_mcu_panel_send_cmds(panel->state, mcu_panel->desc->exit_seq);
+		if (ret)
+			printf("failed to send mcu panel exit cmds: %d\n", ret);
+	}
+
+	if (dm_gpio_is_valid(&mcu_panel->reset_gpio))
+		dm_gpio_set_value(&mcu_panel->reset_gpio, 1);
+
+	if (dm_gpio_is_valid(&mcu_panel->enable_gpio))
+		dm_gpio_set_value(&mcu_panel->enable_gpio, 0);
+
+	if (mcu_panel->desc->delay.unprepare)
+		mdelay(mcu_panel->desc->delay.unprepare);
+
+	mcu_panel->prepared = false;
+}
+
+static void rockchip_mcu_panel_enable(struct rockchip_panel *panel)
+{
+	struct rockchip_mcu_panel *mcu_panel = to_rockchip_mcu_panel(panel);
+
+	if (mcu_panel->enabled)
+		return;
+
+	if (mcu_panel->desc->delay.enable)
+		mdelay(mcu_panel->desc->delay.enable);
+
+	if (mcu_panel->backlight)
+		backlight_enable(mcu_panel->backlight);
+
+	mcu_panel->enabled = true;
+}
+
+static void rockchip_mcu_panel_disable(struct rockchip_panel *panel)
+{
+	struct rockchip_mcu_panel *mcu_panel = to_rockchip_mcu_panel(panel);
+
+	if (!mcu_panel->enabled)
+		return;
+
+	if (mcu_panel->backlight)
+		backlight_disable(mcu_panel->backlight);
+
+	if (mcu_panel->desc->delay.disable)
+		mdelay(mcu_panel->desc->delay.disable);
+
+	mcu_panel->enabled = false;
+}
+
+static const struct rockchip_panel_funcs rockchip_mcu_panel_funcs = {
+	.prepare = rockchip_mcu_panel_prepare,
+	.unprepare = rockchip_mcu_panel_unprepare,
+	.enable = rockchip_mcu_panel_enable,
+	.disable = rockchip_mcu_panel_disable,
+};
+
+static int rockchip_mcu_panel_parse_cmds(const u8 *data, int length,
+					 struct mcu_cmd_seq *pcmds)
+{
+	int len;
+	const u8 *buf;
+	const struct mcu_cmd_header *header;
+	int i, cnt = 0;
+
+	/* scan commands */
+	cnt = 0;
+	buf = data;
+	len = length;
+	while (len > sizeof(*header)) {
+		header = (const struct mcu_cmd_header *)buf;
+		buf += sizeof(*header) + header->payload_length;
+		len -= sizeof(*header) + header->payload_length;
+		cnt++;
+	}
+
+	pcmds->cmds = calloc(cnt, sizeof(struct mcu_cmd_desc));
+	if (!pcmds->cmds)
+		return -ENOMEM;
+
+	pcmds->cmd_cnt = cnt;
+
+	buf = data;
+	len = length;
+	for (i = 0; i < cnt; i++) {
+		struct mcu_cmd_desc *desc = &pcmds->cmds[i];
+
+		header = (const struct mcu_cmd_header *)buf;
+		length -= sizeof(*header);
+		buf += sizeof(*header);
+		desc->header.data_type = header->data_type;
+		desc->header.delay = header->delay;
+		desc->header.payload_length = header->payload_length;
+		desc->payload = buf;
+		buf += header->payload_length;
+		length -= header->payload_length;
+	}
+
+	return 0;
+}
+
+static int rockchip_mcu_panel_init(struct rockchip_mcu_panel *mcu_panel, ofnode mcu_panel_node)
+{
+	const void *data;
+	int len;
+	int ret;
+
+	ret = gpio_request_by_name_nodev(mcu_panel_node, "enable-gpios", 0,
+					 &mcu_panel->enable_gpio, GPIOD_IS_OUT);
+	if (ret && ret != -ENOENT) {
+		printf("%s: Cannot get mcu panel enable GPIO: %d\n", __func__, ret);
+		return ret;
+	}
+
+	ret = gpio_request_by_name_nodev(mcu_panel_node, "reset-gpios", 0,
+					 &mcu_panel->reset_gpio, GPIOD_IS_OUT);
+	if (ret && ret != -ENOENT) {
+		printf("%s: Cannot get mcu panel reset GPIO: %d\n", __func__, ret);
+		return ret;
+	}
+
+	mcu_panel->desc = malloc(sizeof(struct rockchip_mcu_panel_desc));
+	if (!mcu_panel->desc)
+		return -ENOMEM;
+
+	mcu_panel->desc->power_invert = ofnode_read_bool(mcu_panel_node, "power-invert");
+
+	mcu_panel->desc->delay.prepare = ofnode_read_u32_default(mcu_panel_node, "prepare-delay-ms", 0);
+	mcu_panel->desc->delay.unprepare = ofnode_read_u32_default(mcu_panel_node, "unprepare-delay-ms", 0);
+	mcu_panel->desc->delay.enable = ofnode_read_u32_default(mcu_panel_node, "enable-delay-ms", 0);
+	mcu_panel->desc->delay.disable = ofnode_read_u32_default(mcu_panel_node, "disable-delay-ms", 0);
+	mcu_panel->desc->delay.init = ofnode_read_u32_default(mcu_panel_node, "init-delay-ms", 0);
+	mcu_panel->desc->delay.reset = ofnode_read_u32_default(mcu_panel_node, "reset-delay-ms", 0);
+
+	mcu_panel->desc->bus_format = ofnode_read_u32_default(mcu_panel_node, "bus-format",
+							      MEDIA_BUS_FMT_RBG888_1X24);
+	mcu_panel->desc->bpc = ofnode_read_u32_default(mcu_panel_node, "bpc", 8);
+
+	data = ofnode_get_property(mcu_panel_node, "panel-init-sequence", &len);
+	if (data) {
+		mcu_panel->desc->init_seq = calloc(1, sizeof(*mcu_panel->desc->init_seq));
+		if (!mcu_panel->desc->init_seq)
+			return -ENOMEM;
+
+		ret = rockchip_mcu_panel_parse_cmds(data, len, mcu_panel->desc->init_seq);
+		if (ret) {
+			printf("failed to parse panel init sequence\n");
+			goto free_on_cmds;
+		}
+	}
+
+	data = ofnode_get_property(mcu_panel_node, "panel-exit-sequence", &len);
+	if (data) {
+		mcu_panel->desc->exit_seq = calloc(1, sizeof(*mcu_panel->desc->exit_seq));
+		if (!mcu_panel->desc->exit_seq) {
+			ret = -ENOMEM;
+			goto free_on_cmds;
+		}
+
+		ret = rockchip_mcu_panel_parse_cmds(data, len, mcu_panel->desc->exit_seq);
+		if (ret) {
+			printf("failed to parse panel exit sequence\n");
+			goto free_cmds;
+		}
+	}
+
+	return 0;
+
+free_cmds:
+	free(mcu_panel->desc->exit_seq);
+free_on_cmds:
+	free(mcu_panel->desc->init_seq);
+	return ret;
+}
+
+static int rockchip_rgb_probe(struct udevice *dev)
+{
+	struct rockchip_rgb *rgb = dev_get_priv(dev);
+	ofnode mcu_panel_node;
+	int phandle;
+	int ret;
+
+	rgb->dev = dev;
+	rgb->funcs = (const struct rockchip_rgb_funcs *)dev_get_driver_data(dev);
+	rgb->grf = syscon_get_regmap(dev_get_parent(dev));
+	rgb->data_sync_bypass = dev_read_bool(dev, "rockchip,data-sync-bypass");
+	rgb->id = of_alias_get_id(ofnode_to_np(dev->node), "rgb");
+	if (rgb->id < 0)
+		rgb->id = 0;
+
+	mcu_panel_node = dev_read_subnode(dev, "mcu-panel");
+	if (ofnode_valid(mcu_panel_node) && ofnode_is_enabled(mcu_panel_node)) {
+		struct rockchip_mcu_panel *mcu_panel;
+
+		mcu_panel = malloc(sizeof(struct rockchip_mcu_panel));
+		if (!mcu_panel) {
+			printf("failed to alloc mcu_panel data\n");
+			return -ENOMEM;
+		}
+
+		ret = rockchip_mcu_panel_init(mcu_panel, mcu_panel_node);
+		if (ret < 0) {
+			printf("failed to init mcu_panel: %d\n", ret);
+			return ret;
+		}
+
+		phandle = ofnode_read_u32_default(mcu_panel_node, "backlight", -1);
+		if (phandle < 0) {
+			printf("failed to find backlight phandle\n");
+			return -EINVAL;
+		}
+
+		ret = uclass_get_device_by_phandle_id(UCLASS_PANEL_BACKLIGHT, phandle,
+						      &mcu_panel->backlight);
+		if (ret && ret != -ENOENT) {
+			printf("%s: failed to get backlight device: %d\n", __func__, ret);
+			return ret;
+		}
+
+		mcu_panel->base.dev = dev;
+		mcu_panel->base.bus_format = mcu_panel->desc->bus_format;
+		mcu_panel->base.bpc = mcu_panel->desc->bpc;
+		mcu_panel->base.funcs = &rockchip_mcu_panel_funcs;
+		mcu_panel->enabled = false;
+		mcu_panel->prepared = false;
+
+		rgb->connector.panel = &mcu_panel->base;
+	}
+
+	rockchip_connector_bind(&rgb->connector, dev, rgb->id, &rockchip_rgb_connector_funcs,
+				NULL, DRM_MODE_CONNECTOR_LVDS);
+
+	return 0;
+}
+
+static void rv1106_rgb_prepare(struct rockchip_rgb *rgb, int pipe)
+{
+	regmap_write(rgb->grf, RV1106_VENC_GRF_VOP_IO_WRAPPER,
+		     RV1106_IO_BYPASS_SEL(rgb->data_sync_bypass ? 0x3 : 0x0));
+	regmap_write(rgb->grf, RV1106_VOGRF_VOP_PIPE_BYPASS,
+		     RV1106_VOP_PIPE_BYPASS(rgb->data_sync_bypass ? 0x3 : 0x0));
+}
+
+static const struct rockchip_rgb_funcs rv1106_rgb_funcs = {
+	.prepare = rv1106_rgb_prepare,
+};
+
+static void rv1126_rgb_prepare(struct rockchip_rgb *rgb, int pipe)
+{
+	regmap_write(rgb->grf, RV1126_GRF_IOFUNC_CON3,
+		     RV1126_LCDC_IO_BYPASS(rgb->data_sync_bypass));
+}
+
+static const struct rockchip_rgb_funcs rv1126_rgb_funcs = {
+	.prepare = rv1126_rgb_prepare,
+};
+
+static void px30_rgb_prepare(struct rockchip_rgb *rgb, int pipe)
+{
+	regmap_write(rgb->grf, PX30_GRF_PD_VO_CON1, PX30_RGB_VOP_SEL(pipe) |
+		     PX30_RGB_DATA_SYNC_BYPASS(rgb->data_sync_bypass));
+}
+
+static const struct rockchip_rgb_funcs px30_rgb_funcs = {
+	.prepare = px30_rgb_prepare,
+};
+
+static void rk1808_rgb_prepare(struct rockchip_rgb *rgb, int pipe)
+{
+	regmap_write(rgb->grf, RK1808_GRF_PD_VO_CON1,
+		     RK1808_RGB_DATA_SYNC_BYPASS(rgb->data_sync_bypass));
+}
+
+static const struct rockchip_rgb_funcs rk1808_rgb_funcs = {
+	.prepare = rk1808_rgb_prepare,
+};
+
+static void rk3288_rgb_prepare(struct rockchip_rgb *rgb, int pipe)
+{
+	regmap_write(rgb->grf, RK3288_GRF_SOC_CON6, RK3288_LVDS_LCDC_SEL(pipe));
+	regmap_write(rgb->grf, RK3288_GRF_SOC_CON7,
+		     RK3288_LVDS_PWRDWN(0) | RK3288_LVDS_CON_ENABLE_2(1) |
+		     RK3288_LVDS_CON_ENABLE_1(1) | RK3288_LVDS_CON_CLKINV(0) |
+		     RK3288_LVDS_CON_TTL_EN(1));
+}
+
+static void rk3288_rgb_unprepare(struct rockchip_rgb *rgb)
+{
+	regmap_write(rgb->grf, RK3288_GRF_SOC_CON7,
+		     RK3288_LVDS_PWRDWN(1) | RK3288_LVDS_CON_ENABLE_2(0) |
+		     RK3288_LVDS_CON_ENABLE_1(0) | RK3288_LVDS_CON_TTL_EN(0));
+}
+
+static const struct rockchip_rgb_funcs rk3288_rgb_funcs = {
+	.prepare = rk3288_rgb_prepare,
+	.unprepare = rk3288_rgb_unprepare,
+};
+
+static void rk3368_rgb_prepare(struct rockchip_rgb *rgb, int pipe)
+{
+	regmap_write(rgb->grf, RK3368_GRF_SOC_CON15, RK3368_FORCE_JETAG(0));
+}
+
+static const struct rockchip_rgb_funcs rk3368_rgb_funcs = {
+	.prepare = rk3368_rgb_prepare,
+};
+
+static void rk3562_rgb_prepare(struct rockchip_rgb *rgb, int pipe)
+{
+	regmap_write(rgb->grf, RK3562_GRF_IOC_VO_IO_CON,
+		     RK3562_RGB_DATA_BYPASS(rgb->data_sync_bypass));
+}
+
+static const struct rockchip_rgb_funcs rk3562_rgb_funcs = {
+	.prepare = rk3562_rgb_prepare,
+};
+
+static void rk3568_rgb_prepare(struct rockchip_rgb *rgb, int pipe)
+{
+	regmap_write(rgb->grf, RK3568_GRF_VO_CON1, RK3568_RGB_DATA_BYPASS(rgb->data_sync_bypass));
+}
+
+static const struct rockchip_rgb_funcs rk3568_rgb_funcs = {
+	.prepare = rk3568_rgb_prepare,
+};
+
+static const struct udevice_id rockchip_rgb_ids[] = {
+	{
+		.compatible = "rockchip,px30-rgb",
+		.data = (ulong)&px30_rgb_funcs,
+	},
+	{
+		.compatible = "rockchip,rk1808-rgb",
+		.data = (ulong)&rk1808_rgb_funcs,
+	},
+	{
+		.compatible = "rockchip,rk3066-rgb",
+	},
+	{
+		.compatible = "rockchip,rk3128-rgb",
+	},
+	{
+		.compatible = "rockchip,rk3288-rgb",
+		.data = (ulong)&rk3288_rgb_funcs,
+	},
+	{
+		.compatible = "rockchip,rk3308-rgb",
+	},
+	{
+		.compatible = "rockchip,rk3368-rgb",
+		.data = (ulong)&rk3368_rgb_funcs,
+	},
+	{
+		.compatible = "rockchip,rk3562-rgb",
+		.data = (ulong)&rk3562_rgb_funcs,
+	},
+	{
+		.compatible = "rockchip,rk3568-rgb",
+		.data = (ulong)&rk3568_rgb_funcs,
+	},
+	{
+		.compatible = "rockchip,rk3588-rgb",
+	},
+	{
+		.compatible = "rockchip,rv1106-rgb",
+		.data = (ulong)&rv1106_rgb_funcs,
+	},
+	{
+		.compatible = "rockchip,rv1108-rgb",
+	},
+	{
+		.compatible = "rockchip,rv1126-rgb",
+		.data = (ulong)&rv1126_rgb_funcs,
+	},
+	{}
+};
+
+U_BOOT_DRIVER(rockchip_rgb) = {
+	.name = "rockchip_rgb",
+	.id = UCLASS_DISPLAY,
+	.of_match = rockchip_rgb_ids,
+	.probe = rockchip_rgb_probe,
+	.priv_auto_alloc_size = sizeof(struct rockchip_rgb),
+};
diff --git a/drivers/video/drm/rockchip_spl_display.c b/drivers/video/drm/rockchip_spl_display.c
new file mode 100644
index 0000000000..10d2d69346
--- /dev/null
+++ b/drivers/video/drm/rockchip_spl_display.c
@@ -0,0 +1,268 @@
+/*
+ * (C) Copyright 2023 Rockchip Electronics Co., Ltd
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <malloc.h>
+#include <mp_boot.h>
+#include <spl.h>
+#include <part.h>
+#include <drm_modes.h>
+#include <spl_display.h>
+#include <linux/hdmi.h>
+
+#include "rockchip_display.h"
+#include "rockchip_crtc.h"
+#include "rockchip_connector.h"
+#include "rockchip_phy.h"
+
+static struct base2_info base_parameter;
+
+struct display_state *rockchip_spl_display_drv_probe(void)
+{
+	struct display_state *state = malloc(sizeof(struct display_state));
+	if (!state)
+		return NULL;
+
+	memset(state, 0, sizeof(*state));
+
+	rockchip_spl_vop_probe(&state->crtc_state);
+	rockchip_spl_dw_hdmi_probe(&state->conn_state);
+	inno_spl_hdmi_phy_probe(state);
+
+	return state;
+}
+
+static int rockchip_spl_display_init(struct display_state *state)
+{
+	struct crtc_state *crtc_state = &state->crtc_state;
+	struct connector_state *conn_state = &state->conn_state;
+	struct rockchip_connector *conn = conn_state->connector;
+	const struct rockchip_crtc *crtc = crtc_state->crtc;
+	const struct rockchip_crtc_funcs *crtc_funcs = crtc->funcs;
+	const struct rockchip_connector_funcs *conn_funcs = conn->funcs;
+	struct drm_display_mode *mode = &state->conn_state.mode;
+	int ret = 0;
+
+	if (!crtc_funcs) {
+		printf("failed to find crtc functions\n");
+		return -ENXIO;
+	}
+
+	if (crtc_funcs->preinit) {
+		ret = crtc_funcs->preinit(state);
+		if (ret)
+			return ret;
+	}
+
+	rockchip_display_make_crc32_table();
+	if (conn_funcs->pre_init) {
+		ret = conn_funcs->pre_init(conn, state);
+		if (ret)
+			return ret;
+	}
+
+	if (conn_funcs->init) {
+		ret = conn_funcs->init(conn, state);
+		if (ret)
+			goto deinit;
+	}
+
+	if (conn->phy)
+		rockchip_phy_init(conn->phy);
+
+	if (conn_funcs->detect) {
+		conn->hpd = conn_funcs->detect(conn, state);
+		if (!conn->hpd)
+			goto deinit;
+	}
+
+	if (conn_funcs->get_timing) {
+		ret = conn_funcs->get_timing(conn, state);
+		if (ret)
+			goto deinit;
+	}
+
+	drm_mode_set_crtcinfo(mode, CRTC_INTERLACE_HALVE_V);
+	if (p->flags & DRM_MODE_FLAG_DBLCLK)
+		p->crtc_clock = 2 * p->clock;
+
+	if (crtc_funcs->init) {
+		ret = crtc_funcs->init(state);
+		if (ret)
+			goto deinit;
+	}
+
+	return 0;
+
+deinit:
+	rockchip_connector_deinit(state);
+	return ret;
+}
+
+static int rockchip_spl_display_post_enable(struct display_state *state)
+{
+	struct crtc_state *crtc_state = &state->crtc_state;
+	struct connector_state *conn_state = &state->conn_state;
+	struct rockchip_connector *conn = conn_state->connector;
+	const struct rockchip_crtc *crtc = crtc_state->crtc;
+	const struct rockchip_crtc_funcs *crtc_funcs = crtc->funcs;
+	const struct rockchip_connector_funcs *conn_funcs = conn->funcs;
+
+	if (crtc_funcs->enable)
+		crtc_funcs->enable(state);
+	state->crtc_state.crtc->active = true;
+
+	if (conn_funcs->enable)
+		conn_funcs->enable(conn, state);
+
+	return 0;
+}
+
+static void rockchip_spl_display_transmit_info_to_uboot(struct display_state *state)
+{
+	struct connector_state *conn_state = &state->conn_state;
+	struct spl_display_info *spl_disp_info = (struct spl_display_info *)CONFIG_SPL_VIDEO_BUF;
+
+	/* transmit mode and bus_format to uboot */
+	memcpy(&spl_disp_info->mode, &conn_state->mode, sizeof(conn_state->mode));
+	spl_disp_info->bus_format = state->conn_state.bus_format;
+	spl_disp_info->enabled = 1;
+	flush_dcache_all();
+}
+
+int spl_init_display(struct task_data *data)
+{
+	struct display_state *state = NULL;
+	struct drm_display_mode *mode;
+	int ret = 0;
+
+	state = rockchip_spl_display_drv_probe();
+	if (!state) {
+		printf("rockchip_spl_display_drv_probe failed\n");
+		return -1;
+	}
+
+	ret = rockchip_spl_display_init(state);
+	if (ret) {
+		printf("rockchip_spl_display_init failed ret:%d\n", ret);
+		return  -1;
+	}
+
+	if (!state->conn_state.connector->hpd) {
+		printf("HDMI is unplug and exit\n");
+		return 0;
+	}
+
+	ret = rockchip_spl_display_post_enable(state);
+	if (ret) {
+		printf("rockchip_spl_display_post_enable failed ret:%d\n", ret);
+		return -1;
+	}
+
+	rockchip_spl_display_transmit_info_to_uboot(state);
+
+	mode = &state->conn_state.mode;
+	printf("SPL enable hdmi, detailed mode clock %u kHz, flags[%x]\n"
+	       "    H: %04d %04d %04d %04d\n"
+	       "    V: %04d %04d %04d %04d\n"
+	       "bus_format: %x\n",
+	       mode->clock, mode->flags,
+	       mode->hdisplay, mode->hsync_start,
+	       mode->hsync_end, mode->htotal,
+	       mode->vdisplay, mode->vsync_start,
+	       mode->vsync_end, mode->vtotal,
+	       state->conn_state.bus_format);
+
+	return ret;
+}
+
+struct base2_disp_info *rockchip_get_disp_info(int type, int id)
+{
+	struct base2_disp_info *disp_info;
+	struct base2_disp_header *disp_header;
+	int i = 0, offset = -1;
+	u32 crc_val;
+	u32 base2_length;
+	void *base_parameter_addr = (void *)&base_parameter;
+#ifdef CONFIG_MP_BOOT
+	void *bp_addr = (void *)CONFIG_SPL_VIDEO_BUF;
+	ulong ret;
+
+	/* make sure the baseparameter is ready */
+	ret = mpb_post(6);
+	printf("SPL read baseparameter %s\n", ret < 0 ? "failed" : "success");
+	memcpy(&base_parameter, bp_addr, sizeof(base_parameter));
+#endif
+	for (i = 0; i < 8; i++) {
+		disp_header = &base_parameter.disp_header[i];
+		if (disp_header->connector_type == type &&
+		    disp_header->connector_id == id) {
+			printf("disp info %d, type:%d, id:%d\n", i, type, id);
+			offset = disp_header->offset;
+			break;
+		}
+	}
+
+	if (offset < 0)
+		return NULL;
+	disp_info = base_parameter_addr + offset;
+	if (disp_info->screen_info[0].type != type ||
+	    disp_info->screen_info[0].id != id) {
+		printf("base2_disp_info couldn't be found, screen_info type[%d] or id[%d] mismatched\n",
+		       disp_info->screen_info[0].type,
+		       disp_info->screen_info[0].id);
+		return NULL;
+	}
+
+	if (strncasecmp(disp_info->disp_head_flag, "DISP", 4))
+		return NULL;
+
+	if (base_parameter.major_version == 3 && base_parameter.minor_version == 0) {
+		crc_val = rockchip_display_crc32c_cal((unsigned char *)disp_info,
+						      sizeof(struct base2_disp_info) - 4);
+		if (crc_val != disp_info->crc2) {
+			printf("error: connector type[%d], id[%d] disp info crc2 check error\n",
+			       type, id);
+			return NULL;
+		}
+	} else {
+		base2_length = sizeof(struct base2_disp_info) - sizeof(struct csc_info) -
+			       sizeof(struct acm_data) - 10 * 1024 - 4;
+		crc_val = rockchip_display_crc32c_cal((unsigned char *)disp_info, base2_length - 4);
+		if (crc_val != disp_info->crc) {
+			printf("error: connector type[%d], id[%d] disp info crc check error\n",
+			       type, id);
+			return NULL;
+		}
+	}
+
+	return disp_info;
+}
+
+int spl_load_baseparamter(struct task_data *data)
+{
+	struct spl_load_info *info = &data->info;
+	ulong addr = CONFIG_SPL_VIDEO_BUF;
+	disk_partition_t part;
+
+	debug("== Baseparam: start\n");
+
+	if (part_get_info_by_name(info->dev, "baseparameter", &part) < 0) {
+		printf("No baseparameter partition\n");
+		return -ENOENT;
+	} else {
+		if (info->read(info, part.start, part.size, (void *)addr) != part.size)
+			return -EIO;
+		else
+			flush_dcache_range(addr, addr + part.size * info->bl_len);
+	}
+
+	debug("== Baseparam: load OK\n");
+
+	return 0;
+}
+
diff --git a/drivers/video/drm/rockchip_tve.c b/drivers/video/drm/rockchip_tve.c
new file mode 100644
index 0000000000..96645490e1
--- /dev/null
+++ b/drivers/video/drm/rockchip_tve.c
@@ -0,0 +1,848 @@
+/*
+ * SPDX-License-Identifier:	GPL-2.0+
+ * (C) Copyright 2008-2015 Fuzhou Rockchip Electronics Co., Ltd
+ */
+#include <common.h>
+#include <malloc.h>
+#include <fdtdec.h>
+#include <fdt_support.h>
+#include <asm/io.h>
+#include <linux/media-bus-format.h>
+#include <asm/arch-rockchip/clock.h>
+#include <dm/device.h>
+#include <dm/read.h>
+#include <dm/uclass-internal.h>
+#include <linux/fb.h>
+#include <edid.h>
+#include <syscon.h>
+#include <boot_rkimg.h>
+#include <mapmem.h>
+#include <misc.h>
+
+#include "rockchip_display.h"
+#include "rockchip_crtc.h"
+#include "rockchip_connector.h"
+#include "rockchip_phy.h"
+#include "rockchip_tve.h"
+
+#define RK322X_VDAC_STANDARD		0x15
+
+static const struct drm_display_mode tve_modes[] = {
+	/* 0 - 720x576i@50Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 13500, 720, 753,
+		   816, 864, 576, 580, 586, 625, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+		   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),
+		   .vrefresh = 50, },
+	/* 1 - 720x480i@60Hz */
+	{ DRM_MODE(DRM_MODE_TYPE_DRIVER, 13500, 720, 753,
+		   815, 858, 480, 483, 486, 525, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+		   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK),
+		   .vrefresh = 60, },
+};
+
+struct env_config {
+	u32 offset;
+	u32 value;
+};
+
+static struct env_config ntsc_bt656_config[] = {
+	{ BT656_DECODER_CROP, 0x00000000 },
+	{ BT656_DECODER_SIZE, 0x01e002d0 },
+	{ BT656_DECODER_HTOTAL_HS_END, 0x035a003e },
+	{ BT656_DECODER_VACT_ST_HACT_ST, 0x00160069 },
+	{ BT656_DECODER_VTOTAL_VS_END, 0x020d0003 },
+	{ BT656_DECODER_VS_ST_END_F1, 0x01060109 },
+	{ BT656_DECODER_DBG_REG, 0x024002d0 },
+	{ BT656_DECODER_CTRL, 0x00000009 },
+};
+
+static struct env_config ntsc_tve_config[] = {
+	{ TVE_MODE_CTRL, 0x000af906 },
+	{ TVE_HOR_TIMING1, 0x00c07a81 },
+	{ TVE_HOR_TIMING2, 0x169810fc },
+	{ TVE_HOR_TIMING3, 0x96b40000 },
+	{ TVE_SUB_CAR_FRQ, 0x21f07bd7 },
+	{ TVE_IMAGE_POSITION, 0x001500d6 },
+	{ TVE_ROUTING, 0x10088880 },
+	{ TVE_SYNC_ADJUST, 0x00000000 },
+	{ TVE_STATUS, 0x00000000 },
+	{ TVE_CTRL, 0x00000000 },
+	{ TVE_INTR_STATUS, 0x00000000 },
+	{ TVE_INTR_EN, 0x00000000 },
+	{ TVE_INTR_CLR, 0x00000000 },
+	{ TVE_COLOR_BUSRT_SAT, 0x0052543c },
+	{ TVE_CHROMA_BANDWIDTH, 0x00000002 },
+	{ TVE_BRIGHTNESS_CONTRAST, 0x00008300 },
+	{ TVE_CLAMP, 0x00000000 },
+};
+
+static struct env_config pal_bt656_config[] = {
+	{ BT656_DECODER_CROP, 0x00000000 },
+	{ BT656_DECODER_SIZE, 0x024002d0 },
+	{ BT656_DECODER_HTOTAL_HS_END, 0x0360003f },
+	{ BT656_DECODER_VACT_ST_HACT_ST, 0x0016006f },
+	{ BT656_DECODER_VTOTAL_VS_END, 0x02710003 },
+	{ BT656_DECODER_VS_ST_END_F1, 0x0138013b },
+	{ BT656_DECODER_DBG_REG, 0x024002d0 },
+	{ BT656_DECODER_CTRL, 0x00000009 },
+};
+
+static struct env_config pal_tve_config[] = {
+	{ TVE_MODE_CTRL, 0x010ab906 },
+	{ TVE_HOR_TIMING1, 0x00c28381 },
+	{ TVE_HOR_TIMING2, 0x267d111d },
+	{ TVE_HOR_TIMING3, 0x66c00880 },
+	{ TVE_SUB_CAR_FRQ, 0x2a098acb },
+	{ TVE_IMAGE_POSITION, 0x001500f6 },
+	{ TVE_ROUTING, 0x10008882 },
+	{ TVE_SYNC_ADJUST, 0x00000000 },
+	{ TVE_STATUS, 0x000000b0 },
+	{ TVE_CTRL, 0x00000000 },
+	{ TVE_INTR_STATUS, 0x00000000 },
+	{ TVE_INTR_EN, 0x00000000 },
+	{ TVE_INTR_CLR, 0x00000000 },
+	{ TVE_COLOR_BUSRT_SAT, 0x00356245 },
+	{ TVE_CHROMA_BANDWIDTH, 0x00000022 },
+	{ TVE_BRIGHTNESS_CONTRAST, 0x0000aa00 },
+	{ TVE_CLAMP, 0x00000000 },
+};
+
+#define BT656_ENV_CONFIG_SIZE		(sizeof(ntsc_bt656_config) / sizeof(struct env_config))
+#define TVE_ENV_CONFIG_SIZE		(sizeof(ntsc_tve_config) / sizeof(struct env_config))
+
+#define tve_writel(offset, v)		writel(v, tve->reg_base  + offset)
+#define tve_readl(offset)		readl(tve->reg_base + offset)
+
+#define tve_dac_writel(offset, v)	writel(v, tve->vdac_base + offset)
+#define tve_dac_readl(offset)		readl(tve->vdac_base + offset)
+
+#define tve_grf_writel(offset, v)	writel(v, tve->grf + offset)
+#define tve_grf_readl(offset, v)	readl(tve->grf + offset)
+
+struct rockchip_tve_data {
+	int	input_format;
+	int	soc_type;
+};
+
+struct rockchip_tve {
+	struct	rockchip_connector connector;
+	struct	udevice *dev;
+	void	*reg_base;
+	void	*vdac_base;
+	int	soc_type;
+	int	input_format;
+	int 	tv_format;
+	int	test_mode;
+	int	saturation;
+	int	brightcontrast;
+	int	adjtiming;
+	int	lumafilter0;
+	int	lumafilter1;
+	int	lumafilter2;
+	int	lumafilter3;
+	int	lumafilter4;
+	int	lumafilter5;
+	int	lumafilter6;
+	int	lumafilter7;
+	int	daclevel;
+	int	dac1level;
+	int	preferred_mode;
+	int	upsample_mode;
+	void	*grf;
+};
+
+static void tve_write_block(struct rockchip_tve *tve, struct env_config *config, int len)
+{
+	int i;
+
+	for (i = 0; i < len; i++)
+		tve_writel(config[i].offset, config[i].value);
+}
+
+static void tve_set_mode(struct rockchip_tve *tve)
+{
+	struct env_config *bt656_cfg, *tve_cfg;
+	int mode = tve->tv_format;
+
+	if (tve->soc_type == SOC_RK3528) {
+		tve_writel(TVE_LUMA_FILTER1, tve->lumafilter0);
+		tve_writel(TVE_LUMA_FILTER2, tve->lumafilter1);
+		tve_writel(TVE_LUMA_FILTER3, tve->lumafilter2);
+		tve_writel(TVE_LUMA_FILTER4, tve->lumafilter3);
+		tve_writel(TVE_LUMA_FILTER5, tve->lumafilter4);
+		tve_writel(TVE_LUMA_FILTER6, tve->lumafilter5);
+		tve_writel(TVE_LUMA_FILTER7, tve->lumafilter6);
+		tve_writel(TVE_LUMA_FILTER8, tve->lumafilter7);
+	} else {
+		if (tve->input_format == INPUT_FORMAT_RGB)
+			tve_writel(TV_CTRL, v_CVBS_MODE(mode) | v_CLK_UPSTREAM_EN(2) |
+				v_TIMING_EN(2) | v_LUMA_FILTER_GAIN(0) |
+				v_LUMA_FILTER_UPSAMPLE(1) | v_CSC_PATH(0));
+		else
+			tve_writel(TV_CTRL, v_CVBS_MODE(mode) | v_CLK_UPSTREAM_EN(2) |
+				v_TIMING_EN(2) | v_LUMA_FILTER_GAIN(0) |
+				v_LUMA_FILTER_UPSAMPLE(1) | v_CSC_PATH(3));
+
+		tve_writel(TV_LUMA_FILTER0, tve->lumafilter0);
+		tve_writel(TV_LUMA_FILTER1, tve->lumafilter1);
+		tve_writel(TV_LUMA_FILTER2, tve->lumafilter2);
+	}
+
+	if (mode == TVOUT_CVBS_NTSC) {
+		TVEDBG("tve set ntsc mode\n");
+
+		if (tve->soc_type == SOC_RK3528) {
+			bt656_cfg = ntsc_bt656_config;
+			tve_cfg = ntsc_tve_config;
+
+			tve_write_block(tve, bt656_cfg, BT656_ENV_CONFIG_SIZE);
+			tve_write_block(tve, tve_cfg, TVE_ENV_CONFIG_SIZE);
+		} else {
+			tve_writel(TV_ROUTING, v_DAC_SENSE_EN(0) | v_Y_IRE_7_5(1) |
+				   v_Y_AGC_PULSE_ON(0) | v_Y_VIDEO_ON(1) |
+				   v_YPP_MODE(1) | v_Y_SYNC_ON(1) | v_PIC_MODE(mode));
+			tve_writel(TV_BW_CTRL, v_CHROMA_BW(BP_FILTER_NTSC) |
+				   v_COLOR_DIFF_BW(COLOR_DIFF_FILTER_BW_1_3));
+			tve_writel(TV_SATURATION, 0x0042543C);
+			if (tve->test_mode)
+				tve_writel(TV_BRIGHTNESS_CONTRAST, 0x00008300);
+			else
+				tve_writel(TV_BRIGHTNESS_CONTRAST, 0x00007900);
+
+			tve_writel(TV_FREQ_SC,	0x21F07BD7);
+			tve_writel(TV_SYNC_TIMING, 0x00C07a81);
+			tve_writel(TV_ADJ_TIMING, 0x96B40000 | 0x70);
+			tve_writel(TV_ACT_ST,	0x001500D6);
+			tve_writel(TV_ACT_TIMING, 0x069800FC | (1 << 12) | (1 << 28));
+		}
+	} else if (mode == TVOUT_CVBS_PAL) {
+		TVEDBG("tve set pal mode\n");
+
+		if (tve->soc_type == SOC_RK3528) {
+			bt656_cfg = pal_bt656_config;
+			tve_cfg = pal_tve_config;
+
+			tve_write_block(tve, bt656_cfg, BT656_ENV_CONFIG_SIZE);
+			tve_write_block(tve, tve_cfg, TVE_ENV_CONFIG_SIZE);
+		} else {
+			tve_writel(TV_ROUTING, v_DAC_SENSE_EN(0) | v_Y_IRE_7_5(0) |
+				   v_Y_AGC_PULSE_ON(0) | v_Y_VIDEO_ON(1) |
+				   v_YPP_MODE(1) | v_Y_SYNC_ON(1) | v_PIC_MODE(mode));
+			tve_writel(TV_BW_CTRL, v_CHROMA_BW(BP_FILTER_PAL) |
+				   v_COLOR_DIFF_BW(COLOR_DIFF_FILTER_BW_1_3));
+
+			tve_writel(TV_SATURATION, tve->saturation);
+			tve_writel(TV_BRIGHTNESS_CONTRAST, tve->brightcontrast);
+
+			tve_writel(TV_FREQ_SC,	0x2A098ACB);
+			tve_writel(TV_SYNC_TIMING, 0x00C28381);
+			tve_writel(TV_ADJ_TIMING, (0xc << 28) | 0x06c00800 | 0x80);
+			tve_writel(TV_ACT_ST,	0x001500F6);
+			tve_writel(TV_ACT_TIMING, 0x0694011D | (1 << 12) | (2 << 28));
+
+			tve_writel(TV_ADJ_TIMING, tve->adjtiming);
+			tve_writel(TV_ACT_TIMING, 0x0694011D | (1 << 12) | (2 << 28));
+		}
+	}
+
+	if (tve->soc_type == SOC_RK3528) {
+		u32 upsample_mode = 0;
+		u32 mask = 0;
+		u32 val = 0;
+		bool upsample_en;
+
+		upsample_en = tve->upsample_mode ? 1 : 0;
+		if (upsample_en)
+			upsample_mode = tve->upsample_mode - 1;
+		mask = m_TVE_DCLK_POL | m_TVE_DCLK_EN | m_DCLK_UPSAMPLE_2X4X |
+		       m_DCLK_UPSAMPLE_EN | m_TVE_MODE | m_TVE_EN;
+		val = v_TVE_DCLK_POL(0) | v_TVE_DCLK_EN(1) | v_DCLK_UPSAMPLE_2X4X(upsample_mode) |
+		      v_DCLK_UPSAMPLE_EN(upsample_en) | v_TVE_MODE(tve->tv_format) | v_TVE_EN(1);
+
+		tve_grf_writel(RK3528_VO_GRF_CVBS_CON, (mask << 16) | val);
+	}
+}
+
+static void dac_init(struct rockchip_tve *tve)
+{
+	tve_dac_writel(VDAC_VDAC1, v_CUR_REG(tve->dac1level) |
+				   m_DR_PWR_DOWN | m_BG_PWR_DOWN);
+	tve_dac_writel(VDAC_VDAC2, v_CUR_CTR(tve->daclevel));
+	tve_dac_writel(VDAC_VDAC3, v_CAB_EN(0));
+}
+
+static void dac_enable(struct rockchip_tve *tve, bool enable)
+{
+	u32 mask = 0;
+	u32 val = 0;
+	u32 grfreg = 0;
+	u32 offset = 0;
+
+	if (enable) {
+		TVEDBG("tve enable\n");
+
+		if (tve->soc_type == SOC_RK3036) {
+			mask = m_VBG_EN | m_DAC_EN | m_DAC_GAIN;
+			val = m_VBG_EN | m_DAC_EN | v_DAC_GAIN(tve->daclevel);
+			grfreg = RK3036_GRF_SOC_CON3;
+		} else if (tve->soc_type == SOC_RK312X) {
+			mask = m_VBG_EN | m_DAC_EN | m_DAC_GAIN;
+			val = m_VBG_EN | m_DAC_EN | v_DAC_GAIN(tve->daclevel);
+			grfreg = RK312X_GRF_TVE_CON;
+		} else if (tve->soc_type == SOC_RK322X || tve->soc_type == SOC_RK3328) {
+			val = v_CUR_REG(tve->dac1level) | v_DR_PWR_DOWN(0) | v_BG_PWR_DOWN(0);
+		} else if (tve->soc_type == SOC_RK3528) {
+			/*
+			 * Reset the vdac
+			 */
+			tve_dac_writel(VDAC_CLK_RST, v_ANALOG_RST(0) | v_DIGITAL_RST(0));
+			mdelay(20);
+			tve_dac_writel(VDAC_CLK_RST, v_ANALOG_RST(1) | v_DIGITAL_RST(1));
+
+			tve_dac_writel(VDAC_CURRENT_CTRL, v_OUT_CURRENT(0xd2));
+
+			val = v_REF_VOLTAGE(7) | v_DAC_PWN(1) | v_BIAS_PWN(1);
+			offset = VDAC_PWM_REF_CTRL;
+		}
+	} else {
+		TVEDBG("tve disable\n");
+
+		if (tve->soc_type == SOC_RK312X) {
+			mask = m_VBG_EN | m_DAC_EN;
+			grfreg = RK312X_GRF_TVE_CON;
+		} else if (tve->soc_type == SOC_RK3036) {
+			mask = m_VBG_EN | m_DAC_EN;
+			grfreg = RK3036_GRF_SOC_CON3;
+		} else if (tve->soc_type == SOC_RK322X || tve->soc_type == SOC_RK3328) {
+			val = v_CUR_REG(tve->dac1level) | m_DR_PWR_DOWN | m_BG_PWR_DOWN;
+			offset = VDAC_VDAC1;
+		} else if (tve->soc_type == SOC_RK3528) {
+			val = v_DAC_PWN(0) | v_BIAS_PWN(0);
+			offset = VDAC_PWM_REF_CTRL;
+		}
+	}
+
+	if (grfreg)
+		tve_grf_writel(grfreg, (mask << 16) | val);
+	else if (tve->vdac_base)
+		tve_dac_writel(offset, val);
+}
+
+static u8 rk_get_vdac_value(void)
+{
+	u8 value = 0;
+#ifdef CONFIG_ROCKCHIP_EFUSE
+#if defined(CONFIG_ROCKCHIP_RK322X)
+	struct udevice *dev;
+	u32 regs[2] = {0};
+	u8 fuses[1];
+	ofnode node;
+	int ret;
+
+	ret = uclass_get_device_by_driver(UCLASS_MISC, DM_GET_DRIVER(rockchip_efuse), &dev);
+	if (ret) {
+		printf("%s: no misc-device found\n", __func__);
+		return -EINVAL;
+	}
+
+	node = dev_read_subnode(dev, "tve_dac");
+	if (!ofnode_valid(node))
+		return -EINVAL;
+
+	ret = ofnode_read_u32_array(node, "reg", regs, 2);
+	if (ret) {
+		printf("Cannot get efuse reg\n");
+		return -EINVAL;
+	}
+
+	ret = misc_read(dev, regs[0], &fuses, regs[1]);
+	if (ret) {
+		printf("%s: misc_read failed\n", __func__);
+		return 0;
+	}
+
+	value = fuses[0];
+	value = (value >> 3) & 0x1f;
+#endif
+#endif /* CONFIG_RK_EFUSE */
+	if (value > 0)
+		value += 5;
+	TVEDBG("%s value = 0x%x\n", __func__, value);
+
+	return value;
+}
+
+static int tve_parse_dt(struct rockchip_tve *tve)
+{
+	tve->preferred_mode = dev_read_u32_default(tve->dev, "rockchip,tvemode", -1);
+	if (tve->preferred_mode < 0) {
+		tve->preferred_mode = 0;
+	} else if (tve->preferred_mode > 1) {
+		printf("tve mode value invalid\n");
+		return -EINVAL;
+	}
+
+	tve->lumafilter0 = dev_read_u32_default(tve->dev, "rockchip,lumafilter0", 0);
+	if (tve->lumafilter0 == 0) {
+		printf("tve get lumafilter0 err\n");
+		return -EINVAL;
+	}
+
+	tve->lumafilter1 = dev_read_u32_default(tve->dev, "rockchip,lumafilter1", 0);
+	if (tve->lumafilter1 == 0) {
+		printf("tve get lumafilter1 err\n");
+		return -EINVAL;
+	}
+
+	tve->lumafilter2 = dev_read_u32_default(tve->dev, "rockchip,lumafilter2", 0);
+	if (tve->lumafilter2 == 0) {
+		printf("tve get lumafilter2 err\n");
+		return -EINVAL;
+	}
+
+	tve->lumafilter3 = dev_read_u32_default(tve->dev, "rockchip,lumafilter3", 0);
+	if (tve->lumafilter3 == 0) {
+		printf("tve get lumafilter3 err\n");
+		return -EINVAL;
+	}
+
+	tve->lumafilter4 = dev_read_u32_default(tve->dev, "rockchip,lumafilter4", 0);
+	if (tve->lumafilter4 == 0) {
+		printf("tve get lumafilter4 err\n");
+		return -EINVAL;
+	}
+
+	tve->lumafilter5 = dev_read_u32_default(tve->dev, "rockchip,lumafilter5", 0);
+	if (tve->lumafilter5 == 0) {
+		printf("tve get lumafilter5 err\n");
+		return -EINVAL;
+	}
+
+	tve->lumafilter6 = dev_read_u32_default(tve->dev, "rockchip,lumafilter6", 0);
+	if (tve->lumafilter6 == 0) {
+		printf("tve get lumafilter6 err\n");
+		return -EINVAL;
+	}
+
+	tve->lumafilter7 = dev_read_u32_default(tve->dev, "rockchip,lumafilter7", 0);
+	if (tve->lumafilter7 == 0) {
+		printf("tve get lumafilter7 err\n");
+		return -EINVAL;
+	}
+
+	tve->upsample_mode = dev_read_u32_default(tve->dev, "rockchip,tve-upsample", -1);
+	if (tve->upsample_mode < 0 || tve->upsample_mode > DCLK_UPSAMPLEx4) {
+		printf("tve get upsample_mode err\n");
+		return -EINVAL;
+	}
+
+	TVEDBG("tve->preferred_mode = 0x%x\n", tve->preferred_mode);
+	TVEDBG("tve->lumafilter0 = 0x%x\n", tve->lumafilter0);
+	TVEDBG("tve->lumafilter1 = 0x%x\n", tve->lumafilter1);
+	TVEDBG("tve->lumafilter2 = 0x%x\n", tve->lumafilter2);
+	TVEDBG("tve->lumafilter3 = 0x%x\n", tve->lumafilter3);
+	TVEDBG("tve->lumafilter4 = 0x%x\n", tve->lumafilter4);
+	TVEDBG("tve->lumafilter5 = 0x%x\n", tve->lumafilter5);
+	TVEDBG("tve->lumafilter6 = 0x%x\n", tve->lumafilter6);
+	TVEDBG("tve->lumafilter7 = 0x%x\n", tve->lumafilter7);
+	TVEDBG("tve->upsample_mode = 0x%x\n", tve->upsample_mode);
+
+	return 0;
+}
+
+static int tve_parse_dt_legacy(struct rockchip_tve *tve)
+{
+	int dac_value, getvdac;
+
+	if (tve->soc_type == SOC_RK312X)
+		tve->test_mode = dev_read_u32_default(tve->dev, "test_mode", 0);
+
+	tve->preferred_mode = dev_read_u32_default(tve->dev, "rockchip,tvemode", -1);
+	if (tve->preferred_mode < 0) {
+		tve->preferred_mode = 0;
+	} else if (tve->preferred_mode > 1) {
+		printf("tve mode value invalid\n");
+		return -EINVAL;
+	}
+
+	tve->saturation = dev_read_u32_default(tve->dev, "rockchip,saturation", 0);
+	if (tve->saturation == 0) {
+		printf("tve get saturation err\n");
+		return -EINVAL;
+	}
+
+	tve->brightcontrast = dev_read_u32_default(tve->dev, "rockchip,brightcontrast", 0);
+	if (tve->brightcontrast == 0) {
+		printf("tve get brightcontrast err\n");
+		return -EINVAL;
+	}
+
+	tve->adjtiming = dev_read_u32_default(tve->dev, "rockchip,adjtiming", 0);
+	if (tve->adjtiming == 0) {
+		printf("tve get adjtiming err\n");
+		return -EINVAL;
+	}
+
+	tve->lumafilter0 = dev_read_u32_default(tve->dev, "rockchip,lumafilter0", 0);
+	if (tve->lumafilter0 == 0) {
+		printf("tve get lumafilter0 err\n");
+		return -EINVAL;
+	}
+
+	tve->lumafilter1 = dev_read_u32_default(tve->dev, "rockchip,lumafilter1", 0);
+	if (tve->lumafilter1 == 0) {
+		printf("tve get lumafilter1 err\n");
+		return -EINVAL;
+	}
+
+	tve->lumafilter2 = dev_read_u32_default(tve->dev, "rockchip,lumafilter2", 0);
+	if (tve->lumafilter2 == 0) {
+		printf("tve get lumafilter2 err\n");
+		return -EINVAL;
+	}
+
+	dac_value = dev_read_u32_default(tve->dev, "rockchip,daclevel", 0);
+	if (dac_value == 0) {
+		printf("tve get dac_value err\n");
+		return -EINVAL;
+	}
+
+	tve->daclevel = dac_value;
+	if (tve->soc_type == SOC_RK322X || tve->soc_type == SOC_RK3328) {
+		getvdac = rk_get_vdac_value();
+		if (getvdac > 0) {
+			tve->daclevel = dac_value + getvdac - RK322X_VDAC_STANDARD;
+			if (tve->daclevel > 0x3f || tve->daclevel < 0) {
+				printf("rk322x daclevel error!\n");
+				tve->daclevel = dac_value;
+			}
+		} else if (getvdac < 0) {
+			printf("get rk322x daclevel error\n");
+			return -EINVAL;
+		}
+	}
+
+	if (tve->soc_type == SOC_RK322X || tve->soc_type == SOC_RK3328) {
+		tve->dac1level = dev_read_u32_default(tve->dev, "rockchip,dac1level", 0);
+		if (tve->dac1level == 0) {
+			printf("rk322x dac1level error!\n");
+			return -EINVAL;
+		}
+	}
+
+	TVEDBG("tve->test_mode = 0x%x\n", tve->test_mode);
+	TVEDBG("tve->saturation = 0x%x\n", tve->saturation);
+	TVEDBG("tve->brightcontrast = 0x%x\n", tve->brightcontrast);
+	TVEDBG("tve->adjtiming = 0x%x\n", tve->adjtiming);
+	TVEDBG("tve->lumafilter0 = 0x%x\n", tve->lumafilter0);
+	TVEDBG("tve->lumafilter1 = 0x%x\n", tve->lumafilter1);
+	TVEDBG("tve->lumafilter2 = 0x%x\n", tve->lumafilter2);
+	TVEDBG("tve->daclevel = 0x%x\n", tve->daclevel);
+
+	return 0;
+}
+
+static int rockchip_drm_tve_init(struct rockchip_connector *conn, struct display_state *state)
+{
+	struct rockchip_tve *tve = dev_get_priv(conn->dev);
+	struct connector_state *conn_state = &state->conn_state;
+	fdt_addr_t addr;
+	int ret;
+
+	conn_state->output_mode = ROCKCHIP_OUT_MODE_P888;
+	conn_state->bus_format = MEDIA_BUS_FMT_YUV8_1X24;
+	if (tve->soc_type == SOC_RK3528)
+		conn_state->output_if |= VOP_OUTPUT_IF_BT656;
+	conn_state->color_space = V4L2_COLORSPACE_SMPTE170M;
+
+	conn_state->disp_info = rockchip_get_disp_info(conn_state->type, 0);
+
+	if (tve->soc_type == SOC_RK3528)
+		ret = tve_parse_dt(tve);
+	else
+		ret = tve_parse_dt_legacy(tve);
+	if (ret) {
+		printf("tve parse dts error\n");
+		return -EINVAL;
+	}
+
+	addr = dev_read_addr_index(conn->dev, 0);
+	if (addr == FDT_ADDR_T_NONE) {
+		printf("failed to get tve reg_base\n");
+		return -EINVAL;
+	}
+	tve->reg_base = (void *)addr;
+
+	if (tve->soc_type == SOC_RK322X || tve->soc_type == SOC_RK3328 ||
+	    tve->soc_type == SOC_RK3528) {
+		addr = dev_read_addr_index(conn->dev, 1);
+		if (addr == FDT_ADDR_T_NONE) {
+			printf("failed to get tve vdac_base\n");
+			return -EINVAL;
+		}
+		tve->vdac_base = (void *)addr;
+	}
+
+	tve->grf = syscon_get_first_range(ROCKCHIP_SYSCON_GRF);
+
+	if (tve->soc_type == SOC_RK322X || tve->soc_type == SOC_RK3328)
+		dac_init(tve);
+
+	return 0;
+}
+
+static int rockchip_drm_tve_enable(struct rockchip_connector *conn, struct display_state *state)
+{
+	struct rockchip_tve *tve = dev_get_priv(conn->dev);
+	struct connector_state *conn_state = &state->conn_state;
+	struct drm_display_mode *mode = &conn_state->mode;
+
+#ifdef CONFIG_ROCKCHIP_INNO_HDMI_PHY
+	/* set inno hdmi phy clk. */
+	if (tve->soc_type != SOC_RK3528)
+		rockchip_phy_set_pll(conn->phy, 27000000);
+#endif
+	if (mode->vdisplay == 576)
+		tve->tv_format = TVOUT_CVBS_PAL;
+	else
+		tve->tv_format = TVOUT_CVBS_NTSC;
+
+	tve_set_mode(tve);
+	mdelay(1000);
+	dac_enable(tve, true);
+
+	return 0;
+}
+
+static void rockchip_drm_tve_deinit(struct rockchip_connector *conn, struct display_state *state)
+{
+	struct rockchip_tve *tve = dev_get_priv(conn->dev);
+
+	dac_enable(tve, false);
+}
+
+static int rockchip_drm_tve_prepare(struct rockchip_connector *conn, struct display_state *state)
+{
+	return 0;
+}
+
+static int rockchip_drm_tve_disable(struct rockchip_connector *conn, struct display_state *state)
+{
+	struct rockchip_tve *tve = dev_get_priv(conn->dev);
+
+	dac_enable(tve, false);
+
+	return 0;
+}
+
+static int rockchip_drm_tve_detect(struct rockchip_connector *conn, struct display_state *state)
+{
+	return 1;
+}
+
+static void tve_select_output(struct rockchip_tve *tve, struct connector_state *conn_state,
+			      struct drm_display_mode *mode)
+{
+	int ret, i, screen_size;
+	struct base_screen_info *screen_info = NULL;
+	struct base2_screen_info *screen_info2 = NULL;
+	struct base_disp_info base_parameter;
+	struct base2_disp_info *base2_parameter = conn_state->disp_info;
+	struct drm_display_mode modes[2];
+	const struct base_overscan *scan;
+	struct overscan *overscan = &conn_state->overscan;
+	char baseparameter_buf[8 * RK_BLK_SIZE] __aligned(ARCH_DMA_MINALIGN);
+	struct blk_desc *dev_desc;
+	disk_partition_t part_info;
+	int max_scan = 100;
+	int min_scan = 50;
+	int offset = 0;
+	bool found = false;
+
+	for (i = 0; i < 2; i++) {
+		modes[i] = tve_modes[i];
+		if (i == tve->preferred_mode)
+			modes[i].type |= DRM_MODE_TYPE_PREFERRED;
+	}
+	*mode = modes[tve->preferred_mode];
+
+	if (!base2_parameter) {
+		dev_desc = rockchip_get_bootdev();
+		if (!dev_desc) {
+			printf("%s: Could not find device\n", __func__);
+			goto null_basep;
+		}
+
+		ret = part_get_info_by_name(dev_desc, "baseparameter",
+					    &part_info);
+		if (ret < 0) {
+			printf("Could not find baseparameter partition\n");
+			goto null_basep;
+		}
+
+read_aux:
+		ret = blk_dread(dev_desc, part_info.start + offset, 1,
+				(void *)baseparameter_buf);
+		if (ret < 0) {
+			printf("read baseparameter failed\n");
+			goto null_basep;
+		}
+
+		memcpy(&base_parameter, baseparameter_buf,
+		       sizeof(base_parameter));
+		scan = &base_parameter.scan;
+
+		screen_size = sizeof(base_parameter.screen_list) /
+			sizeof(base_parameter.screen_list[0]);
+
+		for (i = 0; i < screen_size; i++) {
+			if (base_parameter.screen_list[i].type ==
+			    DRM_MODE_CONNECTOR_TV) {
+				found = true;
+				screen_info = &base_parameter.screen_list[i];
+				break;
+			}
+		}
+
+		if (!found && !offset) {
+			printf("cvbs info isn't saved in main block\n");
+			offset += 16;
+			goto read_aux;
+		}
+	} else {
+		scan = &base2_parameter->overscan_info;
+		screen_size = sizeof(base2_parameter->screen_info) /
+			sizeof(base2_parameter->screen_info[0]);
+
+		for (i = 0; i < screen_size; i++) {
+			if (base2_parameter->screen_info[i].type ==
+			    DRM_MODE_CONNECTOR_TV) {
+				screen_info2 =
+					&base2_parameter->screen_info[i];
+				break;
+			}
+		}
+		screen_info = malloc(sizeof(*screen_info));
+
+		screen_info->type = screen_info2->type;
+		screen_info->mode = screen_info2->resolution;
+		screen_info->format = screen_info2->format;
+		screen_info->depth = screen_info2->depthc;
+		screen_info->feature = screen_info2->feature;
+	}
+
+	if (scan->leftscale < min_scan && scan->leftscale > 0)
+		overscan->left_margin = min_scan;
+	else if (scan->leftscale < max_scan && scan->leftscale > 0)
+		overscan->left_margin = scan->leftscale;
+
+	if (scan->rightscale < min_scan && scan->rightscale > 0)
+		overscan->right_margin = min_scan;
+	else if (scan->rightscale < max_scan && scan->rightscale > 0)
+		overscan->right_margin = scan->rightscale;
+
+	if (scan->topscale < min_scan && scan->topscale > 0)
+		overscan->top_margin = min_scan;
+	else if (scan->topscale < max_scan && scan->topscale > 0)
+		overscan->top_margin = scan->topscale;
+
+	if (scan->bottomscale < min_scan && scan->bottomscale > 0)
+		overscan->bottom_margin = min_scan;
+	else if (scan->bottomscale < max_scan && scan->bottomscale > 0)
+		overscan->bottom_margin = scan->bottomscale;
+
+null_basep:
+
+	if (screen_info)
+		printf("cvbs base_parameter.mode:%dx%d\n",
+		       screen_info->mode.hdisplay,
+		       screen_info->mode.vdisplay);
+
+	if (screen_info &&
+	    (screen_info->mode.hdisplay == 720 &&
+	     screen_info->mode.vdisplay == 576))
+		*mode = modes[0];
+	else if (screen_info &&
+		 (screen_info->mode.hdisplay == 720 &&
+		  screen_info->mode.vdisplay == 480))
+		*mode = modes[1];
+}
+
+static int rockchip_drm_tve_get_timing(struct rockchip_connector *conn, struct display_state *state)
+{
+	struct rockchip_tve *tve = dev_get_priv(conn->dev);
+	struct connector_state *conn_state = &state->conn_state;
+	struct drm_display_mode *mode = &conn_state->mode;
+
+	tve_select_output(tve, conn_state, mode);
+
+	return 0;
+}
+
+const struct rockchip_connector_funcs rockchip_drm_tve_funcs = {
+	.init = rockchip_drm_tve_init,
+	.deinit = rockchip_drm_tve_deinit,
+	.prepare = rockchip_drm_tve_prepare,
+	.enable = rockchip_drm_tve_enable,
+	.disable = rockchip_drm_tve_disable,
+	.get_timing = rockchip_drm_tve_get_timing,
+	.detect = rockchip_drm_tve_detect,
+};
+
+static int rockchip_drm_tve_probe(struct udevice *dev)
+{
+	struct rockchip_tve *tve = dev_get_priv(dev);
+	const struct rockchip_tve_data *data;
+
+	tve->dev = dev;
+	data = (const struct rockchip_tve_data *)dev_get_driver_data(dev);
+	tve->soc_type = data->soc_type;
+	tve->input_format = data->input_format;
+
+	rockchip_connector_bind(&tve->connector, dev, 0, &rockchip_drm_tve_funcs, NULL, DRM_MODE_CONNECTOR_TV);
+
+	return 0;
+}
+
+static const struct rockchip_tve_data rk3036_tve = {
+	.soc_type = SOC_RK3036,
+	.input_format = INPUT_FORMAT_RGB,
+};
+
+static const struct rockchip_tve_data rk312x_tve = {
+	.soc_type = SOC_RK312X,
+	.input_format = INPUT_FORMAT_RGB,
+};
+
+static const struct rockchip_tve_data rk322x_tve = {
+	.soc_type = SOC_RK322X,
+	.input_format = INPUT_FORMAT_YUV,
+};
+
+static const struct rockchip_tve_data rk3328_tve = {
+	.soc_type = SOC_RK3328,
+	.input_format = INPUT_FORMAT_YUV,
+};
+
+static const struct rockchip_tve_data rk3528_tve = {
+	.soc_type = SOC_RK3528,
+	.input_format = INPUT_FORMAT_YUV,
+};
+
+static const struct udevice_id rockchip_drm_tve_ids[] = {
+	{ .compatible = "rockchip,rk3036-tve", .data = (ulong)&rk3036_tve },
+	{ .compatible = "rockchip,rk312x-tve", .data = (ulong)&rk312x_tve },
+	{ .compatible = "rockchip,rk322x-tve", .data = (ulong)&rk322x_tve },
+	{ .compatible = "rockchip,rk3328-tve", .data = (ulong)&rk3328_tve },
+	{ .compatible = "rockchip,rk3528-tve", .data = (ulong)&rk3528_tve },
+};
+
+U_BOOT_DRIVER(rockchip_drm_tve) = {
+	.name = "rockchip_drm_tve",
+	.id = UCLASS_DISPLAY,
+	.of_match = rockchip_drm_tve_ids,
+	.probe	= rockchip_drm_tve_probe,
+	.priv_auto_alloc_size = sizeof(struct rockchip_tve),
+};
diff --git a/drivers/video/drm/rockchip_tve.h b/drivers/video/drm/rockchip_tve.h
new file mode 100644
index 0000000000..5cf5f21cb4
--- /dev/null
+++ b/drivers/video/drm/rockchip_tve.h
@@ -0,0 +1,253 @@
+/*
+ * SPDX-License-Identifier:	GPL-2.0+
+ * (C) Copyright 2008-2015 Fuzhou Rockchip Electronics Co., Ltd
+ */
+#ifndef __ROCKCHIP_TVE_H__
+#define __ROCKCHIP_TVE_H__
+
+#define RK3036_GRF_SOC_CON3	0x0154
+#define RK312X_GRF_TVE_CON	0x0170
+	#define m_EXTREF_EN		BIT(0)
+	#define m_VBG_EN		BIT(1)
+	#define m_DAC_EN		BIT(2)
+	#define m_SENSE_EN		BIT(3)
+	#define m_BIAS_EN		(7 << 4)
+	#define m_DAC_GAIN		(0x3f << 7)
+	#define v_DAC_GAIN(x)		(((x) & 0x3f) << 7)
+
+#define TV_CTRL			(0x00)
+	#define m_CVBS_MODE			BIT(24)
+	#define m_CLK_UPSTREAM_EN		(3 << 18)
+	#define m_TIMING_EN			(3 << 16)
+	#define m_LUMA_FILTER_GAIN		(3 << 9)
+	#define m_LUMA_FILTER_BW		BIT(8)
+	#define m_CSC_PATH			(3 << 1)
+
+	#define v_CVBS_MODE(x)			(((x) & 1) << 24)
+	#define v_CLK_UPSTREAM_EN(x)		(((x) & 3) << 18)
+	#define v_TIMING_EN(x)			(((x) & 3) << 16)
+	#define v_LUMA_FILTER_GAIN(x)		(((x) & 3) << 9)
+	#define v_LUMA_FILTER_UPSAMPLE(x)	(((x) & 1) << 8)
+	#define v_CSC_PATH(x)			(((x) & 3) << 1)
+
+#define TV_SYNC_TIMING		(0x04)
+#define TV_ACT_TIMING		(0x08)
+#define TV_ADJ_TIMING		(0x0c)
+#define TV_FREQ_SC		(0x10)
+#define TV_LUMA_FILTER0		(0x14)
+#define TV_LUMA_FILTER1		(0x18)
+#define TV_LUMA_FILTER2		(0x1C)
+#define TV_ACT_ST		(0x34)
+#define TV_ROUTING		(0x38)
+	#define m_DAC_SENSE_EN		BIT(27)
+	#define m_Y_IRE_7_5		BIT(19)
+	#define m_Y_AGC_PULSE_ON	BIT(15)
+	#define m_Y_VIDEO_ON		BIT(11)
+	#define m_Y_SYNC_ON		BIT(7)
+	#define m_YPP_MODE		BIT(3)
+	#define m_MONO_EN		BIT(2)
+	#define m_PIC_MODE		BIT(1)
+
+	#define v_DAC_SENSE_EN(x)	(((x) & 1) << 27)
+	#define v_Y_IRE_7_5(x)		(((x) & 1) << 19)
+	#define v_Y_AGC_PULSE_ON(x)	(((x) & 1) << 15)
+	#define v_Y_VIDEO_ON(x)		(((x) & 1) << 11)
+	#define v_Y_SYNC_ON(x)		(((x) & 1) << 7)
+	#define v_YPP_MODE(x)		(((x) & 1) << 3)
+	#define v_MONO_EN(x)		(((x) & 1) << 2)
+	#define v_PIC_MODE(x)		(((x) & 1) << 1)
+
+#define TV_SYNC_ADJUST		(0x50)
+#define TV_STATUS		(0x54)
+#define TV_RESET		(0x68)
+	#define m_RESET			BIT(1)
+	#define v_RESET(x)		(((x) & 1) << 1)
+#define TV_SATURATION		(0x78)
+#define TV_BW_CTRL		(0x8C)
+	#define m_CHROMA_BW	(3 << 4)
+	#define m_COLOR_DIFF_BW	(0xf)
+
+	enum {
+		BP_FILTER_PASS = 0,
+		BP_FILTER_NTSC,
+		BP_FILTER_PAL,
+	};
+	enum {
+		COLOR_DIFF_FILTER_OFF = 0,
+		COLOR_DIFF_FILTER_BW_0_6,
+		COLOR_DIFF_FILTER_BW_1_3,
+		COLOR_DIFF_FILTER_BW_2_0
+	};
+
+	#define v_CHROMA_BW(x)		((3 & (x)) << 4)
+	#define v_COLOR_DIFF_BW(x)	(0xF & (x))
+
+#define TV_BRIGHTNESS_CONTRAST	(0x90)
+
+#define VDAC_VDAC0		(0x00)
+	#define m_RST_ANA		BIT(7)
+	#define m_RST_DIG		BIT(6)
+
+	#define v_RST_ANA(x)		(((x) & 1) << 7)
+	#define v_RST_DIG(x)		(((x) & 1) << 6)
+#define VDAC_VDAC1		(0x280)
+	#define m_CUR_REG		(0xf << 4)
+	#define m_DR_PWR_DOWN		BIT(1)
+	#define m_BG_PWR_DOWN		BIT(0)
+
+	#define v_CUR_REG(x)		(((x) & 0xf) << 4)
+	#define v_DR_PWR_DOWN(x)	(((x) & 1) << 1)
+	#define v_BG_PWR_DOWN(x)	(((x) & 1) << 0)
+#define VDAC_VDAC2	(0x284)
+	#define m_CUR_CTR		(0X3f)
+
+	#define v_CUR_CTR(x)		(((x) & 0x3f))
+#define VDAC_VDAC3		(0x288)
+	#define m_CAB_EN		BIT(5)
+	#define m_CAB_REF		BIT(4)
+	#define m_CAB_FLAG		BIT(0)
+
+	#define v_CAB_EN(x)		(((x) & 1) << 5)
+	#define v_CAB_REF(x)		(((x) & 1) << 4)
+	#define v_CAB_FLAG(x)		(((x) & 1) << 0)
+
+// RK3528 CVBS GRF
+#define RK3528_VO_GRF_VDAC_DIS	0x60000
+	#define m_VDAC_DIS_NEGE_ST	BIT(2)
+	#define m_VDAC_DIS_POSE_ST	BIT(1)
+	#define m_STAT_VDAC_DISDET	BIT(0)
+
+	#define v_VDAC_DIS_NEGE_ST(x)	(((x) & 1) << 2)
+	#define v_VDAC_DIS_POSE_ST(x)	(((x) & 1) << 1)
+	#define v_STAT_VDAC_DISDET(x)	(((x) & 1) << 0)
+
+#define RK3528_VO_GRF_CVBS_CON	0x60010
+	#define m_VDAC_DIS_INT_EN	BIT(8)
+	#define m_VDAC_DIS_NEGE_MASK	BIT(7)
+	#define m_VDAC_DIS_POSE_MASK	BIT(6)
+	#define m_TVE_DCLK_POL		BIT(5)
+	#define m_TVE_DCLK_EN		BIT(4)
+	#define m_DCLK_UPSAMPLE_2X4X	BIT(3)
+	#define m_DCLK_UPSAMPLE_EN	BIT(2)
+	#define m_TVE_MODE		BIT(1)
+	#define m_TVE_EN		BIT(0)
+
+	#define v_VDAC_DIS_INT_EN(x)	(((x) & 1) << 8)
+	#define v_VDAC_DIS_NEGE_MASK(x)	(((x) & 1) << 7)
+	#define v_VDAC_DIS_POSE_MASK(x)	(((x) & 1) << 6)
+	#define v_TVE_DCLK_POL(x)	(((x) & 1) << 5)
+	#define v_TVE_DCLK_EN(x)	(((x) & 1) << 4)
+	#define v_DCLK_UPSAMPLE_2X4X(x)	(((x) & 1) << 3)
+	#define v_DCLK_UPSAMPLE_EN(x)	(((x) & 1) << 2)
+	#define v_TVE_MODE(x)		(((x) & 1) << 1)
+	#define v_TVE_EN(x)		(((x) & 1) << 0)
+
+// RK3528 CVBS TVE
+#define BT656_DECODER_CTRL		(0x3D00)
+#define BT656_DECODER_CROP		(0x3D04)
+#define BT656_DECODER_SIZE		(0x3D08)
+#define BT656_DECODER_HTOTAL_HS_END	(0x3D0C)
+#define BT656_DECODER_VACT_ST_HACT_ST	(0x3D10)
+#define BT656_DECODER_VTOTAL_VS_END	(0x3D14)
+#define BT656_DECODER_VS_ST_END_F1	(0x3D18)
+#define BT656_DECODER_DBG_REG		(0x3D1C)
+#define TVE_MODE_CTRL			(0x3E00)
+#define TVE_HOR_TIMING1			(0x3E04)
+#define TVE_HOR_TIMING2			(0x3E08)
+#define TVE_HOR_TIMING3			(0x3E0C)
+#define TVE_SUB_CAR_FRQ			(0x3E10)
+#define TVE_LUMA_FILTER1		(0x3E14)
+#define TVE_LUMA_FILTER2		(0x3E18)
+#define TVE_LUMA_FILTER3		(0x3E1C)
+#define TVE_LUMA_FILTER4		(0x3E20)
+#define TVE_LUMA_FILTER5		(0x3E24)
+#define TVE_LUMA_FILTER6		(0x3E28)
+#define TVE_LUMA_FILTER7		(0x3E2C)
+#define TVE_LUMA_FILTER8		(0x3E30)
+#define TVE_IMAGE_POSITION		(0x3E34)
+#define TVE_ROUTING			(0x3E38)
+#define TVE_SYNC_ADJUST			(0x3E50)
+#define TVE_STATUS			(0x3E54)
+#define TVE_CTRL			(0x3E68)
+#define TVE_INTR_STATUS			(0x3E6C)
+#define TVE_INTR_EN			(0x3E70)
+#define TVE_INTR_CLR			(0x3E74)
+#define TVE_COLOR_BUSRT_SAT		(0x3E78)
+#define TVE_CHROMA_BANDWIDTH		(0x3E8C)
+#define TVE_BRIGHTNESS_CONTRAST		(0x3E90)
+#define TVE_ID				(0x3E98)
+#define TVE_REVISION			(0x3E9C)
+#define TVE_CLAMP			(0x3EA0)
+
+// RK3528 CVBS VDAC
+#define VDAC_CLK_RST			(0x0000)
+	#define m_ANALOG_RST		BIT(7)
+	#define m_DIGITAL_RST		BIT(6)
+	#define m_INPUT_CLK_INV		BIT(0)
+
+	#define v_ANALOG_RST(x)		(((x) & 1) << 7)
+	#define v_DIGITAL_RST(x)	(((x) & 1) << 6)
+	#define v_INPUT_CLK_INV(x)	(((x) & 1) << 0)
+#define VDAC_SINE_CTRL			(0x0004)
+#define VDAC_SQUARE_CTRL		(0x0008)
+#define VDAC_LEVEL_CTRL0		(0x0018)
+#define VDAC_LEVEL_CTRL1		(0x001C)
+#define VDAC_PWM_REF_CTRL		(0x0280)
+	#define m_REF_VOLTAGE		(0xf << 4)
+	#define m_REF_RESISTOR		BIT(3)
+	#define m_SMP_CLK_INV		BIT(2)
+	#define m_DAC_PWN		BIT(1)
+	#define m_BIAS_PWN		BIT(0)
+
+	#define v_REF_VOLTAGE(x)	(((x) & 0xf) << 4)
+	#define v_SMP_CLK_INV(x)	(((x) & 1) << 2)
+	#define v_REF_RESISTOR(x)	(((x) & 1) << 3)
+	#define v_DAC_PWN(x)		(((x) & 1) << 1)
+	#define v_BIAS_PWN(x)		(((x) & 1) << 0)
+#define VDAC_CURRENT_CTRL		(0x0284)
+	#define m_OUT_CURRENT		(0xff << 0)
+
+	#define v_OUT_CURRENT(x)	(((x) & 0xff) << 0)
+#define VDAC_CABLE_CTRL			(0x0288)
+#define VDAC_VOLTAGE_CTRL		(0x028C)
+#define VDAC_BIAS_CLK_CTRL0		(0x0290)
+#define VDAC_BIAS_CLK_CTRL1		(0x0294)
+#define VDAC_AUTO_CLK_CTRL0		(0x0298)
+#define VDAC_AUTO_CLK_CTRL1		(0x029C)
+
+enum {
+	TVOUT_CVBS_NTSC = 0,
+	TVOUT_CVBS_PAL,
+};
+
+enum {
+	INPUT_FORMAT_RGB = 0,
+	INPUT_FORMAT_YUV
+};
+
+enum {
+	SOC_RK3036 = 0,
+	SOC_RK312X,
+	SOC_RK322X,
+	SOC_RK3328,
+	SOC_RK3528
+};
+
+
+enum {
+	DCLK_UPSAMPLEx1 = 0,
+	DCLK_UPSAMPLEx2,
+	DCLK_UPSAMPLEx4
+};
+
+#define RK30_TVE_REGBASE 0x10118000 + 0x200
+#define MAX_TVE_COUNT  2
+
+#ifdef TVEDEBUG
+#define TVEDBG(format, ...) \
+		printf("TVE: " format, ## __VA_ARGS__)
+#else
+#define TVEDBG(format, ...)
+#endif
+
+#endif /* __ROCKCHIP_TVE_H__ */
diff --git a/drivers/video/drm/rockchip_vop.c b/drivers/video/drm/rockchip_vop.c
new file mode 100644
index 0000000000..1d6a1c9d8d
--- /dev/null
+++ b/drivers/video/drm/rockchip_vop.c
@@ -0,0 +1,940 @@
+/*
+ * (C) Copyright 2008-2017 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <config.h>
+#include <common.h>
+#include <errno.h>
+#include <malloc.h>
+#include <fdtdec.h>
+#include <fdt_support.h>
+#include <asm/unaligned.h>
+#include <asm/io.h>
+#include <linux/list.h>
+#include <linux/media-bus-format.h>
+#include <clk.h>
+#include <asm/arch/clock.h>
+#include <linux/err.h>
+#include <dm/device.h>
+#include <dm/read.h>
+#include <syscon.h>
+
+#include "rockchip_display.h"
+#include "rockchip_crtc.h"
+#include "rockchip_connector.h"
+#include "rockchip_vop.h"
+
+static inline int us_to_vertical_line(struct drm_display_mode *mode, int us)
+{
+	return us * mode->clock / mode->htotal / 1000;
+}
+
+static inline void set_vop_mcu_rs(struct vop *vop, int v)
+{
+	if (dm_gpio_is_valid(&vop->mcu_rs_gpio))
+		dm_gpio_set_value(&vop->mcu_rs_gpio, v);
+	else
+		VOP_CTRL_SET(vop, mcu_rs, v);
+}
+
+static int to_vop_csc_mode(int csc_mode)
+{
+	switch (csc_mode) {
+	case V4L2_COLORSPACE_SMPTE170M:
+		return CSC_BT601L;
+	case V4L2_COLORSPACE_REC709:
+	case V4L2_COLORSPACE_DEFAULT:
+		return CSC_BT709L;
+	case V4L2_COLORSPACE_JPEG:
+		return CSC_BT601F;
+	case V4L2_COLORSPACE_BT2020:
+		return CSC_BT2020;
+	default:
+		return CSC_BT709L;
+	}
+}
+
+static bool is_yuv_output(uint32_t bus_format)
+{
+	switch (bus_format) {
+	case MEDIA_BUS_FMT_YUV8_1X24:
+	case MEDIA_BUS_FMT_YUV10_1X30:
+	case MEDIA_BUS_FMT_UYYVYY8_0_5X24:
+	case MEDIA_BUS_FMT_UYYVYY10_0_5X30:
+	case MEDIA_BUS_FMT_YUYV8_2X8:
+	case MEDIA_BUS_FMT_YVYU8_2X8:
+	case MEDIA_BUS_FMT_UYVY8_2X8:
+	case MEDIA_BUS_FMT_VYUY8_2X8:
+	case MEDIA_BUS_FMT_YUYV8_1X16:
+	case MEDIA_BUS_FMT_YVYU8_1X16:
+	case MEDIA_BUS_FMT_UYVY8_1X16:
+	case MEDIA_BUS_FMT_VYUY8_1X16:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static bool is_uv_swap(uint32_t bus_format, uint32_t output_mode)
+{
+	/*
+	 * FIXME:
+	 *
+	 * There is no media type for YUV444 output,
+	 * so when out_mode is AAAA or P888, assume output is YUV444 on
+	 * yuv format.
+	 *
+	 * From H/W testing, YUV444 mode need a rb swap.
+	 */
+	if ((bus_format == MEDIA_BUS_FMT_YUV8_1X24 ||
+	     bus_format == MEDIA_BUS_FMT_YUV10_1X30) &&
+	    (output_mode == ROCKCHIP_OUT_MODE_AAAA ||
+	     output_mode == ROCKCHIP_OUT_MODE_P888))
+		return true;
+	else
+		return false;
+}
+
+static bool is_rb_swap(uint32_t bus_format, uint32_t output_mode)
+{
+	/*
+	 * The default component order of serial rgb3x8 formats
+	 * is BGR. So it is needed to enable RB swap.
+	 */
+	if (bus_format == MEDIA_BUS_FMT_RGB888_3X8 ||
+	    bus_format == MEDIA_BUS_FMT_RGB888_DUMMY_4X8)
+		return true;
+	else
+		return false;
+}
+
+static int rockchip_vop_init_gamma(struct vop *vop, struct display_state *state)
+{
+	struct crtc_state *crtc_state = &state->crtc_state;
+	struct connector_state *conn_state = &state->conn_state;
+	u32 *lut = conn_state->gamma.lut;
+	fdt_size_t lut_size;
+	int i, lut_len;
+	u32 *lut_regs;
+
+	if (!conn_state->gamma.lut)
+		return 0;
+
+	i = dev_read_stringlist_search(crtc_state->dev, "reg-names", "gamma_lut");
+	if (i < 0) {
+		printf("Warning: vop not support gamma\n");
+		return 0;
+	}
+	lut_regs = (u32 *)dev_read_addr_size(crtc_state->dev, &lut_size);
+	if (lut_regs == (u32 *)FDT_ADDR_T_NONE) {
+		printf("failed to get gamma lut register\n");
+		return 0;
+	}
+	lut_len = lut_size / 4;
+	if (lut_len != 256 && lut_len != 1024) {
+		printf("Warning: unsupport gamma lut table[%d]\n", lut_len);
+		return 0;
+	}
+
+	if (conn_state->gamma.size != lut_len) {
+		int size = conn_state->gamma.size;
+		u32 j, r, g, b, color;
+
+		for (i = 0; i < lut_len; i++) {
+			j = i * size / lut_len;
+			r = lut[j] / size / size * lut_len / size;
+			g = lut[j] / size % size * lut_len / size;
+			b = lut[j] % size * lut_len / size;
+			color = r * lut_len * lut_len + g * lut_len + b;
+
+			writel(color, lut_regs + (i << 2));
+		}
+	} else {
+		for (i = 0; i < lut_len; i++)
+			writel(lut[i], lut_regs + (i << 2));
+	}
+
+	VOP_CTRL_SET(vop, dsp_lut_en, 1);
+	VOP_CTRL_SET(vop, update_gamma_lut, 1);
+
+	return 0;
+}
+
+static void vop_post_config(struct display_state *state, struct vop *vop)
+{
+	struct connector_state *conn_state = &state->conn_state;
+	struct drm_display_mode *mode = &conn_state->mode;
+	u16 vtotal = mode->crtc_vtotal;
+	u16 hact_st = mode->crtc_htotal - mode->crtc_hsync_start;
+	u16 vact_st = mode->crtc_vtotal - mode->crtc_vsync_start;
+	u16 hdisplay = mode->crtc_hdisplay;
+	u16 vdisplay = mode->crtc_vdisplay;
+	u16 hsize = hdisplay * (conn_state->overscan.left_margin + conn_state->overscan.right_margin) / 200;
+	u16 vsize = vdisplay * (conn_state->overscan.top_margin + conn_state->overscan.bottom_margin) / 200;
+	u16 hact_end, vact_end;
+	u32 val;
+
+	if (mode->flags & DRM_MODE_FLAG_INTERLACE)
+		vsize = round_down(vsize, 2);
+
+	hact_st += hdisplay * (100 - conn_state->overscan.left_margin) / 200;
+	hact_end = hact_st + hsize;
+	val = hact_st << 16;
+	val |= hact_end;
+
+	VOP_CTRL_SET(vop, hpost_st_end, val);
+	vact_st += vdisplay * (100 - conn_state->overscan.top_margin) / 200;
+	vact_end = vact_st + vsize;
+	val = vact_st << 16;
+	val |= vact_end;
+	VOP_CTRL_SET(vop, vpost_st_end, val);
+	val = scl_cal_scale2(vdisplay, vsize) << 16;
+	val |= scl_cal_scale2(hdisplay, hsize);
+	VOP_CTRL_SET(vop, post_scl_factor, val);
+#define POST_HORIZONTAL_SCALEDOWN_EN(x)		((x) << 0)
+#define POST_VERTICAL_SCALEDOWN_EN(x)		((x) << 1)
+	VOP_CTRL_SET(vop, post_scl_ctrl,
+		     POST_HORIZONTAL_SCALEDOWN_EN(hdisplay != hsize) |
+		     POST_VERTICAL_SCALEDOWN_EN(vdisplay != vsize));
+	if (mode->flags & DRM_MODE_FLAG_INTERLACE) {
+		u16 vact_st_f1 = vtotal + vact_st + 1;
+		u16 vact_end_f1 = vact_st_f1 + vsize;
+
+		val = vact_st_f1 << 16 | vact_end_f1;
+		VOP_CTRL_SET(vop, vpost_st_end_f1, val);
+	}
+}
+
+static void vop_mcu_mode(struct display_state *state, struct vop *vop)
+{
+	struct crtc_state *crtc_state = &state->crtc_state;
+
+	VOP_CTRL_SET(vop, mcu_clk_sel, 1);
+	VOP_CTRL_SET(vop, mcu_type, 1);
+
+	VOP_CTRL_SET(vop, mcu_hold_mode, 1);
+	VOP_CTRL_SET(vop, mcu_pix_total, crtc_state->mcu_timing.mcu_pix_total);
+	VOP_CTRL_SET(vop, mcu_cs_pst, crtc_state->mcu_timing.mcu_cs_pst);
+	VOP_CTRL_SET(vop, mcu_cs_pend, crtc_state->mcu_timing.mcu_cs_pend);
+	VOP_CTRL_SET(vop, mcu_rw_pst, crtc_state->mcu_timing.mcu_rw_pst);
+	VOP_CTRL_SET(vop, mcu_rw_pend, crtc_state->mcu_timing.mcu_rw_pend);
+}
+
+static int rockchip_vop_preinit(struct display_state *state)
+{
+	const struct vop_data *vop_data = state->crtc_state.crtc->data;
+
+	state->crtc_state.max_output = vop_data->max_output;
+
+	return 0;
+}
+
+static int rockchip_vop_init(struct display_state *state)
+{
+	struct crtc_state *crtc_state = &state->crtc_state;
+	struct connector_state *conn_state = &state->conn_state;
+	struct drm_display_mode *mode = &conn_state->mode;
+	const struct rockchip_crtc *crtc = crtc_state->crtc;
+	const struct vop_data *vop_data = crtc->data;
+	struct vop *vop;
+	u16 hsync_len = mode->crtc_hsync_end - mode->crtc_hsync_start;
+	u16 hdisplay = mode->crtc_hdisplay;
+	u16 htotal = mode->crtc_htotal;
+	u16 hact_st = mode->crtc_htotal - mode->crtc_hsync_start;
+	u16 hact_end = hact_st + hdisplay;
+	u16 vdisplay = mode->crtc_vdisplay;
+	u16 vtotal = mode->crtc_vtotal;
+	u16 vsync_len = mode->crtc_vsync_end - mode->crtc_vsync_start;
+	u16 vact_st = mode->crtc_vtotal - mode->crtc_vsync_start;
+	u16 vact_end = vact_st + vdisplay;
+	struct clk dclk;
+	u32 val, act_end;
+	int ret;
+	bool yuv_overlay = false, post_r2y_en = false, post_y2r_en = false;
+	u16 post_csc_mode;
+	bool dclk_inv;
+	char output_type_name[30] = {0};
+
+	vop = malloc(sizeof(*vop));
+	if (!vop)
+		return -ENOMEM;
+	memset(vop, 0, sizeof(*vop));
+
+	crtc_state->private = vop;
+	vop->regs = dev_read_addr_ptr(crtc_state->dev);
+	vop->regsbak = malloc(vop_data->reg_len);
+	vop->win = vop_data->win;
+	vop->win_offset = vop_data->win_offset;
+	vop->ctrl = vop_data->ctrl;
+	vop->grf = syscon_get_first_range(ROCKCHIP_SYSCON_GRF);
+	if (vop->grf <= 0)
+		printf("%s: Get syscon grf failed (ret=%p)\n",
+		      __func__, vop->grf);
+
+	vop->grf_ctrl = vop_data->grf_ctrl;
+	vop->line_flag = vop_data->line_flag;
+	vop->csc_table = vop_data->csc_table;
+	vop->win_csc = vop_data->win_csc;
+	vop->version = vop_data->version;
+
+	printf("VOP:0x%8p update mode to: %dx%d%s%d, type:%s\n",
+	       vop->regs, mode->crtc_hdisplay, mode->vdisplay,
+	       mode->flags & DRM_MODE_FLAG_INTERLACE ? "i" : "p",
+	       mode->vrefresh,
+	       rockchip_get_output_if_name(conn_state->output_if, output_type_name));
+
+	/* Process 'assigned-{clocks/clock-parents/clock-rates}' properties */
+	ret = clk_set_defaults(crtc_state->dev, CLK_DEFAULTS_PRE);
+	if (ret)
+		debug("%s clk_set_defaults failed %d\n", __func__, ret);
+
+	ret = clk_get_by_name(crtc_state->dev, "dclk_vop", &dclk);
+	if (!ret)
+		ret = clk_set_rate(&dclk, mode->crtc_clock * 1000);
+	if (IS_ERR_VALUE(ret)) {
+		printf("%s: Failed to set dclk: ret=%d\n", __func__, ret);
+		return ret;
+	}
+	printf("VOP:0x%8p set crtc_clock to %dKHz\n", vop->regs, mode->crtc_clock);
+
+	memcpy(vop->regsbak, vop->regs, vop_data->reg_len);
+
+	rockchip_vop_init_gamma(vop, state);
+
+	ret = gpio_request_by_name(crtc_state->dev, "mcu-rs-gpios",
+				   0, &vop->mcu_rs_gpio, GPIOD_IS_OUT);
+	if (ret && ret != -ENOENT)
+		printf("%s: Cannot get mcu rs GPIO: %d\n", __func__, ret);
+
+	VOP_CTRL_SET(vop, global_regdone_en, 1);
+	VOP_CTRL_SET(vop, axi_outstanding_max_num, 30);
+	VOP_CTRL_SET(vop, axi_max_outstanding_en, 1);
+	VOP_CTRL_SET(vop, reg_done_frm, 1);
+	VOP_CTRL_SET(vop, win_gate[0], 1);
+	VOP_CTRL_SET(vop, win_gate[1], 1);
+	VOP_CTRL_SET(vop, win_channel[0], 0x12);
+	VOP_CTRL_SET(vop, win_channel[1], 0x34);
+	VOP_CTRL_SET(vop, win_channel[2], 0x56);
+	VOP_CTRL_SET(vop, dsp_blank, 0);
+
+	dclk_inv = (conn_state->bus_flags & DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE) ? 1 : 0;
+	/* For improving signal quality, dclk need to be inverted by default on rv1106. */
+	if ((VOP_MAJOR(vop->version) == 2 && VOP_MINOR(vop->version) == 12))
+		dclk_inv = !dclk_inv;
+	VOP_CTRL_SET(vop, dclk_pol, dclk_inv);
+
+	val = 0x8;
+	val |= (mode->flags & DRM_MODE_FLAG_NHSYNC) ? 0 : 1;
+	val |= (mode->flags & DRM_MODE_FLAG_NVSYNC) ? 0 : (1 << 1);
+	VOP_CTRL_SET(vop, pin_pol, val);
+
+	switch (conn_state->type) {
+	case DRM_MODE_CONNECTOR_LVDS:
+		VOP_CTRL_SET(vop, rgb_en, 1);
+		VOP_CTRL_SET(vop, rgb_pin_pol, val);
+		VOP_CTRL_SET(vop, rgb_dclk_pol, dclk_inv);
+		VOP_CTRL_SET(vop, lvds_en, 1);
+		VOP_CTRL_SET(vop, lvds_pin_pol, val);
+		VOP_CTRL_SET(vop, lvds_dclk_pol, dclk_inv);
+		if (!IS_ERR_OR_NULL(vop->grf))
+			VOP_GRF_SET(vop, grf_dclk_inv, dclk_inv);
+		break;
+	case DRM_MODE_CONNECTOR_eDP:
+		VOP_CTRL_SET(vop, edp_en, 1);
+		VOP_CTRL_SET(vop, edp_pin_pol, val);
+		VOP_CTRL_SET(vop, edp_dclk_pol, dclk_inv);
+		break;
+	case DRM_MODE_CONNECTOR_HDMIA:
+		VOP_CTRL_SET(vop, hdmi_en, 1);
+		VOP_CTRL_SET(vop, hdmi_pin_pol, val);
+		VOP_CTRL_SET(vop, hdmi_dclk_pol, 1);
+		break;
+	case DRM_MODE_CONNECTOR_DSI:
+		VOP_CTRL_SET(vop, mipi_en, 1);
+		VOP_CTRL_SET(vop, mipi_pin_pol, val);
+		VOP_CTRL_SET(vop, mipi_dclk_pol, dclk_inv);
+		VOP_CTRL_SET(vop, mipi_dual_channel_en,
+			!!(conn_state->output_flags & ROCKCHIP_OUTPUT_DUAL_CHANNEL_LEFT_RIGHT_MODE));
+		VOP_CTRL_SET(vop, data01_swap,
+			!!(conn_state->output_flags & ROCKCHIP_OUTPUT_DATA_SWAP) ||
+			crtc_state->dual_channel_swap);
+		break;
+	case DRM_MODE_CONNECTOR_DisplayPort:
+		VOP_CTRL_SET(vop, dp_dclk_pol, 0);
+		VOP_CTRL_SET(vop, dp_pin_pol, val);
+		VOP_CTRL_SET(vop, dp_en, 1);
+		break;
+	case DRM_MODE_CONNECTOR_TV:
+		if (vdisplay == CVBS_PAL_VDISPLAY)
+			VOP_CTRL_SET(vop, tve_sw_mode, 1);
+		else
+			VOP_CTRL_SET(vop, tve_sw_mode, 0);
+		VOP_CTRL_SET(vop, tve_dclk_pol, 1);
+		VOP_CTRL_SET(vop, tve_dclk_en, 1);
+		/* use the same pol reg with hdmi */
+		VOP_CTRL_SET(vop, hdmi_pin_pol, val);
+		VOP_CTRL_SET(vop, sw_genlock, 1);
+		VOP_CTRL_SET(vop, sw_uv_offset_en, 1);
+		VOP_CTRL_SET(vop, dither_up, 1);
+		break;
+	default:
+		printf("unsupport connector_type[%d]\n", conn_state->type);
+	}
+
+	if (conn_state->output_mode == ROCKCHIP_OUT_MODE_AAAA &&
+	    !(vop_data->feature & VOP_FEATURE_OUTPUT_10BIT))
+		conn_state->output_mode = ROCKCHIP_OUT_MODE_P888;
+
+	switch (conn_state->bus_format) {
+	case MEDIA_BUS_FMT_RGB565_1X16:
+		val = DITHER_DOWN_EN(1) | DITHER_DOWN_MODE(RGB888_TO_RGB565);
+		break;
+	case MEDIA_BUS_FMT_RGB666_1X18:
+	case MEDIA_BUS_FMT_RGB666_1X24_CPADHI:
+	case MEDIA_BUS_FMT_RGB666_1X7X3_SPWG:
+	case MEDIA_BUS_FMT_RGB666_1X7X3_JEIDA:
+		val = DITHER_DOWN_EN(1) | DITHER_DOWN_MODE(RGB888_TO_RGB666);
+		break;
+	case MEDIA_BUS_FMT_YUV8_1X24:
+	case MEDIA_BUS_FMT_UYYVYY8_0_5X24:
+		val = DITHER_DOWN_EN(0) | PRE_DITHER_DOWN_EN(1);
+		break;
+	case MEDIA_BUS_FMT_YUV10_1X30:
+	case MEDIA_BUS_FMT_UYYVYY10_0_5X30:
+		val = DITHER_DOWN_EN(0) | PRE_DITHER_DOWN_EN(0);
+		break;
+	case MEDIA_BUS_FMT_RGB888_1X24:
+	case MEDIA_BUS_FMT_RGB888_1X7X4_SPWG:
+	case MEDIA_BUS_FMT_RGB888_1X7X4_JEIDA:
+	default:
+		val = DITHER_DOWN_EN(0) | PRE_DITHER_DOWN_EN(0);
+		break;
+	}
+	if (conn_state->output_mode == ROCKCHIP_OUT_MODE_AAAA)
+		val |= PRE_DITHER_DOWN_EN(0);
+	else
+		val |= PRE_DITHER_DOWN_EN(1);
+	val |= DITHER_DOWN_MODE_SEL(DITHER_DOWN_ALLEGRO);
+	VOP_CTRL_SET(vop, dither_down, val);
+
+	VOP_CTRL_SET(vop, dclk_ddr,
+		     conn_state->output_mode == ROCKCHIP_OUT_MODE_YUV420 ? 1 : 0);
+	VOP_CTRL_SET(vop, hdmi_dclk_out_en,
+		     conn_state->output_mode == ROCKCHIP_OUT_MODE_YUV420 ? 1 : 0);
+
+	if (is_uv_swap(conn_state->bus_format, conn_state->output_mode) ||
+	    is_rb_swap(conn_state->bus_format, conn_state->output_mode))
+		VOP_CTRL_SET(vop, dsp_rb_swap, 1);
+	else
+		VOP_CTRL_SET(vop, dsp_data_swap, 0);
+
+	VOP_CTRL_SET(vop, out_mode, conn_state->output_mode);
+
+	if (VOP_CTRL_SUPPORT(vop, overlay_mode)) {
+		yuv_overlay = is_yuv_output(conn_state->bus_format);
+		VOP_CTRL_SET(vop, overlay_mode, yuv_overlay);
+	}
+	/*
+	 * todo: r2y for win csc
+	 */
+	VOP_CTRL_SET(vop, dsp_out_yuv, is_yuv_output(conn_state->bus_format));
+
+	if (yuv_overlay) {
+		if (!is_yuv_output(conn_state->bus_format))
+			post_y2r_en = true;
+	} else {
+		if (is_yuv_output(conn_state->bus_format))
+			post_r2y_en = true;
+	}
+
+	crtc_state->yuv_overlay = yuv_overlay;
+	post_csc_mode = to_vop_csc_mode(conn_state->color_space);
+	VOP_CTRL_SET(vop, bcsh_r2y_en, post_r2y_en);
+	VOP_CTRL_SET(vop, bcsh_y2r_en, post_y2r_en);
+	VOP_CTRL_SET(vop, bcsh_r2y_csc_mode, post_csc_mode);
+	VOP_CTRL_SET(vop, bcsh_y2r_csc_mode, post_csc_mode);
+
+	/*
+	 * Background color is 10bit depth if vop version >= 3.5
+	 */
+	if (!is_yuv_output(conn_state->bus_format))
+		val = 0;
+	else if (VOP_MAJOR(vop->version) == 3 &&
+		 VOP_MINOR(vop->version) >= 5)
+		val = 0x20010200;
+	else
+		val = 0x801080;
+	VOP_CTRL_SET(vop, dsp_background, val);
+
+	VOP_CTRL_SET(vop, htotal_pw, (htotal << 16) | hsync_len);
+	val = hact_st << 16;
+	val |= hact_end;
+	VOP_CTRL_SET(vop, hact_st_end, val);
+	val = vact_st << 16;
+	val |= vact_end;
+	VOP_CTRL_SET(vop, vact_st_end, val);
+	if (mode->flags & DRM_MODE_FLAG_INTERLACE) {
+		u16 vact_st_f1 = vtotal + vact_st + 1;
+		u16 vact_end_f1 = vact_st_f1 + vdisplay;
+
+		val = vact_st_f1 << 16 | vact_end_f1;
+		VOP_CTRL_SET(vop, vact_st_end_f1, val);
+
+		val = vtotal << 16 | (vtotal + vsync_len);
+		VOP_CTRL_SET(vop, vs_st_end_f1, val);
+		VOP_CTRL_SET(vop, dsp_interlace, 1);
+		VOP_CTRL_SET(vop, p2i_en, 1);
+		vtotal += vtotal + 1;
+		act_end = vact_end_f1;
+	} else {
+		VOP_CTRL_SET(vop, dsp_interlace, 0);
+		VOP_CTRL_SET(vop, p2i_en, 0);
+		act_end = vact_end;
+	}
+	VOP_CTRL_SET(vop, vtotal_pw, (vtotal << 16) | vsync_len);
+	vop_post_config(state, vop);
+	VOP_CTRL_SET(vop, core_dclk_div,
+		     !!(mode->flags & DRM_MODE_FLAG_DBLCLK));
+
+	VOP_LINE_FLAG_SET(vop, line_flag_num[0], act_end - 3);
+	VOP_LINE_FLAG_SET(vop, line_flag_num[1],
+			  act_end - us_to_vertical_line(mode, 1000));
+	if (state->crtc_state.mcu_timing.mcu_pix_total > 0)
+		vop_mcu_mode(state, vop);
+	vop_cfg_done(vop);
+
+	return 0;
+}
+
+static uint16_t scl_vop_cal_scale(enum scale_mode mode, uint32_t src,
+				  uint32_t dst, bool is_horizontal,
+				  int vsu_mode, int *vskiplines)
+{
+	uint16_t val = 1 << SCL_FT_DEFAULT_FIXPOINT_SHIFT;
+
+	if (is_horizontal) {
+		if (mode == SCALE_UP)
+			val = GET_SCL_FT_BIC(src, dst);
+		else if (mode == SCALE_DOWN)
+			val = GET_SCL_FT_BILI_DN(src, dst);
+	} else {
+		if (mode == SCALE_UP) {
+			if (vsu_mode == SCALE_UP_BIL)
+				val = GET_SCL_FT_BILI_UP(src, dst);
+			else
+				val = GET_SCL_FT_BIC(src, dst);
+		} else if (mode == SCALE_DOWN) {
+			if (vskiplines) {
+				*vskiplines = scl_get_vskiplines(src, dst);
+				val = scl_get_bili_dn_vskip(src, dst,
+							    *vskiplines);
+			} else {
+				val = GET_SCL_FT_BILI_DN(src, dst);
+			}
+		}
+	}
+
+	return val;
+}
+
+static void scl_vop_cal_scl_fac(struct vop *vop,
+				uint32_t src_w, uint32_t src_h, uint32_t dst_w,
+				uint32_t dst_h, uint32_t pixel_format)
+{
+	uint16_t yrgb_hor_scl_mode, yrgb_ver_scl_mode;
+	uint16_t cbcr_hor_scl_mode = SCALE_NONE;
+	uint16_t cbcr_ver_scl_mode = SCALE_NONE;
+	int hsub = drm_format_horz_chroma_subsampling(pixel_format);
+	int vsub = drm_format_vert_chroma_subsampling(pixel_format);
+	bool is_yuv = false;
+	uint16_t cbcr_src_w = src_w / hsub;
+	uint16_t cbcr_src_h = src_h / vsub;
+	uint16_t vsu_mode;
+	uint16_t lb_mode;
+	uint32_t val;
+	int vskiplines = 0;
+
+	if (!vop->win->scl)
+		return;
+
+	if (!vop->win->scl->ext) {
+		VOP_SCL_SET(vop, scale_yrgb_x,
+			    scl_cal_scale2(src_w, dst_w));
+		VOP_SCL_SET(vop, scale_yrgb_y,
+			    scl_cal_scale2(src_h, dst_h));
+		if (is_yuv) {
+			VOP_SCL_SET(vop, scale_cbcr_x,
+				    scl_cal_scale2(src_w, dst_w));
+			VOP_SCL_SET(vop, scale_cbcr_y,
+				    scl_cal_scale2(src_h, dst_h));
+		}
+		return;
+	}
+
+	yrgb_hor_scl_mode = scl_get_scl_mode(src_w, dst_w);
+	yrgb_ver_scl_mode = scl_get_scl_mode(src_h, dst_h);
+
+	if (is_yuv) {
+		cbcr_hor_scl_mode = scl_get_scl_mode(cbcr_src_w, dst_w);
+		cbcr_ver_scl_mode = scl_get_scl_mode(cbcr_src_h, dst_h);
+		if (cbcr_hor_scl_mode == SCALE_DOWN)
+			lb_mode = scl_vop_cal_lb_mode(dst_w, true);
+		else
+			lb_mode = scl_vop_cal_lb_mode(cbcr_src_w, true);
+	} else {
+		if (yrgb_hor_scl_mode == SCALE_DOWN)
+			lb_mode = scl_vop_cal_lb_mode(dst_w, false);
+		else
+			lb_mode = scl_vop_cal_lb_mode(src_w, false);
+	}
+
+	VOP_SCL_SET_EXT(vop, lb_mode, lb_mode);
+	if (lb_mode == LB_RGB_3840X2) {
+		if (yrgb_ver_scl_mode != SCALE_NONE) {
+			printf("ERROR : not allow yrgb ver scale\n");
+			return;
+		}
+		if (cbcr_ver_scl_mode != SCALE_NONE) {
+			printf("ERROR : not allow cbcr ver scale\n");
+			return;
+		}
+		vsu_mode = SCALE_UP_BIL;
+	} else if (lb_mode == LB_RGB_2560X4) {
+		vsu_mode = SCALE_UP_BIL;
+	} else {
+		vsu_mode = SCALE_UP_BIC;
+	}
+
+	val = scl_vop_cal_scale(yrgb_hor_scl_mode, src_w, dst_w,
+				true, 0, NULL);
+	VOP_SCL_SET(vop, scale_yrgb_x, val);
+	val = scl_vop_cal_scale(yrgb_ver_scl_mode, src_h, dst_h,
+				false, vsu_mode, &vskiplines);
+	VOP_SCL_SET(vop, scale_yrgb_y, val);
+
+	VOP_SCL_SET_EXT(vop, vsd_yrgb_gt4, vskiplines == 4);
+	VOP_SCL_SET_EXT(vop, vsd_yrgb_gt2, vskiplines == 2);
+
+	VOP_SCL_SET_EXT(vop, yrgb_hor_scl_mode, yrgb_hor_scl_mode);
+	VOP_SCL_SET_EXT(vop, yrgb_ver_scl_mode, yrgb_ver_scl_mode);
+	VOP_SCL_SET_EXT(vop, yrgb_hsd_mode, SCALE_DOWN_BIL);
+	VOP_SCL_SET_EXT(vop, yrgb_vsd_mode, SCALE_DOWN_BIL);
+	VOP_SCL_SET_EXT(vop, yrgb_vsu_mode, vsu_mode);
+	if (is_yuv) {
+		val = scl_vop_cal_scale(cbcr_hor_scl_mode, cbcr_src_w,
+					dst_w, true, 0, NULL);
+		VOP_SCL_SET(vop, scale_cbcr_x, val);
+		val = scl_vop_cal_scale(cbcr_ver_scl_mode, cbcr_src_h,
+					dst_h, false, vsu_mode, &vskiplines);
+		VOP_SCL_SET(vop, scale_cbcr_y, val);
+
+		VOP_SCL_SET_EXT(vop, vsd_cbcr_gt4, vskiplines == 4);
+		VOP_SCL_SET_EXT(vop, vsd_cbcr_gt2, vskiplines == 2);
+		VOP_SCL_SET_EXT(vop, cbcr_hor_scl_mode, cbcr_hor_scl_mode);
+		VOP_SCL_SET_EXT(vop, cbcr_ver_scl_mode, cbcr_ver_scl_mode);
+		VOP_SCL_SET_EXT(vop, cbcr_hsd_mode, SCALE_DOWN_BIL);
+		VOP_SCL_SET_EXT(vop, cbcr_vsd_mode, SCALE_DOWN_BIL);
+		VOP_SCL_SET_EXT(vop, cbcr_vsu_mode, vsu_mode);
+	}
+}
+
+static void vop_load_csc_table(struct vop *vop, u32 offset, const u32 *table)
+{
+	int i;
+
+	/*
+	 * so far the csc offset is not 0 and in the feature the csc offset
+	 * impossible be 0, so when the offset is 0, should return here.
+	 */
+	if (!table || offset == 0)
+		return;
+
+	for (i = 0; i < 8; i++)
+		vop_writel(vop, offset + i * 4, table[i]);
+}
+
+static int rockchip_vop_setup_csc_table(struct display_state *state)
+{
+	struct crtc_state *crtc_state = &state->crtc_state;
+	struct connector_state *conn_state = &state->conn_state;
+	struct vop *vop = crtc_state->private;
+	const uint32_t *csc_table = NULL;
+
+	if (!vop->csc_table || !crtc_state->yuv_overlay)
+		return 0;
+	/* todo: only implement r2y*/
+	switch (conn_state->color_space) {
+	case V4L2_COLORSPACE_SMPTE170M:
+		csc_table = vop->csc_table->r2y_bt601_12_235;
+		break;
+	case V4L2_COLORSPACE_REC709:
+	case V4L2_COLORSPACE_DEFAULT:
+	case V4L2_COLORSPACE_JPEG:
+		csc_table = vop->csc_table->r2y_bt709;
+		break;
+	case V4L2_COLORSPACE_BT2020:
+		csc_table = vop->csc_table->r2y_bt2020;
+		break;
+	default:
+		csc_table = vop->csc_table->r2y_bt601;
+		break;
+	}
+
+	vop_load_csc_table(vop, vop->win_csc->r2y_offset, csc_table);
+	VOP_WIN_CSC_SET(vop, r2y_en, 1);
+
+	return 0;
+}
+
+static int rockchip_vop_set_plane(struct display_state *state)
+{
+	struct crtc_state *crtc_state = &state->crtc_state;
+	const struct rockchip_crtc *crtc = crtc_state->crtc;
+	const struct vop_data *vop_data = crtc->data;
+	struct connector_state *conn_state = &state->conn_state;
+	struct drm_display_mode *mode = &conn_state->mode;
+	u32 act_info, dsp_info, dsp_st, dsp_stx, dsp_sty;
+	struct vop *vop = crtc_state->private;
+	int src_w = crtc_state->src_rect.w;
+	int src_h = crtc_state->src_rect.h;
+	int crtc_x = crtc_state->crtc_rect.x;
+	int crtc_y = crtc_state->crtc_rect.y;
+	int crtc_w = crtc_state->crtc_rect.w;
+	int crtc_h = crtc_state->crtc_rect.h;
+	int xvir = crtc_state->xvir;
+	int x_mirror = 0, y_mirror = 0;
+
+	if (crtc_w > crtc_state->max_output.width) {
+		printf("ERROR: output w[%d] exceeded max width[%d]\n",
+		       crtc_w, crtc_state->max_output.width);
+		return -EINVAL;
+	}
+
+	act_info = (src_h - 1) << 16;
+	act_info |= (src_w - 1) & 0xffff;
+
+	dsp_info = (crtc_h - 1) << 16;
+	dsp_info |= (crtc_w - 1) & 0xffff;
+
+	dsp_stx = crtc_x + mode->crtc_htotal - mode->crtc_hsync_start;
+	dsp_sty = crtc_y + mode->crtc_vtotal - mode->crtc_vsync_start;
+	dsp_st = dsp_sty << 16 | (dsp_stx & 0xffff);
+	/*
+	 * vop full need to treats rgb888 as bgr888 so we reverse the rb swap to workaround
+	 */
+	if (crtc_state->format == ROCKCHIP_FMT_RGB888 && VOP_MAJOR(vop_data->version) == 3)
+		crtc_state->rb_swap = !crtc_state->rb_swap;
+
+	if (mode->flags & DRM_MODE_FLAG_YMIRROR)
+		y_mirror = 1;
+	else
+		y_mirror = 0;
+	if (mode->flags & DRM_MODE_FLAG_XMIRROR)
+		x_mirror = 1;
+	else
+		x_mirror = 0;
+	if (crtc_state->ymirror ^ y_mirror)
+		y_mirror = 1;
+	else
+		y_mirror = 0;
+	if (y_mirror) {
+		if (VOP_CTRL_SUPPORT(vop, ymirror))
+			crtc_state->dma_addr += (src_h - 1) * xvir * 4;
+		else
+			y_mirror = 0;
+		}
+	VOP_CTRL_SET(vop, ymirror, y_mirror);
+	VOP_CTRL_SET(vop, xmirror, x_mirror);
+
+	VOP_WIN_SET(vop, format, crtc_state->format);
+	VOP_WIN_SET(vop, yrgb_vir, xvir);
+	VOP_WIN_SET(vop, yrgb_mst, crtc_state->dma_addr);
+
+	scl_vop_cal_scl_fac(vop, src_w, src_h, crtc_w, crtc_h,
+			    crtc_state->format);
+
+	VOP_WIN_SET(vop, act_info, act_info);
+	VOP_WIN_SET(vop, dsp_info, dsp_info);
+	VOP_WIN_SET(vop, dsp_st, dsp_st);
+	VOP_WIN_SET(vop, rb_swap, crtc_state->rb_swap);
+
+	VOP_WIN_SET(vop, src_alpha_ctl, 0);
+
+	rockchip_vop_setup_csc_table(state);
+	VOP_WIN_SET(vop, enable, 1);
+	VOP_WIN_SET(vop, gate, 1);
+	vop_cfg_done(vop);
+
+	return 0;
+}
+
+static int rockchip_vop_prepare(struct display_state *state)
+{
+	return 0;
+}
+
+static int rockchip_vop_enable(struct display_state *state)
+{
+	struct crtc_state *crtc_state = &state->crtc_state;
+	struct vop *vop = crtc_state->private;
+
+	VOP_CTRL_SET(vop, standby, 0);
+	vop_cfg_done(vop);
+	if (crtc_state->mcu_timing.mcu_pix_total > 0)
+		VOP_CTRL_SET(vop, mcu_hold_mode, 0);
+
+	return 0;
+}
+
+static int rockchip_vop_disable(struct display_state *state)
+{
+	struct crtc_state *crtc_state = &state->crtc_state;
+	struct vop *vop = crtc_state->private;
+
+	VOP_CTRL_SET(vop, standby, 1);
+	vop_cfg_done(vop);
+	return 0;
+}
+
+static int rockchip_vop_fixup_dts(struct display_state *state, void *blob)
+{
+#if 0
+	struct crtc_state *crtc_state = &state->crtc_state;
+	struct panel_state *pstate = &state->panel_state;
+	uint32_t phandle;
+	char path[100];
+	int ret, dsp_lut_node;
+
+	if (!ofnode_valid(pstate->dsp_lut_node))
+		return 0;
+	ret = fdt_get_path(state->blob, pstate->dsp_lut_node, path, sizeof(path));
+	if (ret < 0) {
+		printf("failed to get dsp_lut path[%s], ret=%d\n",
+			path, ret);
+		return ret;
+	}
+
+	dsp_lut_node = fdt_path_offset(blob, path);
+	phandle = fdt_get_phandle(blob, dsp_lut_node);
+	if (!phandle) {
+		phandle = fdt_alloc_phandle(blob);
+		if (!phandle) {
+			printf("failed to alloc phandle\n");
+			return -ENOMEM;
+		}
+
+		fdt_set_phandle(blob, dsp_lut_node, phandle);
+	}
+
+	ret = fdt_get_path(state->blob, crtc_state->node, path, sizeof(path));
+	if (ret < 0) {
+		printf("failed to get route path[%s], ret=%d\n",
+			path, ret);
+		return ret;
+	}
+
+	do_fixup_by_path_u32(blob, path, "dsp-lut", phandle, 1);
+#endif
+	return 0;
+}
+
+static int rockchip_vop_send_mcu_cmd(struct display_state *state,
+				     u32 type, u32 value)
+{
+	struct crtc_state *crtc_state = &state->crtc_state;
+	struct vop *vop = crtc_state->private;
+
+	if (vop) {
+		switch (type) {
+		case MCU_WRCMD:
+			set_vop_mcu_rs(vop, 0);
+			VOP_CTRL_SET(vop, mcu_rw_bypass_port, value);
+			set_vop_mcu_rs(vop, 1);
+			break;
+		case MCU_WRDATA:
+			set_vop_mcu_rs(vop, 1);
+			VOP_CTRL_SET(vop, mcu_rw_bypass_port, value);
+			break;
+		case MCU_SETBYPASS:
+			VOP_CTRL_SET(vop, mcu_bypass, value ? 1 : 0);
+			break;
+		default:
+			break;
+		}
+	}
+
+	return 0;
+}
+
+static int rockchip_vop_mode_valid(struct display_state *state)
+{
+	struct connector_state *conn_state = &state->conn_state;
+	struct drm_display_mode *mode = &conn_state->mode;
+	struct videomode vm;
+
+	drm_display_mode_to_videomode(mode, &vm);
+
+	if (vm.hactive < 32 || vm.vactive < 32 ||
+	    (vm.hfront_porch * vm.hsync_len * vm.hback_porch *
+	     vm.vfront_porch * vm.vsync_len * vm.vback_porch == 0)) {
+		printf("ERROR: unsupported display timing\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int rockchip_vop_plane_check(struct display_state *state)
+{
+	struct crtc_state *crtc_state = &state->crtc_state;
+	const struct rockchip_crtc *crtc = crtc_state->crtc;
+	const struct vop_data *vop_data = crtc->data;
+	const struct vop_win *win = vop_data->win;
+	struct display_rect *src = &crtc_state->src_rect;
+	struct display_rect *dst = &crtc_state->crtc_rect;
+	int min_scale, max_scale;
+	int hscale, vscale;
+
+	min_scale = win->scl ? FRAC_16_16(1, 8) : VOP_PLANE_NO_SCALING;
+	max_scale = win->scl ? FRAC_16_16(8, 1) : VOP_PLANE_NO_SCALING;
+
+	hscale = display_rect_calc_hscale(src, dst, min_scale, max_scale);
+	vscale = display_rect_calc_vscale(src, dst, min_scale, max_scale);
+	if (hscale < 0 || vscale < 0) {
+		printf("ERROR: scale factor is out of range\n");
+		return -ERANGE;
+	}
+
+	return 0;
+}
+
+static int rockchip_vop_mode_fixup(struct display_state *state)
+{
+	struct crtc_state *crtc_state = &state->crtc_state;
+	struct connector_state *conn_state = &state->conn_state;
+	struct drm_display_mode *mode = &conn_state->mode;
+
+	drm_mode_set_crtcinfo(mode, CRTC_INTERLACE_HALVE_V | CRTC_STEREO_DOUBLE);
+
+	mode->crtc_clock *= rockchip_drm_get_cycles_per_pixel(conn_state->bus_format);
+	if (crtc_state->mcu_timing.mcu_pix_total)
+		mode->crtc_clock *= crtc_state->mcu_timing.mcu_pix_total + 1;
+
+	return 0;
+}
+
+const struct rockchip_crtc_funcs rockchip_vop_funcs = {
+	.preinit = rockchip_vop_preinit,
+	.init = rockchip_vop_init,
+	.set_plane = rockchip_vop_set_plane,
+	.prepare = rockchip_vop_prepare,
+	.enable = rockchip_vop_enable,
+	.disable = rockchip_vop_disable,
+	.fixup_dts = rockchip_vop_fixup_dts,
+	.send_mcu_cmd = rockchip_vop_send_mcu_cmd,
+	.mode_valid = rockchip_vop_mode_valid,
+	.plane_check = rockchip_vop_plane_check,
+	.mode_fixup = rockchip_vop_mode_fixup,
+};
diff --git a/drivers/video/drm/rockchip_vop.h b/drivers/video/drm/rockchip_vop.h
new file mode 100644
index 0000000000..aa2209d4d8
--- /dev/null
+++ b/drivers/video/drm/rockchip_vop.h
@@ -0,0 +1,569 @@
+/*
+ * (C) Copyright 2008-2017 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _ROCKCHIP_VOP_H_
+#define _ROCKCHIP_VOP_H_
+#include "rockchip_display.h"
+#include <asm/gpio.h>
+
+
+#define VOP_REG_SUPPORT(vop, reg) \
+		(reg.mask && \
+		 (!reg.major || \
+		  (reg.major == VOP_MAJOR(vop->version) && \
+		   reg.begin_minor <= VOP_MINOR(vop->version) && \
+		   reg.end_minor >= VOP_MINOR(vop->version))))
+
+#define VOP_WIN_SUPPORT(vop, win, name) \
+		VOP_REG_SUPPORT(vop, win->name)
+
+#define VOP_CTRL_SUPPORT(vop, name) \
+		VOP_REG_SUPPORT(vop, vop->ctrl->name)
+
+#define __REG_SET(x, off, mask, shift, v, write_mask) \
+		vop_mask_write(x, off, mask, shift, v, write_mask)
+
+#define _REG_SET(vop, name, off, reg, mask, v) \
+	do { \
+		if (VOP_REG_SUPPORT(vop, reg)) \
+			__REG_SET(vop, off + reg.offset, mask, reg.shift, \
+				  v, reg.write_mask); \
+		else \
+			debug("Warning: not support "#name"\n"); \
+	} while(0)
+
+#define REG_SET(x, name, off, reg, v) \
+		_REG_SET(x, name, off, reg, reg.mask, v)
+#define REG_SET_MASK(x, name, off, reg, mask, v, relaxed) \
+		_REG_SET(x, name, off, reg, reg.mask & mask, v)
+
+#define VOP_WIN_SET(x, name, v) \
+		REG_SET(x, name, x->win_offset, x->win->name, v)
+#define VOP_WIN_SET_EXT(x, ext, name, v) \
+		REG_SET(x, name, x->win_offset, x->win->ext->name, v)
+#define VOP_SCL_SET(x, name, v) \
+		REG_SET(x, name, x->win_offset, x->win->scl->name, v)
+#define VOP_SCL_SET_EXT(x, name, v) \
+		REG_SET(x, name, x->win_offset, x->win->scl->ext->name, v)
+
+#define VOP_CTRL_SET(x, name, v) \
+		REG_SET(x, name, 0, (x)->ctrl->name, v)
+#define VOP_LINE_FLAG_SET(x, name, v) \
+		REG_SET(x, name, 0, (x)->line_flag->name, v)
+#define VOP_WIN_CSC_SET(x, name, v) \
+		REG_SET(x, name, 0, (x)->win_csc->name, v)
+
+#define VOP_CTRL_GET(x, name) \
+		vop_read_reg(x, 0, &vop->ctrl->name)
+
+#define VOP_WIN_GET(x, name) \
+		vop_read_reg(x, vop->win->offset, &vop->win->name)
+
+#define VOP_GRF_SET(vop, name, v) \
+	do { \
+		if (vop->grf_ctrl) { \
+			vop_grf_writel(vop, vop->grf_ctrl->name, v); \
+		} \
+	} while (0)
+
+#define CVBS_PAL_VDISPLAY              288
+
+enum alpha_mode {
+	ALPHA_STRAIGHT,
+	ALPHA_INVERSE,
+};
+
+enum global_blend_mode {
+	ALPHA_GLOBAL,
+	ALPHA_PER_PIX,
+	ALPHA_PER_PIX_GLOBAL,
+};
+
+enum alpha_cal_mode {
+	ALPHA_SATURATION,
+	ALPHA_NO_SATURATION,
+};
+
+enum color_mode {
+	ALPHA_SRC_PRE_MUL,
+	ALPHA_SRC_NO_PRE_MUL,
+};
+
+enum factor_mode {
+	ALPHA_ZERO,
+	ALPHA_ONE,
+	ALPHA_SRC,
+	ALPHA_SRC_INVERSE,
+	ALPHA_SRC_GLOBAL,
+};
+
+enum scale_mode {
+	SCALE_NONE = 0x0,
+	SCALE_UP   = 0x1,
+	SCALE_DOWN = 0x2
+};
+
+enum lb_mode {
+	LB_YUV_3840X5 = 0x0,
+	LB_YUV_2560X8 = 0x1,
+	LB_RGB_3840X2 = 0x2,
+	LB_RGB_2560X4 = 0x3,
+	LB_RGB_1920X5 = 0x4,
+	LB_RGB_1280X8 = 0x5
+};
+
+enum sacle_up_mode {
+	SCALE_UP_BIL = 0x0,
+	SCALE_UP_BIC = 0x1
+};
+
+enum scale_down_mode {
+	SCALE_DOWN_BIL = 0x0,
+	SCALE_DOWN_AVG = 0x1
+};
+
+enum dither_down_mode {
+	RGB888_TO_RGB565 = 0x0,
+	RGB888_TO_RGB666 = 0x1
+};
+
+enum dither_down_mode_sel {
+	DITHER_DOWN_ALLEGRO = 0x0,
+	DITHER_DOWN_FRC = 0x1
+};
+
+enum vop_csc_format {
+	CSC_BT601L,
+	CSC_BT709L,
+	CSC_BT601F,
+	CSC_BT2020,
+};
+
+#define DSP_BG_SWAP		0x1
+#define DSP_RB_SWAP		0x2
+#define DSP_RG_SWAP		0x4
+#define DSP_DELTA_SWAP		0x8
+
+#define PRE_DITHER_DOWN_EN(x)	((x) << 0)
+#define DITHER_DOWN_EN(x)	((x) << 1)
+#define DITHER_DOWN_MODE(x)	((x) << 2)
+#define DITHER_DOWN_MODE_SEL(x)	((x) << 3)
+
+#define FRAC_16_16(mult, div)    (((mult) << 16) / (div))
+#define SCL_FT_DEFAULT_FIXPOINT_SHIFT	12
+#define SCL_MAX_VSKIPLINES		4
+#define MIN_SCL_FT_AFTER_VSKIP		1
+
+#define VOP_PLANE_NO_SCALING	BIT(16)
+
+static inline uint16_t scl_cal_scale(int src, int dst, int shift)
+{
+	return ((src * 2 - 3) << (shift - 1)) / (dst - 1);
+}
+
+static inline uint16_t scl_cal_scale2(int src, int dst)
+{
+	return ((src - 1) << 12) / (dst - 1);
+}
+
+#define GET_SCL_FT_BILI_DN(src, dst)	scl_cal_scale(src, dst, 12)
+#define GET_SCL_FT_BILI_UP(src, dst)	scl_cal_scale(src, dst, 16)
+#define GET_SCL_FT_BIC(src, dst)	scl_cal_scale(src, dst, 16)
+
+static inline uint16_t scl_get_bili_dn_vskip(int src_h, int dst_h,
+					     int vskiplines)
+{
+	int act_height;
+
+	act_height = (src_h + vskiplines - 1) / vskiplines;
+
+	return GET_SCL_FT_BILI_DN(act_height, dst_h);
+}
+
+static inline enum scale_mode scl_get_scl_mode(int src, int dst)
+{
+	if (src < dst)
+		return SCALE_UP;
+	else if (src > dst)
+		return SCALE_DOWN;
+
+	return SCALE_NONE;
+}
+
+static inline int scl_get_vskiplines(uint32_t srch, uint32_t dsth)
+{
+	uint32_t vskiplines;
+
+	for (vskiplines = SCL_MAX_VSKIPLINES; vskiplines > 1; vskiplines /= 2)
+		if (srch >= vskiplines * dsth * MIN_SCL_FT_AFTER_VSKIP)
+			break;
+
+	return vskiplines;
+}
+
+static inline int scl_vop_cal_lb_mode(int width, bool is_yuv)
+{
+	int lb_mode;
+
+	if (width > 2560)
+		lb_mode = LB_RGB_3840X2;
+	else if (width > 1920)
+		lb_mode = LB_RGB_2560X4;
+	else if (!is_yuv)
+		lb_mode = LB_RGB_1920X5;
+	else if (width > 1280)
+		lb_mode = LB_YUV_3840X5;
+	else
+		lb_mode = LB_YUV_2560X8;
+
+	return lb_mode;
+}
+
+struct vop_reg_data {
+	uint32_t offset;
+	uint32_t value;
+};
+
+struct vop_reg {
+	uint32_t mask;
+	uint32_t offset:17;
+	uint32_t shift:5;
+	uint32_t begin_minor:4;
+	uint32_t end_minor:4;
+	uint32_t reserved:2;
+	uint32_t major:3;
+	uint32_t write_mask:1;
+};
+
+struct vop_ctrl {
+	struct vop_reg standby;
+	struct vop_reg axi_outstanding_max_num;
+	struct vop_reg axi_max_outstanding_en;
+	struct vop_reg htotal_pw;
+	struct vop_reg hact_st_end;
+	struct vop_reg vtotal_pw;
+	struct vop_reg vact_st_end;
+	struct vop_reg vact_st_end_f1;
+	struct vop_reg vs_st_end_f1;
+	struct vop_reg hpost_st_end;
+	struct vop_reg vpost_st_end;
+	struct vop_reg vpost_st_end_f1;
+	struct vop_reg post_scl_factor;
+	struct vop_reg post_scl_ctrl;
+	struct vop_reg dsp_interlace;
+	struct vop_reg global_regdone_en;
+	struct vop_reg auto_gate_en;
+	struct vop_reg post_lb_mode;
+	struct vop_reg dsp_layer_sel;
+	struct vop_reg overlay_mode;
+	struct vop_reg core_dclk_div;
+	struct vop_reg dclk_ddr;
+	struct vop_reg p2i_en;
+	struct vop_reg hdmi_dclk_out_en;
+	struct vop_reg rgb_en;
+	struct vop_reg lvds_en;
+	struct vop_reg edp_en;
+	struct vop_reg hdmi_en;
+	struct vop_reg mipi_en;
+	struct vop_reg data01_swap;
+	struct vop_reg mipi_dual_channel_en;
+	struct vop_reg dp_en;
+	struct vop_reg dclk_pol;
+	struct vop_reg pin_pol;
+	struct vop_reg rgb_dclk_pol;
+	struct vop_reg rgb_pin_pol;
+	struct vop_reg lvds_dclk_pol;
+	struct vop_reg lvds_pin_pol;
+	struct vop_reg hdmi_dclk_pol;
+	struct vop_reg hdmi_pin_pol;
+	struct vop_reg edp_dclk_pol;
+	struct vop_reg edp_pin_pol;
+	struct vop_reg mipi_dclk_pol;
+	struct vop_reg mipi_pin_pol;
+	struct vop_reg dp_dclk_pol;
+	struct vop_reg dp_pin_pol;
+
+	struct vop_reg dither_up;
+	struct vop_reg dither_down;
+
+	struct vop_reg sw_dac_sel;
+	struct vop_reg tve_sw_mode;
+	struct vop_reg tve_dclk_pol;
+	struct vop_reg tve_dclk_en;
+	struct vop_reg sw_genlock;
+	struct vop_reg sw_uv_offset_en;
+
+	struct vop_reg dsp_out_yuv;
+	struct vop_reg dsp_data_swap;
+	struct vop_reg dsp_bg_swap;
+	struct vop_reg dsp_rb_swap;
+	struct vop_reg dsp_rg_swap;
+	struct vop_reg dsp_delta_swap;
+	struct vop_reg dsp_dummy_swap;
+	struct vop_reg dsp_ccir656_avg;
+	struct vop_reg dsp_black;
+	struct vop_reg dsp_blank;
+	struct vop_reg dsp_outzero;
+	struct vop_reg dsp_lut_en;
+	struct vop_reg update_gamma_lut;
+
+	struct vop_reg out_mode;
+
+	struct vop_reg xmirror;
+	struct vop_reg ymirror;
+	struct vop_reg dsp_background;
+
+	/* CABC */
+	struct vop_reg cabc_total_num;
+	struct vop_reg cabc_config_mode;
+	struct vop_reg cabc_stage_up_mode;
+	struct vop_reg cabc_scale_cfg_value;
+	struct vop_reg cabc_scale_cfg_enable;
+	struct vop_reg cabc_global_dn_limit_en;
+	struct vop_reg cabc_lut_en;
+	struct vop_reg cabc_en;
+	struct vop_reg cabc_handle_en;
+	struct vop_reg cabc_stage_up;
+	struct vop_reg cabc_stage_down;
+	struct vop_reg cabc_global_dn;
+	struct vop_reg cabc_calc_pixel_num;
+
+	struct vop_reg win_gate[4];
+	struct vop_reg win_channel[4];
+
+	/* BCSH */
+	struct vop_reg bcsh_brightness;
+	struct vop_reg bcsh_contrast;
+	struct vop_reg bcsh_sat_con;
+	struct vop_reg bcsh_sin_hue;
+	struct vop_reg bcsh_cos_hue;
+	struct vop_reg bcsh_r2y_csc_mode;
+	struct vop_reg bcsh_r2y_en;
+	struct vop_reg bcsh_y2r_csc_mode;
+	struct vop_reg bcsh_y2r_en;
+	struct vop_reg bcsh_color_bar;
+	struct vop_reg bcsh_out_mode;
+	struct vop_reg bcsh_en;
+	struct vop_reg reg_done_frm;
+
+	/* MCU OUTPUT */
+	struct vop_reg mcu_pix_total;
+	struct vop_reg mcu_cs_pst;
+	struct vop_reg mcu_cs_pend;
+	struct vop_reg mcu_rw_pst;
+	struct vop_reg mcu_rw_pend;
+	struct vop_reg mcu_clk_sel;
+	struct vop_reg mcu_hold_mode;
+	struct vop_reg mcu_frame_st;
+	struct vop_reg mcu_rs;
+	struct vop_reg mcu_bypass;
+	struct vop_reg mcu_type;
+	struct vop_reg mcu_rw_bypass_port;
+
+	/* bt1120 */
+	struct vop_reg bt1120_yc_swap;
+	struct vop_reg bt1120_en;
+
+	/* bt656 */
+	struct vop_reg bt656_en;
+
+	struct vop_reg cfg_done;
+};
+
+struct vop_scl_extension {
+	struct vop_reg cbcr_vsd_mode;
+	struct vop_reg cbcr_vsu_mode;
+	struct vop_reg cbcr_hsd_mode;
+	struct vop_reg cbcr_ver_scl_mode;
+	struct vop_reg cbcr_hor_scl_mode;
+	struct vop_reg yrgb_vsd_mode;
+	struct vop_reg yrgb_vsu_mode;
+	struct vop_reg yrgb_hsd_mode;
+	struct vop_reg yrgb_ver_scl_mode;
+	struct vop_reg yrgb_hor_scl_mode;
+	struct vop_reg line_load_mode;
+	struct vop_reg cbcr_axi_gather_num;
+	struct vop_reg yrgb_axi_gather_num;
+	struct vop_reg vsd_cbcr_gt2;
+	struct vop_reg vsd_cbcr_gt4;
+	struct vop_reg vsd_yrgb_gt2;
+	struct vop_reg vsd_yrgb_gt4;
+	struct vop_reg bic_coe_sel;
+	struct vop_reg cbcr_axi_gather_en;
+	struct vop_reg yrgb_axi_gather_en;
+	struct vop_reg lb_mode;
+};
+
+struct vop_scl_regs {
+	const struct vop_scl_extension *ext;
+
+	struct vop_reg scale_yrgb_x;
+	struct vop_reg scale_yrgb_y;
+	struct vop_reg scale_cbcr_x;
+	struct vop_reg scale_cbcr_y;
+};
+
+struct vop_win {
+	const struct vop_scl_regs *scl;
+
+	struct vop_reg gate;
+	struct vop_reg enable;
+	struct vop_reg format;
+	struct vop_reg interlace_read;
+	struct vop_reg ymirror;
+	struct vop_reg rb_swap;
+	struct vop_reg act_info;
+	struct vop_reg dsp_info;
+	struct vop_reg dsp_st;
+	struct vop_reg yrgb_mst;
+	struct vop_reg uv_mst;
+	struct vop_reg yrgb_vir;
+	struct vop_reg uv_vir;
+	struct vop_reg alpha_mode;
+	struct vop_reg alpha_en;
+
+	struct vop_reg dst_alpha_ctl;
+	struct vop_reg src_alpha_ctl;
+};
+
+struct vop_line_flag {
+	struct vop_reg line_flag_num[2];
+};
+
+struct vop_grf_ctrl {
+	struct vop_reg grf_dclk_inv;
+};
+
+struct vop_csc_table {
+	const uint32_t *r2y_bt601;
+	const uint32_t *r2y_bt601_12_235;
+	const uint32_t *r2y_bt709;
+	const uint32_t *r2y_bt2020;
+};
+
+struct vop_csc {
+	struct vop_reg y2r_en;
+	struct vop_reg r2r_en;
+	struct vop_reg r2y_en;
+
+	uint32_t y2r_offset;
+	uint32_t r2r_offset;
+	uint32_t r2y_offset;
+};
+
+#define VOP_FEATURE_OUTPUT_10BIT	BIT(0)
+
+struct vop_data {
+	uint32_t version;
+	const struct vop_ctrl *ctrl;
+	const struct vop_win *win;
+	const struct vop_line_flag *line_flag;
+	const struct vop_grf_ctrl *grf_ctrl;
+	const struct vop_csc_table *csc_table;
+	const struct vop_csc *win_csc;
+	int win_offset;
+	int reg_len;
+	u64 feature;
+	struct vop_rect max_output;
+};
+
+struct vop {
+	u32 *regsbak;
+	void *regs;
+	void *grf;
+
+	uint32_t version;
+	const struct vop_ctrl *ctrl;
+	const struct vop_win *win;
+	const struct vop_line_flag *line_flag;
+	const struct vop_grf_ctrl *grf_ctrl;
+	const struct vop_csc_table *csc_table;
+	const struct vop_csc *win_csc;
+	int win_offset;
+
+	struct gpio_desc mcu_rs_gpio;
+};
+
+static inline void vop_writel(struct vop *vop, uint32_t offset, uint32_t v)
+{
+	writel(v, vop->regs + offset);
+	vop->regsbak[offset >> 2] = v;
+}
+
+static inline uint32_t vop_readl(struct vop *vop, uint32_t offset)
+{
+	return readl(vop->regs + offset);
+}
+
+static inline uint32_t vop_read_reg(struct vop *vop, uint32_t base,
+				    const struct vop_reg *reg)
+{
+	return (vop_readl(vop, base + reg->offset) >> reg->shift) & reg->mask;
+}
+
+static inline void vop_mask_write(struct vop *vop, uint32_t offset,
+				  uint32_t mask, uint32_t shift, uint32_t v,
+				  bool write_mask)
+{
+	if (!mask)
+		return;
+
+	if (write_mask) {
+		v = ((v & mask) << shift) | (mask << (shift + 16));
+	} else {
+		uint32_t cached_val = vop->regsbak[offset >> 2];
+
+		v = (cached_val & ~(mask << shift)) | ((v & mask) << shift);
+		vop->regsbak[offset >> 2] = v;
+	}
+
+	writel(v, vop->regs + offset);
+}
+
+static inline void vop_cfg_done(struct vop *vop)
+{
+	VOP_CTRL_SET(vop, cfg_done, 1);
+}
+
+static inline void vop_grf_writel(struct vop *vop, struct vop_reg reg, u32 v)
+{
+	u32 val = 0;
+
+	if (VOP_REG_SUPPORT(vop, reg)) {
+		val = (v << reg.shift) | (reg.mask << (reg.shift + 16));
+		writel(val, vop->grf + reg.offset);
+	}
+}
+
+/**
+ * drm_format_horz_chroma_subsampling - get the horizontal chroma subsampling factor
+ * @format: pixel format (DRM_FORMAT_*)
+ *
+ * Returns:
+ * The horizontal chroma subsampling factor for the
+ * specified pixel format.
+ */
+static inline int drm_format_horz_chroma_subsampling(uint32_t format)
+{
+	/* uboot only support RGB format */
+	return 1;
+}
+
+/**
+ * drm_format_vert_chroma_subsampling - get the vertical chroma subsampling factor
+ * @format: pixel format (DRM_FORMAT_*)
+ *
+ * Returns:
+ * The vertical chroma subsampling factor for the
+ * specified pixel format.
+ */
+static inline int drm_format_vert_chroma_subsampling(uint32_t format)
+{
+	/* uboot only support RGB format */
+	return 1;
+}
+
+#endif
diff --git a/drivers/video/drm/rockchip_vop2.c b/drivers/video/drm/rockchip_vop2.c
new file mode 100644
index 0000000000..dc7a177def
--- /dev/null
+++ b/drivers/video/drm/rockchip_vop2.c
@@ -0,0 +1,5966 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * (C) Copyright 2008-2017 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ */
+
+#include <config.h>
+#include <common.h>
+#include <errno.h>
+#include <malloc.h>
+#include <fdtdec.h>
+#include <fdt_support.h>
+#include <regmap.h>
+#include <asm/arch/cpu.h>
+#include <asm/unaligned.h>
+#include <asm/io.h>
+#include <linux/list.h>
+#include <linux/log2.h>
+#include <linux/media-bus-format.h>
+#include <asm/arch/clock.h>
+#include <asm/gpio.h>
+#include <linux/err.h>
+#include <linux/ioport.h>
+#include <dm/device.h>
+#include <dm/read.h>
+#include <dm/ofnode.h>
+#include <fixp-arith.h>
+#include <syscon.h>
+#include <linux/iopoll.h>
+#include <dm/uclass-internal.h>
+#include <stdlib.h>
+
+#include "rockchip_display.h"
+#include "rockchip_crtc.h"
+#include "rockchip_connector.h"
+#include "rockchip_phy.h"
+#include "rockchip_post_csc.h"
+
+/* System registers definition */
+#define RK3568_REG_CFG_DONE			0x000
+#define	CFG_DONE_EN				BIT(15)
+
+#define RK3568_VERSION_INFO			0x004
+#define EN_MASK					1
+
+#define RK3568_AUTO_GATING_CTRL			0x008
+#define AUTO_GATING_EN_SHIFT			31
+#define PORT_DCLK_AUTO_GATING_EN_SHIFT		14
+
+#define RK3568_SYS_AXI_LUT_CTRL			0x024
+#define LUT_DMA_EN_SHIFT			0
+#define DSP_VS_T_SEL_SHIFT			16
+
+#define RK3568_DSP_IF_EN			0x028
+#define RGB_EN_SHIFT				0
+#define RK3588_DP0_EN_SHIFT			0
+#define RK3588_DP1_EN_SHIFT			1
+#define RK3588_RGB_EN_SHIFT			8
+#define HDMI0_EN_SHIFT				1
+#define EDP0_EN_SHIFT				3
+#define RK3588_EDP0_EN_SHIFT			2
+#define RK3588_HDMI0_EN_SHIFT			3
+#define MIPI0_EN_SHIFT				4
+#define RK3588_EDP1_EN_SHIFT			4
+#define RK3588_HDMI1_EN_SHIFT			5
+#define RK3588_MIPI0_EN_SHIFT                   6
+#define MIPI1_EN_SHIFT				20
+#define RK3588_MIPI1_EN_SHIFT                   7
+#define LVDS0_EN_SHIFT				5
+#define LVDS1_EN_SHIFT				24
+#define BT1120_EN_SHIFT				6
+#define BT656_EN_SHIFT				7
+#define IF_MUX_MASK				3
+#define RGB_MUX_SHIFT				8
+#define HDMI0_MUX_SHIFT				10
+#define RK3588_DP0_MUX_SHIFT			12
+#define RK3588_DP1_MUX_SHIFT			14
+#define EDP0_MUX_SHIFT				14
+#define RK3588_HDMI_EDP0_MUX_SHIFT		16
+#define RK3588_HDMI_EDP1_MUX_SHIFT		18
+#define MIPI0_MUX_SHIFT				16
+#define RK3588_MIPI0_MUX_SHIFT			20
+#define MIPI1_MUX_SHIFT				21
+#define LVDS0_MUX_SHIFT				18
+#define LVDS1_MUX_SHIFT				25
+
+#define RK3568_DSP_IF_CTRL			0x02c
+#define LVDS_DUAL_EN_SHIFT			0
+#define RK3588_BT656_UV_SWAP_SHIFT		0
+#define LVDS_DUAL_LEFT_RIGHT_EN_SHIFT		1
+#define RK3588_BT656_YC_SWAP_SHIFT		1
+#define LVDS_DUAL_SWAP_EN_SHIFT			2
+#define BT656_UV_SWAP				4
+#define RK3588_BT1120_UV_SWAP_SHIFT		4
+#define BT656_YC_SWAP				5
+#define RK3588_BT1120_YC_SWAP_SHIFT		5
+#define BT656_DCLK_POL				6
+#define RK3588_HDMI_DUAL_EN_SHIFT		8
+#define RK3588_EDP_DUAL_EN_SHIFT		8
+#define RK3588_DP_DUAL_EN_SHIFT			9
+#define RK3568_MIPI_DUAL_EN_SHIFT		10
+#define RK3588_MIPI_DSI0_MODE_SEL_SHIFT		11
+#define RK3588_MIPI_DSI1_MODE_SEL_SHIFT		12
+
+#define RK3568_DSP_IF_POL			0x030
+#define IF_CTRL_REG_DONE_IMD_MASK		1
+#define IF_CTRL_REG_DONE_IMD_SHIFT		28
+#define IF_CRTL_MIPI_DCLK_POL_SHIT		19
+#define IF_CRTL_EDP_DCLK_POL_SHIT		15
+#define IF_CTRL_EDP_PIN_POL_MASK		0x7
+#define IF_CTRL_EDP_PIN_POL_SHIFT		12
+#define IF_CRTL_HDMI_DCLK_POL_SHIT		7
+#define IF_CRTL_HDMI_PIN_POL_MASK		0x7
+#define IF_CRTL_HDMI_PIN_POL_SHIT		4
+#define IF_CTRL_RGB_LVDS_DCLK_POL_SHIFT		3
+#define IF_CTRL_RGB_LVDS_PIN_POL_MASK		0x7
+#define IF_CTRL_RGB_LVDS_PIN_POL_SHIFT		0
+
+#define RK3562_MIPI_DCLK_POL_SHIFT		15
+#define RK3562_MIPI_PIN_POL_SHIFT		12
+#define RK3562_IF_PIN_POL_MASK			0x7
+
+#define RK3588_DP0_PIN_POL_SHIFT		8
+#define RK3588_DP1_PIN_POL_SHIFT		12
+#define RK3588_IF_PIN_POL_MASK			0x7
+
+#define HDMI_EDP0_DCLK_DIV_SHIFT		16
+#define HDMI_EDP0_PIXCLK_DIV_SHIFT		18
+#define HDMI_EDP1_DCLK_DIV_SHIFT		20
+#define HDMI_EDP1_PIXCLK_DIV_SHIFT		22
+#define MIPI0_PIXCLK_DIV_SHIFT			24
+#define MIPI1_PIXCLK_DIV_SHIFT			26
+
+#define RK3568_SYS_OTP_WIN_EN			0x50
+#define OTP_WIN_EN_SHIFT			0
+#define RK3568_SYS_LUT_PORT_SEL			0x58
+#define GAMMA_PORT_SEL_MASK			0x3
+#define GAMMA_PORT_SEL_SHIFT			0
+#define GAMMA_AHB_WRITE_SEL_MASK		0x3
+#define GAMMA_AHB_WRITE_SEL_SHIFT		12
+#define PORT_MERGE_EN_SHIFT			16
+#define ESMART_LB_MODE_SEL_MASK			0x3
+#define ESMART_LB_MODE_SEL_SHIFT		26
+
+#define RK3568_SYS_PD_CTRL			0x034
+#define RK3568_VP0_LINE_FLAG			0x70
+#define RK3568_VP1_LINE_FLAG			0x74
+#define RK3568_VP2_LINE_FLAG			0x78
+#define RK3568_SYS0_INT_EN			0x80
+#define RK3568_SYS0_INT_CLR			0x84
+#define RK3568_SYS0_INT_STATUS			0x88
+#define RK3568_SYS1_INT_EN			0x90
+#define RK3568_SYS1_INT_CLR			0x94
+#define RK3568_SYS1_INT_STATUS			0x98
+#define RK3568_VP0_INT_EN			0xA0
+#define RK3568_VP0_INT_CLR			0xA4
+#define RK3568_VP0_INT_STATUS			0xA8
+#define RK3568_VP1_INT_EN			0xB0
+#define RK3568_VP1_INT_CLR			0xB4
+#define RK3568_VP1_INT_STATUS			0xB8
+#define RK3568_VP2_INT_EN			0xC0
+#define RK3568_VP2_INT_CLR			0xC4
+#define RK3568_VP2_INT_STATUS			0xC8
+#define RK3588_CLUSTER0_PD_EN_SHIFT		0
+#define RK3588_CLUSTER1_PD_EN_SHIFT		1
+#define RK3588_CLUSTER2_PD_EN_SHIFT		2
+#define RK3588_CLUSTER3_PD_EN_SHIFT		3
+#define RK3588_DSC_8K_PD_EN_SHIFT		5
+#define RK3588_DSC_4K_PD_EN_SHIFT		6
+#define RK3588_ESMART_PD_EN_SHIFT		7
+
+#define RK3588_SYS_VAR_FREQ_CTRL		0x038
+#define RK3588_VP0_LINE_FLAG_OR_EN_SHIFT	20
+#define RK3588_VP0_DSP_HOLD_OR_EN_SHIFT		24
+#define RK3588_VP0_ALMOST_FULL_OR_EN_SHIFT	28
+
+#define RK3568_SYS_STATUS0			0x60
+#define RK3588_CLUSTER0_PD_STATUS_SHIFT		8
+#define RK3588_CLUSTER1_PD_STATUS_SHIFT		9
+#define RK3588_CLUSTER2_PD_STATUS_SHIFT		10
+#define RK3588_CLUSTER3_PD_STATUS_SHIFT		11
+#define RK3588_DSC_8K_PD_STATUS_SHIFT		13
+#define RK3588_DSC_4K_PD_STATUS_SHIFT		14
+#define RK3588_ESMART_PD_STATUS_SHIFT		15
+
+#define RK3568_SYS_CTRL_LINE_FLAG0		0x70
+#define LINE_FLAG_NUM_MASK			0x1fff
+#define RK3568_DSP_LINE_FLAG_NUM0_SHIFT		0
+#define RK3568_DSP_LINE_FLAG_NUM1_SHIFT		16
+
+/* DSC CTRL registers definition */
+#define RK3588_DSC_8K_SYS_CTRL			0x200
+#define DSC_PORT_SEL_MASK			0x3
+#define DSC_PORT_SEL_SHIFT			0
+#define DSC_MAN_MODE_MASK			0x1
+#define DSC_MAN_MODE_SHIFT			2
+#define DSC_INTERFACE_MODE_MASK			0x3
+#define DSC_INTERFACE_MODE_SHIFT		4
+#define DSC_PIXEL_NUM_MASK			0x3
+#define DSC_PIXEL_NUM_SHIFT			6
+#define DSC_PXL_CLK_DIV_MASK			0x1
+#define DSC_PXL_CLK_DIV_SHIFT			8
+#define DSC_CDS_CLK_DIV_MASK			0x3
+#define DSC_CDS_CLK_DIV_SHIFT			12
+#define DSC_TXP_CLK_DIV_MASK			0x3
+#define DSC_TXP_CLK_DIV_SHIFT			14
+#define DSC_INIT_DLY_MODE_MASK			0x1
+#define DSC_INIT_DLY_MODE_SHIFT			16
+#define DSC_SCAN_EN_SHIFT			17
+#define DSC_HALT_EN_SHIFT			18
+
+#define RK3588_DSC_8K_RST			0x204
+#define RST_DEASSERT_MASK			0x1
+#define RST_DEASSERT_SHIFT			0
+
+#define RK3588_DSC_8K_CFG_DONE			0x208
+#define DSC_CFG_DONE_SHIFT			0
+
+#define RK3588_DSC_8K_INIT_DLY			0x20C
+#define DSC_INIT_DLY_NUM_MASK			0xffff
+#define DSC_INIT_DLY_NUM_SHIFT			0
+#define SCAN_TIMING_PARA_IMD_EN_SHIFT		16
+
+#define RK3588_DSC_8K_HTOTAL_HS_END		0x210
+#define DSC_HTOTAL_PW_MASK			0xffffffff
+#define DSC_HTOTAL_PW_SHIFT			0
+
+#define RK3588_DSC_8K_HACT_ST_END		0x214
+#define DSC_HACT_ST_END_MASK			0xffffffff
+#define DSC_HACT_ST_END_SHIFT			0
+
+#define RK3588_DSC_8K_VTOTAL_VS_END		0x218
+#define DSC_VTOTAL_PW_MASK			0xffffffff
+#define DSC_VTOTAL_PW_SHIFT			0
+
+#define RK3588_DSC_8K_VACT_ST_END		0x21C
+#define DSC_VACT_ST_END_MASK			0xffffffff
+#define DSC_VACT_ST_END_SHIFT			0
+
+#define RK3588_DSC_8K_STATUS			0x220
+
+/* Overlay registers definition    */
+#define RK3528_OVL_SYS				0x500
+#define RK3528_OVL_SYS_PORT_SEL_IMD		0x504
+#define RK3528_OVL_SYS_GATING_EN_IMD		0x508
+#define RK3528_OVL_SYS_CLUSTER0_CTRL		0x510
+#define RK3528_OVL_SYS_ESMART0_CTRL		0x520
+#define ESMART_DLY_NUM_MASK			0xff
+#define ESMART_DLY_NUM_SHIFT			0
+#define RK3528_OVL_SYS_ESMART1_CTRL		0x524
+#define RK3528_OVL_SYS_ESMART2_CTRL		0x528
+#define RK3528_OVL_SYS_ESMART3_CTRL		0x52C
+#define RK3528_CLUSTER0_MIX_SRC_COLOR_CTRL	0x530
+#define RK3528_CLUSTER0_MIX_DST_COLOR_CTRL	0x534
+#define RK3528_CLUSTER0_MIX_SRC_ALPHA_CTRL	0x538
+#define RK3528_CLUSTER0_MIX_DST_ALPHA_CTRL	0x53c
+
+#define RK3528_OVL_PORT0_CTRL			0x600
+#define RK3568_OVL_CTRL				0x600
+#define OVL_MODE_SEL_MASK			0x1
+#define OVL_MODE_SEL_SHIFT			0
+#define OVL_PORT_MUX_REG_DONE_IMD_SHIFT		28
+#define RK3528_OVL_PORT0_LAYER_SEL		0x604
+#define RK3568_OVL_LAYER_SEL			0x604
+#define LAYER_SEL_MASK				0xf
+
+#define RK3568_OVL_PORT_SEL			0x608
+#define PORT_MUX_MASK				0xf
+#define PORT_MUX_SHIFT				0
+#define LAYER_SEL_PORT_MASK			0x3
+#define LAYER_SEL_PORT_SHIFT			16
+
+#define RK3568_CLUSTER0_MIX_SRC_COLOR_CTRL	0x610
+#define RK3568_CLUSTER0_MIX_DST_COLOR_CTRL	0x614
+#define RK3568_CLUSTER0_MIX_SRC_ALPHA_CTRL	0x618
+#define RK3568_CLUSTER0_MIX_DST_ALPHA_CTRL	0x61C
+#define RK3528_OVL_PORT0_MIX0_SRC_COLOR_CTRL	0x620
+#define RK3528_OVL_PORT0_MIX0_DST_COLOR_CTRL	0x624
+#define RK3528_OVL_PORT0_MIX0_SRC_ALPHA_CTRL	0x628
+#define RK3528_OVL_PORT0_MIX0_DST_ALPHA_CTRL	0x62C
+#define RK3528_OVL_PORT0_MIX1_SRC_COLOR_CTRL	0x630
+#define RK3528_OVL_PORT0_MIX1_DST_COLOR_CTRL	0x634
+#define RK3528_OVL_PORT0_MIX1_SRC_ALPHA_CTRL	0x638
+#define RK3528_OVL_PORT0_MIX1_DST_ALPHA_CTRL	0x63C
+#define RK3528_OVL_PORT0_MIX2_SRC_COLOR_CTRL	0x640
+#define RK3528_OVL_PORT0_MIX2_DST_COLOR_CTRL	0x644
+#define RK3528_OVL_PORT0_MIX2_SRC_ALPHA_CTRL	0x648
+#define RK3528_OVL_PORT0_MIX2_DST_ALPHA_CTRL	0x64C
+#define RK3568_MIX0_SRC_COLOR_CTRL		0x650
+#define RK3568_MIX0_DST_COLOR_CTRL		0x654
+#define RK3568_MIX0_SRC_ALPHA_CTRL		0x658
+#define RK3568_MIX0_DST_ALPHA_CTRL		0x65C
+#define RK3528_HDR_SRC_COLOR_CTRL		0x660
+#define RK3528_HDR_DST_COLOR_CTRL		0x664
+#define RK3528_HDR_SRC_ALPHA_CTRL		0x668
+#define RK3528_HDR_DST_ALPHA_CTRL		0x66C
+#define RK3528_OVL_PORT0_BG_MIX_CTRL		0x670
+#define RK3568_HDR0_SRC_COLOR_CTRL		0x6C0
+#define RK3568_HDR0_DST_COLOR_CTRL		0x6C4
+#define RK3568_HDR0_SRC_ALPHA_CTRL		0x6C8
+#define RK3568_HDR0_DST_ALPHA_CTRL		0x6CC
+#define RK3568_VP0_BG_MIX_CTRL			0x6E0
+#define BG_MIX_CTRL_MASK			0xff
+#define BG_MIX_CTRL_SHIFT			24
+#define RK3568_VP1_BG_MIX_CTRL			0x6E4
+#define RK3568_VP2_BG_MIX_CTRL			0x6E8
+#define RK3568_CLUSTER_DLY_NUM			0x6F0
+#define RK3568_SMART_DLY_NUM			0x6F8
+
+#define RK3528_OVL_PORT1_CTRL			0x700
+#define RK3528_OVL_PORT1_LAYER_SEL		0x704
+#define RK3528_OVL_PORT1_MIX0_SRC_COLOR_CTRL	0x720
+#define RK3528_OVL_PORT1_MIX0_DST_COLOR_CTRL	0x724
+#define RK3528_OVL_PORT1_MIX0_SRC_ALPHA_CTRL	0x728
+#define RK3528_OVL_PORT1_MIX0_DST_ALPHA_CTRL	0x72C
+#define RK3528_OVL_PORT1_MIX1_SRC_COLOR_CTRL	0x730
+#define RK3528_OVL_PORT1_MIX1_DST_COLOR_CTRL	0x734
+#define RK3528_OVL_PORT1_MIX1_SRC_ALPHA_CTRL	0x738
+#define RK3528_OVL_PORT1_MIX1_DST_ALPHA_CTRL	0x73C
+#define RK3528_OVL_PORT1_MIX2_SRC_COLOR_CTRL	0x740
+#define RK3528_OVL_PORT1_MIX2_DST_COLOR_CTRL	0x744
+#define RK3528_OVL_PORT1_MIX2_SRC_ALPHA_CTRL	0x748
+#define RK3528_OVL_PORT1_MIX2_DST_ALPHA_CTRL	0x74C
+#define RK3528_OVL_PORT1_BG_MIX_CTRL		0x770
+
+/* Video Port registers definition */
+#define RK3568_VP0_DSP_CTRL			0xC00
+#define OUT_MODE_MASK				0xf
+#define OUT_MODE_SHIFT				0
+#define DATA_SWAP_MASK				0x1f
+#define DATA_SWAP_SHIFT				8
+#define DSP_BG_SWAP				0x1
+#define DSP_RB_SWAP				0x2
+#define DSP_RG_SWAP				0x4
+#define DSP_DELTA_SWAP				0x8
+#define CORE_DCLK_DIV_EN_SHIFT			4
+#define P2I_EN_SHIFT				5
+#define DSP_FILED_POL				6
+#define INTERLACE_EN_SHIFT			7
+#define DSP_X_MIR_EN_SHIFT			13
+#define POST_DSP_OUT_R2Y_SHIFT			15
+#define PRE_DITHER_DOWN_EN_SHIFT		16
+#define DITHER_DOWN_EN_SHIFT			17
+#define DITHER_DOWN_MODE_SHIFT			20
+#define GAMMA_UPDATE_EN_SHIFT			22
+#define DSP_LUT_EN_SHIFT			28
+
+#define STANDBY_EN_SHIFT			31
+
+#define RK3568_VP0_MIPI_CTRL			0xC04
+#define DCLK_DIV2_SHIFT				4
+#define DCLK_DIV2_MASK				0x3
+#define MIPI_DUAL_EN_SHIFT			20
+#define MIPI_DUAL_SWAP_EN_SHIFT			21
+#define EDPI_TE_EN				28
+#define EDPI_WMS_HOLD_EN			30
+#define EDPI_WMS_FS				31
+
+
+#define RK3568_VP0_COLOR_BAR_CTRL		0xC08
+
+#define RK3568_VP0_DCLK_SEL			0xC0C
+
+#define RK3568_VP0_3D_LUT_CTRL			0xC10
+#define VP0_3D_LUT_EN_SHIFT				0
+#define VP0_3D_LUT_UPDATE_SHIFT			2
+
+#define RK3588_VP0_CLK_CTRL			0xC0C
+#define DCLK_CORE_DIV_SHIFT			0
+#define DCLK_OUT_DIV_SHIFT			2
+
+#define RK3568_VP0_3D_LUT_MST			0xC20
+
+#define RK3568_VP0_DSP_BG			0xC2C
+#define RK3568_VP0_PRE_SCAN_HTIMING		0xC30
+#define RK3568_VP0_POST_DSP_HACT_INFO		0xC34
+#define RK3568_VP0_POST_DSP_VACT_INFO		0xC38
+#define RK3568_VP0_POST_SCL_FACTOR_YRGB		0xC3C
+#define RK3568_VP0_POST_SCL_CTRL		0xC40
+#define RK3568_VP0_POST_DSP_VACT_INFO_F1	0xC44
+#define RK3568_VP0_DSP_HTOTAL_HS_END		0xC48
+#define RK3568_VP0_DSP_HACT_ST_END		0xC4C
+#define RK3568_VP0_DSP_VTOTAL_VS_END		0xC50
+#define RK3568_VP0_DSP_VACT_ST_END		0xC54
+#define RK3568_VP0_DSP_VS_ST_END_F1		0xC58
+#define RK3568_VP0_DSP_VACT_ST_END_F1		0xC5C
+
+#define RK3568_VP0_BCSH_CTRL			0xC60
+#define BCSH_CTRL_Y2R_SHIFT			0
+#define BCSH_CTRL_Y2R_MASK			0x1
+#define BCSH_CTRL_Y2R_CSC_MODE_SHIFT		2
+#define BCSH_CTRL_Y2R_CSC_MODE_MASK		0x3
+#define BCSH_CTRL_R2Y_SHIFT			4
+#define BCSH_CTRL_R2Y_MASK			0x1
+#define BCSH_CTRL_R2Y_CSC_MODE_SHIFT		6
+#define BCSH_CTRL_R2Y_CSC_MODE_MASK		0x3
+
+#define RK3568_VP0_BCSH_BCS			0xC64
+#define BCSH_BRIGHTNESS_SHIFT			0
+#define BCSH_BRIGHTNESS_MASK			0xFF
+#define BCSH_CONTRAST_SHIFT			8
+#define BCSH_CONTRAST_MASK			0x1FF
+#define BCSH_SATURATION_SHIFT			20
+#define BCSH_SATURATION_MASK			0x3FF
+#define BCSH_OUT_MODE_SHIFT			30
+#define BCSH_OUT_MODE_MASK			0x3
+
+#define RK3568_VP0_BCSH_H			0xC68
+#define BCSH_SIN_HUE_SHIFT			0
+#define BCSH_SIN_HUE_MASK			0x1FF
+#define BCSH_COS_HUE_SHIFT			16
+#define BCSH_COS_HUE_MASK			0x1FF
+
+#define RK3568_VP0_BCSH_COLOR			0xC6C
+#define BCSH_EN_SHIFT				31
+#define BCSH_EN_MASK				1
+
+#define RK3528_VP0_ACM_CTRL			0xCD0
+#define POST_CSC_COE00_MASK			0xFFFF
+#define POST_CSC_COE00_SHIFT			16
+#define POST_R2Y_MODE_MASK			0x7
+#define POST_R2Y_MODE_SHIFT			8
+#define POST_CSC_MODE_MASK			0x7
+#define POST_CSC_MODE_SHIFT			3
+#define POST_R2Y_EN_MASK			0x1
+#define POST_R2Y_EN_SHIFT			2
+#define POST_CSC_EN_MASK			0x1
+#define POST_CSC_EN_SHIFT			1
+#define POST_ACM_BYPASS_EN_MASK			0x1
+#define POST_ACM_BYPASS_EN_SHIFT		0
+#define RK3528_VP0_CSC_COE01_02			0xCD4
+#define RK3528_VP0_CSC_COE10_11			0xCD8
+#define RK3528_VP0_CSC_COE12_20			0xCDC
+#define RK3528_VP0_CSC_COE21_22			0xCE0
+#define RK3528_VP0_CSC_OFFSET0			0xCE4
+#define RK3528_VP0_CSC_OFFSET1			0xCE8
+#define RK3528_VP0_CSC_OFFSET2			0xCEC
+
+#define RK3562_VP0_MCU_CTRL			0xCF8
+#define MCU_TYPE_SHIFT				31
+#define MCU_BYPASS_SHIFT			30
+#define MCU_RS_SHIFT				29
+#define MCU_FRAME_ST_SHIFT			28
+#define MCU_HOLD_MODE_SHIFT			27
+#define MCU_CLK_SEL_SHIFT			26
+#define MCU_CLK_SEL_MASK			0x1
+#define MCU_RW_PEND_SHIFT			20
+#define MCU_RW_PEND_MASK			0x3F
+#define MCU_RW_PST_SHIFT			16
+#define MCU_RW_PST_MASK				0xF
+#define MCU_CS_PEND_SHIFT			10
+#define MCU_CS_PEND_MASK			0x3F
+#define MCU_CS_PST_SHIFT			6
+#define MCU_CS_PST_MASK				0xF
+#define MCU_PIX_TOTAL_SHIFT			0
+#define MCU_PIX_TOTAL_MASK			0x3F
+
+#define RK3562_VP0_MCU_RW_BYPASS_PORT		0xCFC
+#define MCU_WRITE_DATA_BYPASS_SHIFT		0
+#define MCU_WRITE_DATA_BYPASS_MASK		0xFFFFFFFF
+
+#define RK3568_VP1_DSP_CTRL			0xD00
+#define RK3568_VP1_MIPI_CTRL			0xD04
+#define RK3568_VP1_COLOR_BAR_CTRL		0xD08
+#define RK3568_VP1_PRE_SCAN_HTIMING		0xD30
+#define RK3568_VP1_POST_DSP_HACT_INFO		0xD34
+#define RK3568_VP1_POST_DSP_VACT_INFO		0xD38
+#define RK3568_VP1_POST_SCL_FACTOR_YRGB		0xD3C
+#define RK3568_VP1_POST_SCL_CTRL		0xD40
+#define RK3568_VP1_DSP_HACT_INFO		0xD34
+#define RK3568_VP1_DSP_VACT_INFO		0xD38
+#define RK3568_VP1_POST_DSP_VACT_INFO_F1	0xD44
+#define RK3568_VP1_DSP_HTOTAL_HS_END		0xD48
+#define RK3568_VP1_DSP_HACT_ST_END		0xD4C
+#define RK3568_VP1_DSP_VTOTAL_VS_END		0xD50
+#define RK3568_VP1_DSP_VACT_ST_END		0xD54
+#define RK3568_VP1_DSP_VS_ST_END_F1		0xD58
+#define RK3568_VP1_DSP_VACT_ST_END_F1		0xD5C
+
+#define RK3568_VP2_DSP_CTRL			0xE00
+#define RK3568_VP2_MIPI_CTRL			0xE04
+#define RK3568_VP2_COLOR_BAR_CTRL		0xE08
+#define RK3568_VP2_PRE_SCAN_HTIMING		0xE30
+#define RK3568_VP2_POST_DSP_HACT_INFO		0xE34
+#define RK3568_VP2_POST_DSP_VACT_INFO		0xE38
+#define RK3568_VP2_POST_SCL_FACTOR_YRGB		0xE3C
+#define RK3568_VP2_POST_SCL_CTRL		0xE40
+#define RK3568_VP2_DSP_HACT_INFO		0xE34
+#define RK3568_VP2_DSP_VACT_INFO		0xE38
+#define RK3568_VP2_POST_DSP_VACT_INFO_F1	0xE44
+#define RK3568_VP2_DSP_HTOTAL_HS_END		0xE48
+#define RK3568_VP2_DSP_HACT_ST_END		0xE4C
+#define RK3568_VP2_DSP_VTOTAL_VS_END		0xE50
+#define RK3568_VP2_DSP_VACT_ST_END		0xE54
+#define RK3568_VP2_DSP_VS_ST_END_F1		0xE58
+#define RK3568_VP2_DSP_VACT_ST_END_F1		0xE5C
+
+/* Cluster0 register definition */
+#define RK3568_CLUSTER0_WIN0_CTRL0		0x1000
+#define CLUSTER_YUV2RGB_EN_SHIFT		8
+#define CLUSTER_RGB2YUV_EN_SHIFT		9
+#define CLUSTER_CSC_MODE_SHIFT			10
+#define CLUSTER_DITHER_UP_EN_SHIFT		18
+#define RK3568_CLUSTER0_WIN0_CTRL1		0x1004
+#define RK3568_CLUSTER_YRGB_XSCL_MODE_SHIFT	12
+#define RK3568_CLUSTER_YRGB_YSCL_MODE_SHIFT	14
+#define RK3528_CLUSTER_YRGB_YSCL_MODE_SHIFT	14
+#define AVG2_MASK				0x1
+#define CLUSTER_AVG2_SHIFT			18
+#define AVG4_MASK				0x1
+#define CLUSTER_AVG4_SHIFT			19
+#define RK3528_CLUSTER_YRGB_XSCL_MODE_SHIFT	22
+#define CLUSTER_XGT_EN_SHIFT			24
+#define XGT_MODE_MASK				0x3
+#define CLUSTER_XGT_MODE_SHIFT			25
+#define CLUSTER_XAVG_EN_SHIFT			27
+#define CLUSTER_YRGB_GT2_SHIFT			28
+#define CLUSTER_YRGB_GT4_SHIFT			29
+#define RK3568_CLUSTER0_WIN0_CTRL2		0x1008
+#define CLUSTER_AXI_YRGB_ID_MASK		0x1f
+#define CLUSTER_AXI_YRGB_ID_SHIFT		0
+#define CLUSTER_AXI_UV_ID_MASK			0x1f
+#define CLUSTER_AXI_UV_ID_SHIFT			5
+
+#define RK3568_CLUSTER0_WIN0_YRGB_MST		0x1010
+#define RK3568_CLUSTER0_WIN0_CBR_MST		0x1014
+#define RK3568_CLUSTER0_WIN0_VIR		0x1018
+#define RK3568_CLUSTER0_WIN0_ACT_INFO		0x1020
+#define RK3568_CLUSTER0_WIN0_DSP_INFO		0x1024
+#define RK3568_CLUSTER0_WIN0_DSP_ST		0x1028
+#define RK3568_CLUSTER0_WIN0_SCL_FACTOR_YRGB	0x1030
+#define RK3568_CLUSTER0_WIN0_AFBCD_ROTATE_MODE	0x1054
+#define RK3568_CLUSTER0_WIN0_AFBCD_HDR_PTR	0x1058
+#define RK3568_CLUSTER0_WIN0_AFBCD_VIR_WIDTH	0x105C
+#define RK3568_CLUSTER0_WIN0_AFBCD_PIC_SIZE	0x1060
+#define RK3568_CLUSTER0_WIN0_AFBCD_PIC_OFFSET	0x1064
+#define RK3568_CLUSTER0_WIN0_AFBCD_DSP_OFFSET	0x1068
+#define RK3568_CLUSTER0_WIN0_AFBCD_CTRL		0x106C
+#define CLUSTER_AFBCD_HALF_BLOCK_SHIFT		7
+
+#define RK3568_CLUSTER0_WIN1_CTRL0		0x1080
+#define RK3568_CLUSTER0_WIN1_CTRL1		0x1084
+#define RK3568_CLUSTER0_WIN1_YRGB_MST		0x1090
+#define RK3568_CLUSTER0_WIN1_CBR_MST		0x1094
+#define RK3568_CLUSTER0_WIN1_VIR		0x1098
+#define RK3568_CLUSTER0_WIN1_ACT_INFO		0x10A0
+#define RK3568_CLUSTER0_WIN1_DSP_INFO		0x10A4
+#define RK3568_CLUSTER0_WIN1_DSP_ST		0x10A8
+#define RK3568_CLUSTER0_WIN1_SCL_FACTOR_YRGB	0x10B0
+#define RK3568_CLUSTER0_WIN1_AFBCD_ROTATE_MODE	0x10D4
+#define RK3568_CLUSTER0_WIN1_AFBCD_HDR_PTR	0x10D8
+#define RK3568_CLUSTER0_WIN1_AFBCD_VIR_WIDTH	0x10DC
+#define RK3568_CLUSTER0_WIN1_AFBCD_PIC_SIZE	0x10E0
+#define RK3568_CLUSTER0_WIN1_AFBCD_PIC_OFFSET	0x10E4
+#define RK3568_CLUSTER0_WIN1_AFBCD_DSP_OFFSET	0x10E8
+#define RK3568_CLUSTER0_WIN1_AFBCD_CTRL		0x10EC
+
+#define RK3568_CLUSTER0_CTRL			0x1100
+#define CLUSTER_EN_SHIFT			0
+#define CLUSTER_AXI_ID_MASK			0x1
+#define CLUSTER_AXI_ID_SHIFT			13
+
+#define RK3568_CLUSTER1_WIN0_CTRL0		0x1200
+#define RK3568_CLUSTER1_WIN0_CTRL1		0x1204
+#define RK3568_CLUSTER1_WIN0_YRGB_MST		0x1210
+#define RK3568_CLUSTER1_WIN0_CBR_MST		0x1214
+#define RK3568_CLUSTER1_WIN0_VIR		0x1218
+#define RK3568_CLUSTER1_WIN0_ACT_INFO		0x1220
+#define RK3568_CLUSTER1_WIN0_DSP_INFO		0x1224
+#define RK3568_CLUSTER1_WIN0_DSP_ST		0x1228
+#define RK3568_CLUSTER1_WIN0_SCL_FACTOR_YRGB	0x1230
+#define RK3568_CLUSTER1_WIN0_AFBCD_ROTATE_MODE	0x1254
+#define RK3568_CLUSTER1_WIN0_AFBCD_HDR_PTR	0x1258
+#define RK3568_CLUSTER1_WIN0_AFBCD_VIR_WIDTH	0x125C
+#define RK3568_CLUSTER1_WIN0_AFBCD_PIC_SIZE	0x1260
+#define RK3568_CLUSTER1_WIN0_AFBCD_PIC_OFFSET	0x1264
+#define RK3568_CLUSTER1_WIN0_AFBCD_DSP_OFFSET	0x1268
+#define RK3568_CLUSTER1_WIN0_AFBCD_CTRL		0x126C
+
+#define RK3568_CLUSTER1_WIN1_CTRL0		0x1280
+#define RK3568_CLUSTER1_WIN1_CTRL1		0x1284
+#define RK3568_CLUSTER1_WIN1_YRGB_MST		0x1290
+#define RK3568_CLUSTER1_WIN1_CBR_MST		0x1294
+#define RK3568_CLUSTER1_WIN1_VIR		0x1298
+#define RK3568_CLUSTER1_WIN1_ACT_INFO		0x12A0
+#define RK3568_CLUSTER1_WIN1_DSP_INFO		0x12A4
+#define RK3568_CLUSTER1_WIN1_DSP_ST		0x12A8
+#define RK3568_CLUSTER1_WIN1_SCL_FACTOR_YRGB	0x12B0
+#define RK3568_CLUSTER1_WIN1_AFBCD_ROTATE_MODE	0x12D4
+#define RK3568_CLUSTER1_WIN1_AFBCD_HDR_PTR	0x12D8
+#define RK3568_CLUSTER1_WIN1_AFBCD_VIR_WIDTH	0x12DC
+#define RK3568_CLUSTER1_WIN1_AFBCD_PIC_SIZE	0x12E0
+#define RK3568_CLUSTER1_WIN1_AFBCD_PIC_OFFSET	0x12E4
+#define RK3568_CLUSTER1_WIN1_AFBCD_DSP_OFFSET	0x12E8
+#define RK3568_CLUSTER1_WIN1_AFBCD_CTRL		0x12EC
+
+#define RK3568_CLUSTER1_CTRL			0x1300
+
+/* Esmart register definition */
+#define RK3568_ESMART0_CTRL0			0x1800
+#define RGB2YUV_EN_SHIFT			1
+#define CSC_MODE_SHIFT				2
+#define CSC_MODE_MASK				0x3
+#define ESMART_LB_SELECT_SHIFT			12
+#define ESMART_LB_SELECT_MASK			0x3
+
+#define RK3568_ESMART0_CTRL1			0x1804
+#define ESMART_AXI_YRGB_ID_MASK			0x1f
+#define ESMART_AXI_YRGB_ID_SHIFT		4
+#define ESMART_AXI_UV_ID_MASK			0x1f
+#define ESMART_AXI_UV_ID_SHIFT			12
+#define YMIRROR_EN_SHIFT			31
+
+#define RK3568_ESMART0_AXI_CTRL			0x1808
+#define ESMART_AXI_ID_MASK			0x1
+#define ESMART_AXI_ID_SHIFT			1
+
+#define RK3568_ESMART0_REGION0_CTRL		0x1810
+#define WIN_EN_SHIFT				0
+#define WIN_FORMAT_MASK				0x1f
+#define WIN_FORMAT_SHIFT			1
+#define REGION0_DITHER_UP_EN_SHIFT		12
+#define REGION0_RB_SWAP_SHIFT			14
+#define ESMART_XAVG_EN_SHIFT			20
+#define ESMART_XGT_EN_SHIFT			21
+#define ESMART_XGT_MODE_SHIFT			22
+
+#define RK3568_ESMART0_REGION0_YRGB_MST		0x1814
+#define RK3568_ESMART0_REGION0_CBR_MST		0x1818
+#define RK3568_ESMART0_REGION0_VIR		0x181C
+#define RK3568_ESMART0_REGION0_ACT_INFO		0x1820
+#define RK3568_ESMART0_REGION0_DSP_INFO		0x1824
+#define RK3568_ESMART0_REGION0_DSP_ST		0x1828
+#define RK3568_ESMART0_REGION0_SCL_CTRL		0x1830
+#define YRGB_XSCL_MODE_MASK			0x3
+#define YRGB_XSCL_MODE_SHIFT			0
+#define YRGB_XSCL_FILTER_MODE_MASK		0x3
+#define YRGB_XSCL_FILTER_MODE_SHIFT		2
+#define YRGB_YSCL_MODE_MASK			0x3
+#define YRGB_YSCL_MODE_SHIFT			4
+#define YRGB_YSCL_FILTER_MODE_MASK		0x3
+#define YRGB_YSCL_FILTER_MODE_SHIFT		6
+
+#define RK3568_ESMART0_REGION0_SCL_FACTOR_YRGB	0x1834
+#define RK3568_ESMART0_REGION0_SCL_FACTOR_CBR	0x1838
+#define RK3568_ESMART0_REGION0_SCL_OFFSET	0x183C
+#define RK3568_ESMART0_REGION1_CTRL		0x1840
+#define YRGB_GT2_MASK				0x1
+#define YRGB_GT2_SHIFT				8
+#define YRGB_GT4_MASK				0x1
+#define YRGB_GT4_SHIFT				9
+
+#define RK3568_ESMART0_REGION1_YRGB_MST		0x1844
+#define RK3568_ESMART0_REGION1_CBR_MST		0x1848
+#define RK3568_ESMART0_REGION1_VIR		0x184C
+#define RK3568_ESMART0_REGION1_ACT_INFO		0x1850
+#define RK3568_ESMART0_REGION1_DSP_INFO		0x1854
+#define RK3568_ESMART0_REGION1_DSP_ST		0x1858
+#define RK3568_ESMART0_REGION1_SCL_CTRL		0x1860
+#define RK3568_ESMART0_REGION1_SCL_FACTOR_YRGB	0x1864
+#define RK3568_ESMART0_REGION1_SCL_FACTOR_CBR	0x1868
+#define RK3568_ESMART0_REGION1_SCL_OFFSET	0x186C
+#define RK3568_ESMART0_REGION2_CTRL		0x1870
+#define RK3568_ESMART0_REGION2_YRGB_MST		0x1874
+#define RK3568_ESMART0_REGION2_CBR_MST		0x1878
+#define RK3568_ESMART0_REGION2_VIR		0x187C
+#define RK3568_ESMART0_REGION2_ACT_INFO		0x1880
+#define RK3568_ESMART0_REGION2_DSP_INFO		0x1884
+#define RK3568_ESMART0_REGION2_DSP_ST		0x1888
+#define RK3568_ESMART0_REGION2_SCL_CTRL		0x1890
+#define RK3568_ESMART0_REGION2_SCL_FACTOR_YRGB	0x1894
+#define RK3568_ESMART0_REGION2_SCL_FACTOR_CBR	0x1898
+#define RK3568_ESMART0_REGION2_SCL_OFFSET	0x189C
+#define RK3568_ESMART0_REGION3_CTRL		0x18A0
+#define RK3568_ESMART0_REGION3_YRGB_MST		0x18A4
+#define RK3568_ESMART0_REGION3_CBR_MST		0x18A8
+#define RK3568_ESMART0_REGION3_VIR		0x18AC
+#define RK3568_ESMART0_REGION3_ACT_INFO		0x18B0
+#define RK3568_ESMART0_REGION3_DSP_INFO		0x18B4
+#define RK3568_ESMART0_REGION3_DSP_ST		0x18B8
+#define RK3568_ESMART0_REGION3_SCL_CTRL		0x18C0
+#define RK3568_ESMART0_REGION3_SCL_FACTOR_YRGB	0x18C4
+#define RK3568_ESMART0_REGION3_SCL_FACTOR_CBR	0x18C8
+#define RK3568_ESMART0_REGION3_SCL_OFFSET	0x18CC
+
+#define RK3568_ESMART1_CTRL0			0x1A00
+#define RK3568_ESMART1_CTRL1			0x1A04
+#define RK3568_ESMART1_REGION0_CTRL		0x1A10
+#define RK3568_ESMART1_REGION0_YRGB_MST		0x1A14
+#define RK3568_ESMART1_REGION0_CBR_MST		0x1A18
+#define RK3568_ESMART1_REGION0_VIR		0x1A1C
+#define RK3568_ESMART1_REGION0_ACT_INFO		0x1A20
+#define RK3568_ESMART1_REGION0_DSP_INFO		0x1A24
+#define RK3568_ESMART1_REGION0_DSP_ST		0x1A28
+#define RK3568_ESMART1_REGION0_SCL_CTRL		0x1A30
+#define RK3568_ESMART1_REGION0_SCL_FACTOR_YRGB	0x1A34
+#define RK3568_ESMART1_REGION0_SCL_FACTOR_CBR	0x1A38
+#define RK3568_ESMART1_REGION0_SCL_OFFSET	0x1A3C
+#define RK3568_ESMART1_REGION1_CTRL		0x1A40
+#define RK3568_ESMART1_REGION1_YRGB_MST		0x1A44
+#define RK3568_ESMART1_REGION1_CBR_MST		0x1A48
+#define RK3568_ESMART1_REGION1_VIR		0x1A4C
+#define RK3568_ESMART1_REGION1_ACT_INFO		0x1A50
+#define RK3568_ESMART1_REGION1_DSP_INFO		0x1A54
+#define RK3568_ESMART1_REGION1_DSP_ST		0x1A58
+#define RK3568_ESMART1_REGION1_SCL_CTRL		0x1A60
+#define RK3568_ESMART1_REGION1_SCL_FACTOR_YRGB	0x1A64
+#define RK3568_ESMART1_REGION1_SCL_FACTOR_CBR	0x1A68
+#define RK3568_ESMART1_REGION1_SCL_OFFSET	0x1A6C
+#define RK3568_ESMART1_REGION2_CTRL		0x1A70
+#define RK3568_ESMART1_REGION2_YRGB_MST		0x1A74
+#define RK3568_ESMART1_REGION2_CBR_MST		0x1A78
+#define RK3568_ESMART1_REGION2_VIR		0x1A7C
+#define RK3568_ESMART1_REGION2_ACT_INFO		0x1A80
+#define RK3568_ESMART1_REGION2_DSP_INFO		0x1A84
+#define RK3568_ESMART1_REGION2_DSP_ST		0x1A88
+#define RK3568_ESMART1_REGION2_SCL_CTRL		0x1A90
+#define RK3568_ESMART1_REGION2_SCL_FACTOR_YRGB	0x1A94
+#define RK3568_ESMART1_REGION2_SCL_FACTOR_CBR	0x1A98
+#define RK3568_ESMART1_REGION2_SCL_OFFSET	0x1A9C
+#define RK3568_ESMART1_REGION3_CTRL		0x1AA0
+#define RK3568_ESMART1_REGION3_YRGB_MST		0x1AA4
+#define RK3568_ESMART1_REGION3_CBR_MST		0x1AA8
+#define RK3568_ESMART1_REGION3_VIR		0x1AAC
+#define RK3568_ESMART1_REGION3_ACT_INFO		0x1AB0
+#define RK3568_ESMART1_REGION3_DSP_INFO		0x1AB4
+#define RK3568_ESMART1_REGION3_DSP_ST		0x1AB8
+#define RK3568_ESMART1_REGION3_SCL_CTRL		0x1AC0
+#define RK3568_ESMART1_REGION3_SCL_FACTOR_YRGB	0x1AC4
+#define RK3568_ESMART1_REGION3_SCL_FACTOR_CBR	0x1AC8
+#define RK3568_ESMART1_REGION3_SCL_OFFSET	0x1ACC
+
+#define RK3568_SMART0_CTRL0			0x1C00
+#define RK3568_SMART0_CTRL1			0x1C04
+#define RK3568_SMART0_REGION0_CTRL		0x1C10
+#define RK3568_SMART0_REGION0_YRGB_MST		0x1C14
+#define RK3568_SMART0_REGION0_CBR_MST		0x1C18
+#define RK3568_SMART0_REGION0_VIR		0x1C1C
+#define RK3568_SMART0_REGION0_ACT_INFO		0x1C20
+#define RK3568_SMART0_REGION0_DSP_INFO		0x1C24
+#define RK3568_SMART0_REGION0_DSP_ST		0x1C28
+#define RK3568_SMART0_REGION0_SCL_CTRL		0x1C30
+#define RK3568_SMART0_REGION0_SCL_FACTOR_YRGB	0x1C34
+#define RK3568_SMART0_REGION0_SCL_FACTOR_CBR	0x1C38
+#define RK3568_SMART0_REGION0_SCL_OFFSET	0x1C3C
+#define RK3568_SMART0_REGION1_CTRL		0x1C40
+#define RK3568_SMART0_REGION1_YRGB_MST		0x1C44
+#define RK3568_SMART0_REGION1_CBR_MST		0x1C48
+#define RK3568_SMART0_REGION1_VIR		0x1C4C
+#define RK3568_SMART0_REGION1_ACT_INFO		0x1C50
+#define RK3568_SMART0_REGION1_DSP_INFO		0x1C54
+#define RK3568_SMART0_REGION1_DSP_ST		0x1C58
+#define RK3568_SMART0_REGION1_SCL_CTRL		0x1C60
+#define RK3568_SMART0_REGION1_SCL_FACTOR_YRGB	0x1C64
+#define RK3568_SMART0_REGION1_SCL_FACTOR_CBR	0x1C68
+#define RK3568_SMART0_REGION1_SCL_OFFSET	0x1C6C
+#define RK3568_SMART0_REGION2_CTRL		0x1C70
+#define RK3568_SMART0_REGION2_YRGB_MST		0x1C74
+#define RK3568_SMART0_REGION2_CBR_MST		0x1C78
+#define RK3568_SMART0_REGION2_VIR		0x1C7C
+#define RK3568_SMART0_REGION2_ACT_INFO		0x1C80
+#define RK3568_SMART0_REGION2_DSP_INFO		0x1C84
+#define RK3568_SMART0_REGION2_DSP_ST		0x1C88
+#define RK3568_SMART0_REGION2_SCL_CTRL		0x1C90
+#define RK3568_SMART0_REGION2_SCL_FACTOR_YRGB	0x1C94
+#define RK3568_SMART0_REGION2_SCL_FACTOR_CBR	0x1C98
+#define RK3568_SMART0_REGION2_SCL_OFFSET	0x1C9C
+#define RK3568_SMART0_REGION3_CTRL		0x1CA0
+#define RK3568_SMART0_REGION3_YRGB_MST		0x1CA4
+#define RK3568_SMART0_REGION3_CBR_MST		0x1CA8
+#define RK3568_SMART0_REGION3_VIR		0x1CAC
+#define RK3568_SMART0_REGION3_ACT_INFO		0x1CB0
+#define RK3568_SMART0_REGION3_DSP_INFO		0x1CB4
+#define RK3568_SMART0_REGION3_DSP_ST		0x1CB8
+#define RK3568_SMART0_REGION3_SCL_CTRL		0x1CC0
+#define RK3568_SMART0_REGION3_SCL_FACTOR_YRGB	0x1CC4
+#define RK3568_SMART0_REGION3_SCL_FACTOR_CBR	0x1CC8
+#define RK3568_SMART0_REGION3_SCL_OFFSET	0x1CCC
+
+#define RK3568_SMART1_CTRL0			0x1E00
+#define RK3568_SMART1_CTRL1			0x1E04
+#define RK3568_SMART1_REGION0_CTRL		0x1E10
+#define RK3568_SMART1_REGION0_YRGB_MST		0x1E14
+#define RK3568_SMART1_REGION0_CBR_MST		0x1E18
+#define RK3568_SMART1_REGION0_VIR		0x1E1C
+#define RK3568_SMART1_REGION0_ACT_INFO		0x1E20
+#define RK3568_SMART1_REGION0_DSP_INFO		0x1E24
+#define RK3568_SMART1_REGION0_DSP_ST		0x1E28
+#define RK3568_SMART1_REGION0_SCL_CTRL		0x1E30
+#define RK3568_SMART1_REGION0_SCL_FACTOR_YRGB	0x1E34
+#define RK3568_SMART1_REGION0_SCL_FACTOR_CBR	0x1E38
+#define RK3568_SMART1_REGION0_SCL_OFFSET	0x1E3C
+#define RK3568_SMART1_REGION1_CTRL		0x1E40
+#define RK3568_SMART1_REGION1_YRGB_MST		0x1E44
+#define RK3568_SMART1_REGION1_CBR_MST		0x1E48
+#define RK3568_SMART1_REGION1_VIR		0x1E4C
+#define RK3568_SMART1_REGION1_ACT_INFO		0x1E50
+#define RK3568_SMART1_REGION1_DSP_INFO		0x1E54
+#define RK3568_SMART1_REGION1_DSP_ST		0x1E58
+#define RK3568_SMART1_REGION1_SCL_CTRL		0x1E60
+#define RK3568_SMART1_REGION1_SCL_FACTOR_YRGB	0x1E64
+#define RK3568_SMART1_REGION1_SCL_FACTOR_CBR	0x1E68
+#define RK3568_SMART1_REGION1_SCL_OFFSET	0x1E6C
+#define RK3568_SMART1_REGION2_CTRL		0x1E70
+#define RK3568_SMART1_REGION2_YRGB_MST		0x1E74
+#define RK3568_SMART1_REGION2_CBR_MST		0x1E78
+#define RK3568_SMART1_REGION2_VIR		0x1E7C
+#define RK3568_SMART1_REGION2_ACT_INFO		0x1E80
+#define RK3568_SMART1_REGION2_DSP_INFO		0x1E84
+#define RK3568_SMART1_REGION2_DSP_ST		0x1E88
+#define RK3568_SMART1_REGION2_SCL_CTRL		0x1E90
+#define RK3568_SMART1_REGION2_SCL_FACTOR_YRGB	0x1E94
+#define RK3568_SMART1_REGION2_SCL_FACTOR_CBR	0x1E98
+#define RK3568_SMART1_REGION2_SCL_OFFSET	0x1E9C
+#define RK3568_SMART1_REGION3_CTRL		0x1EA0
+#define RK3568_SMART1_REGION3_YRGB_MST		0x1EA4
+#define RK3568_SMART1_REGION3_CBR_MST		0x1EA8
+#define RK3568_SMART1_REGION3_VIR		0x1EAC
+#define RK3568_SMART1_REGION3_ACT_INFO		0x1EB0
+#define RK3568_SMART1_REGION3_DSP_INFO		0x1EB4
+#define RK3568_SMART1_REGION3_DSP_ST		0x1EB8
+#define RK3568_SMART1_REGION3_SCL_CTRL		0x1EC0
+#define RK3568_SMART1_REGION3_SCL_FACTOR_YRGB	0x1EC4
+#define RK3568_SMART1_REGION3_SCL_FACTOR_CBR	0x1EC8
+#define RK3568_SMART1_REGION3_SCL_OFFSET	0x1ECC
+
+/* HDR register definition */
+#define RK3568_HDR_LUT_CTRL			0x2000
+
+#define RK3588_VP3_DSP_CTRL			0xF00
+#define RK3588_CLUSTER2_WIN0_CTRL0		0x1400
+#define RK3588_CLUSTER3_WIN0_CTRL0		0x1600
+
+/* DSC 8K/4K register definition */
+#define RK3588_DSC_8K_PPS0_3			0x4000
+#define RK3588_DSC_8K_CTRL0			0x40A0
+#define DSC_EN_SHIFT				0
+#define DSC_RBIT_SHIFT				2
+#define DSC_RBYT_SHIFT				3
+#define DSC_FLAL_SHIFT				4
+#define DSC_MER_SHIFT				5
+#define DSC_EPB_SHIFT				6
+#define DSC_EPL_SHIFT				7
+#define DSC_NSLC_MASK				0x7
+#define DSC_NSLC_SHIFT				16
+#define DSC_SBO_SHIFT				28
+#define DSC_IFEP_SHIFT				29
+#define DSC_PPS_UPD_SHIFT			31
+#define DSC_CTRL0_DEF_CON ((1 << DSC_EN_SHIFT)   | (1 << DSC_RBIT_SHIFT) | (0 << DSC_RBYT_SHIFT) | \
+			   (1 << DSC_FLAL_SHIFT) | (1 << DSC_MER_SHIFT)  | (0 << DSC_EPB_SHIFT)  | \
+			   (1 << DSC_EPL_SHIFT)  | (1 << DSC_SBO_SHIFT))
+
+#define RK3588_DSC_8K_CTRL1			0x40A4
+#define RK3588_DSC_8K_STS0			0x40A8
+#define RK3588_DSC_8K_ERS			0x40C4
+
+#define RK3588_DSC_4K_PPS0_3			0x4100
+#define RK3588_DSC_4K_CTRL0			0x41A0
+#define RK3588_DSC_4K_CTRL1			0x41A4
+#define RK3588_DSC_4K_STS0			0x41A8
+#define RK3588_DSC_4K_ERS			0x41C4
+
+/* RK3528 HDR register definition */
+#define RK3528_HDR_LUT_CTRL			0x2000
+
+/* RK3528 ACM register definition */
+#define RK3528_ACM_CTRL				0x6400
+#define RK3528_ACM_DELTA_RANGE			0x6404
+#define RK3528_ACM_FETCH_START			0x6408
+#define RK3528_ACM_FETCH_DONE			0x6420
+#define RK3528_ACM_YHS_DEL_HY_SEG0		0x6500
+#define RK3528_ACM_YHS_DEL_HY_SEG152		0x6760
+#define RK3528_ACM_YHS_DEL_HS_SEG0		0x6764
+#define RK3528_ACM_YHS_DEL_HS_SEG220		0x6ad4
+#define RK3528_ACM_YHS_DEL_HGAIN_SEG0		0x6ad8
+#define RK3528_ACM_YHS_DEL_HGAIN_SEG64		0x6bd8
+
+#define RK3568_MAX_REG				0x1ED0
+
+#define RK3562_GRF_IOC_VO_IO_CON		0x10500
+#define RK3568_GRF_VO_CON1			0x0364
+#define GRF_BT656_CLK_INV_SHIFT			1
+#define GRF_BT1120_CLK_INV_SHIFT		2
+#define GRF_RGB_DCLK_INV_SHIFT			3
+
+#define RK3588_GRF_SOC_CON1			0x0304
+#define RK3588_GRF_VOP_DCLK_INV_SEL_SHIFT	14
+
+#define RK3588_GRF_VOP_CON2			0x0008
+#define RK3588_GRF_EDP0_ENABLE_SHIFT		0
+#define RK3588_GRF_HDMITX0_ENABLE_SHIFT		1
+#define RK3588_GRF_EDP1_ENABLE_SHIFT		3
+#define RK3588_GRF_HDMITX1_ENABLE_SHIFT		4
+
+#define RK3588_GRF_VO1_CON0			0x0000
+#define HDMI_SYNC_POL_MASK			0x3
+#define HDMI0_SYNC_POL_SHIFT			5
+#define HDMI1_SYNC_POL_SHIFT			7
+
+#define RK3588_PMU_BISR_CON3			0x20C
+#define RK3588_PD_CLUSTER0_REPAIR_EN_SHIFT	9
+#define RK3588_PD_CLUSTER1_REPAIR_EN_SHIFT	10
+#define RK3588_PD_CLUSTER2_REPAIR_EN_SHIFT	11
+#define RK3588_PD_CLUSTER3_REPAIR_EN_SHIFT	12
+#define RK3588_PD_DSC_8K_REPAIR_EN_SHIFT	13
+#define RK3588_PD_DSC_4K_REPAIR_EN_SHIFT	14
+#define RK3588_PD_ESMART_REPAIR_EN_SHIFT	15
+
+#define RK3588_PMU_BISR_STATUS5			0x294
+#define RK3588_PD_CLUSTER0_PWR_STAT_SHIFI	9
+#define RK3588_PD_CLUSTER1_PWR_STAT_SHIFI	10
+#define RK3588_PD_CLUSTER2_PWR_STAT_SHIFI	11
+#define RK3588_PD_CLUSTER3_PWR_STAT_SHIFI	12
+#define RK3588_PD_DSC_8K_PWR_STAT_SHIFI		13
+#define RK3588_PD_DSC_4K_PWR_STAT_SHIFI		14
+#define RK3588_PD_ESMART_PWR_STAT_SHIFI		15
+
+#define VOP2_LAYER_MAX				8
+
+#define VOP2_MAX_VP_OUTPUT_WIDTH		4096
+
+#define VOP_FEATURE_OUTPUT_10BIT		BIT(0)
+
+/* KHz */
+#define VOP2_MAX_DCLK_RATE			600000
+
+/*
+ * vop2 dsc id
+ */
+#define ROCKCHIP_VOP2_DSC_8K	0
+#define ROCKCHIP_VOP2_DSC_4K	1
+
+/*
+ * vop2 internal power domain id,
+ * should be all none zero, 0 will be
+ * treat as invalid;
+ */
+#define VOP2_PD_CLUSTER0			BIT(0)
+#define VOP2_PD_CLUSTER1			BIT(1)
+#define VOP2_PD_CLUSTER2			BIT(2)
+#define VOP2_PD_CLUSTER3			BIT(3)
+#define VOP2_PD_DSC_8K				BIT(5)
+#define VOP2_PD_DSC_4K				BIT(6)
+#define VOP2_PD_ESMART				BIT(7)
+
+#define VOP2_PLANE_NO_SCALING			BIT(16)
+
+#define VOP_FEATURE_OUTPUT_10BIT	BIT(0)
+#define VOP_FEATURE_AFBDC		BIT(1)
+#define VOP_FEATURE_ALPHA_SCALE		BIT(2)
+#define VOP_FEATURE_HDR10		BIT(3)
+#define VOP_FEATURE_NEXT_HDR		BIT(4)
+/* a feature to splice two windows and two vps to support resolution > 4096 */
+#define VOP_FEATURE_SPLICE		BIT(5)
+#define VOP_FEATURE_OVERSCAN		BIT(6)
+#define VOP_FEATURE_VIVID_HDR		BIT(7)
+#define VOP_FEATURE_POST_ACM		BIT(8)
+#define VOP_FEATURE_POST_CSC		BIT(9)
+
+#define WIN_FEATURE_HDR2SDR		BIT(0)
+#define WIN_FEATURE_SDR2HDR		BIT(1)
+#define WIN_FEATURE_PRE_OVERLAY		BIT(2)
+#define WIN_FEATURE_AFBDC		BIT(3)
+#define WIN_FEATURE_CLUSTER_MAIN	BIT(4)
+#define WIN_FEATURE_CLUSTER_SUB		BIT(5)
+/* a mirror win can only get fb address
+ * from source win:
+ * Cluster1---->Cluster0
+ * Esmart1 ---->Esmart0
+ * Smart1  ---->Smart0
+ * This is a feather on rk3566
+ */
+#define WIN_FEATURE_MIRROR		BIT(6)
+#define WIN_FEATURE_MULTI_AREA		BIT(7)
+#define WIN_FEATURE_Y2R_13BIT_DEPTH	BIT(8)
+
+#define V4L2_COLORSPACE_BT709F		0xfe
+#define V4L2_COLORSPACE_BT2020F		0xff
+
+enum vop_csc_format {
+	CSC_BT601L,
+	CSC_BT709L,
+	CSC_BT601F,
+	CSC_BT2020,
+	CSC_BT709L_13BIT,
+	CSC_BT709F_13BIT,
+	CSC_BT2020L_13BIT,
+	CSC_BT2020F_13BIT,
+};
+
+enum vop_csc_bit_depth {
+	CSC_10BIT_DEPTH,
+	CSC_13BIT_DEPTH,
+};
+
+enum vop2_pol {
+	HSYNC_POSITIVE = 0,
+	VSYNC_POSITIVE = 1,
+	DEN_NEGATIVE   = 2,
+	DCLK_INVERT    = 3
+};
+
+enum vop2_bcsh_out_mode {
+	BCSH_OUT_MODE_BLACK,
+	BCSH_OUT_MODE_BLUE,
+	BCSH_OUT_MODE_COLOR_BAR,
+	BCSH_OUT_MODE_NORMAL_VIDEO,
+};
+
+#define _VOP_REG(off, _mask, _shift, _write_mask) \
+		{ \
+		 .offset = off, \
+		 .mask = _mask, \
+		 .shift = _shift, \
+		 .write_mask = _write_mask, \
+		}
+
+#define VOP_REG(off, _mask, _shift) \
+		_VOP_REG(off, _mask, _shift, false)
+enum dither_down_mode {
+	RGB888_TO_RGB565 = 0x0,
+	RGB888_TO_RGB666 = 0x1
+};
+
+enum vop2_video_ports_id {
+	VOP2_VP0,
+	VOP2_VP1,
+	VOP2_VP2,
+	VOP2_VP3,
+	VOP2_VP_MAX,
+};
+
+enum vop2_layer_type {
+	CLUSTER_LAYER = 0,
+	ESMART_LAYER = 1,
+	SMART_LAYER = 2,
+};
+
+/* This define must same with kernel win phy id */
+enum vop2_layer_phy_id {
+	ROCKCHIP_VOP2_CLUSTER0 = 0,
+	ROCKCHIP_VOP2_CLUSTER1,
+	ROCKCHIP_VOP2_ESMART0,
+	ROCKCHIP_VOP2_ESMART1,
+	ROCKCHIP_VOP2_SMART0,
+	ROCKCHIP_VOP2_SMART1,
+	ROCKCHIP_VOP2_CLUSTER2,
+	ROCKCHIP_VOP2_CLUSTER3,
+	ROCKCHIP_VOP2_ESMART2,
+	ROCKCHIP_VOP2_ESMART3,
+	ROCKCHIP_VOP2_LAYER_MAX,
+};
+
+enum vop2_scale_up_mode {
+	VOP2_SCALE_UP_NRST_NBOR,
+	VOP2_SCALE_UP_BIL,
+	VOP2_SCALE_UP_BIC,
+};
+
+enum vop2_scale_down_mode {
+	VOP2_SCALE_DOWN_NRST_NBOR,
+	VOP2_SCALE_DOWN_BIL,
+	VOP2_SCALE_DOWN_AVG,
+};
+
+enum scale_mode {
+	SCALE_NONE = 0x0,
+	SCALE_UP   = 0x1,
+	SCALE_DOWN = 0x2
+};
+
+enum vop_dsc_interface_mode {
+	VOP_DSC_IF_DISABLE = 0,
+	VOP_DSC_IF_HDMI = 1,
+	VOP_DSC_IF_MIPI_DS_MODE = 2,
+	VOP_DSC_IF_MIPI_VIDEO_MODE = 3,
+};
+
+enum vop3_pre_scale_down_mode {
+	VOP3_PRE_SCALE_UNSPPORT,
+	VOP3_PRE_SCALE_DOWN_GT,
+	VOP3_PRE_SCALE_DOWN_AVG,
+};
+
+enum vop3_esmart_lb_mode {
+	VOP3_ESMART_8K_MODE,
+	VOP3_ESMART_4K_4K_MODE,
+	VOP3_ESMART_4K_2K_2K_MODE,
+	VOP3_ESMART_2K_2K_2K_2K_MODE,
+};
+
+struct vop2_layer {
+	u8 id;
+	/**
+	 * @win_phys_id: window id of the layer selected.
+	 * Every layer must make sure to select different
+	 * windows of others.
+	 */
+	u8 win_phys_id;
+};
+
+struct vop2_power_domain_data {
+	u8 id;
+	u8 parent_id;
+	/*
+	 * @module_id_mask: module id of which module this power domain is belongs to.
+	 * PD_CLUSTER0,1,2,3 only belongs to CLUSTER0/1/2/3, PD_Esmart0 shared by Esmart1/2/3
+	 */
+	u32 module_id_mask;
+};
+
+struct vop2_win_data {
+	char *name;
+	u8 phys_id;
+	enum vop2_layer_type type;
+	u8 win_sel_port_offset;
+	u8 layer_sel_win_id[VOP2_VP_MAX];
+	u8 axi_id;
+	u8 axi_uv_id;
+	u8 axi_yrgb_id;
+	u8 splice_win_id;
+	u8 pd_id;
+	u8 hsu_filter_mode;
+	u8 hsd_filter_mode;
+	u8 vsu_filter_mode;
+	u8 vsd_filter_mode;
+	u8 hsd_pre_filter_mode;
+	u8 vsd_pre_filter_mode;
+	u8 scale_engine_num;
+	u8 source_win_id;
+	u32 reg_offset;
+	u32 max_upscale_factor;
+	u32 max_downscale_factor;
+	u32 feature;
+	bool splice_mode_right;
+};
+
+struct vop2_vp_data {
+	u32 feature;
+	u8 pre_scan_max_dly;
+	u8 layer_mix_dly;
+	u8 hdr_mix_dly;
+	u8 win_dly;
+	u8 splice_vp_id;
+	struct vop_rect max_output;
+	u32 max_dclk;
+};
+
+struct vop2_plane_table {
+	enum vop2_layer_phy_id plane_id;
+	enum vop2_layer_type plane_type;
+};
+
+struct vop2_vp_plane_mask {
+	u8 primary_plane_id; /* use this win to show logo */
+	u8 attached_layers_nr; /* number layers attach to this vp */
+	u8 attached_layers[VOP2_LAYER_MAX]; /* the layers attached to this vp */
+	u32 plane_mask;
+	int cursor_plane_id;
+};
+
+struct vop2_dsc_data {
+	u8 id;
+	u8 pd_id;
+	u8 max_slice_num;
+	u8 max_linebuf_depth;	/* used to generate the bitstream */
+	u8 min_bits_per_pixel;	/* bit num after encoder compress */
+	const char *dsc_txp_clk_src_name;
+	const char *dsc_txp_clk_name;
+	const char *dsc_pxl_clk_name;
+	const char *dsc_cds_clk_name;
+};
+
+struct dsc_error_info {
+	u32 dsc_error_val;
+	char dsc_error_info[50];
+};
+
+struct vop2_dump_regs {
+	u32 offset;
+	const char *name;
+	u32 state_base;
+	u32 state_mask;
+	u32 state_shift;
+	bool enable_state;
+};
+
+struct vop2_data {
+	u32 version;
+	u32 esmart_lb_mode;
+	struct vop2_vp_data *vp_data;
+	struct vop2_win_data *win_data;
+	struct vop2_vp_plane_mask *plane_mask;
+	struct vop2_plane_table *plane_table;
+	struct vop2_power_domain_data *pd;
+	struct vop2_dsc_data *dsc;
+	struct dsc_error_info *dsc_error_ecw;
+	struct dsc_error_info *dsc_error_buffer_flow;
+	struct vop2_dump_regs *dump_regs;
+	u8 *vp_primary_plane_order;
+	u8 nr_vps;
+	u8 nr_layers;
+	u8 nr_mixers;
+	u8 nr_gammas;
+	u8 nr_pd;
+	u8 nr_dscs;
+	u8 nr_dsc_ecw;
+	u8 nr_dsc_buffer_flow;
+	u32 reg_len;
+	u32 dump_regs_size;
+};
+
+struct vop2 {
+	u32 *regsbak;
+	void *regs;
+	void *grf;
+	void *vop_grf;
+	void *vo1_grf;
+	void *sys_pmu;
+	u32 reg_len;
+	u32 version;
+	u32 esmart_lb_mode;
+	bool global_init;
+	const struct vop2_data *data;
+	struct vop2_vp_plane_mask vp_plane_mask[VOP2_VP_MAX];
+};
+
+static struct vop2 *rockchip_vop2;
+
+static inline bool is_vop3(struct vop2 *vop2)
+{
+	if (vop2->version == VOP_VERSION_RK3568 || vop2->version == VOP_VERSION_RK3588)
+		return false;
+	else
+		return true;
+}
+
+/*
+ * bli_sd_factor = (src - 1) / (dst - 1) << 12;
+ * avg_sd_factor:
+ * bli_su_factor:
+ * bic_su_factor:
+ * = (src - 1) / (dst - 1) << 16;
+ *
+ * ygt2 enable: dst get one line from two line of the src
+ * ygt4 enable: dst get one line from four line of the src.
+ *
+ */
+#define VOP2_BILI_SCL_DN(src, dst)	(((src - 1) << 12) / (dst - 1))
+#define VOP2_COMMON_SCL(src, dst)	(((src - 1) << 16) / (dst - 1))
+
+#define VOP2_BILI_SCL_FAC_CHECK(src, dst, fac)	 \
+				(fac * (dst - 1) >> 12 < (src - 1))
+#define VOP2_COMMON_SCL_FAC_CHECK(src, dst, fac) \
+				(fac * (dst - 1) >> 16 < (src - 1))
+#define VOP3_COMMON_HOR_SCL_FAC_CHECK(src, dst, fac) \
+				(fac * (dst - 1) >> 16 < (src - 1))
+
+static uint16_t vop2_scale_factor(enum scale_mode mode,
+				  int32_t filter_mode,
+				  uint32_t src, uint32_t dst)
+{
+	uint32_t fac = 0;
+	int i = 0;
+
+	if (mode == SCALE_NONE)
+		return 0;
+
+	/*
+	 * A workaround to avoid zero div.
+	 */
+	if ((dst == 1) || (src == 1)) {
+		dst = dst + 1;
+		src = src + 1;
+	}
+
+	if ((mode == SCALE_DOWN) && (filter_mode == VOP2_SCALE_DOWN_BIL)) {
+		fac = VOP2_BILI_SCL_DN(src, dst);
+		for (i = 0; i < 100; i++) {
+			if (VOP2_BILI_SCL_FAC_CHECK(src, dst, fac))
+				break;
+			fac -= 1;
+			printf("down fac cali: src:%d, dst:%d, fac:0x%x\n", src, dst, fac);
+		}
+	} else {
+		fac = VOP2_COMMON_SCL(src, dst);
+		for (i = 0; i < 100; i++) {
+			if (VOP2_COMMON_SCL_FAC_CHECK(src, dst, fac))
+				break;
+			fac -= 1;
+			printf("up fac cali:  src:%d, dst:%d, fac:0x%x\n", src, dst, fac);
+		}
+	}
+
+	return fac;
+}
+
+static bool vop3_scale_up_fac_check(uint32_t src, uint32_t dst, uint32_t fac, bool is_hor)
+{
+	if (is_hor)
+		return VOP3_COMMON_HOR_SCL_FAC_CHECK(src, dst, fac);
+	return VOP2_COMMON_SCL_FAC_CHECK(src, dst, fac);
+}
+
+static uint16_t vop3_scale_factor(enum scale_mode mode,
+				  uint32_t src, uint32_t dst, bool is_hor)
+{
+	uint32_t fac = 0;
+	int i = 0;
+
+	if (mode == SCALE_NONE)
+		return 0;
+
+	/*
+	 * A workaround to avoid zero div.
+	 */
+	if ((dst == 1) || (src == 1)) {
+		dst = dst + 1;
+		src = src + 1;
+	}
+
+	if (mode == SCALE_DOWN) {
+		fac = VOP2_BILI_SCL_DN(src, dst);
+		for (i = 0; i < 100; i++) {
+			if (VOP2_BILI_SCL_FAC_CHECK(src, dst, fac))
+				break;
+			fac -= 1;
+			printf("down fac cali: src:%d, dst:%d, fac:0x%x\n", src, dst, fac);
+		}
+	} else {
+		fac = VOP2_COMMON_SCL(src, dst);
+		for (i = 0; i < 100; i++) {
+			if (vop3_scale_up_fac_check(src, dst, fac, is_hor))
+				break;
+			fac -= 1;
+			printf("up fac cali:  src:%d, dst:%d, fac:0x%x\n", src, dst, fac);
+		}
+	}
+
+	return fac;
+}
+
+static inline enum scale_mode scl_get_scl_mode(int src, int dst)
+{
+	if (src < dst)
+		return SCALE_UP;
+	else if (src > dst)
+		return SCALE_DOWN;
+
+	return SCALE_NONE;
+}
+
+static inline int interpolate(int x1, int y1, int x2, int y2, int x)
+{
+	return y1 + (y2 - y1) * (x - x1) / (x2 - x1);
+}
+
+static int vop2_get_primary_plane(struct vop2 *vop2, u32 plane_mask)
+{
+	int i = 0;
+
+	for (i = 0; i < vop2->data->nr_layers; i++) {
+		if (plane_mask & BIT(vop2->data->vp_primary_plane_order[i]))
+			return vop2->data->vp_primary_plane_order[i];
+	}
+
+	return vop2->data->vp_primary_plane_order[0];
+}
+
+static inline u16 scl_cal_scale(int src, int dst, int shift)
+{
+	return ((src * 2 - 3) << (shift - 1)) / (dst - 1);
+}
+
+static inline u16 scl_cal_scale2(int src, int dst)
+{
+	return ((src - 1) << 12) / (dst - 1);
+}
+
+static inline void vop2_writel(struct vop2 *vop2, u32 offset, u32 v)
+{
+	writel(v, vop2->regs + offset);
+	vop2->regsbak[offset >> 2] = v;
+}
+
+static inline u32 vop2_readl(struct vop2 *vop2, u32 offset)
+{
+	return readl(vop2->regs + offset);
+}
+
+static inline void vop2_mask_write(struct vop2 *vop2, u32 offset,
+				   u32 mask, u32 shift, u32 v,
+				   bool write_mask)
+{
+	if (!mask)
+		return;
+
+	if (write_mask) {
+		v = ((v & mask) << shift) | (mask << (shift + 16));
+	} else {
+		u32 cached_val = vop2->regsbak[offset >> 2];
+
+		v = (cached_val & ~(mask << shift)) | ((v & mask) << shift);
+		vop2->regsbak[offset >> 2] = v;
+	}
+
+	writel(v, vop2->regs + offset);
+}
+
+static inline void vop2_grf_writel(struct vop2 *vop, void *grf_base, u32 offset,
+				   u32 mask, u32 shift, u32 v)
+{
+	u32 val = 0;
+
+	val = (v << shift) | (mask << (shift + 16));
+	writel(val, grf_base + offset);
+}
+
+static inline u32 vop2_grf_readl(struct vop2 *vop, void *grf_base, u32 offset,
+				  u32 mask, u32 shift)
+{
+	return (readl(grf_base + offset) >> shift) & mask;
+}
+
+static char *get_plane_name(int plane_id, char *name)
+{
+	switch (plane_id) {
+	case ROCKCHIP_VOP2_CLUSTER0:
+		strcat(name, "Cluster0");
+		break;
+	case ROCKCHIP_VOP2_CLUSTER1:
+		strcat(name, "Cluster1");
+		break;
+	case ROCKCHIP_VOP2_ESMART0:
+		strcat(name, "Esmart0");
+		break;
+	case ROCKCHIP_VOP2_ESMART1:
+		strcat(name, "Esmart1");
+		break;
+	case ROCKCHIP_VOP2_SMART0:
+		strcat(name, "Smart0");
+		break;
+	case ROCKCHIP_VOP2_SMART1:
+		strcat(name, "Smart1");
+		break;
+	case ROCKCHIP_VOP2_CLUSTER2:
+		strcat(name, "Cluster2");
+		break;
+	case ROCKCHIP_VOP2_CLUSTER3:
+		strcat(name, "Cluster3");
+		break;
+	case ROCKCHIP_VOP2_ESMART2:
+		strcat(name, "Esmart2");
+		break;
+	case ROCKCHIP_VOP2_ESMART3:
+		strcat(name, "Esmart3");
+		break;
+	}
+
+	return name;
+}
+
+static bool is_yuv_output(u32 bus_format)
+{
+	switch (bus_format) {
+	case MEDIA_BUS_FMT_YUV8_1X24:
+	case MEDIA_BUS_FMT_YUV10_1X30:
+	case MEDIA_BUS_FMT_YUYV10_1X20:
+	case MEDIA_BUS_FMT_UYYVYY8_0_5X24:
+	case MEDIA_BUS_FMT_UYYVYY10_0_5X30:
+	case MEDIA_BUS_FMT_YUYV8_2X8:
+	case MEDIA_BUS_FMT_YVYU8_2X8:
+	case MEDIA_BUS_FMT_UYVY8_2X8:
+	case MEDIA_BUS_FMT_VYUY8_2X8:
+	case MEDIA_BUS_FMT_YUYV8_1X16:
+	case MEDIA_BUS_FMT_YVYU8_1X16:
+	case MEDIA_BUS_FMT_UYVY8_1X16:
+	case MEDIA_BUS_FMT_VYUY8_1X16:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static int vop2_convert_csc_mode(int csc_mode, int bit_depth)
+{
+	switch (csc_mode) {
+	case V4L2_COLORSPACE_SMPTE170M:
+	case V4L2_COLORSPACE_470_SYSTEM_M:
+	case V4L2_COLORSPACE_470_SYSTEM_BG:
+		return CSC_BT601L;
+	case V4L2_COLORSPACE_REC709:
+	case V4L2_COLORSPACE_SMPTE240M:
+	case V4L2_COLORSPACE_DEFAULT:
+		if (bit_depth == CSC_13BIT_DEPTH)
+			return CSC_BT709L_13BIT;
+		else
+			return CSC_BT709L;
+	case V4L2_COLORSPACE_JPEG:
+		return CSC_BT601F;
+	case V4L2_COLORSPACE_BT2020:
+		if (bit_depth == CSC_13BIT_DEPTH)
+			return CSC_BT2020L_13BIT;
+		else
+			return CSC_BT2020;
+	case V4L2_COLORSPACE_BT709F:
+		if (bit_depth == CSC_10BIT_DEPTH) {
+			printf("WARN: Unsupported bt709f at 10bit csc depth, use bt601f instead\n");
+			return CSC_BT601F;
+		} else {
+			return CSC_BT709F_13BIT;
+		}
+	case V4L2_COLORSPACE_BT2020F:
+		if (bit_depth == CSC_10BIT_DEPTH) {
+			printf("WARN: Unsupported bt2020f at 10bit csc depth, use bt601f instead\n");
+			return CSC_BT601F;
+		} else {
+			return CSC_BT2020F_13BIT;
+		}
+	default:
+		return CSC_BT709L;
+	}
+}
+
+static bool is_uv_swap(u32 bus_format, u32 output_mode)
+{
+	/*
+	 * FIXME:
+	 *
+	 * There is no media type for YUV444 output,
+	 * so when out_mode is AAAA or P888, assume output is YUV444 on
+	 * yuv format.
+	 *
+	 * From H/W testing, YUV444 mode need a rb swap.
+	 */
+	if (bus_format == MEDIA_BUS_FMT_YVYU8_1X16 ||
+	    bus_format == MEDIA_BUS_FMT_VYUY8_1X16 ||
+	    bus_format == MEDIA_BUS_FMT_YVYU8_2X8 ||
+	    bus_format == MEDIA_BUS_FMT_VYUY8_2X8 ||
+	    ((bus_format == MEDIA_BUS_FMT_YUV8_1X24 ||
+	     bus_format == MEDIA_BUS_FMT_YUV10_1X30) &&
+	    (output_mode == ROCKCHIP_OUT_MODE_AAAA ||
+	     output_mode == ROCKCHIP_OUT_MODE_P888)))
+		return true;
+	else
+		return false;
+}
+
+static bool is_rb_swap(u32 bus_format, u32 output_mode)
+{
+	/*
+	 * The default component order of serial rgb3x8 formats
+	 * is BGR. So it is needed to enable RB swap.
+	 */
+	if (bus_format == MEDIA_BUS_FMT_RGB888_3X8 ||
+	    bus_format == MEDIA_BUS_FMT_RGB888_DUMMY_4X8)
+		return true;
+	else
+		return false;
+}
+
+static bool is_yc_swap(u32 bus_format)
+{
+	switch (bus_format) {
+	case MEDIA_BUS_FMT_YUYV8_1X16:
+	case MEDIA_BUS_FMT_YVYU8_1X16:
+	case MEDIA_BUS_FMT_YUYV8_2X8:
+	case MEDIA_BUS_FMT_YVYU8_2X8:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static inline bool is_hot_plug_devices(int output_type)
+{
+	switch (output_type) {
+	case DRM_MODE_CONNECTOR_HDMIA:
+	case DRM_MODE_CONNECTOR_HDMIB:
+	case DRM_MODE_CONNECTOR_TV:
+	case DRM_MODE_CONNECTOR_DisplayPort:
+	case DRM_MODE_CONNECTOR_VGA:
+	case DRM_MODE_CONNECTOR_Unknown:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static struct vop2_win_data *vop2_find_win_by_phys_id(struct vop2 *vop2, int phys_id)
+{
+	int i = 0;
+
+	for (i = 0; i < vop2->data->nr_layers; i++) {
+		if (vop2->data->win_data[i].phys_id == phys_id)
+			return &vop2->data->win_data[i];
+	}
+
+	return NULL;
+}
+
+static struct vop2_power_domain_data *vop2_find_pd_data_by_id(struct vop2 *vop2, int pd_id)
+{
+	int i = 0;
+
+	for (i = 0; i < vop2->data->nr_pd; i++) {
+		if (vop2->data->pd[i].id == pd_id)
+			return &vop2->data->pd[i];
+	}
+
+	return NULL;
+}
+
+static void rk3568_vop2_load_lut(struct vop2 *vop2, int crtc_id,
+				 u32 *lut_regs, u32 *lut_val, int lut_len)
+{
+	u32 vp_offset = crtc_id * 0x100;
+	int i;
+
+	vop2_mask_write(vop2, RK3568_SYS_LUT_PORT_SEL,
+			GAMMA_PORT_SEL_MASK, GAMMA_PORT_SEL_SHIFT,
+			crtc_id, false);
+
+	for (i = 0; i < lut_len; i++)
+		writel(lut_val[i], lut_regs + i);
+
+	vop2_mask_write(vop2, RK3568_VP0_DSP_CTRL + vp_offset,
+			EN_MASK, DSP_LUT_EN_SHIFT, 1, false);
+}
+
+static void rk3588_vop2_load_lut(struct vop2 *vop2, int crtc_id,
+				 u32 *lut_regs, u32 *lut_val, int lut_len)
+{
+	u32 vp_offset = crtc_id * 0x100;
+	int i;
+
+	vop2_mask_write(vop2, RK3568_SYS_LUT_PORT_SEL,
+			GAMMA_AHB_WRITE_SEL_MASK, GAMMA_AHB_WRITE_SEL_SHIFT,
+			crtc_id, false);
+
+	for (i = 0; i < lut_len; i++)
+		writel(lut_val[i], lut_regs + i);
+
+	vop2_mask_write(vop2, RK3568_VP0_DSP_CTRL + vp_offset,
+			EN_MASK, DSP_LUT_EN_SHIFT, 1, false);
+	vop2_mask_write(vop2, RK3568_VP0_DSP_CTRL + vp_offset,
+			EN_MASK, GAMMA_UPDATE_EN_SHIFT, 1, false);
+}
+
+static int rockchip_vop2_gamma_lut_init(struct vop2 *vop2,
+					struct display_state *state)
+{
+	struct connector_state *conn_state = &state->conn_state;
+	struct crtc_state *cstate = &state->crtc_state;
+	struct resource gamma_res;
+	fdt_size_t lut_size;
+	int i, lut_len, ret = 0;
+	u32 *lut_regs;
+	u32 *lut_val;
+	u32 r, g, b;
+	struct base2_disp_info *disp_info = conn_state->disp_info;
+	static int gamma_lut_en_num = 1;
+
+	if (gamma_lut_en_num > vop2->data->nr_gammas) {
+		printf("warn: only %d vp support gamma\n", vop2->data->nr_gammas);
+		return 0;
+	}
+
+	if (!disp_info)
+		return 0;
+
+	if (!disp_info->gamma_lut_data.size)
+		return 0;
+
+	ret = ofnode_read_resource_byname(cstate->node, "gamma_lut", &gamma_res);
+	if (ret)
+		printf("failed to get gamma lut res\n");
+	lut_regs = (u32 *)gamma_res.start;
+	lut_size = gamma_res.end - gamma_res.start + 1;
+	if (lut_regs == (u32 *)FDT_ADDR_T_NONE) {
+		printf("failed to get gamma lut register\n");
+		return 0;
+	}
+	lut_len = lut_size / 4;
+	if (lut_len != 256 && lut_len != 1024) {
+		printf("Warning: unsupport gamma lut table[%d]\n", lut_len);
+		return 0;
+	}
+	lut_val = (u32 *)calloc(1, lut_size);
+	for (i = 0; i < lut_len; i++) {
+		r = disp_info->gamma_lut_data.lred[i] * (lut_len - 1) / 0xffff;
+		g = disp_info->gamma_lut_data.lgreen[i] * (lut_len - 1) / 0xffff;
+		b = disp_info->gamma_lut_data.lblue[i] * (lut_len - 1) / 0xffff;
+
+		lut_val[i] = b * lut_len * lut_len + g * lut_len + r;
+	}
+
+	if (vop2->version == VOP_VERSION_RK3568) {
+		rk3568_vop2_load_lut(vop2, cstate->crtc_id, lut_regs, lut_val, lut_len);
+		gamma_lut_en_num++;
+	} else if (vop2->version == VOP_VERSION_RK3588) {
+		rk3588_vop2_load_lut(vop2, cstate->crtc_id, lut_regs, lut_val, lut_len);
+		if (cstate->splice_mode) {
+			rk3588_vop2_load_lut(vop2, cstate->splice_crtc_id, lut_regs, lut_val, lut_len);
+			gamma_lut_en_num++;
+		}
+		gamma_lut_en_num++;
+	}
+
+	return 0;
+}
+
+static int rockchip_vop2_cubic_lut_init(struct vop2 *vop2,
+					struct display_state *state)
+{
+	struct connector_state *conn_state = &state->conn_state;
+	struct crtc_state *cstate = &state->crtc_state;
+	int i, cubic_lut_len;
+	u32 vp_offset = cstate->crtc_id * 0x100;
+	struct base2_disp_info *disp_info = conn_state->disp_info;
+	struct base2_cubic_lut_data *lut = &conn_state->disp_info->cubic_lut_data;
+	u32 *cubic_lut_addr;
+
+	if (!disp_info || CONFIG_ROCKCHIP_CUBIC_LUT_SIZE == 0)
+		return 0;
+
+	if (!disp_info->cubic_lut_data.size)
+		return 0;
+
+	cubic_lut_addr = (u32 *)get_cubic_lut_buffer(cstate->crtc_id);
+	cubic_lut_len = disp_info->cubic_lut_data.size;
+
+	for (i = 0; i < cubic_lut_len / 2; i++) {
+		*cubic_lut_addr++ = ((lut->lred[2 * i]) & 0xfff) +
+					((lut->lgreen[2 * i] & 0xfff) << 12) +
+					((lut->lblue[2 * i] & 0xff) << 24);
+		*cubic_lut_addr++ = ((lut->lblue[2 * i] & 0xf00) >> 8) +
+					((lut->lred[2 * i + 1] & 0xfff) << 4) +
+					((lut->lgreen[2 * i + 1] & 0xfff) << 16) +
+					((lut->lblue[2 * i + 1] & 0xf) << 28);
+		*cubic_lut_addr++ = (lut->lblue[2 * i + 1] & 0xff0) >> 4;
+		*cubic_lut_addr++ = 0;
+	}
+
+	if (cubic_lut_len % 2) {
+		*cubic_lut_addr++ = (lut->lred[2 * i] & 0xfff) +
+					((lut->lgreen[2 * i] & 0xfff) << 12) +
+					((lut->lblue[2 * i] & 0xff) << 24);
+		*cubic_lut_addr++ = (lut->lblue[2 * i] & 0xf00) >> 8;
+		*cubic_lut_addr++ = 0;
+		*cubic_lut_addr = 0;
+	}
+
+	vop2_writel(vop2, RK3568_VP0_3D_LUT_MST + vp_offset,
+		    get_cubic_lut_buffer(cstate->crtc_id));
+	vop2_mask_write(vop2, RK3568_SYS_AXI_LUT_CTRL,
+			EN_MASK, LUT_DMA_EN_SHIFT, 1, false);
+	vop2_mask_write(vop2, RK3568_VP0_3D_LUT_CTRL + vp_offset,
+			EN_MASK, VP0_3D_LUT_EN_SHIFT, 1, false);
+	vop2_mask_write(vop2, RK3568_VP0_3D_LUT_CTRL + vp_offset,
+			EN_MASK, VP0_3D_LUT_UPDATE_SHIFT, 1, false);
+
+	return 0;
+}
+
+static void vop2_bcsh_reg_update(struct display_state *state, struct vop2 *vop2,
+				 struct bcsh_state *bcsh_state, int crtc_id)
+{
+	struct crtc_state *cstate = &state->crtc_state;
+	u32 vp_offset = crtc_id * 0x100;
+
+	vop2_mask_write(vop2, RK3568_VP0_BCSH_CTRL + vp_offset, BCSH_CTRL_R2Y_MASK,
+			BCSH_CTRL_R2Y_SHIFT, cstate->post_r2y_en, false);
+	vop2_mask_write(vop2, RK3568_VP0_BCSH_CTRL + vp_offset, BCSH_CTRL_Y2R_MASK,
+			BCSH_CTRL_Y2R_SHIFT, cstate->post_y2r_en, false);
+
+	vop2_mask_write(vop2, RK3568_VP0_BCSH_CTRL + vp_offset, BCSH_CTRL_R2Y_CSC_MODE_MASK,
+			BCSH_CTRL_R2Y_CSC_MODE_SHIFT, cstate->post_csc_mode, false);
+	vop2_mask_write(vop2, RK3568_VP0_BCSH_CTRL + vp_offset, BCSH_CTRL_Y2R_CSC_MODE_MASK,
+			BCSH_CTRL_Y2R_CSC_MODE_SHIFT, cstate->post_csc_mode, false);
+
+	if (!cstate->bcsh_en) {
+		vop2_mask_write(vop2, RK3568_VP0_BCSH_COLOR + vp_offset,
+				BCSH_EN_MASK, BCSH_EN_SHIFT, 0, false);
+		return;
+	}
+
+	vop2_mask_write(vop2, RK3568_VP0_BCSH_BCS + vp_offset,
+			BCSH_BRIGHTNESS_MASK, BCSH_BRIGHTNESS_SHIFT,
+			bcsh_state->brightness, false);
+	vop2_mask_write(vop2, RK3568_VP0_BCSH_BCS + vp_offset,
+			BCSH_CONTRAST_MASK, BCSH_CONTRAST_SHIFT, bcsh_state->contrast, false);
+	vop2_mask_write(vop2, RK3568_VP0_BCSH_BCS + vp_offset,
+			BCSH_SATURATION_MASK, BCSH_SATURATION_SHIFT,
+			bcsh_state->saturation * bcsh_state->contrast / 0x100, false);
+	vop2_mask_write(vop2, RK3568_VP0_BCSH_H + vp_offset,
+			BCSH_SIN_HUE_MASK, BCSH_SIN_HUE_SHIFT, bcsh_state->sin_hue, false);
+	vop2_mask_write(vop2, RK3568_VP0_BCSH_H + vp_offset,
+			BCSH_COS_HUE_MASK, BCSH_COS_HUE_SHIFT, bcsh_state->cos_hue, false);
+	vop2_mask_write(vop2, RK3568_VP0_BCSH_BCS + vp_offset,
+			BCSH_OUT_MODE_MASK, BCSH_OUT_MODE_SHIFT,
+			BCSH_OUT_MODE_NORMAL_VIDEO, false);
+	vop2_mask_write(vop2, RK3568_VP0_BCSH_COLOR + vp_offset,
+			BCSH_EN_MASK, BCSH_EN_SHIFT, 1, false);
+}
+
+static void vop2_tv_config_update(struct display_state *state, struct vop2 *vop2)
+{
+	struct connector_state *conn_state = &state->conn_state;
+	struct base_bcsh_info *bcsh_info;
+	struct crtc_state *cstate = &state->crtc_state;
+	struct bcsh_state bcsh_state;
+	int brightness, contrast, saturation, hue, sin_hue, cos_hue;
+
+	if (!conn_state->disp_info)
+		return;
+	bcsh_info = &conn_state->disp_info->bcsh_info;
+	if (!bcsh_info)
+		return;
+
+	if (bcsh_info->brightness != 50 ||
+	    bcsh_info->contrast != 50 ||
+	    bcsh_info->saturation != 50 || bcsh_info->hue != 50)
+		cstate->bcsh_en = true;
+
+	if (cstate->bcsh_en) {
+		if (!cstate->yuv_overlay)
+			cstate->post_r2y_en = 1;
+		if (!is_yuv_output(conn_state->bus_format))
+			cstate->post_y2r_en = 1;
+	} else {
+		if (!cstate->yuv_overlay && is_yuv_output(conn_state->bus_format))
+			cstate->post_r2y_en = 1;
+		if (cstate->yuv_overlay && !is_yuv_output(conn_state->bus_format))
+			cstate->post_y2r_en = 1;
+	}
+
+	cstate->post_csc_mode = vop2_convert_csc_mode(conn_state->color_space, CSC_10BIT_DEPTH);
+
+	if (cstate->feature & VOP_FEATURE_OUTPUT_10BIT)
+		brightness = interpolate(0, -128, 100, 127,
+					 bcsh_info->brightness);
+	else
+		brightness = interpolate(0, -32, 100, 31,
+					 bcsh_info->brightness);
+	contrast = interpolate(0, 0, 100, 511, bcsh_info->contrast);
+	saturation = interpolate(0, 0, 100, 511, bcsh_info->saturation);
+	hue = interpolate(0, -30, 100, 30, bcsh_info->hue);
+
+
+	/*
+	 *  a:[-30~0):
+	 *    sin_hue = 0x100 - sin(a)*256;
+	 *    cos_hue = cos(a)*256;
+	 *  a:[0~30]
+	 *    sin_hue = sin(a)*256;
+	 *    cos_hue = cos(a)*256;
+	 */
+	sin_hue = fixp_sin32(hue) >> 23;
+	cos_hue = fixp_cos32(hue) >> 23;
+
+	bcsh_state.brightness = brightness;
+	bcsh_state.contrast = contrast;
+	bcsh_state.saturation = saturation;
+	bcsh_state.sin_hue = sin_hue;
+	bcsh_state.cos_hue = cos_hue;
+
+	vop2_bcsh_reg_update(state, vop2, &bcsh_state, cstate->crtc_id);
+	if (cstate->splice_mode)
+		vop2_bcsh_reg_update(state, vop2, &bcsh_state, cstate->splice_crtc_id);
+}
+
+static void vop2_setup_dly_for_vp(struct display_state *state, struct vop2 *vop2, int crtc_id)
+{
+	struct connector_state *conn_state = &state->conn_state;
+	struct drm_display_mode *mode = &conn_state->mode;
+	struct crtc_state *cstate = &state->crtc_state;
+	u32 bg_ovl_dly, bg_dly, pre_scan_dly;
+	u16 hdisplay = mode->crtc_hdisplay;
+	u16 hsync_len = mode->crtc_hsync_end - mode->crtc_hsync_start;
+
+	bg_ovl_dly = cstate->crtc->vps[crtc_id].bg_ovl_dly;
+	bg_dly = vop2->data->vp_data[crtc_id].pre_scan_max_dly;
+	bg_dly -= bg_ovl_dly;
+
+	if (cstate->splice_mode)
+		pre_scan_dly = bg_dly + (hdisplay >> 2) - 1;
+	else
+		pre_scan_dly = bg_dly + (hdisplay >> 1) - 1;
+
+	if (vop2->version == VOP_VERSION_RK3588 && hsync_len < 8)
+		hsync_len = 8;
+	pre_scan_dly = (pre_scan_dly << 16) | hsync_len;
+	vop2_mask_write(vop2, RK3568_VP0_BG_MIX_CTRL + crtc_id * 4,
+			BG_MIX_CTRL_MASK, BG_MIX_CTRL_SHIFT, bg_dly, false);
+	vop2_writel(vop2, RK3568_VP0_PRE_SCAN_HTIMING + (crtc_id * 0x100), pre_scan_dly);
+}
+
+static void vop3_setup_pipe_dly(struct display_state *state, struct vop2 *vop2, int crtc_id)
+{
+	struct connector_state *conn_state = &state->conn_state;
+	struct drm_display_mode *mode = &conn_state->mode;
+	struct crtc_state *cstate = &state->crtc_state;
+	struct vop2_win_data *win_data;
+	u32 bg_dly, pre_scan_dly;
+	u16 hdisplay = mode->crtc_hdisplay;
+	u16 hsync_len = mode->crtc_hsync_end - mode->crtc_hsync_start;
+	u8 primary_plane_id = vop2->vp_plane_mask[cstate->crtc_id].primary_plane_id;
+	u8 win_id;
+
+	win_data = vop2_find_win_by_phys_id(vop2, primary_plane_id);
+	win_id = win_data->name[strlen(win_data->name) - 1]-'0';
+	vop2_mask_write(vop2, RK3528_OVL_SYS_ESMART0_CTRL + win_id * 4,
+			ESMART_DLY_NUM_MASK, ESMART_DLY_NUM_SHIFT, 0, false);
+
+	bg_dly = vop2->data->vp_data[crtc_id].win_dly +
+		 vop2->data->vp_data[crtc_id].layer_mix_dly +
+		 vop2->data->vp_data[crtc_id].hdr_mix_dly;
+	pre_scan_dly = bg_dly + (hdisplay >> 1) - 1;
+	pre_scan_dly = (pre_scan_dly << 16) | hsync_len;
+	vop2_mask_write(vop2, RK3528_OVL_PORT0_BG_MIX_CTRL + crtc_id * 0x100,
+			BG_MIX_CTRL_MASK, BG_MIX_CTRL_SHIFT, bg_dly, false);
+	vop2_writel(vop2, RK3568_VP0_PRE_SCAN_HTIMING + (crtc_id * 0x100), pre_scan_dly);
+}
+
+static void vop2_post_config(struct display_state *state, struct vop2 *vop2)
+{
+	struct connector_state *conn_state = &state->conn_state;
+	struct drm_display_mode *mode = &conn_state->mode;
+	struct crtc_state *cstate = &state->crtc_state;
+	u32 vp_offset = (cstate->crtc_id * 0x100);
+	u16 vtotal = mode->crtc_vtotal;
+	u16 hact_st = mode->crtc_htotal - mode->crtc_hsync_start;
+	u16 vact_st = mode->crtc_vtotal - mode->crtc_vsync_start;
+	u16 hdisplay = mode->crtc_hdisplay;
+	u16 vdisplay = mode->crtc_vdisplay;
+	u16 hsize =
+	    hdisplay * (conn_state->overscan.left_margin +
+			conn_state->overscan.right_margin) / 200;
+	u16 vsize =
+	    vdisplay * (conn_state->overscan.top_margin +
+			conn_state->overscan.bottom_margin) / 200;
+	u16 hact_end, vact_end;
+	u32 val;
+
+	hsize = round_down(hsize, 2);
+	vsize = round_down(vsize, 2);
+
+	hact_st += hdisplay * (100 - conn_state->overscan.left_margin) / 200;
+	hact_end = hact_st + hsize;
+	val = hact_st << 16;
+	val |= hact_end;
+
+	vop2_writel(vop2, RK3568_VP0_POST_DSP_HACT_INFO + vp_offset, val);
+	vact_st += vdisplay * (100 - conn_state->overscan.top_margin) / 200;
+	vact_end = vact_st + vsize;
+	val = vact_st << 16;
+	val |= vact_end;
+	vop2_writel(vop2, RK3568_VP0_POST_DSP_VACT_INFO + vp_offset, val);
+	val = scl_cal_scale2(vdisplay, vsize) << 16;
+	val |= scl_cal_scale2(hdisplay, hsize);
+	vop2_writel(vop2, RK3568_VP0_POST_SCL_FACTOR_YRGB + vp_offset, val);
+#define POST_HORIZONTAL_SCALEDOWN_EN(x)		((x) << 0)
+#define POST_VERTICAL_SCALEDOWN_EN(x)		((x) << 1)
+	vop2_writel(vop2, RK3568_VP0_POST_SCL_CTRL + vp_offset,
+		    POST_HORIZONTAL_SCALEDOWN_EN(hdisplay != hsize) |
+		    POST_VERTICAL_SCALEDOWN_EN(vdisplay != vsize));
+	if (mode->flags & DRM_MODE_FLAG_INTERLACE) {
+		u16 vact_st_f1 = vtotal + vact_st + 1;
+		u16 vact_end_f1 = vact_st_f1 + vsize;
+
+		val = vact_st_f1 << 16 | vact_end_f1;
+		vop2_writel(vop2, RK3568_VP0_POST_DSP_VACT_INFO_F1 + vp_offset, val);
+	}
+
+	if (is_vop3(vop2)) {
+		vop3_setup_pipe_dly(state, vop2, cstate->crtc_id);
+	} else {
+		vop2_setup_dly_for_vp(state, vop2, cstate->crtc_id);
+		if (cstate->splice_mode)
+			vop2_setup_dly_for_vp(state, vop2, cstate->splice_crtc_id);
+	}
+}
+
+static void vop3_post_acm_config(struct display_state *state, struct vop2 *vop2)
+{
+	struct connector_state *conn_state = &state->conn_state;
+	struct crtc_state *cstate = &state->crtc_state;
+	struct acm_data *acm = &conn_state->disp_info->acm_data;
+	struct drm_display_mode *mode = &conn_state->mode;
+	u32 vp_offset = (cstate->crtc_id * 0x100);
+	s16 *lut_y;
+	s16 *lut_h;
+	s16 *lut_s;
+	u32 value;
+	int i;
+
+	vop2_mask_write(vop2, RK3528_VP0_ACM_CTRL + vp_offset,
+		POST_ACM_BYPASS_EN_MASK, POST_ACM_BYPASS_EN_SHIFT, 0, false);
+	if (!acm->acm_enable) {
+		writel(0, vop2->regs + RK3528_ACM_CTRL);
+		return;
+	}
+
+	printf("post acm enable\n");
+
+	writel(1, vop2->regs + RK3528_ACM_FETCH_START);
+
+	value = (acm->acm_enable & 0x1) + ((mode->hdisplay & 0xfff) << 8) +
+		((mode->vdisplay & 0xfff) << 20);
+	writel(value, vop2->regs + RK3528_ACM_CTRL);
+
+	value = (acm->y_gain & 0x3ff) + ((acm->h_gain << 10) & 0xffc00) +
+		((acm->s_gain << 20) & 0x3ff00000);
+	writel(value, vop2->regs + RK3528_ACM_DELTA_RANGE);
+
+	lut_y = &acm->gain_lut_hy[0];
+	lut_h = &acm->gain_lut_hy[ACM_GAIN_LUT_HY_LENGTH];
+	lut_s = &acm->gain_lut_hy[ACM_GAIN_LUT_HY_LENGTH * 2];
+	for (i = 0; i < ACM_GAIN_LUT_HY_LENGTH; i++) {
+		value = (lut_y[i] & 0xff) + ((lut_h[i] << 8) & 0xff00) +
+			((lut_s[i] << 16) & 0xff0000);
+		writel(value, vop2->regs + RK3528_ACM_YHS_DEL_HY_SEG0 + (i << 2));
+	}
+
+	lut_y = &acm->gain_lut_hs[0];
+	lut_h = &acm->gain_lut_hs[ACM_GAIN_LUT_HS_LENGTH];
+	lut_s = &acm->gain_lut_hs[ACM_GAIN_LUT_HS_LENGTH * 2];
+	for (i = 0; i < ACM_GAIN_LUT_HS_LENGTH; i++) {
+		value = (lut_y[i] & 0xff) + ((lut_h[i] << 8) & 0xff00) +
+			((lut_s[i] << 16) & 0xff0000);
+		writel(value, vop2->regs + RK3528_ACM_YHS_DEL_HS_SEG0 + (i << 2));
+	}
+
+	lut_y = &acm->delta_lut_h[0];
+	lut_h = &acm->delta_lut_h[ACM_DELTA_LUT_H_LENGTH];
+	lut_s = &acm->delta_lut_h[ACM_DELTA_LUT_H_LENGTH * 2];
+	for (i = 0; i < ACM_DELTA_LUT_H_LENGTH; i++) {
+		value = (lut_y[i] & 0x3ff) + ((lut_h[i] << 12) & 0xff000) +
+			((lut_s[i] << 20) & 0x3ff00000);
+		writel(value, vop2->regs + RK3528_ACM_YHS_DEL_HGAIN_SEG0 + (i << 2));
+	}
+
+	writel(1, vop2->regs + RK3528_ACM_FETCH_DONE);
+}
+
+static void vop3_post_csc_config(struct display_state *state, struct vop2 *vop2)
+{
+	struct connector_state *conn_state = &state->conn_state;
+	struct crtc_state *cstate = &state->crtc_state;
+	struct acm_data *acm = &conn_state->disp_info->acm_data;
+	struct csc_info *csc = &conn_state->disp_info->csc_info;
+	struct post_csc_coef csc_coef;
+	bool is_input_yuv = false;
+	bool is_output_yuv = false;
+	bool post_r2y_en = false;
+	bool post_csc_en = false;
+	u32 vp_offset = (cstate->crtc_id * 0x100);
+	u32 value;
+	int range_type;
+
+	printf("post csc enable\n");
+
+	if (acm->acm_enable) {
+		if (!cstate->yuv_overlay)
+			post_r2y_en = true;
+
+		/* do y2r in csc module */
+		if (!is_yuv_output(conn_state->bus_format))
+			post_csc_en = true;
+	} else {
+		if (!cstate->yuv_overlay && is_yuv_output(conn_state->bus_format))
+			post_r2y_en = true;
+
+		/* do y2r in csc module */
+		if (cstate->yuv_overlay && !is_yuv_output(conn_state->bus_format))
+			post_csc_en = true;
+	}
+
+	if (csc->csc_enable)
+		post_csc_en = true;
+
+	if (cstate->yuv_overlay || post_r2y_en)
+		is_input_yuv = true;
+
+	if (is_yuv_output(conn_state->bus_format))
+		is_output_yuv = true;
+
+	cstate->post_csc_mode = vop2_convert_csc_mode(conn_state->color_space, CSC_13BIT_DEPTH);
+
+	if (post_csc_en) {
+		rockchip_calc_post_csc(csc, &csc_coef, cstate->post_csc_mode, is_input_yuv,
+				       is_output_yuv);
+
+		vop2_mask_write(vop2, RK3528_VP0_ACM_CTRL + vp_offset,
+				POST_CSC_COE00_MASK, POST_CSC_COE00_SHIFT,
+				csc_coef.csc_coef00, false);
+		value = csc_coef.csc_coef01 & 0xffff;
+		value |= (csc_coef.csc_coef02 << 16) & 0xffff0000;
+		writel(value, vop2->regs + RK3528_VP0_CSC_COE01_02);
+		value = csc_coef.csc_coef10 & 0xffff;
+		value |= (csc_coef.csc_coef11 << 16) & 0xffff0000;
+		writel(value, vop2->regs + RK3528_VP0_CSC_COE10_11);
+		value = csc_coef.csc_coef12 & 0xffff;
+		value |= (csc_coef.csc_coef20 << 16) & 0xffff0000;
+		writel(value, vop2->regs + RK3528_VP0_CSC_COE12_20);
+		value = csc_coef.csc_coef21 & 0xffff;
+		value |= (csc_coef.csc_coef22 << 16) & 0xffff0000;
+		writel(value, vop2->regs + RK3528_VP0_CSC_COE21_22);
+		writel(csc_coef.csc_dc0, vop2->regs + RK3528_VP0_CSC_OFFSET0);
+		writel(csc_coef.csc_dc1, vop2->regs + RK3528_VP0_CSC_OFFSET1);
+		writel(csc_coef.csc_dc2, vop2->regs + RK3528_VP0_CSC_OFFSET2);
+
+		range_type = csc_coef.range_type ? 0 : 1;
+		range_type <<= is_input_yuv ? 0 : 1;
+		vop2_mask_write(vop2, RK3528_VP0_ACM_CTRL + vp_offset,
+				POST_CSC_MODE_MASK, POST_CSC_MODE_SHIFT, range_type, false);
+	}
+
+	vop2_mask_write(vop2, RK3528_VP0_ACM_CTRL + vp_offset,
+			POST_R2Y_EN_MASK, POST_R2Y_EN_SHIFT, post_r2y_en ? 1 : 0, false);
+	vop2_mask_write(vop2, RK3528_VP0_ACM_CTRL + vp_offset,
+			POST_CSC_EN_MASK, POST_CSC_EN_SHIFT, post_csc_en ? 1 : 0, false);
+	vop2_mask_write(vop2, RK3528_VP0_ACM_CTRL + vp_offset,
+			POST_R2Y_MODE_MASK, POST_R2Y_MODE_SHIFT, cstate->post_csc_mode, false);
+}
+
+static void vop3_post_config(struct display_state *state, struct vop2 *vop2)
+{
+	struct connector_state *conn_state = &state->conn_state;
+	struct base2_disp_info *disp_info = conn_state->disp_info;
+	const char *enable_flag;
+	if (!disp_info) {
+		printf("disp_info is empty\n");
+		return;
+	}
+
+	enable_flag = (const char *)&disp_info->cacm_header;
+	if (strncasecmp(enable_flag, "CACM", 4)) {
+		printf("acm and csc is not support\n");
+		return;
+	}
+
+	vop3_post_acm_config(state, vop2);
+	vop3_post_csc_config(state, vop2);
+}
+
+/*
+ * Read VOP internal power domain on/off status.
+ * We should query BISR_STS register in PMU for
+ * power up/down status when memory repair is enabled.
+ * Return value: 1 for power on, 0 for power off;
+ */
+static int vop2_wait_power_domain_on(struct vop2 *vop2, struct vop2_power_domain_data *pd_data)
+{
+	int val = 0;
+	int shift = 0;
+	int shift_factor = 0;
+	bool is_bisr_en = false;
+
+	/*
+	 * The order of pd status bits in BISR_STS register
+	 * is different from that in VOP SYS_STS register.
+	 */
+	if (pd_data->id == VOP2_PD_DSC_8K ||
+	    pd_data->id == VOP2_PD_DSC_4K ||
+	    pd_data->id == VOP2_PD_ESMART)
+			shift_factor = 1;
+
+	shift = RK3588_PD_CLUSTER0_REPAIR_EN_SHIFT + generic_ffs(pd_data->id) - 1 - shift_factor;
+	is_bisr_en = vop2_grf_readl(vop2, vop2->sys_pmu, RK3588_PMU_BISR_CON3, EN_MASK, shift);
+	if (is_bisr_en) {
+		shift = RK3588_PD_CLUSTER0_PWR_STAT_SHIFI + generic_ffs(pd_data->id) - 1 - shift_factor;
+
+		return readl_poll_timeout(vop2->sys_pmu + RK3588_PMU_BISR_STATUS5, val,
+					  ((val >> shift) & 0x1), 50 * 1000);
+	} else {
+		shift = RK3588_CLUSTER0_PD_STATUS_SHIFT + generic_ffs(pd_data->id) - 1;
+
+		return readl_poll_timeout(vop2->regs + RK3568_SYS_STATUS0, val,
+					  !((val >> shift) & 0x1), 50 * 1000);
+	}
+}
+
+static int vop2_power_domain_on(struct vop2 *vop2, int pd_id)
+{
+	struct vop2_power_domain_data *pd_data;
+	int ret = 0;
+
+	if (!pd_id)
+		return 0;
+
+	pd_data = vop2_find_pd_data_by_id(vop2, pd_id);
+	if (!pd_data) {
+		printf("can't find pd_data by id\n");
+		return -EINVAL;
+	}
+
+	if (pd_data->parent_id) {
+		ret = vop2_power_domain_on(vop2, pd_data->parent_id);
+		if (ret) {
+			printf("can't open parent power domain\n");
+			return -EINVAL;
+		}
+	}
+
+	vop2_mask_write(vop2, RK3568_SYS_PD_CTRL, EN_MASK,
+			RK3588_CLUSTER0_PD_EN_SHIFT + generic_ffs(pd_id) - 1, 0, false);
+	ret = vop2_wait_power_domain_on(vop2, pd_data);
+	if (ret) {
+		printf("wait vop2 power domain timeout\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static void rk3588_vop2_regsbak(struct vop2 *vop2)
+{
+	u32 *base = vop2->regs;
+	int i = 0;
+
+	/*
+	 * No need to backup HDR/DSC/GAMMA_LUT/BPP_LUT/MMU
+	 */
+	for (i = 0; i < (vop2->reg_len >> 2); i++)
+		vop2->regsbak[i] = base[i];
+}
+
+static void vop3_overlay_init(struct vop2 *vop2, struct display_state *state)
+{
+	struct vop2_win_data *win_data;
+	int layer_phy_id = 0;
+	int i, j;
+	u32 ovl_port_offset = 0;
+	u32 layer_nr = 0;
+	u8 shift = 0;
+
+	/* layer sel win id */
+	for (i = 0; i < vop2->data->nr_vps; i++) {
+		shift = 0;
+		ovl_port_offset = 0x100 * i;
+		layer_nr = vop2->vp_plane_mask[i].attached_layers_nr;
+		for (j = 0; j < layer_nr; j++) {
+			layer_phy_id = vop2->vp_plane_mask[i].attached_layers[j];
+			win_data = vop2_find_win_by_phys_id(vop2, layer_phy_id);
+			vop2_mask_write(vop2, RK3528_OVL_PORT0_LAYER_SEL + ovl_port_offset, LAYER_SEL_MASK,
+					shift, win_data->layer_sel_win_id[i], false);
+			shift += 4;
+		}
+	}
+
+	/* win sel port */
+	for (i = 0; i < vop2->data->nr_vps; i++) {
+		layer_nr = vop2->vp_plane_mask[i].attached_layers_nr;
+		for (j = 0; j < layer_nr; j++) {
+			if (!vop2->vp_plane_mask[i].attached_layers[j])
+				continue;
+			layer_phy_id = vop2->vp_plane_mask[i].attached_layers[j];
+			win_data = vop2_find_win_by_phys_id(vop2, layer_phy_id);
+			shift = win_data->win_sel_port_offset * 2;
+			vop2_mask_write(vop2, RK3528_OVL_SYS_PORT_SEL_IMD, LAYER_SEL_PORT_MASK,
+					shift, i, false);
+		}
+	}
+}
+
+static void vop2_overlay_init(struct vop2 *vop2, struct display_state *state)
+{
+	struct crtc_state *cstate = &state->crtc_state;
+	struct vop2_win_data *win_data;
+	int layer_phy_id = 0;
+	int total_used_layer = 0;
+	int port_mux = 0;
+	int i, j;
+	u32 layer_nr = 0;
+	u8 shift = 0;
+
+	/* layer sel win id */
+	for (i = 0; i < vop2->data->nr_vps; i++) {
+		layer_nr = vop2->vp_plane_mask[i].attached_layers_nr;
+		for (j = 0; j < layer_nr; j++) {
+			layer_phy_id = vop2->vp_plane_mask[i].attached_layers[j];
+			win_data = vop2_find_win_by_phys_id(vop2, layer_phy_id);
+			vop2_mask_write(vop2, RK3568_OVL_LAYER_SEL, LAYER_SEL_MASK,
+					shift, win_data->layer_sel_win_id[i], false);
+			shift += 4;
+		}
+	}
+
+	/* win sel port */
+	for (i = 0; i < vop2->data->nr_vps; i++) {
+		layer_nr = vop2->vp_plane_mask[i].attached_layers_nr;
+		for (j = 0; j < layer_nr; j++) {
+			if (!vop2->vp_plane_mask[i].attached_layers[j])
+				continue;
+			layer_phy_id = vop2->vp_plane_mask[i].attached_layers[j];
+			win_data = vop2_find_win_by_phys_id(vop2, layer_phy_id);
+			shift = win_data->win_sel_port_offset * 2;
+			vop2_mask_write(vop2, RK3568_OVL_PORT_SEL, LAYER_SEL_PORT_MASK,
+					LAYER_SEL_PORT_SHIFT + shift, i, false);
+		}
+	}
+
+	/**
+	 * port mux config
+	 */
+	for (i = 0; i < vop2->data->nr_vps; i++) {
+		shift = i * 4;
+		if (vop2->vp_plane_mask[i].attached_layers_nr) {
+			total_used_layer += vop2->vp_plane_mask[i].attached_layers_nr;
+			port_mux = total_used_layer - 1;
+		} else {
+			port_mux = 8;
+		}
+
+		if (i == vop2->data->nr_vps - 1)
+			port_mux = vop2->data->nr_mixers;
+
+		cstate->crtc->vps[i].bg_ovl_dly = (vop2->data->nr_mixers - port_mux) << 1;
+		vop2_mask_write(vop2, RK3568_OVL_PORT_SEL, PORT_MUX_MASK,
+				PORT_MUX_SHIFT + shift, port_mux, false);
+	}
+}
+
+static bool vop3_ignore_plane(struct vop2 *vop2, struct vop2_win_data *win)
+{
+	if (!is_vop3(vop2))
+		return false;
+
+	if (vop2->esmart_lb_mode == VOP3_ESMART_8K_MODE &&
+	    win->phys_id != ROCKCHIP_VOP2_ESMART0)
+		return true;
+	else if (vop2->esmart_lb_mode == VOP3_ESMART_4K_4K_MODE &&
+		 (win->phys_id == ROCKCHIP_VOP2_ESMART1 || win->phys_id == ROCKCHIP_VOP2_ESMART3))
+		return true;
+	else if (vop2->esmart_lb_mode == VOP3_ESMART_4K_2K_2K_MODE &&
+		 win->phys_id == ROCKCHIP_VOP2_ESMART1)
+		return true;
+	else
+		return false;
+}
+
+static void vop3_init_esmart_scale_engine(struct vop2 *vop2)
+{
+	struct vop2_win_data *win_data;
+	int i;
+	u8 scale_engine_num = 0;
+
+	/* store plane mask for vop2_fixup_dts */
+	for (i = 0; i < vop2->data->nr_layers; i++) {
+		win_data = &vop2->data->win_data[i];
+		if (win_data->type == CLUSTER_LAYER || vop3_ignore_plane(vop2, win_data))
+			continue;
+
+		win_data->scale_engine_num = scale_engine_num++;
+	}
+}
+
+static void vop2_global_initial(struct vop2 *vop2, struct display_state *state)
+{
+	struct crtc_state *cstate = &state->crtc_state;
+	struct vop2_vp_plane_mask *plane_mask;
+	int layer_phy_id = 0;
+	int i, j;
+	int ret;
+	u32 layer_nr = 0;
+
+	if (vop2->global_init)
+		return;
+
+	/* OTP must enable at the first time, otherwise mirror layer register is error */
+	if (soc_is_rk3566())
+		vop2_mask_write(vop2, RK3568_SYS_OTP_WIN_EN, EN_MASK,
+				OTP_WIN_EN_SHIFT, 1, false);
+
+	if (cstate->crtc->assign_plane) {/* dts assign plane */
+		u32 plane_mask;
+		int primary_plane_id;
+
+		for (i = 0; i < vop2->data->nr_vps; i++) {
+			plane_mask = cstate->crtc->vps[i].plane_mask;
+			vop2->vp_plane_mask[i].plane_mask = plane_mask;
+			layer_nr = hweight32(plane_mask); /* use bitmap to store plane mask */
+			vop2->vp_plane_mask[i].attached_layers_nr = layer_nr;
+			primary_plane_id = cstate->crtc->vps[i].primary_plane_id;
+			if (primary_plane_id >= ROCKCHIP_VOP2_LAYER_MAX)
+				primary_plane_id = vop2_get_primary_plane(vop2, plane_mask);
+			vop2->vp_plane_mask[i].primary_plane_id = primary_plane_id;
+			vop2->vp_plane_mask[i].plane_mask = plane_mask;
+
+			/* plane mask[bitmap] convert into layer phy id[enum vop2_layer_phy_id]*/
+			for (j = 0; j < layer_nr; j++) {
+				vop2->vp_plane_mask[i].attached_layers[j] = ffs(plane_mask) - 1;
+				plane_mask &= ~BIT(vop2->vp_plane_mask[i].attached_layers[j]);
+			}
+		}
+	} else {/* need soft assign plane mask */
+		/* find the first unplug devices and set it as main display */
+		int main_vp_index = -1;
+		int active_vp_num = 0;
+
+		for (i = 0; i < vop2->data->nr_vps; i++) {
+			if (cstate->crtc->vps[i].enable)
+				active_vp_num++;
+		}
+		printf("VOP have %d active VP\n", active_vp_num);
+
+		if (soc_is_rk3566() && active_vp_num > 2)
+			printf("ERROR: rk3566 only support 2 display output!!\n");
+		plane_mask = vop2->data->plane_mask;
+		plane_mask += (active_vp_num - 1) * VOP2_VP_MAX;
+		/*
+		 * For rk3528, one display policy for hdmi store in plane_mask[0], and the other
+		 * for cvbs store in plane_mask[2].
+		 */
+		if (vop2->version == VOP_VERSION_RK3528 && active_vp_num == 1 &&
+		    cstate->crtc->vps[1].output_type == DRM_MODE_CONNECTOR_TV)
+			plane_mask += 2 * VOP2_VP_MAX;
+
+		if (vop2->version == VOP_VERSION_RK3528) {
+			/*
+			 * For rk3528, the plane mask of vp is limited, only esmart2 can be selected
+			 * by both vp0 and vp1.
+			 */
+			j = 0;
+		} else {
+			for (i = 0; i < vop2->data->nr_vps; i++) {
+				if (!is_hot_plug_devices(cstate->crtc->vps[i].output_type)) {
+					vop2->vp_plane_mask[i] = plane_mask[0]; /* the first store main display plane mask*/
+					main_vp_index = i;
+					break;
+				}
+			}
+
+			/* if no find unplug devices, use vp0 as main display */
+			if (main_vp_index < 0) {
+				main_vp_index = 0;
+				vop2->vp_plane_mask[0] = plane_mask[0];
+			}
+
+			j = 1; /* plane_mask[0] store main display, so we from plane_mask[1] */
+		}
+
+		/* init other display except main display */
+		for (i = 0; i < vop2->data->nr_vps; i++) {
+			if (i == main_vp_index || !cstate->crtc->vps[i].enable) /* main display or no connect devices */
+				continue;
+			vop2->vp_plane_mask[i] = plane_mask[j++];
+		}
+
+		/* store plane mask for vop2_fixup_dts */
+		for (i = 0; i < vop2->data->nr_vps; i++) {
+			layer_nr = vop2->vp_plane_mask[i].attached_layers_nr;
+			for (j = 0; j < layer_nr; j++) {
+				layer_phy_id = vop2->vp_plane_mask[i].attached_layers[j];
+				vop2->vp_plane_mask[i].plane_mask |= BIT(layer_phy_id);
+			}
+		}
+	}
+
+	if (vop2->version == VOP_VERSION_RK3588)
+		rk3588_vop2_regsbak(vop2);
+	else
+		memcpy(vop2->regsbak, vop2->regs, vop2->reg_len);
+
+	vop2_mask_write(vop2, RK3568_OVL_CTRL, EN_MASK,
+			OVL_PORT_MUX_REG_DONE_IMD_SHIFT, 1, false);
+	vop2_mask_write(vop2, RK3568_DSP_IF_POL, EN_MASK,
+			IF_CTRL_REG_DONE_IMD_SHIFT, 1, false);
+
+	for (i = 0; i < vop2->data->nr_vps; i++) {
+		printf("vp%d have layer nr:%d[", i, vop2->vp_plane_mask[i].attached_layers_nr);
+		for (j = 0; j < vop2->vp_plane_mask[i].attached_layers_nr; j++)
+			printf("%d ", vop2->vp_plane_mask[i].attached_layers[j]);
+		printf("], primary plane: %d\n", vop2->vp_plane_mask[i].primary_plane_id);
+	}
+
+	if (is_vop3(vop2))
+		vop3_overlay_init(vop2, state);
+	else
+		vop2_overlay_init(vop2, state);
+
+	if (is_vop3(vop2)) {
+		/*
+		 * you can rewrite at dts vop node:
+		 *
+		 * VOP3_ESMART_8K_MODE = 0,
+		 * VOP3_ESMART_4K_4K_MODE = 1,
+		 * VOP3_ESMART_4K_2K_2K_MODE = 2,
+		 * VOP3_ESMART_2K_2K_2K_2K_MODE = 3,
+		 *
+		 * &vop {
+		 * 	esmart_lb_mode = /bits/ 8 <2>;
+		 * };
+		 */
+		ret = ofnode_read_u32(cstate->node, "esmart_lb_mode", &vop2->esmart_lb_mode);
+		if (ret < 0)
+			vop2->esmart_lb_mode = vop2->data->esmart_lb_mode;
+		vop2_mask_write(vop2, RK3568_SYS_LUT_PORT_SEL, ESMART_LB_MODE_SEL_MASK,
+				ESMART_LB_MODE_SEL_SHIFT, vop2->esmart_lb_mode, false);
+
+		vop3_init_esmart_scale_engine(vop2);
+
+		vop2_mask_write(vop2, RK3568_SYS_AXI_LUT_CTRL, EN_MASK,
+				DSP_VS_T_SEL_SHIFT, 0, false);
+	}
+
+	if (vop2->version == VOP_VERSION_RK3568)
+		vop2_writel(vop2, RK3568_AUTO_GATING_CTRL, 0);
+
+	vop2->global_init = true;
+}
+
+static int vop2_initial(struct vop2 *vop2, struct display_state *state)
+{
+	rockchip_vop2_gamma_lut_init(vop2, state);
+	rockchip_vop2_cubic_lut_init(vop2, state);
+
+	return 0;
+}
+
+/*
+ * VOP2 have multi video ports.
+ * video port ------- crtc
+ */
+static int rockchip_vop2_preinit(struct display_state *state)
+{
+	struct crtc_state *cstate = &state->crtc_state;
+	const struct vop2_data *vop2_data = cstate->crtc->data;
+	struct regmap *map;
+
+	if (!rockchip_vop2) {
+		rockchip_vop2 = calloc(1, sizeof(struct vop2));
+		if (!rockchip_vop2)
+			return -ENOMEM;
+		memset(rockchip_vop2, 0, sizeof(struct vop2));
+		rockchip_vop2->regsbak = malloc(RK3568_MAX_REG);
+		rockchip_vop2->reg_len = RK3568_MAX_REG;
+#ifdef CONFIG_SPL_BUILD
+		rockchip_vop2->regs = (void *)RK3528_VOP_BASE;
+#else
+		rockchip_vop2->regs = dev_read_addr_ptr(cstate->dev);
+		map = syscon_regmap_lookup_by_phandle(cstate->dev, "rockchip,grf");
+		rockchip_vop2->grf = regmap_get_range(map, 0);
+		if (rockchip_vop2->grf <= 0)
+			printf("%s: Get syscon grf failed (ret=%p)\n", __func__, rockchip_vop2->grf);
+#endif
+		rockchip_vop2->version = vop2_data->version;
+		rockchip_vop2->data = vop2_data;
+		if (rockchip_vop2->version == VOP_VERSION_RK3588) {
+			map = syscon_regmap_lookup_by_phandle(cstate->dev, "rockchip,vop-grf");
+			rockchip_vop2->vop_grf = regmap_get_range(map, 0);
+			if (rockchip_vop2->vop_grf <= 0)
+				printf("%s: Get syscon vop_grf failed (ret=%p)\n", __func__, rockchip_vop2->vop_grf);
+			map = syscon_regmap_lookup_by_phandle(cstate->dev, "rockchip,vo1-grf");
+			rockchip_vop2->vo1_grf = regmap_get_range(map, 0);
+			if (rockchip_vop2->vo1_grf <= 0)
+				printf("%s: Get syscon vo1_grf failed (ret=%p)\n", __func__, rockchip_vop2->vo1_grf);
+			map = syscon_regmap_lookup_by_phandle(cstate->dev, "rockchip,pmu");
+			rockchip_vop2->sys_pmu = regmap_get_range(map, 0);
+			if (rockchip_vop2->sys_pmu <= 0)
+				printf("%s: Get syscon sys_pmu failed (ret=%p)\n", __func__, rockchip_vop2->sys_pmu);
+		}
+	}
+
+	cstate->private = rockchip_vop2;
+	cstate->max_output = vop2_data->vp_data[cstate->crtc_id].max_output;
+	cstate->feature = vop2_data->vp_data[cstate->crtc_id].feature;
+
+	vop2_global_initial(rockchip_vop2, state);
+
+	return 0;
+}
+
+/*
+ * calc the dclk on rk3588
+ * the available div of dclk is 1, 2, 4
+ *
+ */
+static unsigned long vop2_calc_dclk(unsigned long child_clk, unsigned long max_dclk)
+{
+	if (child_clk * 4 <= max_dclk)
+		return child_clk * 4;
+	else if (child_clk * 2 <= max_dclk)
+		return child_clk * 2;
+	else if (child_clk <= max_dclk)
+		return child_clk;
+	else
+		return 0;
+}
+
+/*
+ * 4 pixclk/cycle on rk3588
+ * RGB/eDP/HDMI: if_pixclk >= dclk_core
+ * DP: dp_pixclk = dclk_out <= dclk_core
+ * DSI: mipi_pixclk <= dclk_out <= dclk_core
+ */
+static unsigned long vop2_calc_cru_cfg(struct display_state *state,
+				       int *dclk_core_div, int *dclk_out_div,
+				       int *if_pixclk_div, int *if_dclk_div)
+{
+	struct crtc_state *cstate = &state->crtc_state;
+	struct connector_state *conn_state = &state->conn_state;
+	struct drm_display_mode *mode = &conn_state->mode;
+	struct vop2 *vop2 = cstate->private;
+	unsigned long v_pixclk = mode->crtc_clock;
+	unsigned long dclk_core_rate = v_pixclk >> 2;
+	unsigned long dclk_rate = v_pixclk;
+	unsigned long dclk_out_rate;
+	u64 if_dclk_rate;
+	u64 if_pixclk_rate;
+	int output_type = conn_state->type;
+	int output_mode = conn_state->output_mode;
+	int K = 1;
+
+	if (conn_state->output_flags & ROCKCHIP_OUTPUT_DUAL_CHANNEL_LEFT_RIGHT_MODE &&
+	    output_mode == ROCKCHIP_OUT_MODE_YUV420) {
+		printf("Dual channel and YUV420 can't work together\n");
+		return -EINVAL;
+	}
+
+	if (conn_state->output_flags & ROCKCHIP_OUTPUT_DUAL_CHANNEL_LEFT_RIGHT_MODE ||
+	    output_mode == ROCKCHIP_OUT_MODE_YUV420)
+		K = 2;
+
+	if (output_type == DRM_MODE_CONNECTOR_HDMIA) {
+		/*
+		 * K = 2: dclk_core = if_pixclk_rate > if_dclk_rate
+		 * K = 1: dclk_core = hdmie_edp_dclk > if_pixclk_rate
+		 */
+		if (conn_state->output_flags & ROCKCHIP_OUTPUT_DUAL_CHANNEL_LEFT_RIGHT_MODE ||
+		    output_mode == ROCKCHIP_OUT_MODE_YUV420) {
+			dclk_rate = dclk_rate >> 1;
+			K = 2;
+		}
+		if (cstate->dsc_enable) {
+			if_pixclk_rate = cstate->dsc_cds_clk_rate << 1;
+			if_dclk_rate = cstate->dsc_cds_clk_rate;
+		} else {
+			if_pixclk_rate = (dclk_core_rate << 1) / K;
+			if_dclk_rate = dclk_core_rate / K;
+		}
+
+		if (v_pixclk > VOP2_MAX_DCLK_RATE)
+			dclk_rate = vop2_calc_dclk(dclk_core_rate,
+						   vop2->data->vp_data[cstate->crtc_id].max_dclk);
+
+		if (!dclk_rate) {
+			printf("DP if_pixclk_rate out of range(max_dclk: %d KHZ, dclk_core: %lld KHZ)\n",
+			       vop2->data->vp_data[cstate->crtc_id].max_dclk, if_pixclk_rate);
+			return -EINVAL;
+		}
+		*if_pixclk_div = dclk_rate / if_pixclk_rate;
+		*if_dclk_div = dclk_rate / if_dclk_rate;
+		*dclk_core_div = dclk_rate / dclk_core_rate;
+		printf("dclk:%lu,if_pixclk_div;%d,if_dclk_div:%d\n",
+		       dclk_rate, *if_pixclk_div, *if_dclk_div);
+	} else if (output_type == DRM_MODE_CONNECTOR_eDP) {
+		/* edp_pixclk = edp_dclk > dclk_core */
+		if_pixclk_rate = v_pixclk / K;
+		if_dclk_rate = v_pixclk / K;
+		dclk_rate = if_pixclk_rate * K;
+		*dclk_core_div = dclk_rate / dclk_core_rate;
+		*if_pixclk_div = dclk_rate / if_pixclk_rate;
+		*if_dclk_div = *if_pixclk_div;
+	} else if (output_type == DRM_MODE_CONNECTOR_DisplayPort) {
+		dclk_out_rate = v_pixclk >> 2;
+		dclk_out_rate = dclk_out_rate / K;
+
+		dclk_rate = vop2_calc_dclk(dclk_out_rate,
+					   vop2->data->vp_data[cstate->crtc_id].max_dclk);
+		if (!dclk_rate) {
+			printf("DP dclk_core out of range(max_dclk: %d KHZ, dclk_core: %ld KHZ)\n",
+			       vop2->data->vp_data[cstate->crtc_id].max_dclk, dclk_core_rate);
+			return -EINVAL;
+		}
+		*dclk_out_div = dclk_rate / dclk_out_rate;
+		*dclk_core_div = dclk_rate / dclk_core_rate;
+	} else if (output_type == DRM_MODE_CONNECTOR_DSI) {
+		if (conn_state->output_flags & ROCKCHIP_OUTPUT_DUAL_CHANNEL_LEFT_RIGHT_MODE)
+			K = 2;
+		if (cstate->dsc_enable)
+			/* dsc output is 96bit, dsi input is 192 bit */
+			if_pixclk_rate = cstate->dsc_cds_clk_rate >> 1;
+		else
+			if_pixclk_rate = dclk_core_rate / K;
+		/* dclk_core = dclk_out * K = if_pixclk * K = v_pixclk / 4 */
+		dclk_out_rate = dclk_core_rate / K;
+		/* dclk_rate = N * dclk_core_rate N = (1,2,4 ), we get a little factor here */
+		dclk_rate = vop2_calc_dclk(dclk_out_rate,
+					   vop2->data->vp_data[cstate->crtc_id].max_dclk);
+		if (!dclk_rate) {
+			printf("MIPI dclk out of range(max_dclk: %d KHZ, dclk_rate: %ld KHZ)\n",
+			       vop2->data->vp_data[cstate->crtc_id].max_dclk, dclk_rate);
+			return -EINVAL;
+		}
+
+		if (cstate->dsc_enable)
+			dclk_rate /= cstate->dsc_slice_num;
+
+		*dclk_out_div = dclk_rate / dclk_out_rate;
+		*dclk_core_div = dclk_rate / dclk_core_rate;
+		*if_pixclk_div = 1;       /*mipi pixclk == dclk_out*/
+		if (cstate->dsc_enable)
+			*if_pixclk_div = dclk_out_rate * 1000LL / if_pixclk_rate;
+
+	} else if (output_type == DRM_MODE_CONNECTOR_DPI) {
+		dclk_rate = v_pixclk;
+		*dclk_core_div = dclk_rate / dclk_core_rate;
+	}
+
+	*if_pixclk_div = ilog2(*if_pixclk_div);
+	*if_dclk_div = ilog2(*if_dclk_div);
+	*dclk_core_div = ilog2(*dclk_core_div);
+	*dclk_out_div = ilog2(*dclk_out_div);
+
+	return dclk_rate;
+}
+
+static int vop2_calc_dsc_clk(struct display_state *state)
+{
+	struct connector_state *conn_state = &state->conn_state;
+	struct drm_display_mode *mode = &conn_state->mode;
+	struct crtc_state *cstate = &state->crtc_state;
+	u64 v_pixclk = mode->crtc_clock * 1000LL; /* video timing pixclk */
+	u8 k = 1;
+
+	if (conn_state->output_flags & ROCKCHIP_OUTPUT_DUAL_CHANNEL_LEFT_RIGHT_MODE)
+		k = 2;
+
+	cstate->dsc_txp_clk_rate = v_pixclk;
+	do_div(cstate->dsc_txp_clk_rate, (cstate->dsc_pixel_num * k));
+
+	cstate->dsc_pxl_clk_rate = v_pixclk;
+	do_div(cstate->dsc_pxl_clk_rate, (cstate->dsc_slice_num * k));
+
+	/* dsc_cds = crtc_clock / (cds_dat_width / bits_per_pixel)
+	 * cds_dat_width = 96;
+	 * bits_per_pixel = [8-12];
+	 * As cds clk is div from txp clk and only support 1/2/4 div,
+	 * so when txp_clk is equal to v_pixclk, we set dsc_cds = crtc_clock / 4,
+	 * otherwise dsc_cds = crtc_clock / 8;
+	 */
+	cstate->dsc_cds_clk_rate = v_pixclk / (cstate->dsc_txp_clk_rate == v_pixclk ? 4 : 8);
+
+	return 0;
+}
+
+static unsigned long rk3588_vop2_if_cfg(struct display_state *state)
+{
+	struct crtc_state *cstate = &state->crtc_state;
+	struct connector_state *conn_state = &state->conn_state;
+	struct drm_display_mode *mode = &conn_state->mode;
+	struct rockchip_dsc_sink_cap *dsc_sink_cap = &cstate->dsc_sink_cap;
+	struct vop2 *vop2 = cstate->private;
+	u32 vp_offset = (cstate->crtc_id * 0x100);
+	u16 hdisplay = mode->crtc_hdisplay;
+	int output_if = conn_state->output_if;
+	int if_pixclk_div = 0;
+	int if_dclk_div = 0;
+	unsigned long dclk_rate;
+	bool dclk_inv, yc_swap = false;
+	u32 val;
+
+	dclk_inv = (conn_state->bus_flags & DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE) ? 1 : 0;
+	if (output_if & (VOP_OUTPUT_IF_HDMI0 | VOP_OUTPUT_IF_HDMI1)) {
+		val = (mode->flags & DRM_MODE_FLAG_NHSYNC) ? BIT(HSYNC_POSITIVE) : 0;
+		val |= (mode->flags & DRM_MODE_FLAG_NVSYNC) ? BIT(VSYNC_POSITIVE) : 0;
+	} else {
+		val = (mode->flags & DRM_MODE_FLAG_NHSYNC) ? 0 : BIT(HSYNC_POSITIVE);
+		val |= (mode->flags & DRM_MODE_FLAG_NVSYNC) ? 0 : BIT(VSYNC_POSITIVE);
+	}
+
+	if (cstate->dsc_enable) {
+		int k = 1;
+
+		if (!vop2->data->nr_dscs) {
+			printf("Unsupported DSC\n");
+			return 0;
+		}
+
+		if (conn_state->output_flags & ROCKCHIP_OUTPUT_DUAL_CHANNEL_LEFT_RIGHT_MODE)
+			k = 2;
+
+		cstate->dsc_id = output_if & (VOP_OUTPUT_IF_MIPI0 | VOP_OUTPUT_IF_HDMI0) ? 0 : 1;
+		cstate->dsc_slice_num = hdisplay / dsc_sink_cap->slice_width / k;
+		cstate->dsc_pixel_num = cstate->dsc_slice_num > 4 ? 4 : cstate->dsc_slice_num;
+
+		vop2_calc_dsc_clk(state);
+		printf("Enable DSC%d slice:%dx%d, slice num:%d\n",
+		       cstate->dsc_id, dsc_sink_cap->slice_width,
+		       dsc_sink_cap->slice_height, cstate->dsc_slice_num);
+	}
+
+	dclk_rate = vop2_calc_cru_cfg(state, &cstate->dclk_core_div, &cstate->dclk_out_div, &if_pixclk_div, &if_dclk_div);
+
+	if (output_if & VOP_OUTPUT_IF_RGB) {
+		vop2_mask_write(vop2, RK3568_DSP_IF_EN, 0x7, RK3588_RGB_EN_SHIFT,
+				4, false);
+		vop2_grf_writel(vop2, vop2->grf, RK3588_GRF_SOC_CON1, EN_MASK,
+				RK3588_GRF_VOP_DCLK_INV_SEL_SHIFT, !dclk_inv);
+	}
+
+	if (output_if & VOP_OUTPUT_IF_BT1120) {
+		vop2_mask_write(vop2, RK3568_DSP_IF_EN, 0x7, RK3588_RGB_EN_SHIFT,
+				3, false);
+		vop2_grf_writel(vop2, vop2->grf, RK3588_GRF_SOC_CON1, EN_MASK,
+				RK3588_GRF_VOP_DCLK_INV_SEL_SHIFT, !dclk_inv);
+		yc_swap = is_yc_swap(conn_state->bus_format);
+		vop2_mask_write(vop2, RK3568_DSP_IF_CTRL, EN_MASK, RK3588_BT1120_YC_SWAP_SHIFT,
+				yc_swap, false);
+	}
+
+	if (output_if & VOP_OUTPUT_IF_BT656) {
+		vop2_mask_write(vop2, RK3568_DSP_IF_EN, 0x7, RK3588_RGB_EN_SHIFT,
+				2, false);
+		vop2_grf_writel(vop2, vop2->grf, RK3588_GRF_SOC_CON1, EN_MASK,
+				RK3588_GRF_VOP_DCLK_INV_SEL_SHIFT, !dclk_inv);
+		yc_swap = is_yc_swap(conn_state->bus_format);
+		vop2_mask_write(vop2, RK3568_DSP_IF_CTRL, EN_MASK, RK3588_BT656_YC_SWAP_SHIFT,
+				yc_swap, false);
+	}
+
+	if (output_if & VOP_OUTPUT_IF_MIPI0) {
+		if (cstate->crtc_id == 2)
+			val = 0;
+		else
+			val = 1;
+
+		if (conn_state->output_flags & ROCKCHIP_OUTPUT_MIPI_DS_MODE)
+			vop2_mask_write(vop2, RK3568_DSP_IF_CTRL, EN_MASK,
+					RK3588_MIPI_DSI0_MODE_SEL_SHIFT, 1, false);
+
+		vop2_mask_write(vop2, RK3568_DSP_IF_EN, EN_MASK, RK3588_MIPI0_EN_SHIFT,
+				1, false);
+		vop2_mask_write(vop2, RK3568_DSP_IF_EN, 1, RK3588_MIPI0_MUX_SHIFT, val, false);
+		vop2_mask_write(vop2, RK3568_DSP_IF_CTRL, 3, MIPI0_PIXCLK_DIV_SHIFT,
+				if_pixclk_div, false);
+
+		if (conn_state->hold_mode) {
+			vop2_mask_write(vop2, RK3568_VP0_MIPI_CTRL + vp_offset,
+					EN_MASK, EDPI_TE_EN, !cstate->soft_te, false);
+			vop2_mask_write(vop2, RK3568_VP0_MIPI_CTRL + vp_offset,
+					EN_MASK, EDPI_WMS_HOLD_EN, 1, false);
+		}
+	}
+
+	if (output_if & VOP_OUTPUT_IF_MIPI1) {
+		if (cstate->crtc_id == 2)
+			val = 0;
+		else if (cstate->crtc_id == 3)
+			val = 1;
+		else
+			val = 3; /*VP1*/
+		if (conn_state->output_flags & ROCKCHIP_OUTPUT_MIPI_DS_MODE)
+			vop2_mask_write(vop2, RK3568_DSP_IF_CTRL, EN_MASK,
+					RK3588_MIPI_DSI1_MODE_SEL_SHIFT, 1, false);
+
+		vop2_mask_write(vop2, RK3568_DSP_IF_EN, EN_MASK, RK3588_MIPI1_EN_SHIFT,
+				1, false);
+		vop2_mask_write(vop2, RK3568_DSP_IF_EN, IF_MUX_MASK, MIPI1_MUX_SHIFT,
+				val, false);
+		vop2_mask_write(vop2, RK3568_DSP_IF_CTRL, 3, MIPI1_PIXCLK_DIV_SHIFT,
+				if_pixclk_div, false);
+
+		if (conn_state->hold_mode) {
+			vop2_mask_write(vop2, RK3568_VP0_MIPI_CTRL + vp_offset,
+					EN_MASK, EDPI_TE_EN, !cstate->soft_te, false);
+			vop2_mask_write(vop2, RK3568_VP0_MIPI_CTRL + vp_offset,
+					EN_MASK, EDPI_WMS_HOLD_EN, 1, false);
+		}
+	}
+
+	if (conn_state->output_flags & ROCKCHIP_OUTPUT_DUAL_CHANNEL_LEFT_RIGHT_MODE) {
+		vop2_mask_write(vop2, RK3568_VP0_MIPI_CTRL + vp_offset, EN_MASK,
+				MIPI_DUAL_EN_SHIFT, 1, false);
+		if (conn_state->output_flags & ROCKCHIP_OUTPUT_DATA_SWAP)
+			vop2_mask_write(vop2, RK3568_VP0_MIPI_CTRL + vp_offset,
+					EN_MASK, MIPI_DUAL_SWAP_EN_SHIFT, 1,
+					false);
+		switch (conn_state->type) {
+		case DRM_MODE_CONNECTOR_DisplayPort:
+			vop2_mask_write(vop2, RK3568_DSP_IF_CTRL, EN_MASK,
+					RK3588_DP_DUAL_EN_SHIFT, 1, false);
+			break;
+		case DRM_MODE_CONNECTOR_eDP:
+			vop2_mask_write(vop2, RK3568_DSP_IF_CTRL, EN_MASK,
+					RK3588_EDP_DUAL_EN_SHIFT, 1, false);
+			break;
+		case DRM_MODE_CONNECTOR_HDMIA:
+			vop2_mask_write(vop2, RK3568_DSP_IF_CTRL, EN_MASK,
+					RK3588_HDMI_DUAL_EN_SHIFT, 1, false);
+			break;
+		case DRM_MODE_CONNECTOR_DSI:
+			vop2_mask_write(vop2, RK3568_DSP_IF_CTRL, EN_MASK,
+					RK3568_MIPI_DUAL_EN_SHIFT, 1, false);
+			break;
+		default:
+			break;
+		}
+	}
+
+	if (output_if & VOP_OUTPUT_IF_eDP0) {
+		vop2_mask_write(vop2, RK3568_DSP_IF_EN, EN_MASK, RK3588_EDP0_EN_SHIFT,
+				1, false);
+		vop2_mask_write(vop2, RK3568_DSP_IF_EN, IF_MUX_MASK, RK3588_HDMI_EDP0_MUX_SHIFT,
+				cstate->crtc_id, false);
+		vop2_mask_write(vop2, RK3568_DSP_IF_CTRL, 3, HDMI_EDP0_DCLK_DIV_SHIFT,
+				if_dclk_div, false);
+
+		vop2_mask_write(vop2, RK3568_DSP_IF_CTRL, 3, HDMI_EDP0_PIXCLK_DIV_SHIFT,
+				if_pixclk_div, false);
+
+		vop2_grf_writel(vop2, vop2->vop_grf, RK3588_GRF_VOP_CON2, EN_MASK,
+				RK3588_GRF_EDP0_ENABLE_SHIFT, 1);
+	}
+
+	if (output_if & VOP_OUTPUT_IF_eDP1) {
+		vop2_mask_write(vop2, RK3568_DSP_IF_EN, EN_MASK, RK3588_EDP1_EN_SHIFT,
+				1, false);
+		vop2_mask_write(vop2, RK3568_DSP_IF_EN, IF_MUX_MASK, RK3588_HDMI_EDP1_MUX_SHIFT,
+				cstate->crtc_id, false);
+		vop2_mask_write(vop2, RK3568_DSP_IF_CTRL, 3, HDMI_EDP1_DCLK_DIV_SHIFT,
+				if_dclk_div, false);
+
+		vop2_mask_write(vop2, RK3568_DSP_IF_CTRL, 3, HDMI_EDP1_PIXCLK_DIV_SHIFT,
+				if_pixclk_div, false);
+
+		vop2_grf_writel(vop2, vop2->vop_grf, RK3588_GRF_VOP_CON2, EN_MASK,
+				RK3588_GRF_EDP1_ENABLE_SHIFT, 1);
+	}
+
+	if (output_if & VOP_OUTPUT_IF_HDMI0) {
+		vop2_mask_write(vop2, RK3568_DSP_IF_EN, EN_MASK, RK3588_HDMI0_EN_SHIFT,
+				1, false);
+		vop2_mask_write(vop2, RK3568_DSP_IF_EN, IF_MUX_MASK, RK3588_HDMI_EDP0_MUX_SHIFT,
+				cstate->crtc_id, false);
+		vop2_mask_write(vop2, RK3568_DSP_IF_CTRL, 3, HDMI_EDP0_DCLK_DIV_SHIFT,
+				if_dclk_div, false);
+
+		vop2_mask_write(vop2, RK3568_DSP_IF_CTRL, 3, HDMI_EDP0_PIXCLK_DIV_SHIFT,
+				if_pixclk_div, false);
+
+		vop2_grf_writel(vop2, vop2->vop_grf, RK3588_GRF_VOP_CON2, EN_MASK,
+				RK3588_GRF_HDMITX0_ENABLE_SHIFT, 1);
+		vop2_grf_writel(vop2, vop2->vo1_grf, RK3588_GRF_VO1_CON0,
+				HDMI_SYNC_POL_MASK,
+				HDMI0_SYNC_POL_SHIFT, val);
+	}
+
+	if (output_if & VOP_OUTPUT_IF_HDMI1) {
+		vop2_mask_write(vop2, RK3568_DSP_IF_EN, EN_MASK, RK3588_HDMI1_EN_SHIFT,
+				1, false);
+		vop2_mask_write(vop2, RK3568_DSP_IF_EN, IF_MUX_MASK, RK3588_HDMI_EDP1_MUX_SHIFT,
+				cstate->crtc_id, false);
+		vop2_mask_write(vop2, RK3568_DSP_IF_CTRL, 3, HDMI_EDP1_DCLK_DIV_SHIFT,
+				if_dclk_div, false);
+
+		vop2_mask_write(vop2, RK3568_DSP_IF_CTRL, 3, HDMI_EDP1_PIXCLK_DIV_SHIFT,
+				if_pixclk_div, false);
+
+		vop2_grf_writel(vop2, vop2->vop_grf, RK3588_GRF_VOP_CON2, EN_MASK,
+				RK3588_GRF_HDMITX1_ENABLE_SHIFT, 1);
+		vop2_grf_writel(vop2, vop2->vo1_grf, RK3588_GRF_VO1_CON0,
+				HDMI_SYNC_POL_MASK,
+				HDMI1_SYNC_POL_SHIFT, val);
+	}
+
+	if (output_if & VOP_OUTPUT_IF_DP0) {
+		vop2_mask_write(vop2, RK3568_DSP_IF_EN, EN_MASK, RK3588_DP0_EN_SHIFT,
+				1, false);
+		vop2_mask_write(vop2, RK3568_DSP_IF_EN, IF_MUX_MASK, RK3588_DP0_MUX_SHIFT,
+				cstate->crtc_id, false);
+		vop2_mask_write(vop2, RK3568_DSP_IF_POL, RK3588_IF_PIN_POL_MASK,
+				RK3588_DP0_PIN_POL_SHIFT, val, false);
+	}
+
+	if (output_if & VOP_OUTPUT_IF_DP1) {
+		vop2_mask_write(vop2, RK3568_DSP_IF_EN, EN_MASK, RK3588_DP1_EN_SHIFT,
+				1, false);
+		vop2_mask_write(vop2, RK3568_DSP_IF_EN, IF_MUX_MASK, RK3588_DP1_MUX_SHIFT,
+				cstate->crtc_id, false);
+		vop2_mask_write(vop2, RK3568_DSP_IF_POL, RK3588_IF_PIN_POL_MASK,
+				RK3588_DP1_PIN_POL_SHIFT, val, false);
+	}
+
+	vop2_mask_write(vop2, RK3588_VP0_CLK_CTRL + vp_offset, 0x3,
+			DCLK_CORE_DIV_SHIFT, cstate->dclk_core_div, false);
+	vop2_mask_write(vop2, RK3588_VP0_CLK_CTRL + vp_offset, 0x3,
+			DCLK_OUT_DIV_SHIFT, cstate->dclk_out_div, false);
+
+	return dclk_rate;
+}
+
+static void rk3568_vop2_setup_dual_channel_if(struct display_state *state)
+{
+	struct crtc_state *cstate = &state->crtc_state;
+	struct connector_state *conn_state = &state->conn_state;
+	struct vop2 *vop2 = cstate->private;
+	u32 vp_offset = (cstate->crtc_id * 0x100);
+
+	if (conn_state->output_flags &
+	    ROCKCHIP_OUTPUT_DUAL_CHANNEL_ODD_EVEN_MODE) {
+		vop2_mask_write(vop2, RK3568_DSP_IF_CTRL, EN_MASK,
+				LVDS_DUAL_EN_SHIFT, 1, false);
+		vop2_mask_write(vop2, RK3568_DSP_IF_CTRL, EN_MASK,
+				LVDS_DUAL_LEFT_RIGHT_EN_SHIFT, 0, false);
+		if (conn_state->output_flags & ROCKCHIP_OUTPUT_DATA_SWAP)
+			vop2_mask_write(vop2, RK3568_DSP_IF_CTRL, EN_MASK,
+					LVDS_DUAL_SWAP_EN_SHIFT, 1, false);
+
+		return;
+	}
+
+	vop2_mask_write(vop2, RK3568_VP0_MIPI_CTRL + vp_offset, EN_MASK,
+			MIPI_DUAL_EN_SHIFT, 1, false);
+	if (conn_state->output_flags & ROCKCHIP_OUTPUT_DATA_SWAP) {
+		vop2_mask_write(vop2, RK3568_VP0_MIPI_CTRL + vp_offset, EN_MASK,
+				MIPI_DUAL_SWAP_EN_SHIFT, 1, false);
+	}
+
+	if (conn_state->output_if & VOP_OUTPUT_IF_LVDS1) {
+		vop2_mask_write(vop2, RK3568_DSP_IF_CTRL, EN_MASK,
+				LVDS_DUAL_EN_SHIFT, 1, false);
+		vop2_mask_write(vop2, RK3568_DSP_IF_CTRL, EN_MASK,
+				LVDS_DUAL_LEFT_RIGHT_EN_SHIFT, 1, false);
+	}
+}
+
+static unsigned long rk3568_vop2_if_cfg(struct display_state *state)
+{
+	struct crtc_state *cstate = &state->crtc_state;
+	struct connector_state *conn_state = &state->conn_state;
+	struct drm_display_mode *mode = &conn_state->mode;
+	struct vop2 *vop2 = cstate->private;
+	bool dclk_inv;
+	u32 val;
+
+	dclk_inv = (conn_state->bus_flags & DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE) ? 1 : 0;
+	val = (mode->flags & DRM_MODE_FLAG_NHSYNC) ? 0 : BIT(HSYNC_POSITIVE);
+	val |= (mode->flags & DRM_MODE_FLAG_NVSYNC) ? 0 : BIT(VSYNC_POSITIVE);
+
+	if (conn_state->output_if & VOP_OUTPUT_IF_RGB) {
+		vop2_mask_write(vop2, RK3568_DSP_IF_EN, EN_MASK, RGB_EN_SHIFT,
+				1, false);
+		vop2_mask_write(vop2, RK3568_DSP_IF_EN, IF_MUX_MASK,
+				RGB_MUX_SHIFT, cstate->crtc_id, false);
+		vop2_mask_write(vop2, RK3568_DSP_IF_POL, IF_CTRL_RGB_LVDS_PIN_POL_MASK,
+				IF_CTRL_RGB_LVDS_PIN_POL_SHIFT, val, false);
+		vop2_grf_writel(vop2, vop2->grf, RK3568_GRF_VO_CON1, EN_MASK,
+				GRF_RGB_DCLK_INV_SHIFT, dclk_inv);
+	}
+
+	if (conn_state->output_if & VOP_OUTPUT_IF_BT1120) {
+		vop2_mask_write(vop2, RK3568_DSP_IF_EN, EN_MASK, RGB_EN_SHIFT,
+				1, false);
+		vop2_mask_write(vop2, RK3568_DSP_IF_EN, EN_MASK,
+				BT1120_EN_SHIFT, 1, false);
+		vop2_mask_write(vop2, RK3568_DSP_IF_EN, IF_MUX_MASK,
+				RGB_MUX_SHIFT, cstate->crtc_id, false);
+		vop2_grf_writel(vop2, vop2->grf, RK3568_GRF_VO_CON1, EN_MASK,
+				GRF_BT1120_CLK_INV_SHIFT, !dclk_inv);
+	}
+
+	if (conn_state->output_if & VOP_OUTPUT_IF_BT656) {
+		vop2_mask_write(vop2, RK3568_DSP_IF_EN, EN_MASK, BT656_EN_SHIFT,
+				1, false);
+		vop2_mask_write(vop2, RK3568_DSP_IF_EN, IF_MUX_MASK,
+				RGB_MUX_SHIFT, cstate->crtc_id, false);
+		vop2_grf_writel(vop2, vop2->grf, RK3568_GRF_VO_CON1, EN_MASK,
+				GRF_BT656_CLK_INV_SHIFT, !dclk_inv);
+	}
+
+	if (conn_state->output_if & VOP_OUTPUT_IF_LVDS0) {
+		vop2_mask_write(vop2, RK3568_DSP_IF_EN, EN_MASK, LVDS0_EN_SHIFT,
+				1, false);
+		vop2_mask_write(vop2, RK3568_DSP_IF_EN, IF_MUX_MASK,
+				LVDS0_MUX_SHIFT, cstate->crtc_id, false);
+		vop2_mask_write(vop2, RK3568_DSP_IF_POL, IF_CTRL_RGB_LVDS_PIN_POL_MASK,
+				IF_CTRL_RGB_LVDS_PIN_POL_SHIFT, val, false);
+		vop2_mask_write(vop2, RK3568_DSP_IF_POL, EN_MASK,
+				IF_CTRL_RGB_LVDS_DCLK_POL_SHIFT, dclk_inv, false);
+	}
+
+	if (conn_state->output_if & VOP_OUTPUT_IF_LVDS1) {
+		vop2_mask_write(vop2, RK3568_DSP_IF_EN, EN_MASK, LVDS1_EN_SHIFT,
+				1, false);
+		vop2_mask_write(vop2, RK3568_DSP_IF_EN, IF_MUX_MASK,
+				LVDS1_MUX_SHIFT, cstate->crtc_id, false);
+		vop2_mask_write(vop2, RK3568_DSP_IF_POL, IF_CTRL_RGB_LVDS_PIN_POL_MASK,
+				IF_CTRL_RGB_LVDS_PIN_POL_SHIFT, val, false);
+		vop2_mask_write(vop2, RK3568_DSP_IF_POL, EN_MASK,
+				IF_CTRL_RGB_LVDS_DCLK_POL_SHIFT, dclk_inv, false);
+	}
+
+
+	if (conn_state->output_if & VOP_OUTPUT_IF_MIPI0) {
+		vop2_mask_write(vop2, RK3568_DSP_IF_EN, EN_MASK, MIPI0_EN_SHIFT,
+				1, false);
+		vop2_mask_write(vop2, RK3568_DSP_IF_EN, IF_MUX_MASK,
+				MIPI0_MUX_SHIFT, cstate->crtc_id, false);
+		vop2_mask_write(vop2, RK3568_DSP_IF_POL, EN_MASK,
+				IF_CRTL_MIPI_DCLK_POL_SHIT, dclk_inv, false);
+	}
+
+	if (conn_state->output_if & VOP_OUTPUT_IF_MIPI1) {
+		vop2_mask_write(vop2, RK3568_DSP_IF_EN, EN_MASK, MIPI1_EN_SHIFT,
+				1, false);
+		vop2_mask_write(vop2, RK3568_DSP_IF_EN, IF_MUX_MASK,
+				MIPI1_MUX_SHIFT, cstate->crtc_id, false);
+		vop2_mask_write(vop2, RK3568_DSP_IF_POL, EN_MASK,
+				IF_CRTL_MIPI_DCLK_POL_SHIT, dclk_inv, false);
+	}
+
+	if (conn_state->output_flags &
+		    ROCKCHIP_OUTPUT_DUAL_CHANNEL_LEFT_RIGHT_MODE ||
+	    conn_state->output_flags &
+		    ROCKCHIP_OUTPUT_DUAL_CHANNEL_ODD_EVEN_MODE)
+		rk3568_vop2_setup_dual_channel_if(state);
+
+	if (conn_state->output_if & VOP_OUTPUT_IF_eDP0) {
+		vop2_mask_write(vop2, RK3568_DSP_IF_EN, EN_MASK, EDP0_EN_SHIFT,
+				1, false);
+		vop2_mask_write(vop2, RK3568_DSP_IF_EN, IF_MUX_MASK,
+				EDP0_MUX_SHIFT, cstate->crtc_id, false);
+		vop2_mask_write(vop2, RK3568_DSP_IF_POL, EN_MASK,
+				IF_CRTL_EDP_DCLK_POL_SHIT, dclk_inv, false);
+		vop2_mask_write(vop2, RK3568_DSP_IF_POL, IF_CTRL_EDP_PIN_POL_MASK,
+				IF_CTRL_EDP_PIN_POL_SHIFT, val, false);
+	}
+
+	if (conn_state->output_if & VOP_OUTPUT_IF_HDMI0) {
+		vop2_mask_write(vop2, RK3568_DSP_IF_EN, EN_MASK, HDMI0_EN_SHIFT,
+				1, false);
+		vop2_mask_write(vop2, RK3568_DSP_IF_EN, IF_MUX_MASK,
+				HDMI0_MUX_SHIFT, cstate->crtc_id, false);
+		vop2_mask_write(vop2, RK3568_DSP_IF_POL, EN_MASK,
+				IF_CRTL_HDMI_DCLK_POL_SHIT, 1, false);
+		vop2_mask_write(vop2, RK3568_DSP_IF_POL,
+				IF_CRTL_HDMI_PIN_POL_MASK,
+				IF_CRTL_HDMI_PIN_POL_SHIT, val, false);
+	}
+
+	return mode->crtc_clock;
+}
+
+static unsigned long rk3528_vop2_if_cfg(struct display_state *state)
+{
+	struct crtc_state *cstate = &state->crtc_state;
+	struct connector_state *conn_state = &state->conn_state;
+	struct drm_display_mode *mode = &conn_state->mode;
+	struct vop2 *vop2 = cstate->private;
+	u32 val;
+
+	val = (mode->flags & DRM_MODE_FLAG_NHSYNC) ? 0 : BIT(HSYNC_POSITIVE);
+	val |= (mode->flags & DRM_MODE_FLAG_NVSYNC) ? 0 : BIT(VSYNC_POSITIVE);
+
+	if (conn_state->output_if & VOP_OUTPUT_IF_BT656) {
+		vop2_mask_write(vop2, RK3568_DSP_IF_EN, EN_MASK, BT656_EN_SHIFT,
+				1, false);
+		vop2_mask_write(vop2, RK3568_DSP_IF_EN, IF_MUX_MASK,
+				RGB_MUX_SHIFT, cstate->crtc_id, false);
+	}
+
+	if (conn_state->output_if & VOP_OUTPUT_IF_HDMI0) {
+		vop2_mask_write(vop2, RK3568_DSP_IF_EN, EN_MASK, HDMI0_EN_SHIFT,
+				1, false);
+		vop2_mask_write(vop2, RK3568_DSP_IF_EN, IF_MUX_MASK,
+				HDMI0_MUX_SHIFT, cstate->crtc_id, false);
+		vop2_mask_write(vop2, RK3568_DSP_IF_POL, EN_MASK,
+				IF_CRTL_HDMI_DCLK_POL_SHIT, 1, false);
+		vop2_mask_write(vop2, RK3568_DSP_IF_POL,
+				IF_CRTL_HDMI_PIN_POL_MASK,
+				IF_CRTL_HDMI_PIN_POL_SHIT, val, false);
+	}
+
+	return mode->crtc_clock;
+}
+
+static unsigned long rk3562_vop2_if_cfg(struct display_state *state)
+{
+	struct crtc_state *cstate = &state->crtc_state;
+	struct connector_state *conn_state = &state->conn_state;
+	struct drm_display_mode *mode = &conn_state->mode;
+	struct vop2 *vop2 = cstate->private;
+	bool dclk_inv;
+	u32 val;
+
+	dclk_inv = (conn_state->bus_flags & DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE) ? 1 : 0;
+	val = (mode->flags & DRM_MODE_FLAG_NHSYNC) ? 0 : BIT(HSYNC_POSITIVE);
+	val |= (mode->flags & DRM_MODE_FLAG_NVSYNC) ? 0 : BIT(VSYNC_POSITIVE);
+
+	if (conn_state->output_if & VOP_OUTPUT_IF_RGB) {
+		vop2_mask_write(vop2, RK3568_DSP_IF_EN, EN_MASK, RGB_EN_SHIFT,
+				1, false);
+		vop2_mask_write(vop2, RK3568_DSP_IF_EN, IF_MUX_MASK,
+				RGB_MUX_SHIFT, cstate->crtc_id, false);
+		vop2_grf_writel(vop2, vop2->grf, RK3562_GRF_IOC_VO_IO_CON, EN_MASK,
+				GRF_RGB_DCLK_INV_SHIFT, dclk_inv);
+		vop2_mask_write(vop2, RK3568_DSP_IF_POL, RK3562_IF_PIN_POL_MASK,
+				IF_CTRL_RGB_LVDS_PIN_POL_SHIFT, val, false);
+	}
+
+	if (conn_state->output_if & VOP_OUTPUT_IF_LVDS0) {
+		vop2_mask_write(vop2, RK3568_DSP_IF_EN, EN_MASK, LVDS0_EN_SHIFT,
+				1, false);
+		vop2_mask_write(vop2, RK3568_DSP_IF_EN, IF_MUX_MASK,
+				LVDS0_MUX_SHIFT, cstate->crtc_id, false);
+		vop2_mask_write(vop2, RK3568_DSP_IF_POL, EN_MASK,
+				IF_CTRL_RGB_LVDS_DCLK_POL_SHIFT, dclk_inv, false);
+		vop2_mask_write(vop2, RK3568_DSP_IF_POL, RK3562_IF_PIN_POL_MASK,
+				IF_CTRL_RGB_LVDS_PIN_POL_SHIFT, val, false);
+	}
+
+	if (conn_state->output_if & VOP_OUTPUT_IF_MIPI0) {
+		vop2_mask_write(vop2, RK3568_DSP_IF_EN, EN_MASK, MIPI0_EN_SHIFT,
+				1, false);
+		vop2_mask_write(vop2, RK3568_DSP_IF_EN, IF_MUX_MASK,
+				MIPI0_MUX_SHIFT, cstate->crtc_id, false);
+		vop2_mask_write(vop2, RK3568_DSP_IF_POL, EN_MASK,
+				RK3562_MIPI_DCLK_POL_SHIFT, dclk_inv, false);
+		vop2_mask_write(vop2, RK3568_DSP_IF_POL, RK3562_IF_PIN_POL_MASK,
+				RK3562_MIPI_PIN_POL_SHIFT, val, false);
+	}
+
+	return mode->crtc_clock;
+}
+
+static void vop2_post_color_swap(struct display_state *state)
+{
+	struct crtc_state *cstate = &state->crtc_state;
+	struct connector_state *conn_state = &state->conn_state;
+	struct vop2 *vop2 = cstate->private;
+	u32 vp_offset = (cstate->crtc_id * 0x100);
+	u32 output_type = conn_state->type;
+	u32 data_swap = 0;
+
+	if (is_uv_swap(conn_state->bus_format, conn_state->output_mode) ||
+	    is_rb_swap(conn_state->bus_format, conn_state->output_mode))
+		data_swap = DSP_RB_SWAP;
+
+	if (vop2->version == VOP_VERSION_RK3588 &&
+	    (output_type == DRM_MODE_CONNECTOR_HDMIA ||
+	     output_type == DRM_MODE_CONNECTOR_eDP) &&
+	    (conn_state->bus_format == MEDIA_BUS_FMT_YUV8_1X24 ||
+	     conn_state->bus_format == MEDIA_BUS_FMT_YUV10_1X30))
+		data_swap |= DSP_RG_SWAP;
+
+	vop2_mask_write(vop2, RK3568_VP0_DSP_CTRL + vp_offset,
+			DATA_SWAP_MASK, DATA_SWAP_SHIFT, data_swap, false);
+}
+
+static void vop2_clk_set_parent(struct clk *clk, struct clk *parent)
+{
+	int ret = 0;
+
+	if (parent->dev)
+		ret = clk_set_parent(clk, parent);
+	if (ret < 0)
+		debug("failed to set %s as parent for %s\n",
+		      parent->dev->name, clk->dev->name);
+}
+
+static ulong vop2_clk_set_rate(struct clk *clk, ulong rate)
+{
+	int ret = 0;
+
+	if (clk->dev)
+		ret = clk_set_rate(clk, rate);
+	if (ret < 0)
+		debug("failed to set %s rate %lu \n", clk->dev->name, rate);
+
+	return ret;
+}
+
+static void vop2_calc_dsc_cru_cfg(struct display_state *state,
+				  int *dsc_txp_clk_div, int *dsc_pxl_clk_div,
+				  int *dsc_cds_clk_div, u64 dclk_rate)
+{
+	struct crtc_state *cstate = &state->crtc_state;
+
+	*dsc_txp_clk_div = dclk_rate / cstate->dsc_txp_clk_rate;
+	*dsc_pxl_clk_div = dclk_rate / cstate->dsc_pxl_clk_rate;
+	*dsc_cds_clk_div = dclk_rate / cstate->dsc_cds_clk_rate;
+
+	*dsc_txp_clk_div = ilog2(*dsc_txp_clk_div);
+	*dsc_pxl_clk_div = ilog2(*dsc_pxl_clk_div);
+	*dsc_cds_clk_div = ilog2(*dsc_cds_clk_div);
+}
+
+static void vop2_load_pps(struct display_state *state, struct vop2 *vop2, u8 dsc_id)
+{
+	struct crtc_state *cstate = &state->crtc_state;
+	struct drm_dsc_picture_parameter_set *pps = &cstate->pps;
+	struct drm_dsc_picture_parameter_set config_pps;
+	const struct vop2_data *vop2_data = vop2->data;
+	const struct vop2_dsc_data *dsc_data = &vop2_data->dsc[dsc_id];
+	u32 *pps_val = (u32 *)&config_pps;
+	u32 decoder_regs_offset = (dsc_id * 0x100);
+	int i = 0;
+
+	memcpy(&config_pps, pps, sizeof(config_pps));
+
+	if ((config_pps.pps_3 & 0xf) > dsc_data->max_linebuf_depth) {
+		config_pps.pps_3 &= 0xf0;
+		config_pps.pps_3 |= dsc_data->max_linebuf_depth;
+		printf("DSC%d max_linebuf_depth is: %d, current set value is: %d\n",
+		       dsc_id, dsc_data->max_linebuf_depth, config_pps.pps_3 & 0xf);
+	}
+
+	for (i = 0; i < DSC_NUM_BUF_RANGES; i++) {
+		config_pps.rc_range_parameters[i] =
+			(pps->rc_range_parameters[i] >> 3 & 0x1f) |
+			((pps->rc_range_parameters[i] >> 14 & 0x3) << 5) |
+			((pps->rc_range_parameters[i] >> 0 & 0x7) << 7) |
+			((pps->rc_range_parameters[i] >> 8 & 0x3f) << 10);
+	}
+
+	for (i = 0; i < ROCKCHIP_DSC_PPS_SIZE_BYTE / 4; i++)
+		vop2_writel(vop2, RK3588_DSC_8K_PPS0_3 + decoder_regs_offset + i * 4, *pps_val++);
+}
+
+static void vop2_dsc_enable(struct display_state *state, struct vop2 *vop2, u8 dsc_id, u64 dclk_rate)
+{
+	struct connector_state *conn_state = &state->conn_state;
+	struct drm_display_mode *mode = &conn_state->mode;
+	struct crtc_state *cstate = &state->crtc_state;
+	struct rockchip_dsc_sink_cap *dsc_sink_cap = &cstate->dsc_sink_cap;
+	const struct vop2_data *vop2_data = vop2->data;
+	const struct vop2_dsc_data *dsc_data = &vop2_data->dsc[dsc_id];
+	bool mipi_ds_mode = false;
+	u8 dsc_interface_mode = 0;
+	u16 hsync_len = mode->crtc_hsync_end - mode->crtc_hsync_start;
+	u16 hdisplay = mode->crtc_hdisplay;
+	u16 htotal = mode->crtc_htotal;
+	u16 hact_st = mode->crtc_htotal - mode->crtc_hsync_start;
+	u16 vdisplay = mode->crtc_vdisplay;
+	u16 vtotal = mode->crtc_vtotal;
+	u16 vsync_len = mode->crtc_vsync_end - mode->crtc_vsync_start;
+	u16 vact_st = mode->crtc_vtotal - mode->crtc_vsync_start;
+	u16 vact_end = vact_st + vdisplay;
+	u32 ctrl_regs_offset = (dsc_id * 0x30);
+	u32 decoder_regs_offset = (dsc_id * 0x100);
+	int dsc_txp_clk_div = 0;
+	int dsc_pxl_clk_div = 0;
+	int dsc_cds_clk_div = 0;
+	int val = 0;
+
+	if (!vop2->data->nr_dscs) {
+		printf("Unsupported DSC\n");
+		return;
+	}
+
+	if (cstate->dsc_slice_num > dsc_data->max_slice_num)
+		printf("DSC%d supported max slice is: %d, current is: %d\n",
+		       dsc_data->id, dsc_data->max_slice_num, cstate->dsc_slice_num);
+
+	if (dsc_data->pd_id) {
+		if (vop2_power_domain_on(vop2, dsc_data->pd_id))
+			printf("open dsc%d pd fail\n", dsc_id);
+	}
+
+	vop2_mask_write(vop2, RK3588_DSC_8K_INIT_DLY + ctrl_regs_offset, EN_MASK,
+			SCAN_TIMING_PARA_IMD_EN_SHIFT, 1, false);
+	vop2_mask_write(vop2, RK3588_DSC_8K_SYS_CTRL + ctrl_regs_offset, DSC_PORT_SEL_MASK,
+			DSC_PORT_SEL_SHIFT, cstate->crtc_id, false);
+	if (conn_state->output_if & (VOP_OUTPUT_IF_HDMI0 | VOP_OUTPUT_IF_HDMI1)) {
+		dsc_interface_mode = VOP_DSC_IF_HDMI;
+	} else {
+		mipi_ds_mode = !!(conn_state->output_flags & ROCKCHIP_OUTPUT_MIPI_DS_MODE);
+		if (mipi_ds_mode)
+			dsc_interface_mode = VOP_DSC_IF_MIPI_DS_MODE;
+		else
+			dsc_interface_mode = VOP_DSC_IF_MIPI_VIDEO_MODE;
+	}
+
+	if (conn_state->output_flags & ROCKCHIP_OUTPUT_DUAL_CHANNEL_LEFT_RIGHT_MODE)
+		vop2_mask_write(vop2, RK3588_DSC_8K_SYS_CTRL + ctrl_regs_offset, DSC_MAN_MODE_MASK,
+				DSC_MAN_MODE_SHIFT, 0, false);
+	else
+		vop2_mask_write(vop2, RK3588_DSC_8K_SYS_CTRL + ctrl_regs_offset, DSC_MAN_MODE_MASK,
+				DSC_MAN_MODE_SHIFT, 1, false);
+
+	vop2_calc_dsc_cru_cfg(state, &dsc_txp_clk_div, &dsc_pxl_clk_div, &dsc_cds_clk_div, dclk_rate);
+
+	vop2_mask_write(vop2, RK3588_DSC_8K_SYS_CTRL + ctrl_regs_offset, DSC_INTERFACE_MODE_MASK,
+			DSC_INTERFACE_MODE_SHIFT, dsc_interface_mode, false);
+	vop2_mask_write(vop2, RK3588_DSC_8K_SYS_CTRL + ctrl_regs_offset, DSC_PIXEL_NUM_MASK,
+			DSC_PIXEL_NUM_SHIFT, cstate->dsc_pixel_num >> 1, false);
+	vop2_mask_write(vop2, RK3588_DSC_8K_SYS_CTRL + ctrl_regs_offset, DSC_TXP_CLK_DIV_MASK,
+			DSC_TXP_CLK_DIV_SHIFT, dsc_txp_clk_div, false);
+	vop2_mask_write(vop2, RK3588_DSC_8K_SYS_CTRL + ctrl_regs_offset, DSC_PXL_CLK_DIV_MASK,
+			DSC_PXL_CLK_DIV_SHIFT, dsc_pxl_clk_div, false);
+	vop2_mask_write(vop2, RK3588_DSC_8K_SYS_CTRL + ctrl_regs_offset, DSC_CDS_CLK_DIV_MASK,
+			DSC_CDS_CLK_DIV_SHIFT, dsc_cds_clk_div, false);
+	vop2_mask_write(vop2, RK3588_DSC_8K_SYS_CTRL + ctrl_regs_offset, EN_MASK,
+			DSC_SCAN_EN_SHIFT, !mipi_ds_mode, false);
+	vop2_mask_write(vop2, RK3588_DSC_8K_SYS_CTRL + ctrl_regs_offset, DSC_CDS_CLK_DIV_MASK,
+			DSC_HALT_EN_SHIFT, mipi_ds_mode, false);
+
+	if (!mipi_ds_mode) {
+		u16 dsc_hsync, dsc_htotal, dsc_hact_st, dsc_hact_end;
+		u32 target_bpp = dsc_sink_cap->target_bits_per_pixel_x16;
+		u64 dsc_cds_rate = cstate->dsc_cds_clk_rate;
+		u32 v_pixclk_mhz = mode->crtc_clock / 1000; /* video timing pixclk */
+		u32 dly_num, dsc_cds_rate_mhz, val = 0;
+		int k = 1;
+
+		if (conn_state->output_flags & ROCKCHIP_OUTPUT_DUAL_CHANNEL_LEFT_RIGHT_MODE)
+			k = 2;
+
+		if (target_bpp >> 4 < dsc_data->min_bits_per_pixel)
+			printf("Unsupported bpp less than: %d\n", dsc_data->min_bits_per_pixel);
+
+		/*
+		 * dly_num = delay_line_num * T(one-line) / T (dsc_cds)
+		 * T (one-line) = 1/v_pixclk_mhz * htotal = htotal/v_pixclk_mhz
+		 * T (dsc_cds) = 1 / dsc_cds_rate_mhz
+		 *
+		 * HDMI:
+		 * delay_line_num: according the pps initial_xmit_delay to adjust vop dsc delay
+		 *                 delay_line_num = 4 - BPP / 8
+		 *                                = (64 - target_bpp / 8) / 16
+		 * dly_num = htotal * dsc_cds_rate_mhz / v_pixclk_mhz * (64 - target_bpp / 8) / 16;
+		 *
+		 * MIPI DSI[4320 and 9216 is buffer size for DSC]:
+		 * DSC0:delay_line_num = 4320 * 8 / slince_num / chunk_size;
+		 *	delay_line_num = delay_line_num > 5 ? 5 : delay_line_num;
+		 * DSC1:delay_line_num = 9216 * 2 / slince_num / chunk_size;
+		 *	delay_line_num = delay_line_num > 5 ? 5 : delay_line_num;
+		 * dly_num = htotal * dsc_cds_rate_mhz / v_pixclk_mhz * delay_line_num
+		 */
+		do_div(dsc_cds_rate, 1000000); /* hz to Mhz */
+		dsc_cds_rate_mhz = dsc_cds_rate;
+		dsc_hsync = hsync_len / 2;
+		if (dsc_interface_mode == VOP_DSC_IF_HDMI) {
+			dly_num = htotal * dsc_cds_rate_mhz / v_pixclk_mhz * (64 - target_bpp / 8) / 16;
+		} else {
+			int dsc_buf_size  = dsc_id == 0 ? 4320 * 8 : 9216 * 2;
+			int delay_line_num = dsc_buf_size / cstate->dsc_slice_num /
+					     be16_to_cpu(cstate->pps.chunk_size);
+
+			delay_line_num = delay_line_num > 5 ? 5 : delay_line_num;
+			dly_num = htotal * dsc_cds_rate_mhz / v_pixclk_mhz * delay_line_num;
+
+			/* The dsc mipi video mode dsc_hsync minimum size is 8 pixels */
+			if (dsc_hsync < 8)
+				dsc_hsync = 8;
+		}
+		vop2_mask_write(vop2, RK3588_DSC_8K_INIT_DLY + ctrl_regs_offset, DSC_INIT_DLY_MODE_MASK,
+				DSC_INIT_DLY_MODE_SHIFT, 0, false);
+		vop2_mask_write(vop2, RK3588_DSC_8K_INIT_DLY + ctrl_regs_offset, DSC_INIT_DLY_NUM_MASK,
+				DSC_INIT_DLY_NUM_SHIFT, dly_num, false);
+
+		/*
+		 * htotal / dclk_core = dsc_htotal /cds_clk
+		 *
+		 * dclk_core = DCLK / (1 << dclk_core->div_val)
+		 * cds_clk = txp_clk / (1 << dsc_cds_clk->div_val)
+		 * txp_clk = DCLK / (1 << dsc_txp_clk->div_val)
+		 *
+		 * dsc_htotal = htotal * (1 << dclk_core->div_val) /
+		 *              ((1 << dsc_txp_clk->div_val) * (1 << dsc_cds_clk->div_val))
+		 */
+		dsc_htotal = htotal * (1 << cstate->dclk_core_div) /
+			     ((1 << dsc_txp_clk_div) * (1 << dsc_cds_clk_div));
+		val = dsc_htotal << 16 | dsc_hsync;
+		vop2_mask_write(vop2, RK3588_DSC_8K_HTOTAL_HS_END + ctrl_regs_offset, DSC_HTOTAL_PW_MASK,
+				DSC_HTOTAL_PW_SHIFT, val, false);
+
+		dsc_hact_st = hact_st / 2;
+		dsc_hact_end = (hdisplay / k * target_bpp >> 4) / 24 + dsc_hact_st;
+		val = dsc_hact_end << 16 | dsc_hact_st;
+		vop2_mask_write(vop2, RK3588_DSC_8K_HACT_ST_END + ctrl_regs_offset, DSC_HACT_ST_END_MASK,
+				DSC_HACT_ST_END_SHIFT, val, false);
+
+		vop2_mask_write(vop2, RK3588_DSC_8K_VTOTAL_VS_END + ctrl_regs_offset, DSC_VTOTAL_PW_MASK,
+				DSC_VTOTAL_PW_SHIFT, vtotal << 16 | vsync_len, false);
+		vop2_mask_write(vop2, RK3588_DSC_8K_VACT_ST_END + ctrl_regs_offset, DSC_VACT_ST_END_MASK,
+				DSC_VACT_ST_END_SHIFT, vact_end << 16 | vact_st, false);
+	}
+
+	vop2_mask_write(vop2, RK3588_DSC_8K_RST + ctrl_regs_offset, RST_DEASSERT_MASK,
+			RST_DEASSERT_SHIFT, 1, false);
+	udelay(10);
+
+	val |= DSC_CTRL0_DEF_CON | (ilog2(cstate->dsc_slice_num) << DSC_NSLC_SHIFT) |
+	       ((dsc_sink_cap->version_minor == 2 ? 1 : 0) << DSC_IFEP_SHIFT);
+	vop2_writel(vop2, RK3588_DSC_8K_CTRL0 + decoder_regs_offset, val);
+
+	vop2_load_pps(state, vop2, dsc_id);
+
+	val |= (1 << DSC_PPS_UPD_SHIFT);
+	vop2_writel(vop2, RK3588_DSC_8K_CTRL0 + decoder_regs_offset, val);
+
+	printf("DSC%d: txp:%lld div:%d, pxl:%lld div:%d, dsc:%lld div:%d\n",
+	       dsc_id,
+	       cstate->dsc_txp_clk_rate, dsc_txp_clk_div,
+	       cstate->dsc_pxl_clk_rate, dsc_pxl_clk_div,
+	       cstate->dsc_cds_clk_rate, dsc_cds_clk_div);
+}
+
+static bool is_extend_pll(struct display_state *state, struct udevice **clk_dev)
+{
+	struct crtc_state *cstate = &state->crtc_state;
+	struct vop2 *vop2 = cstate->private;
+	struct udevice *vp_dev, *dev;
+	struct ofnode_phandle_args args;
+	char vp_name[10];
+	int ret;
+
+	if (vop2->version != VOP_VERSION_RK3588)
+		return false;
+
+	sprintf(vp_name, "port@%d", cstate->crtc_id);
+	if (uclass_find_device_by_name(UCLASS_VIDEO_CRTC, vp_name, &vp_dev)) {
+		debug("warn: can't get vp device\n");
+		return false;
+	}
+
+	ret = dev_read_phandle_with_args(vp_dev, "assigned-clock-parents", "#clock-cells", 0,
+					 0, &args);
+	if (ret) {
+		debug("assigned-clock-parents's node not define\n");
+		return false;
+	}
+
+	if (uclass_find_device_by_ofnode(UCLASS_CLK, args.node, &dev)) {
+		debug("warn: can't get clk device\n");
+		return false;
+	}
+
+	if (!strcmp(dev->name, "hdmiphypll_clk0") || !strcmp(dev->name, "hdmiphypll_clk1")) {
+		printf("%s: clk dev :%s: vp port:%s\n", __func__, dev->name, vp_dev->name);
+		if (clk_dev)
+			*clk_dev = dev;
+		return true;
+	}
+
+	return false;
+}
+
+static void vop3_mcu_mode_setup(struct display_state *state)
+{
+	struct crtc_state *cstate = &state->crtc_state;
+	struct vop2 *vop2 = cstate->private;
+	u32 vp_offset = (cstate->crtc_id * 0x100);
+
+	vop2_mask_write(vop2, RK3562_VP0_MCU_CTRL + vp_offset, EN_MASK,
+			MCU_TYPE_SHIFT, 1, false);
+	vop2_mask_write(vop2, RK3562_VP0_MCU_CTRL + vp_offset, EN_MASK,
+			MCU_HOLD_MODE_SHIFT, 1, false);
+	vop2_mask_write(vop2, RK3562_VP0_MCU_CTRL + vp_offset, MCU_PIX_TOTAL_MASK,
+			MCU_PIX_TOTAL_SHIFT, cstate->mcu_timing.mcu_pix_total, false);
+	vop2_mask_write(vop2, RK3562_VP0_MCU_CTRL + vp_offset, MCU_CS_PST_MASK,
+			MCU_CS_PST_SHIFT, cstate->mcu_timing.mcu_cs_pst, false);
+	vop2_mask_write(vop2, RK3562_VP0_MCU_CTRL + vp_offset, MCU_CS_PEND_MASK,
+			MCU_CS_PEND_SHIFT, cstate->mcu_timing.mcu_cs_pend, false);
+	vop2_mask_write(vop2, RK3562_VP0_MCU_CTRL + vp_offset, MCU_RW_PST_MASK,
+			MCU_RW_PST_SHIFT, cstate->mcu_timing.mcu_rw_pst, false);
+	vop2_mask_write(vop2, RK3562_VP0_MCU_CTRL + vp_offset, MCU_RW_PEND_MASK,
+			MCU_RW_PEND_SHIFT, cstate->mcu_timing.mcu_rw_pend, false);
+}
+
+static void vop3_mcu_bypass_mode_setup(struct display_state *state)
+{
+	struct crtc_state *cstate = &state->crtc_state;
+	struct vop2 *vop2 = cstate->private;
+	u32 vp_offset = (cstate->crtc_id * 0x100);
+
+	vop2_mask_write(vop2, RK3562_VP0_MCU_CTRL + vp_offset, EN_MASK,
+			MCU_TYPE_SHIFT, 1, false);
+	vop2_mask_write(vop2, RK3562_VP0_MCU_CTRL + vp_offset, EN_MASK,
+			MCU_HOLD_MODE_SHIFT, 1, false);
+	vop2_mask_write(vop2, RK3562_VP0_MCU_CTRL + vp_offset, MCU_PIX_TOTAL_MASK,
+			MCU_PIX_TOTAL_SHIFT, 53, false);
+	vop2_mask_write(vop2, RK3562_VP0_MCU_CTRL + vp_offset, MCU_CS_PST_MASK,
+			MCU_CS_PST_SHIFT, 6, false);
+	vop2_mask_write(vop2, RK3562_VP0_MCU_CTRL + vp_offset, MCU_CS_PEND_MASK,
+			MCU_CS_PEND_SHIFT, 48, false);
+	vop2_mask_write(vop2, RK3562_VP0_MCU_CTRL + vp_offset, MCU_RW_PST_MASK,
+			MCU_RW_PST_SHIFT, 12, false);
+	vop2_mask_write(vop2, RK3562_VP0_MCU_CTRL + vp_offset, MCU_RW_PEND_MASK,
+			MCU_RW_PEND_SHIFT, 30, false);
+}
+
+static int rockchip_vop2_send_mcu_cmd(struct display_state *state, u32 type, u32 value)
+{
+	struct crtc_state *cstate = &state->crtc_state;
+	struct connector_state *conn_state = &state->conn_state;
+	struct drm_display_mode *mode = &conn_state->mode;
+	struct vop2 *vop2 = cstate->private;
+	u32 vp_offset = (cstate->crtc_id * 0x100);
+	u32 cfg_done = CFG_DONE_EN | BIT(cstate->crtc_id) | (BIT(cstate->crtc_id) << 16);
+
+	/*
+	 * 1.disable port dclk auto gating.
+	 * 2.set mcu bypass mode timing to adapt to the mode of sending cmds.
+	 * 3.make setting of output mode take effect.
+	 * 4.set dclk rate to 150M, in order to sync with hclk in sending cmds.
+	 */
+	if (type == MCU_SETBYPASS && value) {
+		vop2_mask_write(vop2, RK3568_AUTO_GATING_CTRL, EN_MASK,
+				AUTO_GATING_EN_SHIFT, 0, false);
+		vop2_mask_write(vop2, RK3568_AUTO_GATING_CTRL, EN_MASK,
+				PORT_DCLK_AUTO_GATING_EN_SHIFT, 0, false);
+		vop3_mcu_bypass_mode_setup(state);
+		vop2_mask_write(vop2, RK3568_VP0_DSP_CTRL + vp_offset, EN_MASK,
+				STANDBY_EN_SHIFT, 0, false);
+		vop2_writel(vop2, RK3568_REG_CFG_DONE, cfg_done);
+		vop2_clk_set_rate(&cstate->dclk, 150000000);
+	}
+
+	switch (type) {
+	case MCU_WRCMD:
+		vop2_mask_write(vop2, RK3562_VP0_MCU_CTRL + vp_offset, EN_MASK,
+				MCU_RS_SHIFT, 0, false);
+		vop2_mask_write(vop2, RK3562_VP0_MCU_RW_BYPASS_PORT + vp_offset,
+				MCU_WRITE_DATA_BYPASS_MASK, MCU_WRITE_DATA_BYPASS_SHIFT,
+				value, false);
+		vop2_mask_write(vop2, RK3562_VP0_MCU_CTRL + vp_offset, EN_MASK,
+				MCU_RS_SHIFT, 1, false);
+		break;
+	case MCU_WRDATA:
+		vop2_mask_write(vop2, RK3562_VP0_MCU_CTRL + vp_offset, EN_MASK,
+				MCU_RS_SHIFT, 1, false);
+		vop2_mask_write(vop2, RK3562_VP0_MCU_RW_BYPASS_PORT + vp_offset,
+				MCU_WRITE_DATA_BYPASS_MASK, MCU_WRITE_DATA_BYPASS_SHIFT,
+				value, false);
+		break;
+	case MCU_SETBYPASS:
+		vop2_mask_write(vop2, RK3562_VP0_MCU_CTRL + vp_offset, EN_MASK,
+				MCU_BYPASS_SHIFT, value ? 1 : 0, false);
+		break;
+	default:
+		break;
+	}
+
+	/*
+	 * 1.restore port dclk auto gating.
+	 * 2.restore mcu data mode timing.
+	 * 3.restore dclk rate to crtc_clock.
+	 */
+	if (type == MCU_SETBYPASS && !value) {
+		vop2_mask_write(vop2, RK3568_AUTO_GATING_CTRL, EN_MASK,
+				AUTO_GATING_EN_SHIFT, 1, false);
+		vop2_mask_write(vop2, RK3568_AUTO_GATING_CTRL, EN_MASK,
+				PORT_DCLK_AUTO_GATING_EN_SHIFT, 1, false);
+		vop3_mcu_mode_setup(state);
+		vop2_mask_write(vop2, RK3568_VP0_DSP_CTRL + vp_offset, EN_MASK,
+				STANDBY_EN_SHIFT, 1, false);
+		vop2_clk_set_rate(&cstate->dclk, mode->crtc_clock * 1000);
+	}
+
+	return 0;
+}
+
+static void vop2_dither_setup(struct vop2 *vop2, int bus_format, int crtc_id)
+{
+	u32 vp_offset = crtc_id * 0x100;
+	u8 dither_down_mode = 0;
+	bool dither_down_en = false;
+	bool pre_dither_down_en = false;
+
+	switch (bus_format) {
+	case MEDIA_BUS_FMT_RGB565_1X16:
+		dither_down_en = true;
+		dither_down_mode = RGB888_TO_RGB565;
+		pre_dither_down_en = true;
+		break;
+	case MEDIA_BUS_FMT_RGB666_1X18:
+	case MEDIA_BUS_FMT_RGB666_1X24_CPADHI:
+	case MEDIA_BUS_FMT_RGB666_1X7X3_SPWG:
+		dither_down_en = true;
+		dither_down_mode = RGB888_TO_RGB666;
+		pre_dither_down_en = true;
+		break;
+	case MEDIA_BUS_FMT_YUYV8_1X16:
+	case MEDIA_BUS_FMT_YUV8_1X24:
+	case MEDIA_BUS_FMT_UYYVYY8_0_5X24:
+		dither_down_en = false;
+		pre_dither_down_en = true;
+		break;
+	case MEDIA_BUS_FMT_YUYV10_1X20:
+	case MEDIA_BUS_FMT_YUV10_1X30:
+	case MEDIA_BUS_FMT_UYYVYY10_0_5X30:
+	case MEDIA_BUS_FMT_RGB101010_1X30:
+		dither_down_en = false;
+		pre_dither_down_en = false;
+		break;
+	case MEDIA_BUS_FMT_RGB888_3X8:
+	case MEDIA_BUS_FMT_RGB888_DUMMY_4X8:
+	case MEDIA_BUS_FMT_RGB888_1X24:
+	case MEDIA_BUS_FMT_RGB888_1X7X4_SPWG:
+	case MEDIA_BUS_FMT_RGB888_1X7X4_JEIDA:
+	default:
+		dither_down_en = false;
+		pre_dither_down_en = true;
+		break;
+	}
+
+	if (is_yuv_output(bus_format))
+		pre_dither_down_en = false;
+
+	vop2_mask_write(vop2, RK3568_VP0_DSP_CTRL + vp_offset, EN_MASK,
+			PRE_DITHER_DOWN_EN_SHIFT, pre_dither_down_en, false);
+	vop2_mask_write(vop2, RK3568_VP0_DSP_CTRL + vp_offset, EN_MASK,
+			DITHER_DOWN_EN_SHIFT, dither_down_en, false);
+	vop2_mask_write(vop2, RK3568_VP0_DSP_CTRL + vp_offset, EN_MASK,
+			DITHER_DOWN_MODE_SHIFT, dither_down_mode, false);
+}
+
+static int rockchip_vop2_init(struct display_state *state)
+{
+	struct crtc_state *cstate = &state->crtc_state;
+	struct rockchip_vp *vp = &cstate->crtc->vps[cstate->crtc_id];
+	struct connector_state *conn_state = &state->conn_state;
+	struct drm_display_mode *mode = &conn_state->mode;
+	struct vop2 *vop2 = cstate->private;
+	u16 hsync_len = mode->crtc_hsync_end - mode->crtc_hsync_start;
+	u16 hdisplay = mode->crtc_hdisplay;
+	u16 htotal = mode->crtc_htotal;
+	u16 hact_st = mode->crtc_htotal - mode->crtc_hsync_start;
+	u16 hact_end = hact_st + hdisplay;
+	u16 vdisplay = mode->crtc_vdisplay;
+	u16 vtotal = mode->crtc_vtotal;
+	u16 vsync_len = mode->crtc_vsync_end - mode->crtc_vsync_start;
+	u16 vact_st = mode->crtc_vtotal - mode->crtc_vsync_start;
+	u16 vact_end = vact_st + vdisplay;
+	bool yuv_overlay = false;
+	u32 vp_offset = (cstate->crtc_id * 0x100);
+	u32 line_flag_offset = (cstate->crtc_id * 4);
+	u32 val, act_end;
+	u8 dclk_div_factor = 0;
+	char output_type_name[30] = {0};
+#ifndef CONFIG_SPL_BUILD
+	char dclk_name[9];
+#endif
+	struct clk hdmi0_phy_pll;
+	struct clk hdmi1_phy_pll;
+	struct clk hdmi_phy_pll;
+	struct udevice *disp_dev;
+	unsigned long dclk_rate = 0;
+	int ret;
+
+	printf("VOP update mode to: %dx%d%s%d, type:%s for VP%d\n",
+	       mode->crtc_hdisplay, mode->vdisplay,
+	       mode->flags & DRM_MODE_FLAG_INTERLACE ? "i" : "p",
+	       mode->vrefresh,
+	       rockchip_get_output_if_name(conn_state->output_if, output_type_name),
+	       cstate->crtc_id);
+
+	if (mode->hdisplay > VOP2_MAX_VP_OUTPUT_WIDTH) {
+		cstate->splice_mode = true;
+		cstate->splice_crtc_id = vop2->data->vp_data[cstate->crtc_id].splice_vp_id;
+		if (!cstate->splice_crtc_id) {
+			printf("%s: Splice mode is unsupported by vp%d\n",
+			       __func__, cstate->crtc_id);
+			return -EINVAL;
+		}
+
+		vop2_mask_write(vop2, RK3568_SYS_LUT_PORT_SEL, EN_MASK,
+				PORT_MERGE_EN_SHIFT, 1, false);
+	}
+
+	vop2_mask_write(vop2, RK3588_SYS_VAR_FREQ_CTRL, EN_MASK,
+			RK3588_VP0_LINE_FLAG_OR_EN_SHIFT + cstate->crtc_id, 1, false);
+	vop2_mask_write(vop2, RK3588_SYS_VAR_FREQ_CTRL, EN_MASK,
+			RK3588_VP0_ALMOST_FULL_OR_EN_SHIFT + cstate->crtc_id, 1, false);
+
+	vop2_initial(vop2, state);
+	if (vop2->version == VOP_VERSION_RK3588)
+		dclk_rate = rk3588_vop2_if_cfg(state);
+	else if (vop2->version == VOP_VERSION_RK3568)
+		dclk_rate = rk3568_vop2_if_cfg(state);
+	else if (vop2->version == VOP_VERSION_RK3528)
+		dclk_rate = rk3528_vop2_if_cfg(state);
+	else if (vop2->version == VOP_VERSION_RK3562)
+		dclk_rate = rk3562_vop2_if_cfg(state);
+
+	if ((conn_state->output_mode == ROCKCHIP_OUT_MODE_AAAA &&
+	     !(cstate->feature & VOP_FEATURE_OUTPUT_10BIT)) ||
+	    conn_state->output_if & VOP_OUTPUT_IF_BT656)
+		conn_state->output_mode = ROCKCHIP_OUT_MODE_P888;
+
+	vop2_post_color_swap(state);
+
+	vop2_mask_write(vop2, RK3568_VP0_DSP_CTRL + vp_offset, OUT_MODE_MASK,
+			OUT_MODE_SHIFT, conn_state->output_mode, false);
+
+	vop2_dither_setup(vop2, conn_state->bus_format, cstate->crtc_id);
+	if (cstate->splice_mode)
+		vop2_dither_setup(vop2, conn_state->bus_format, cstate->splice_crtc_id);
+
+	yuv_overlay = is_yuv_output(conn_state->bus_format) ? 1 : 0;
+	vop2_mask_write(vop2, RK3568_OVL_CTRL, EN_MASK, cstate->crtc_id,
+			yuv_overlay, false);
+
+	cstate->yuv_overlay = yuv_overlay;
+
+	vop2_writel(vop2, RK3568_VP0_DSP_HTOTAL_HS_END + vp_offset,
+		    (htotal << 16) | hsync_len);
+	val = hact_st << 16;
+	val |= hact_end;
+	vop2_writel(vop2, RK3568_VP0_DSP_HACT_ST_END + vp_offset, val);
+	val = vact_st << 16;
+	val |= vact_end;
+	vop2_writel(vop2, RK3568_VP0_DSP_VACT_ST_END + vp_offset, val);
+	if (mode->flags & DRM_MODE_FLAG_INTERLACE) {
+		u16 vact_st_f1 = vtotal + vact_st + 1;
+		u16 vact_end_f1 = vact_st_f1 + vdisplay;
+
+		val = vact_st_f1 << 16 | vact_end_f1;
+		vop2_writel(vop2, RK3568_VP0_DSP_VACT_ST_END_F1 + vp_offset,
+			    val);
+
+		val = vtotal << 16 | (vtotal + vsync_len);
+		vop2_writel(vop2, RK3568_VP0_DSP_VS_ST_END_F1 + vp_offset, val);
+		vop2_mask_write(vop2, RK3568_VP0_DSP_CTRL + vp_offset, EN_MASK,
+				INTERLACE_EN_SHIFT, 1, false);
+		vop2_mask_write(vop2, RK3568_VP0_DSP_CTRL + vp_offset, EN_MASK,
+				DSP_FILED_POL, 1, false);
+		vop2_mask_write(vop2, RK3568_VP0_DSP_CTRL + vp_offset, EN_MASK,
+				P2I_EN_SHIFT, 1, false);
+		vtotal += vtotal + 1;
+		act_end = vact_end_f1;
+	} else {
+		vop2_mask_write(vop2, RK3568_VP0_DSP_CTRL + vp_offset, EN_MASK,
+				INTERLACE_EN_SHIFT, 0, false);
+		vop2_mask_write(vop2, RK3568_VP0_DSP_CTRL + vp_offset, EN_MASK,
+				P2I_EN_SHIFT, 0, false);
+		act_end = vact_end;
+	}
+	vop2_writel(vop2, RK3568_VP0_DSP_VTOTAL_VS_END + vp_offset,
+		    (vtotal << 16) | vsync_len);
+
+	if (mode->flags & DRM_MODE_FLAG_DBLCLK ||
+	    conn_state->output_if & VOP_OUTPUT_IF_BT656)
+		vop2_mask_write(vop2, RK3568_VP0_DSP_CTRL + vp_offset, EN_MASK,
+				CORE_DCLK_DIV_EN_SHIFT, 1, false);
+	else
+		vop2_mask_write(vop2, RK3568_VP0_DSP_CTRL + vp_offset, EN_MASK,
+				CORE_DCLK_DIV_EN_SHIFT, 0, false);
+
+	if (conn_state->output_mode == ROCKCHIP_OUT_MODE_YUV420)
+		vop2_mask_write(vop2, RK3568_VP0_MIPI_CTRL + vp_offset,
+				DCLK_DIV2_MASK, DCLK_DIV2_SHIFT, 0x3, false);
+	else
+		vop2_mask_write(vop2, RK3568_VP0_MIPI_CTRL + vp_offset,
+				DCLK_DIV2_MASK, DCLK_DIV2_SHIFT, 0, false);
+
+	vop2_mask_write(vop2, RK3568_OVL_CTRL, OVL_MODE_SEL_MASK,
+			OVL_MODE_SEL_SHIFT + cstate->crtc_id, yuv_overlay, false);
+
+	if (yuv_overlay)
+		val = 0x20010200;
+	else
+		val = 0;
+	vop2_writel(vop2, RK3568_VP0_DSP_BG + vp_offset, val);
+	if (cstate->splice_mode) {
+		vop2_mask_write(vop2, RK3568_OVL_CTRL, OVL_MODE_SEL_MASK,
+				OVL_MODE_SEL_SHIFT + cstate->splice_crtc_id,
+				yuv_overlay, false);
+		vop2_writel(vop2, RK3568_VP0_DSP_BG + (cstate->splice_crtc_id * 0x100), val);
+	}
+
+	vop2_mask_write(vop2, RK3568_VP0_DSP_CTRL + vp_offset, EN_MASK,
+			POST_DSP_OUT_R2Y_SHIFT, yuv_overlay, false);
+
+	if (vp->xmirror_en)
+		vop2_mask_write(vop2, RK3568_VP0_DSP_CTRL + vp_offset, EN_MASK,
+				DSP_X_MIR_EN_SHIFT, 1, false);
+
+	vop2_tv_config_update(state, vop2);
+	vop2_post_config(state, vop2);
+	if (cstate->feature & (VOP_FEATURE_POST_ACM | VOP_FEATURE_POST_CSC))
+		vop3_post_config(state, vop2);
+
+	if (cstate->dsc_enable) {
+		if (conn_state->output_flags & ROCKCHIP_OUTPUT_DUAL_CHANNEL_LEFT_RIGHT_MODE) {
+			vop2_dsc_enable(state, vop2, 0, dclk_rate * 1000LL);
+			vop2_dsc_enable(state, vop2, 1, dclk_rate * 1000LL);
+		} else {
+			vop2_dsc_enable(state, vop2, cstate->dsc_id, dclk_rate * 1000LL);
+		}
+	}
+
+#ifndef CONFIG_SPL_BUILD
+	snprintf(dclk_name, sizeof(dclk_name), "dclk_vp%d", cstate->crtc_id);
+	ret = clk_get_by_name(cstate->dev, dclk_name, &cstate->dclk);
+	if (ret) {
+		printf("%s: Failed to get dclk ret=%d\n", __func__, ret);
+		return ret;
+	}
+#endif
+
+	ret = uclass_get_device_by_name(UCLASS_VIDEO, "display-subsystem", &disp_dev);
+	if (!ret) {
+		ret = clk_get_by_name(disp_dev, "hdmi0_phy_pll", &hdmi0_phy_pll);
+		if (ret)
+			debug("%s: hdmi0_phy_pll may not define\n", __func__);
+		ret = clk_get_by_name(disp_dev, "hdmi1_phy_pll", &hdmi1_phy_pll);
+		if (ret)
+			debug("%s: hdmi1_phy_pll may not define\n", __func__);
+	} else {
+		hdmi0_phy_pll.dev = NULL;
+		hdmi1_phy_pll.dev = NULL;
+		debug("%s: Faile to find display-subsystem node\n", __func__);
+	}
+
+	if (vop2->version == VOP_VERSION_RK3528) {
+		struct ofnode_phandle_args args;
+
+		ret = dev_read_phandle_with_args(cstate->dev, "assigned-clock-parents",
+						 "#clock-cells", 0, 0, &args);
+		if (!ret) {
+			ret = uclass_find_device_by_ofnode(UCLASS_CLK, args.node, &hdmi0_phy_pll.dev);
+			if (ret) {
+				debug("warn: can't get clk device\n");
+				return ret;
+			}
+		} else {
+			debug("assigned-clock-parents's node not define\n");
+		}
+	}
+
+	if (mode->crtc_clock < VOP2_MAX_DCLK_RATE) {
+		if (conn_state->output_if & VOP_OUTPUT_IF_HDMI0)
+			vop2_clk_set_parent(&cstate->dclk, &hdmi0_phy_pll);
+		else if (conn_state->output_if & VOP_OUTPUT_IF_HDMI1)
+			vop2_clk_set_parent(&cstate->dclk, &hdmi1_phy_pll);
+
+		/*
+		 * uboot clk driver won't set dclk parent's rate when use
+		 * hdmi phypll as dclk source.
+		 * So set dclk rate is meaningless. Set hdmi phypll rate
+		 * directly.
+		 */
+		if ((conn_state->output_if & VOP_OUTPUT_IF_HDMI0) && hdmi0_phy_pll.dev) {
+			ret = vop2_clk_set_rate(&hdmi0_phy_pll, dclk_rate * 1000);
+		} else if ((conn_state->output_if & VOP_OUTPUT_IF_HDMI1) && hdmi1_phy_pll.dev) {
+			ret = vop2_clk_set_rate(&hdmi1_phy_pll, dclk_rate * 1000);
+		} else {
+			if (is_extend_pll(state, &hdmi_phy_pll.dev)) {
+				ret = vop2_clk_set_rate(&hdmi_phy_pll, dclk_rate * 1000);
+			} else {
+#ifndef CONFIG_SPL_BUILD
+				ret = vop2_clk_set_rate(&cstate->dclk, dclk_rate * 1000);
+#else
+				if (vop2->version == VOP_VERSION_RK3528) {
+					void *cru_base = (void *)RK3528_CRU_BASE;
+
+					/* dclk src switch to hdmiphy pll */
+					writel((BIT(0) << 16) | BIT(0), cru_base + 0x450);
+					rockchip_phy_set_pll(conn_state->connector->phy, dclk_rate * 1000);
+					ret = dclk_rate * 1000;
+				}
+#endif
+			}
+		}
+	} else {
+		if (is_extend_pll(state, &hdmi_phy_pll.dev))
+			ret = vop2_clk_set_rate(&hdmi_phy_pll, dclk_rate * 1000);
+		else
+			ret = vop2_clk_set_rate(&cstate->dclk, dclk_rate * 1000);
+	}
+
+	if (IS_ERR_VALUE(ret)) {
+		printf("%s: Failed to set vp%d dclk[%ld KHZ] ret=%d\n",
+		       __func__, cstate->crtc_id, dclk_rate, ret);
+		return ret;
+	} else {
+		if (cstate->mcu_timing.mcu_pix_total) {
+			mode->crtc_clock = roundup(ret, 1000) / 1000;
+		} else {
+			dclk_div_factor = mode->crtc_clock / dclk_rate;
+			mode->crtc_clock = roundup(ret, 1000) * dclk_div_factor / 1000;
+		}
+		printf("VP%d set crtc_clock to %dKHz\n", cstate->crtc_id, mode->crtc_clock);
+	}
+
+	vop2_mask_write(vop2, RK3568_SYS_CTRL_LINE_FLAG0 + line_flag_offset, LINE_FLAG_NUM_MASK,
+			RK3568_DSP_LINE_FLAG_NUM0_SHIFT, act_end, false);
+	vop2_mask_write(vop2, RK3568_SYS_CTRL_LINE_FLAG0 + line_flag_offset, LINE_FLAG_NUM_MASK,
+			RK3568_DSP_LINE_FLAG_NUM1_SHIFT, act_end, false);
+
+	if (cstate->mcu_timing.mcu_pix_total)
+		vop3_mcu_mode_setup(state);
+
+	return 0;
+}
+
+static void vop2_setup_scale(struct vop2 *vop2, struct vop2_win_data *win,
+			     uint32_t src_w, uint32_t src_h, uint32_t dst_w,
+			     uint32_t dst_h)
+{
+	uint16_t yrgb_hor_scl_mode, yrgb_ver_scl_mode;
+	uint16_t hscl_filter_mode, vscl_filter_mode;
+	uint8_t xgt2 = 0, xgt4 = 0;
+	uint8_t ygt2 = 0, ygt4 = 0;
+	uint32_t xfac = 0, yfac = 0;
+	u32 win_offset = win->reg_offset;
+	bool xgt_en = false;
+	bool xavg_en = false;
+
+	if (is_vop3(vop2)) {
+		if (src_w >= (4 * dst_w)) {
+			xgt4 = 1;
+			src_w >>= 2;
+		} else if (src_w >= (2 * dst_w)) {
+			xgt2 = 1;
+			src_w >>= 1;
+		}
+	}
+
+	/**
+	 * The rk3528 is processed as 2 pixel/cycle,
+	 * so ygt2/ygt4 needs to be triggered in advance to improve performance
+	 * when src_w is bigger than 1920.
+	 * dst_h / src_h is at [1, 0.65)     ygt2=0; ygt4=0;
+	 * dst_h / src_h is at [0.65, 0.35)  ygt2=1; ygt4=0;
+	 * dst_h / src_h is at [0.35, 0)     ygt2=0; ygt4=1;
+	 */
+	if (vop2->version == VOP_VERSION_RK3528 && src_w > 1920) {
+		if (src_h >= (100 * dst_h / 35)) {
+			ygt4 = 1;
+			src_h >>= 2;
+		} else if ((src_h >= 100 * dst_h / 65) && (src_h < 100 * dst_h / 35)) {
+			ygt2 = 1;
+			src_h >>= 1;
+		}
+	} else {
+		if (src_h >= (4 * dst_h)) {
+			ygt4 = 1;
+			src_h >>= 2;
+		} else if (src_h >= (2 * dst_h)) {
+			ygt2 = 1;
+			src_h >>= 1;
+		}
+	}
+
+	yrgb_hor_scl_mode = scl_get_scl_mode(src_w, dst_w);
+	yrgb_ver_scl_mode = scl_get_scl_mode(src_h, dst_h);
+
+	if (yrgb_hor_scl_mode == SCALE_UP)
+		hscl_filter_mode = win->hsu_filter_mode;
+	else
+		hscl_filter_mode = win->hsd_filter_mode;
+
+	if (yrgb_ver_scl_mode == SCALE_UP)
+		vscl_filter_mode = win->vsu_filter_mode;
+	else
+		vscl_filter_mode = win->vsd_filter_mode;
+
+	/*
+	 * RK3568 VOP Esmart/Smart dsp_w should be even pixel
+	 * at scale down mode
+	 */
+	if ((yrgb_hor_scl_mode == SCALE_DOWN) && (dst_w & 0x1) && !is_vop3(vop2)) {
+		printf("win dst_w[%d] should align as 2 pixel\n", dst_w);
+		dst_w += 1;
+	}
+
+	if (is_vop3(vop2)) {
+		xfac = vop3_scale_factor(yrgb_hor_scl_mode, src_w, dst_w, true);
+		yfac = vop3_scale_factor(yrgb_ver_scl_mode, src_h, dst_h, false);
+
+		if (win->hsd_pre_filter_mode == VOP3_PRE_SCALE_DOWN_AVG)
+			xavg_en = xgt2 || xgt4;
+		else
+			xgt_en = xgt2 || xgt4;
+	} else {
+		xfac = vop2_scale_factor(yrgb_hor_scl_mode, hscl_filter_mode, src_w, dst_w);
+		yfac = vop2_scale_factor(yrgb_ver_scl_mode, vscl_filter_mode, src_h, dst_h);
+	}
+
+	if (win->type == CLUSTER_LAYER) {
+		vop2_writel(vop2, RK3568_CLUSTER0_WIN0_SCL_FACTOR_YRGB + win_offset,
+			    yfac << 16 | xfac);
+
+		if (is_vop3(vop2)) {
+			vop2_mask_write(vop2, RK3568_CLUSTER0_WIN0_CTRL1 + win_offset,
+					EN_MASK, CLUSTER_XGT_EN_SHIFT, xgt_en, false);
+			vop2_mask_write(vop2, RK3568_CLUSTER0_WIN0_CTRL1 + win_offset,
+					EN_MASK, CLUSTER_XAVG_EN_SHIFT, xavg_en, false);
+			vop2_mask_write(vop2, RK3568_CLUSTER0_WIN0_CTRL1 + win_offset,
+					XGT_MODE_MASK, CLUSTER_XGT_MODE_SHIFT, xgt2 ? 0 : 1, false);
+
+			vop2_mask_write(vop2, RK3568_CLUSTER0_WIN0_CTRL1 + win_offset,
+					YRGB_XSCL_MODE_MASK, RK3528_CLUSTER_YRGB_XSCL_MODE_SHIFT,
+					yrgb_hor_scl_mode, false);
+			vop2_mask_write(vop2, RK3568_CLUSTER0_WIN0_CTRL1 + win_offset,
+					YRGB_YSCL_MODE_MASK, RK3528_CLUSTER_YRGB_YSCL_MODE_SHIFT,
+					yrgb_ver_scl_mode, false);
+		} else {
+			vop2_mask_write(vop2, RK3568_CLUSTER0_WIN0_CTRL1 + win_offset,
+					YRGB_XSCL_MODE_MASK, RK3568_CLUSTER_YRGB_XSCL_MODE_SHIFT,
+					yrgb_hor_scl_mode, false);
+			vop2_mask_write(vop2, RK3568_CLUSTER0_WIN0_CTRL1 + win_offset,
+					YRGB_YSCL_MODE_MASK, RK3568_CLUSTER_YRGB_YSCL_MODE_SHIFT,
+					yrgb_ver_scl_mode, false);
+		}
+
+		if (!is_vop3(vop2) || win->vsd_pre_filter_mode == VOP3_PRE_SCALE_DOWN_GT) {
+			vop2_mask_write(vop2, RK3568_CLUSTER0_WIN0_CTRL1 + win_offset,
+					YRGB_GT2_MASK, CLUSTER_YRGB_GT2_SHIFT, ygt2, false);
+			vop2_mask_write(vop2, RK3568_CLUSTER0_WIN0_CTRL1 + win_offset,
+					YRGB_GT4_MASK, CLUSTER_YRGB_GT4_SHIFT, ygt4, false);
+			vop2_mask_write(vop2, RK3568_CLUSTER0_WIN0_CTRL1 + win_offset,
+					AVG2_MASK, CLUSTER_AVG2_SHIFT, 0, false);
+			vop2_mask_write(vop2, RK3568_CLUSTER0_WIN0_CTRL1 + win_offset,
+					AVG4_MASK, CLUSTER_AVG4_SHIFT, 0, false);
+		} else {
+			vop2_mask_write(vop2, RK3568_CLUSTER0_WIN0_CTRL1 + win_offset,
+					YRGB_GT2_MASK, CLUSTER_YRGB_GT2_SHIFT, 0, false);
+			vop2_mask_write(vop2, RK3568_CLUSTER0_WIN0_CTRL1 + win_offset,
+					YRGB_GT4_MASK, CLUSTER_YRGB_GT4_SHIFT, 0, false);
+			vop2_mask_write(vop2, RK3568_CLUSTER0_WIN0_CTRL1 + win_offset,
+					AVG2_MASK, CLUSTER_AVG2_SHIFT, ygt2, false);
+			vop2_mask_write(vop2, RK3568_CLUSTER0_WIN0_CTRL1 + win_offset,
+					AVG4_MASK, CLUSTER_AVG4_SHIFT, ygt4, false);
+		}
+	} else {
+		vop2_writel(vop2, RK3568_ESMART0_REGION0_SCL_FACTOR_YRGB + win_offset,
+			    yfac << 16 | xfac);
+
+		if (is_vop3(vop2)) {
+			vop2_mask_write(vop2, RK3568_ESMART0_REGION0_CTRL + win_offset,
+					EN_MASK, ESMART_XGT_EN_SHIFT, xgt_en, false);
+			vop2_mask_write(vop2, RK3568_ESMART0_REGION0_CTRL + win_offset,
+					EN_MASK, ESMART_XAVG_EN_SHIFT, xavg_en, false);
+			vop2_mask_write(vop2, RK3568_ESMART0_REGION0_CTRL + win_offset,
+					XGT_MODE_MASK, ESMART_XGT_MODE_SHIFT, xgt2 ? 0 : 1, false);
+		}
+
+		vop2_mask_write(vop2, RK3568_ESMART0_REGION0_CTRL + win_offset,
+				YRGB_GT2_MASK, YRGB_GT2_SHIFT, ygt2, false);
+		vop2_mask_write(vop2, RK3568_ESMART0_REGION0_CTRL + win_offset,
+				YRGB_GT4_MASK, YRGB_GT4_SHIFT, ygt4, false);
+
+		vop2_mask_write(vop2, RK3568_ESMART0_REGION0_SCL_CTRL + win_offset,
+				YRGB_XSCL_MODE_MASK, YRGB_XSCL_MODE_SHIFT, yrgb_hor_scl_mode, false);
+		vop2_mask_write(vop2, RK3568_ESMART0_REGION0_SCL_CTRL + win_offset,
+				YRGB_YSCL_MODE_MASK, YRGB_YSCL_MODE_SHIFT, yrgb_ver_scl_mode, false);
+
+		vop2_mask_write(vop2, RK3568_ESMART0_REGION0_SCL_CTRL + win_offset,
+				YRGB_XSCL_FILTER_MODE_MASK, YRGB_XSCL_FILTER_MODE_SHIFT,
+				hscl_filter_mode, false);
+		vop2_mask_write(vop2, RK3568_ESMART0_REGION0_SCL_CTRL + win_offset,
+				YRGB_YSCL_FILTER_MODE_MASK, YRGB_YSCL_FILTER_MODE_SHIFT,
+				vscl_filter_mode, false);
+	}
+}
+
+static void vop2_axi_config(struct vop2 *vop2, struct vop2_win_data *win)
+{
+	u32 win_offset = win->reg_offset;
+
+	if (win->type == CLUSTER_LAYER) {
+		vop2_mask_write(vop2, RK3568_CLUSTER0_CTRL + win_offset, CLUSTER_AXI_ID_MASK,
+				CLUSTER_AXI_ID_SHIFT, win->axi_id, false);
+		vop2_mask_write(vop2, RK3568_CLUSTER0_WIN0_CTRL2 + win_offset, CLUSTER_AXI_YRGB_ID_MASK,
+				CLUSTER_AXI_YRGB_ID_SHIFT, win->axi_yrgb_id, false);
+		vop2_mask_write(vop2, RK3568_CLUSTER0_WIN0_CTRL2 + win_offset, CLUSTER_AXI_UV_ID_MASK,
+				CLUSTER_AXI_UV_ID_SHIFT, win->axi_uv_id, false);
+	} else {
+		vop2_mask_write(vop2, RK3568_ESMART0_AXI_CTRL + win_offset, ESMART_AXI_ID_MASK,
+				ESMART_AXI_ID_SHIFT, win->axi_id, false);
+		vop2_mask_write(vop2, RK3568_ESMART0_CTRL1 + win_offset, ESMART_AXI_YRGB_ID_MASK,
+				ESMART_AXI_YRGB_ID_SHIFT, win->axi_yrgb_id, false);
+		vop2_mask_write(vop2, RK3568_ESMART0_CTRL1 + win_offset, ESMART_AXI_UV_ID_MASK,
+				ESMART_AXI_UV_ID_SHIFT, win->axi_uv_id, false);
+	}
+}
+
+static bool vop2_win_dither_up(uint32_t format)
+{
+	switch (format) {
+	case ROCKCHIP_FMT_RGB565:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static bool vop2_is_mirror_win(struct vop2_win_data *win)
+{
+	return soc_is_rk3566() && (win->feature & WIN_FEATURE_MIRROR);
+}
+
+static int vop2_set_cluster_win(struct display_state *state, struct vop2_win_data *win)
+{
+	struct crtc_state *cstate = &state->crtc_state;
+	struct connector_state *conn_state = &state->conn_state;
+	struct drm_display_mode *mode = &conn_state->mode;
+	struct vop2 *vop2 = cstate->private;
+	int src_w = cstate->src_rect.w;
+	int src_h = cstate->src_rect.h;
+	int crtc_x = cstate->crtc_rect.x;
+	int crtc_y = cstate->crtc_rect.y;
+	int crtc_w = cstate->crtc_rect.w;
+	int crtc_h = cstate->crtc_rect.h;
+	int xvir = cstate->xvir;
+	int y_mirror = 0;
+	int csc_mode;
+	u32 act_info, dsp_info, dsp_st, dsp_stx, dsp_sty;
+	/* offset of the right window in splice mode */
+	u32 splice_pixel_offset = 0;
+	u32 splice_yrgb_offset = 0;
+	u32 win_offset = win->reg_offset;
+	u32 cfg_done = CFG_DONE_EN | BIT(cstate->crtc_id) | (BIT(cstate->crtc_id) << 16);
+	bool dither_up;
+
+	if (win->splice_mode_right) {
+		src_w = cstate->right_src_rect.w;
+		src_h = cstate->right_src_rect.h;
+		crtc_x = cstate->right_crtc_rect.x;
+		crtc_y = cstate->right_crtc_rect.y;
+		crtc_w = cstate->right_crtc_rect.w;
+		crtc_h = cstate->right_crtc_rect.h;
+		splice_pixel_offset = cstate->right_src_rect.x - cstate->src_rect.x;
+		splice_yrgb_offset = splice_pixel_offset * (state->logo.bpp >> 3);
+		cfg_done = CFG_DONE_EN | BIT(cstate->splice_crtc_id) | (BIT(cstate->splice_crtc_id) << 16);
+	}
+
+	act_info = (src_h - 1) << 16;
+	act_info |= (src_w - 1) & 0xffff;
+
+	dsp_info = (crtc_h - 1) << 16;
+	dsp_info |= (crtc_w - 1) & 0xffff;
+
+	dsp_stx = crtc_x;
+	dsp_sty = crtc_y;
+	dsp_st = dsp_sty << 16 | (dsp_stx & 0xffff);
+
+	if (mode->flags & DRM_MODE_FLAG_YMIRROR)
+		y_mirror = 1;
+	else
+		y_mirror = 0;
+
+	vop2_setup_scale(vop2, win, src_w, src_h, crtc_w, crtc_h);
+
+	if (vop2->version == VOP_VERSION_RK3588 || vop2->version == VOP_VERSION_RK3528 ||
+	    vop2->version == VOP_VERSION_RK3562)
+		vop2_axi_config(vop2, win);
+
+	if (y_mirror)
+		printf("WARN: y mirror is unsupported by cluster window\n");
+
+	/* rk3588 should set half_blocK_en to 1 in line and tile mode */
+	if (vop2->version == VOP_VERSION_RK3588)
+		vop2_mask_write(vop2, RK3568_CLUSTER0_WIN0_AFBCD_CTRL + win_offset,
+				EN_MASK, CLUSTER_AFBCD_HALF_BLOCK_SHIFT, 1, false);
+
+	vop2_mask_write(vop2, RK3568_CLUSTER0_WIN0_CTRL0 + win_offset,
+			WIN_FORMAT_MASK, WIN_FORMAT_SHIFT, cstate->format,
+			false);
+	vop2_writel(vop2, RK3568_CLUSTER0_WIN0_VIR + win_offset, xvir);
+	vop2_writel(vop2, RK3568_CLUSTER0_WIN0_YRGB_MST + win_offset,
+		    cstate->dma_addr + splice_yrgb_offset);
+
+	vop2_writel(vop2, RK3568_CLUSTER0_WIN0_ACT_INFO + win_offset, act_info);
+	vop2_writel(vop2, RK3568_CLUSTER0_WIN0_DSP_INFO + win_offset, dsp_info);
+	vop2_writel(vop2, RK3568_CLUSTER0_WIN0_DSP_ST + win_offset, dsp_st);
+
+	vop2_mask_write(vop2, RK3568_CLUSTER0_WIN0_CTRL0 + win_offset, EN_MASK, WIN_EN_SHIFT, 1, false);
+
+	csc_mode = vop2_convert_csc_mode(conn_state->color_space, CSC_10BIT_DEPTH);
+	vop2_mask_write(vop2, RK3568_CLUSTER0_WIN0_CTRL0 + win_offset, EN_MASK,
+			CLUSTER_RGB2YUV_EN_SHIFT,
+			is_yuv_output(conn_state->bus_format), false);
+	vop2_mask_write(vop2, RK3568_CLUSTER0_WIN0_CTRL0 + win_offset, CSC_MODE_MASK,
+			CLUSTER_CSC_MODE_SHIFT, csc_mode, false);
+
+	dither_up = vop2_win_dither_up(cstate->format);
+	vop2_mask_write(vop2, RK3568_CLUSTER0_WIN0_CTRL0 + win_offset, EN_MASK,
+			CLUSTER_DITHER_UP_EN_SHIFT, dither_up, false);
+
+	vop2_mask_write(vop2, RK3568_CLUSTER0_CTRL + win_offset, EN_MASK, CLUSTER_EN_SHIFT, 1, false);
+
+	vop2_writel(vop2, RK3568_REG_CFG_DONE, cfg_done);
+
+	return 0;
+}
+
+static int vop2_set_smart_win(struct display_state *state, struct vop2_win_data *win)
+{
+	struct crtc_state *cstate = &state->crtc_state;
+	struct connector_state *conn_state = &state->conn_state;
+	struct drm_display_mode *mode = &conn_state->mode;
+	struct vop2 *vop2 = cstate->private;
+	int src_w = cstate->src_rect.w;
+	int src_h = cstate->src_rect.h;
+	int crtc_x = cstate->crtc_rect.x;
+	int crtc_y = cstate->crtc_rect.y;
+	int crtc_w = cstate->crtc_rect.w;
+	int crtc_h = cstate->crtc_rect.h;
+	int xvir = cstate->xvir;
+	int y_mirror = 0;
+	int csc_mode;
+	u32 act_info, dsp_info, dsp_st, dsp_stx, dsp_sty;
+	/* offset of the right window in splice mode */
+	u32 splice_pixel_offset = 0;
+	u32 splice_yrgb_offset = 0;
+	u32 win_offset = win->reg_offset;
+	u32 cfg_done = CFG_DONE_EN | BIT(cstate->crtc_id) | (BIT(cstate->crtc_id) << 16);
+	u32 val;
+	bool dither_up;
+
+	if (vop2_is_mirror_win(win)) {
+		struct vop2_win_data *source_win = vop2_find_win_by_phys_id(vop2, win->source_win_id);
+
+		if (!source_win) {
+			printf("invalid source win id %d\n", win->source_win_id);
+			return -ENODEV;
+		}
+
+		val = vop2_readl(vop2, RK3568_ESMART0_REGION0_CTRL + source_win->reg_offset);
+		if (!(val & BIT(WIN_EN_SHIFT))) {
+			printf("WARN: the source win should be enabled before mirror win\n");
+			return -EAGAIN;
+		}
+	}
+
+	if (win->splice_mode_right) {
+		src_w = cstate->right_src_rect.w;
+		src_h = cstate->right_src_rect.h;
+		crtc_x = cstate->right_crtc_rect.x;
+		crtc_y = cstate->right_crtc_rect.y;
+		crtc_w = cstate->right_crtc_rect.w;
+		crtc_h = cstate->right_crtc_rect.h;
+		splice_pixel_offset = cstate->right_src_rect.x - cstate->src_rect.x;
+		splice_yrgb_offset = splice_pixel_offset * (state->logo.bpp >> 3);
+		cfg_done = CFG_DONE_EN | BIT(cstate->splice_crtc_id) | (BIT(cstate->splice_crtc_id) << 16);
+	}
+
+	/*
+	 * This is workaround solution for IC design:
+	 * esmart can't support scale down when actual_w % 16 == 1.
+	 */
+	if (src_w > crtc_w && (src_w & 0xf) == 1) {
+		printf("WARN: vp%d unsupported act_w[%d] mode 16 = 1 when scale down\n", cstate->crtc_id, src_w);
+		src_w -= 1;
+	}
+
+	act_info = (src_h - 1) << 16;
+	act_info |= (src_w - 1) & 0xffff;
+
+	dsp_info = (crtc_h - 1) << 16;
+	dsp_info |= (crtc_w - 1) & 0xffff;
+
+	dsp_stx = crtc_x;
+	dsp_sty = crtc_y;
+	dsp_st = dsp_sty << 16 | (dsp_stx & 0xffff);
+
+	if (mode->flags & DRM_MODE_FLAG_YMIRROR)
+		y_mirror = 1;
+	else
+		y_mirror = 0;
+
+	if (is_vop3(vop2))
+		vop2_mask_write(vop2, RK3568_ESMART0_CTRL0 + win_offset, ESMART_LB_SELECT_MASK,
+				ESMART_LB_SELECT_SHIFT, win->scale_engine_num, false);
+
+	vop2_setup_scale(vop2, win, src_w, src_h, crtc_w, crtc_h);
+
+	if (vop2->version == VOP_VERSION_RK3588 || vop2->version == VOP_VERSION_RK3528 ||
+	    vop2->version == VOP_VERSION_RK3562)
+		vop2_axi_config(vop2, win);
+
+	if (y_mirror)
+		cstate->dma_addr += (src_h - 1) * xvir * 4;
+	vop2_mask_write(vop2, RK3568_ESMART0_CTRL1 + win_offset, EN_MASK,
+			YMIRROR_EN_SHIFT, y_mirror, false);
+
+	vop2_mask_write(vop2, RK3568_ESMART0_REGION0_CTRL + win_offset,
+			WIN_FORMAT_MASK, WIN_FORMAT_SHIFT, cstate->format,
+			false);
+	vop2_writel(vop2, RK3568_ESMART0_REGION0_VIR + win_offset, xvir);
+	vop2_writel(vop2, RK3568_ESMART0_REGION0_YRGB_MST + win_offset,
+		    cstate->dma_addr + splice_yrgb_offset);
+
+	vop2_writel(vop2, RK3568_ESMART0_REGION0_ACT_INFO + win_offset,
+		    act_info);
+	vop2_writel(vop2, RK3568_ESMART0_REGION0_DSP_INFO + win_offset,
+		    dsp_info);
+	vop2_writel(vop2, RK3568_ESMART0_REGION0_DSP_ST + win_offset, dsp_st);
+
+	vop2_mask_write(vop2, RK3568_ESMART0_REGION0_CTRL + win_offset, EN_MASK,
+			WIN_EN_SHIFT, 1, false);
+
+	csc_mode = vop2_convert_csc_mode(conn_state->color_space, CSC_10BIT_DEPTH);
+	vop2_mask_write(vop2, RK3568_ESMART0_CTRL0 + win_offset, EN_MASK,
+			RGB2YUV_EN_SHIFT,
+			is_yuv_output(conn_state->bus_format), false);
+	vop2_mask_write(vop2, RK3568_ESMART0_CTRL0 + win_offset, CSC_MODE_MASK,
+			CSC_MODE_SHIFT, csc_mode, false);
+
+	dither_up = vop2_win_dither_up(cstate->format);
+	vop2_mask_write(vop2, RK3568_ESMART0_REGION0_CTRL + win_offset, EN_MASK,
+			REGION0_DITHER_UP_EN_SHIFT, dither_up, false);
+
+	vop2_writel(vop2, RK3568_REG_CFG_DONE, cfg_done);
+
+	return 0;
+}
+
+static void vop2_calc_display_rect_for_splice(struct display_state *state)
+{
+	struct crtc_state *cstate = &state->crtc_state;
+	struct connector_state *conn_state = &state->conn_state;
+	struct drm_display_mode *mode = &conn_state->mode;
+	struct display_rect *src_rect = &cstate->src_rect;
+	struct display_rect *dst_rect = &cstate->crtc_rect;
+	struct display_rect left_src, left_dst, right_src, right_dst;
+	u16 half_hdisplay = mode->crtc_hdisplay >> 1;
+	int left_src_w, left_dst_w, right_dst_w;
+
+	left_dst_w = min_t(u16, half_hdisplay, dst_rect->x + dst_rect->w) - dst_rect->x;
+	if (left_dst_w < 0)
+		left_dst_w = 0;
+	right_dst_w = dst_rect->w - left_dst_w;
+
+	if (!right_dst_w)
+		left_src_w = src_rect->w;
+	else
+		left_src_w = src_rect->x + src_rect->w - src_rect->w / 2;
+
+	left_src.x = src_rect->x;
+	left_src.w = left_src_w;
+	left_dst.x = dst_rect->x;
+	left_dst.w = left_dst_w;
+	right_src.x = left_src.x + left_src.w;
+	right_src.w = src_rect->x + src_rect->w - left_src.x - left_src.w;
+	right_dst.x = dst_rect->x + left_dst_w - half_hdisplay;
+	right_dst.w = right_dst_w;
+
+	left_src.y = src_rect->y;
+	left_src.h = src_rect->h;
+	left_dst.y = dst_rect->y;
+	left_dst.h = dst_rect->h;
+	right_src.y = src_rect->y;
+	right_src.h = src_rect->h;
+	right_dst.y = dst_rect->y;
+	right_dst.h = dst_rect->h;
+
+	memcpy(&cstate->src_rect, &left_src, sizeof(struct display_rect));
+	memcpy(&cstate->crtc_rect, &left_dst, sizeof(struct display_rect));
+	memcpy(&cstate->right_src_rect, &right_src, sizeof(struct display_rect));
+	memcpy(&cstate->right_crtc_rect, &right_dst, sizeof(struct display_rect));
+}
+
+static int rockchip_vop2_set_plane(struct display_state *state)
+{
+	struct crtc_state *cstate = &state->crtc_state;
+	struct vop2 *vop2 = cstate->private;
+	struct vop2_win_data *win_data;
+	struct vop2_win_data *splice_win_data;
+	u8 primary_plane_id = vop2->vp_plane_mask[cstate->crtc_id].primary_plane_id;
+	char plane_name[10] = {0};
+	int ret;
+
+	if (cstate->crtc_rect.w > cstate->max_output.width) {
+		printf("ERROR: output w[%d] exceeded max width[%d]\n",
+		       cstate->crtc_rect.w, cstate->max_output.width);
+		return -EINVAL;
+	}
+
+	win_data = vop2_find_win_by_phys_id(vop2, primary_plane_id);
+	if (!win_data) {
+		printf("invalid win id %d\n", primary_plane_id);
+		return -ENODEV;
+	}
+
+	/* ignore some plane register according vop3 esmart lb mode */
+	if (vop3_ignore_plane(vop2, win_data))
+		return -EACCES;
+
+	if (vop2->version == VOP_VERSION_RK3588) {
+		if (vop2_power_domain_on(vop2, win_data->pd_id))
+			printf("open vp%d plane pd fail\n", cstate->crtc_id);
+	}
+
+	if (cstate->splice_mode) {
+		if (win_data->splice_win_id) {
+			splice_win_data = vop2_find_win_by_phys_id(vop2, win_data->splice_win_id);
+			splice_win_data->splice_mode_right = true;
+
+			if (vop2_power_domain_on(vop2, splice_win_data->pd_id))
+				printf("splice mode: open vp%d plane pd fail\n", cstate->splice_crtc_id);
+
+			vop2_calc_display_rect_for_splice(state);
+			if (win_data->type == CLUSTER_LAYER)
+				vop2_set_cluster_win(state, splice_win_data);
+			else
+				vop2_set_smart_win(state, splice_win_data);
+		} else {
+			printf("ERROR: splice mode is unsupported by plane %s\n",
+			       get_plane_name(primary_plane_id, plane_name));
+			return -EINVAL;
+		}
+	}
+
+	if (win_data->type == CLUSTER_LAYER)
+		ret = vop2_set_cluster_win(state, win_data);
+	else
+		ret = vop2_set_smart_win(state, win_data);
+	if (ret)
+		return ret;
+
+	printf("VOP VP%d enable %s[%dx%d->%dx%d@%dx%d] fmt[%d] addr[0x%x]\n",
+		cstate->crtc_id, get_plane_name(primary_plane_id, plane_name),
+		cstate->src_rect.w, cstate->src_rect.h, cstate->crtc_rect.w, cstate->crtc_rect.h,
+		cstate->crtc_rect.x, cstate->crtc_rect.y, cstate->format,
+		cstate->dma_addr);
+
+	return 0;
+}
+
+static int rockchip_vop2_prepare(struct display_state *state)
+{
+	return 0;
+}
+
+static void vop2_dsc_cfg_done(struct display_state *state)
+{
+	struct connector_state *conn_state = &state->conn_state;
+	struct crtc_state *cstate = &state->crtc_state;
+	struct vop2 *vop2 = cstate->private;
+	u8 dsc_id = cstate->dsc_id;
+	u32 ctrl_regs_offset = (dsc_id * 0x30);
+
+	if (conn_state->output_flags & ROCKCHIP_OUTPUT_DUAL_CHANNEL_LEFT_RIGHT_MODE) {
+		vop2_mask_write(vop2, RK3588_DSC_8K_CFG_DONE, EN_MASK,
+				DSC_CFG_DONE_SHIFT, 1, false);
+		vop2_mask_write(vop2, RK3588_DSC_8K_CFG_DONE + 0x30, EN_MASK,
+				DSC_CFG_DONE_SHIFT, 1, false);
+	} else {
+		vop2_mask_write(vop2, RK3588_DSC_8K_CFG_DONE + ctrl_regs_offset, EN_MASK,
+				DSC_CFG_DONE_SHIFT, 1, false);
+	}
+}
+
+static int rockchip_vop2_enable(struct display_state *state)
+{
+	struct crtc_state *cstate = &state->crtc_state;
+	struct vop2 *vop2 = cstate->private;
+	u32 vp_offset = (cstate->crtc_id * 0x100);
+	u32 cfg_done = CFG_DONE_EN | BIT(cstate->crtc_id) | (BIT(cstate->crtc_id) << 16);
+
+	vop2_mask_write(vop2, RK3568_VP0_DSP_CTRL + vp_offset, EN_MASK,
+			STANDBY_EN_SHIFT, 0, false);
+
+	if (cstate->splice_mode)
+		cfg_done |= BIT(cstate->splice_crtc_id) | (BIT(cstate->splice_crtc_id) << 16);
+
+	vop2_writel(vop2, RK3568_REG_CFG_DONE, cfg_done);
+
+	if (cstate->dsc_enable)
+		vop2_dsc_cfg_done(state);
+
+	if (cstate->mcu_timing.mcu_pix_total)
+		vop2_mask_write(vop2, RK3562_VP0_MCU_CTRL + vp_offset, EN_MASK,
+				MCU_HOLD_MODE_SHIFT, 0, false);
+
+	return 0;
+}
+
+static int rockchip_vop2_disable(struct display_state *state)
+{
+	struct crtc_state *cstate = &state->crtc_state;
+	struct vop2 *vop2 = cstate->private;
+	u32 vp_offset = (cstate->crtc_id * 0x100);
+	u32 cfg_done = CFG_DONE_EN | BIT(cstate->crtc_id) | (BIT(cstate->crtc_id) << 16);
+
+	vop2_mask_write(vop2, RK3568_VP0_DSP_CTRL + vp_offset, EN_MASK,
+			STANDBY_EN_SHIFT, 1, false);
+
+	if (cstate->splice_mode)
+		cfg_done |= BIT(cstate->splice_crtc_id) | (BIT(cstate->splice_crtc_id) << 16);
+
+	vop2_writel(vop2, RK3568_REG_CFG_DONE, cfg_done);
+
+	return 0;
+}
+
+static int rockchip_vop2_get_cursor_plane(struct display_state *state, u32 plane_mask, int cursor_plane)
+{
+	struct crtc_state *cstate = &state->crtc_state;
+	struct vop2 *vop2 = cstate->private;
+	int i = 0;
+	int correct_cursor_plane = -1;
+	int plane_type = -1;
+
+	if (cursor_plane < 0)
+		return -1;
+
+	if (plane_mask & (1 << cursor_plane))
+		return cursor_plane;
+
+	/* Get current cursor plane type */
+	for (i = 0; i < vop2->data->nr_layers; i++) {
+		if (vop2->data->plane_table[i].plane_id == cursor_plane) {
+			plane_type = vop2->data->plane_table[i].plane_type;
+			break;
+		}
+	}
+
+	/* Get the other same plane type plane id */
+	for (i = 0; i < vop2->data->nr_layers; i++) {
+		if (vop2->data->plane_table[i].plane_type == plane_type &&
+		    vop2->data->plane_table[i].plane_id != cursor_plane) {
+			correct_cursor_plane = vop2->data->plane_table[i].plane_id;
+			break;
+		}
+	}
+
+	/* To check whether the new correct_cursor_plane is attach to current vp */
+	if (correct_cursor_plane < 0 || !(plane_mask & (1 << correct_cursor_plane))) {
+		printf("error: faild to find correct plane as cursor plane\n");
+		return -1;
+	}
+
+	printf("vp%d adjust cursor plane from %d to %d\n",
+	       cstate->crtc_id, cursor_plane, correct_cursor_plane);
+
+	return correct_cursor_plane;
+}
+
+static int rockchip_vop2_fixup_dts(struct display_state *state, void *blob)
+{
+	struct crtc_state *cstate = &state->crtc_state;
+	struct vop2 *vop2 = cstate->private;
+	ofnode vp_node;
+	struct device_node *port_parent_node = cstate->ports_node;
+	static bool vop_fix_dts;
+	const char *path;
+	u32 plane_mask = 0;
+	int vp_id = 0;
+	int cursor_plane_id = -1;
+
+	if (vop_fix_dts || vop2->version == VOP_VERSION_RK3528)
+		return 0;
+
+	ofnode_for_each_subnode(vp_node, np_to_ofnode(port_parent_node)) {
+		path = vp_node.np->full_name;
+		plane_mask = vop2->vp_plane_mask[vp_id].plane_mask;
+
+		if (cstate->crtc->assign_plane)
+			continue;
+		cursor_plane_id = rockchip_vop2_get_cursor_plane(state, plane_mask,
+								 cstate->crtc->vps[vp_id].cursor_plane);
+		printf("vp%d, plane_mask:0x%x, primary-id:%d, curser-id:%d\n",
+		       vp_id, plane_mask,
+		       vop2->vp_plane_mask[vp_id].primary_plane_id,
+		       cursor_plane_id);
+
+		do_fixup_by_path_u32(blob, path, "rockchip,plane-mask",
+				     plane_mask, 1);
+		do_fixup_by_path_u32(blob, path, "rockchip,primary-plane",
+				     vop2->vp_plane_mask[vp_id].primary_plane_id, 1);
+		if (cursor_plane_id >= 0)
+			do_fixup_by_path_u32(blob, path, "cursor-win-id",
+					     cursor_plane_id, 1);
+		vp_id++;
+	}
+
+	vop_fix_dts = true;
+
+	return 0;
+}
+
+static int rockchip_vop2_check(struct display_state *state)
+{
+	struct crtc_state *cstate = &state->crtc_state;
+	struct rockchip_crtc *crtc = cstate->crtc;
+
+	if (crtc->splice_mode && cstate->crtc_id == crtc->splice_crtc_id) {
+		printf("WARN: VP%d is busy in splice mode\n", cstate->crtc_id);
+		return -ENOTSUPP;
+	}
+
+	if (cstate->splice_mode) {
+		crtc->splice_mode = true;
+		crtc->splice_crtc_id = cstate->splice_crtc_id;
+	}
+
+	return 0;
+}
+
+static int rockchip_vop2_mode_valid(struct display_state *state)
+{
+	struct connector_state *conn_state = &state->conn_state;
+	struct crtc_state *cstate = &state->crtc_state;
+	struct drm_display_mode *mode = &conn_state->mode;
+	struct videomode vm;
+
+	drm_display_mode_to_videomode(mode, &vm);
+
+	if (vm.hactive < 32 || vm.vactive < 32 ||
+	    (vm.hfront_porch * vm.hsync_len * vm.hback_porch *
+	     vm.vfront_porch * vm.vsync_len * vm.vback_porch == 0)) {
+		printf("ERROR: VP%d: unsupported display timing\n", cstate->crtc_id);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int rockchip_vop2_mode_fixup(struct display_state *state)
+{
+	struct connector_state *conn_state = &state->conn_state;
+	struct drm_display_mode *mode = &conn_state->mode;
+	struct crtc_state *cstate = &state->crtc_state;
+	struct vop2 *vop2 = cstate->private;
+
+	drm_mode_set_crtcinfo(mode, CRTC_INTERLACE_HALVE_V | CRTC_STEREO_DOUBLE);
+
+	if (mode->flags & DRM_MODE_FLAG_DBLCLK || conn_state->output_if & VOP_OUTPUT_IF_BT656)
+		mode->crtc_clock *= 2;
+
+	/*
+	 * For RK3528, the path of CVBS output is like:
+	 * VOP BT656 ENCODER -> CVBS BT656 DECODER -> CVBS ENCODER -> CVBS VDAC
+	 * The vop2 dclk should be four times crtc_clock for CVBS sampling
+	 * clock needs.
+	 */
+	if (vop2->version == VOP_VERSION_RK3528 && conn_state->output_if & VOP_OUTPUT_IF_BT656)
+		mode->crtc_clock *= 4;
+
+	mode->crtc_clock *= rockchip_drm_get_cycles_per_pixel(conn_state->bus_format);
+	if (cstate->mcu_timing.mcu_pix_total)
+		mode->crtc_clock *= cstate->mcu_timing.mcu_pix_total + 1;
+
+	if (conn_state->secondary &&
+	    conn_state->secondary->type != DRM_MODE_CONNECTOR_LVDS) {
+		mode->crtc_clock *= 2;
+		mode->crtc_hdisplay *= 2;
+		mode->crtc_hsync_start *= 2;
+		mode->crtc_hsync_end *= 2;
+		mode->crtc_htotal *= 2;
+	}
+
+	return 0;
+}
+
+#define FRAC_16_16(mult, div)	(((mult) << 16) / (div))
+
+static int rockchip_vop2_plane_check(struct display_state *state)
+{
+	struct crtc_state *cstate = &state->crtc_state;
+	struct vop2 *vop2 = cstate->private;
+	struct display_rect *src = &cstate->src_rect;
+	struct display_rect *dst = &cstate->crtc_rect;
+	struct vop2_win_data *win_data;
+	int min_scale, max_scale;
+	int hscale, vscale;
+	u8 primary_plane_id = vop2->vp_plane_mask[cstate->crtc_id].primary_plane_id;
+
+	win_data = vop2_find_win_by_phys_id(vop2, primary_plane_id);
+	if (!win_data) {
+		printf("ERROR: invalid win id %d\n", primary_plane_id);
+		return -ENODEV;
+	}
+
+	min_scale = FRAC_16_16(1, win_data->max_downscale_factor);
+	max_scale = FRAC_16_16(win_data->max_upscale_factor, 1);
+
+	hscale = display_rect_calc_hscale(src, dst, min_scale, max_scale);
+	vscale = display_rect_calc_vscale(src, dst, min_scale, max_scale);
+	if (hscale < 0 || vscale < 0) {
+		printf("ERROR: VP%d %s: scale factor is out of range\n", cstate->crtc_id, win_data->name);
+		return -ERANGE;
+		}
+
+	return 0;
+}
+
+static int rockchip_vop2_apply_soft_te(struct display_state *state)
+{
+	__maybe_unused struct connector_state *conn_state = &state->conn_state;
+	struct crtc_state *cstate = &state->crtc_state;
+	struct vop2 *vop2 = cstate->private;
+	u32 vp_offset = (cstate->crtc_id * 0x100);
+	int val = 0;
+	int ret = 0;
+
+	ret = readl_poll_timeout(vop2->regs + RK3568_VP0_MIPI_CTRL + vp_offset, val,
+				 (val >> EDPI_WMS_FS) & 0x1, 50 * 1000);
+	if (!ret) {
+#ifndef CONFIG_SPL_BUILD
+		ret = readx_poll_timeout(dm_gpio_get_value, conn_state->te_gpio, val,
+					 !val, 50 * 1000);
+		if (!ret) {
+			ret = readx_poll_timeout(dm_gpio_get_value, conn_state->te_gpio, val,
+						 val, 50 * 1000);
+			if (!ret) {
+				vop2_mask_write(vop2, RK3568_VP0_MIPI_CTRL + vp_offset,
+						EN_MASK, EDPI_WMS_FS, 1, false);
+			} else {
+				printf("ERROR: vp%d wait for active TE signal timeout\n",
+				       cstate->crtc_id);
+				return ret;
+			}
+		} else {
+			printf("ERROR: vp%d TE signal maybe always high\n", cstate->crtc_id);
+			return ret;
+		}
+#endif
+	} else {
+		printf("ERROR: vp%d wait vop2 frame start timeout in hold mode\n", cstate->crtc_id);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int rockchip_vop2_regs_dump(struct display_state *state)
+{
+	struct crtc_state *cstate = &state->crtc_state;
+	struct vop2 *vop2 = cstate->private;
+	const struct vop2_data *vop2_data = vop2->data;
+	const struct vop2_dump_regs *regs = vop2_data->dump_regs;
+	u32 n, i, j;
+	u32 base;
+
+	if (!cstate->crtc->active)
+		return -EINVAL;
+
+	n = vop2_data->dump_regs_size;
+	for (i = 0; i < n; i++) {
+		base = regs[i].offset;
+		printf("\n%s:\n", regs[i].name);
+		for (j = 0; j < 68;) {
+			printf("%08lx:  %08x %08x %08x %08x\n", (uintptr_t)vop2->regs + base + j * 4,
+			       vop2_readl(vop2, base + (4 * j)),
+			       vop2_readl(vop2, base + (4 * (j + 1))),
+			       vop2_readl(vop2, base + (4 * (j + 2))),
+			       vop2_readl(vop2, base + (4 * (j + 3))));
+			j += 4;
+		}
+	}
+
+	return 0;
+}
+
+static int rockchip_vop2_active_regs_dump(struct display_state *state)
+{
+	struct crtc_state *cstate = &state->crtc_state;
+	struct vop2 *vop2 = cstate->private;
+	const struct vop2_data *vop2_data = vop2->data;
+	const struct vop2_dump_regs *regs = vop2_data->dump_regs;
+	u32 n, i, j;
+	u32 base;
+	bool enable_state;
+
+	if (!cstate->crtc->active)
+		return -EINVAL;
+
+	n = vop2_data->dump_regs_size;
+	for (i = 0; i < n; i++) {
+		if (regs[i].state_mask) {
+			enable_state = (vop2_readl(vop2, regs[i].state_base) >> regs[i].state_shift) &
+				       regs[i].state_mask;
+			if (enable_state != regs[i].enable_state)
+				continue;
+		}
+
+		base = regs[i].offset;
+		printf("\n%s:\n", regs[i].name);
+		for (j = 0; j < 68;) {
+			printf("%08lx:  %08x %08x %08x %08x\n", (uintptr_t)vop2->regs + base + j * 4,
+			       vop2_readl(vop2, base + (4 * j)),
+			       vop2_readl(vop2, base + (4 * (j + 1))),
+			       vop2_readl(vop2, base + (4 * (j + 2))),
+			       vop2_readl(vop2, base + (4 * (j + 3))));
+			j += 4;
+		}
+	}
+
+	return 0;
+}
+
+static struct vop2_dump_regs rk3528_dump_regs[] = {
+	{ RK3568_REG_CFG_DONE, "SYS", 0, 0, 0, 0 },
+	{ RK3528_OVL_SYS, "OVL_SYS", 0, 0, 0, 0 },
+	{ RK3528_OVL_PORT0_CTRL, "OVL_VP0", RK3568_VP0_DSP_CTRL, 0x1, 31, 0 },
+	{ RK3528_OVL_PORT1_CTRL, "OVL_VP1", RK3568_VP1_DSP_CTRL, 0x1, 31, 0 },
+	{ RK3568_VP0_DSP_CTRL, "VP0", RK3568_VP0_DSP_CTRL, 0x1, 31, 0 },
+	{ RK3568_VP1_DSP_CTRL, "VP1", RK3568_VP1_DSP_CTRL, 0x1, 31, 0 },
+	{ RK3568_CLUSTER0_WIN0_CTRL0, "Cluster0", RK3568_CLUSTER0_WIN0_CTRL0, 0x1, 0, 1 },
+	{ RK3568_ESMART0_CTRL0, "Esmart0", RK3568_ESMART0_REGION0_CTRL, 0x1, 0, 1 },
+	{ RK3568_ESMART1_CTRL0, "Esmart1", RK3568_ESMART1_REGION0_CTRL, 0x1, 0, 1 },
+	{ RK3568_SMART0_CTRL0, "Esmart2", RK3568_SMART0_CTRL0, 0x1, 0, 1 },
+	{ RK3568_SMART1_CTRL0, "Esmart3", RK3568_SMART1_CTRL0, 0x1, 0, 1 },
+	{ RK3528_HDR_LUT_CTRL, "HDR", 0, 0, 0, 0 },
+	{ RK3528_ACM_CTRL, "ACM", RK3528_ACM_CTRL, 0x1, 0, 1},
+};
+
+static u8 rk3528_vp_primary_plane_order[ROCKCHIP_VOP2_LAYER_MAX] = {
+	ROCKCHIP_VOP2_ESMART0,
+	ROCKCHIP_VOP2_ESMART1,
+	ROCKCHIP_VOP2_ESMART2,
+	ROCKCHIP_VOP2_ESMART3,
+};
+
+static struct vop2_plane_table rk3528_plane_table[ROCKCHIP_VOP2_LAYER_MAX] = {
+	{ROCKCHIP_VOP2_CLUSTER0, CLUSTER_LAYER},
+	{ROCKCHIP_VOP2_ESMART0, ESMART_LAYER},
+	{ROCKCHIP_VOP2_ESMART1, ESMART_LAYER},
+	{ROCKCHIP_VOP2_ESMART2, ESMART_LAYER},
+	{ROCKCHIP_VOP2_ESMART3, ESMART_LAYER},
+};
+
+static struct vop2_vp_plane_mask rk3528_vp_plane_mask[VOP2_VP_MAX][VOP2_VP_MAX] = {
+	{ /* one display policy for hdmi */
+		{/* main display */
+			.primary_plane_id = ROCKCHIP_VOP2_ESMART0,
+			.attached_layers_nr = 4,
+			.attached_layers = {
+				  ROCKCHIP_VOP2_CLUSTER0,
+				  ROCKCHIP_VOP2_ESMART0,  ROCKCHIP_VOP2_ESMART1, ROCKCHIP_VOP2_ESMART2
+				},
+		},
+		{/* second display */},
+		{/* third  display */},
+		{/* fourth display */},
+	},
+
+	{ /* two display policy */
+		{/* main display */
+			.primary_plane_id = ROCKCHIP_VOP2_ESMART0,
+			.attached_layers_nr = 3,
+			.attached_layers = {
+				  ROCKCHIP_VOP2_CLUSTER0, ROCKCHIP_VOP2_ESMART0, ROCKCHIP_VOP2_ESMART1
+				},
+		},
+
+		{/* second display */
+			.primary_plane_id = ROCKCHIP_VOP2_ESMART3,
+			.attached_layers_nr = 2,
+			.attached_layers = {
+				  ROCKCHIP_VOP2_ESMART2, ROCKCHIP_VOP2_ESMART3
+				},
+		},
+		{/* third  display */},
+		{/* fourth display */},
+	},
+
+	{ /* one display policy for cvbs */
+		{/* main display */
+			.primary_plane_id = ROCKCHIP_VOP2_ESMART3,
+			.attached_layers_nr = 2,
+			.attached_layers = {
+				  ROCKCHIP_VOP2_ESMART2, ROCKCHIP_VOP2_ESMART3
+				},
+		},
+		{/* second display */},
+		{/* third  display */},
+		{/* fourth display */},
+	},
+
+	{/* reserved */},
+};
+
+static struct vop2_win_data rk3528_win_data[5] = {
+	{
+		.name = "Esmart0",
+		.phys_id = ROCKCHIP_VOP2_ESMART0,
+		.type = ESMART_LAYER,
+		.win_sel_port_offset = 8,
+		.layer_sel_win_id = { 1, 0xff, 0xff, 0xff },
+		.reg_offset = 0,
+		.axi_id = 0,
+		.axi_yrgb_id = 0x06,
+		.axi_uv_id = 0x07,
+		.hsu_filter_mode = VOP2_SCALE_UP_BIC,
+		.hsd_filter_mode = VOP2_SCALE_DOWN_BIL,
+		.vsu_filter_mode = VOP2_SCALE_UP_BIL,
+		.vsd_filter_mode = VOP2_SCALE_DOWN_BIL,
+		.hsd_pre_filter_mode = VOP3_PRE_SCALE_DOWN_AVG,	/* gt or avg */
+		.vsd_pre_filter_mode = VOP3_PRE_SCALE_DOWN_GT,	/* gt only */
+		.max_upscale_factor = 8,
+		.max_downscale_factor = 8,
+	},
+
+	{
+		.name = "Esmart1",
+		.phys_id = ROCKCHIP_VOP2_ESMART1,
+		.type = ESMART_LAYER,
+		.win_sel_port_offset = 10,
+		.layer_sel_win_id = { 2, 0xff, 0xff, 0xff },
+		.reg_offset = 0x200,
+		.axi_id = 0,
+		.axi_yrgb_id = 0x08,
+		.axi_uv_id = 0x09,
+		.hsu_filter_mode = VOP2_SCALE_UP_BIC,
+		.hsd_filter_mode = VOP2_SCALE_DOWN_BIL,
+		.vsu_filter_mode = VOP2_SCALE_UP_BIL,
+		.vsd_filter_mode = VOP2_SCALE_DOWN_BIL,
+		.hsd_pre_filter_mode = VOP3_PRE_SCALE_DOWN_AVG,	/* gt or avg */
+		.vsd_pre_filter_mode = VOP3_PRE_SCALE_DOWN_GT,	/* gt only */
+		.max_upscale_factor = 8,
+		.max_downscale_factor = 8,
+	},
+
+	{
+		.name = "Esmart2",
+		.phys_id = ROCKCHIP_VOP2_ESMART2,
+		.type = ESMART_LAYER,
+		.win_sel_port_offset = 12,
+		.layer_sel_win_id = { 3, 0, 0xff, 0xff },
+		.reg_offset = 0x400,
+		.axi_id = 0,
+		.axi_yrgb_id = 0x0a,
+		.axi_uv_id = 0x0b,
+		.hsu_filter_mode = VOP2_SCALE_UP_BIC,
+		.hsd_filter_mode = VOP2_SCALE_DOWN_BIL,
+		.vsu_filter_mode = VOP2_SCALE_UP_BIL,
+		.vsd_filter_mode = VOP2_SCALE_DOWN_BIL,
+		.hsd_pre_filter_mode = VOP3_PRE_SCALE_DOWN_AVG,	/* gt or avg */
+		.vsd_pre_filter_mode = VOP3_PRE_SCALE_DOWN_GT,	/* gt only */
+		.max_upscale_factor = 8,
+		.max_downscale_factor = 8,
+	},
+
+	{
+		.name = "Esmart3",
+		.phys_id = ROCKCHIP_VOP2_ESMART3,
+		.type = ESMART_LAYER,
+		.win_sel_port_offset = 14,
+		.layer_sel_win_id = { 0xff, 1, 0xff, 0xff },
+		.reg_offset = 0x600,
+		.axi_id = 0,
+		.axi_yrgb_id = 0x0c,
+		.axi_uv_id = 0x0d,
+		.hsu_filter_mode = VOP2_SCALE_UP_BIC,
+		.hsd_filter_mode = VOP2_SCALE_DOWN_BIL,
+		.vsu_filter_mode = VOP2_SCALE_UP_BIL,
+		.vsd_filter_mode = VOP2_SCALE_DOWN_BIL,
+		.hsd_pre_filter_mode = VOP3_PRE_SCALE_DOWN_AVG,	/* gt or avg */
+		.vsd_pre_filter_mode = VOP3_PRE_SCALE_DOWN_GT,	/* gt only */
+		.max_upscale_factor = 8,
+		.max_downscale_factor = 8,
+	},
+
+	{
+		.name = "Cluster0",
+		.phys_id = ROCKCHIP_VOP2_CLUSTER0,
+		.type = CLUSTER_LAYER,
+		.win_sel_port_offset = 0,
+		.layer_sel_win_id = { 0, 0xff, 0xff, 0xff },
+		.reg_offset = 0,
+		.axi_id = 0,
+		.axi_yrgb_id = 0x02,
+		.axi_uv_id = 0x03,
+		.hsu_filter_mode = VOP2_SCALE_UP_BIC,
+		.hsd_filter_mode = VOP2_SCALE_DOWN_BIL,
+		.vsu_filter_mode = VOP2_SCALE_UP_BIL,
+		.vsd_filter_mode = VOP2_SCALE_DOWN_BIL,
+		.hsd_pre_filter_mode = VOP3_PRE_SCALE_DOWN_AVG,	/* gt or avg */
+		.vsd_pre_filter_mode = VOP3_PRE_SCALE_DOWN_AVG,	/* gt or avg */
+		.max_upscale_factor = 8,
+		.max_downscale_factor = 8,
+	},
+};
+
+static struct vop2_vp_data rk3528_vp_data[2] = {
+	{
+		.feature = VOP_FEATURE_ALPHA_SCALE | VOP_FEATURE_OVERSCAN | VOP_FEATURE_POST_ACM |
+			   VOP_FEATURE_POST_CSC,
+		.max_output = {4096, 4096},
+		.layer_mix_dly = 6,
+		.hdr_mix_dly = 2,
+		.win_dly = 8,
+	},
+	{
+		.feature = VOP_FEATURE_ALPHA_SCALE | VOP_FEATURE_OVERSCAN,
+		.max_output = {1920, 1080},
+		.layer_mix_dly = 2,
+		.hdr_mix_dly = 0,
+		.win_dly = 8,
+	},
+};
+
+const struct vop2_data rk3528_vop = {
+	.version = VOP_VERSION_RK3528,
+	.nr_vps = 2,
+	.vp_data = rk3528_vp_data,
+	.win_data = rk3528_win_data,
+	.plane_mask = rk3528_vp_plane_mask[0],
+	.plane_table = rk3528_plane_table,
+	.vp_primary_plane_order = rk3528_vp_primary_plane_order,
+	.nr_layers = 5,
+	.nr_mixers = 3,
+	.nr_gammas = 2,
+	.esmart_lb_mode = VOP3_ESMART_4K_2K_2K_MODE,
+	.dump_regs = rk3528_dump_regs,
+	.dump_regs_size = ARRAY_SIZE(rk3528_dump_regs),
+};
+
+static struct vop2_dump_regs rk3562_dump_regs[] = {
+	{ RK3568_REG_CFG_DONE, "SYS", 0, 0, 0, 0 },
+	{ RK3528_OVL_SYS, "OVL_SYS", 0, 0, 0, 0 },
+	{ RK3528_OVL_PORT0_CTRL, "OVL_VP0", RK3568_VP0_DSP_CTRL, 0x1, 31, 0 },
+	{ RK3528_OVL_PORT1_CTRL, "OVL_VP1", RK3568_VP1_DSP_CTRL, 0x1, 31, 0 },
+	{ RK3568_VP0_DSP_CTRL, "VP0", RK3568_VP0_DSP_CTRL, 0x1, 31, 0 },
+	{ RK3568_VP1_DSP_CTRL, "VP1", RK3568_VP1_DSP_CTRL, 0x1, 31, 0 },
+	{ RK3568_ESMART0_CTRL0, "Esmart0", RK3568_ESMART0_REGION0_CTRL, 0x1, 0, 1 },
+	{ RK3568_ESMART1_CTRL0, "Esmart1", RK3568_ESMART1_REGION0_CTRL, 0x1, 0, 1 },
+	{ RK3568_SMART0_CTRL0, "Esmart2", RK3568_SMART0_CTRL0, 0x1, 0, 1 },
+	{ RK3568_SMART1_CTRL0, "Esmart3", RK3568_SMART1_CTRL0, 0x1, 0, 1 },
+};
+
+static u8 rk3562_vp_primary_plane_order[ROCKCHIP_VOP2_LAYER_MAX] = {
+	ROCKCHIP_VOP2_ESMART0,
+	ROCKCHIP_VOP2_ESMART1,
+	ROCKCHIP_VOP2_ESMART2,
+	ROCKCHIP_VOP2_ESMART3,
+};
+
+static struct vop2_plane_table rk3562_plane_table[ROCKCHIP_VOP2_LAYER_MAX] = {
+	{ROCKCHIP_VOP2_ESMART0, ESMART_LAYER},
+	{ROCKCHIP_VOP2_ESMART1, ESMART_LAYER},
+	{ROCKCHIP_VOP2_ESMART2, ESMART_LAYER},
+	{ROCKCHIP_VOP2_ESMART3, ESMART_LAYER},
+};
+
+static struct vop2_vp_plane_mask rk3562_vp_plane_mask[VOP2_VP_MAX][VOP2_VP_MAX] = {
+	{ /* one display policy for hdmi */
+		{/* main display */
+			.primary_plane_id = ROCKCHIP_VOP2_ESMART0,
+			.attached_layers_nr = 4,
+			.attached_layers = {
+				  ROCKCHIP_VOP2_ESMART0,  ROCKCHIP_VOP2_ESMART1,
+				  ROCKCHIP_VOP2_ESMART2,  ROCKCHIP_VOP2_ESMART3
+				},
+		},
+		{/* second display */},
+		{/* third  display */},
+		{/* fourth display */},
+	},
+
+	{ /* two display policy */
+		{/* main display */
+			.primary_plane_id = ROCKCHIP_VOP2_ESMART0,
+			.attached_layers_nr = 2,
+			.attached_layers = {
+				  ROCKCHIP_VOP2_ESMART0, ROCKCHIP_VOP2_ESMART1
+				},
+		},
+
+		{/* second display */
+			.primary_plane_id = ROCKCHIP_VOP2_ESMART2,
+			.attached_layers_nr = 2,
+			.attached_layers = {
+				  ROCKCHIP_VOP2_ESMART2, ROCKCHIP_VOP2_ESMART3
+				},
+		},
+		{/* third  display */},
+		{/* fourth display */},
+	},
+
+	{/* reserved */},
+};
+
+static struct vop2_win_data rk3562_win_data[4] = {
+	{
+		.name = "Esmart0",
+		.phys_id = ROCKCHIP_VOP2_ESMART0,
+		.type = ESMART_LAYER,
+		.win_sel_port_offset = 8,
+		.layer_sel_win_id = { 0, 0, 0xff, 0xff },
+		.reg_offset = 0,
+		.axi_id = 0,
+		.axi_yrgb_id = 0x02,
+		.axi_uv_id = 0x03,
+		.hsu_filter_mode = VOP2_SCALE_UP_BIC,
+		.hsd_filter_mode = VOP2_SCALE_DOWN_BIL,
+		.vsu_filter_mode = VOP2_SCALE_UP_BIL,
+		.vsd_filter_mode = VOP2_SCALE_DOWN_BIL,
+		.max_upscale_factor = 8,
+		.max_downscale_factor = 8,
+	},
+
+	{
+		.name = "Esmart1",
+		.phys_id = ROCKCHIP_VOP2_ESMART1,
+		.type = ESMART_LAYER,
+		.win_sel_port_offset = 10,
+		.layer_sel_win_id = { 1, 1, 0xff, 0xff },
+		.reg_offset = 0x200,
+		.axi_id = 0,
+		.axi_yrgb_id = 0x04,
+		.axi_uv_id = 0x05,
+		.hsu_filter_mode = VOP2_SCALE_UP_BIC,
+		.hsd_filter_mode = VOP2_SCALE_DOWN_BIL,
+		.vsu_filter_mode = VOP2_SCALE_UP_BIL,
+		.vsd_filter_mode = VOP2_SCALE_DOWN_BIL,
+		.max_upscale_factor = 8,
+		.max_downscale_factor = 8,
+	},
+
+	{
+		.name = "Esmart2",
+		.phys_id = ROCKCHIP_VOP2_ESMART2,
+		.type = ESMART_LAYER,
+		.win_sel_port_offset = 12,
+		.layer_sel_win_id = { 2, 2, 0xff, 0xff },
+		.reg_offset = 0x400,
+		.axi_id = 0,
+		.axi_yrgb_id = 0x06,
+		.axi_uv_id = 0x07,
+		.hsu_filter_mode = VOP2_SCALE_UP_BIC,
+		.hsd_filter_mode = VOP2_SCALE_DOWN_BIL,
+		.vsu_filter_mode = VOP2_SCALE_UP_BIL,
+		.vsd_filter_mode = VOP2_SCALE_DOWN_BIL,
+		.max_upscale_factor = 8,
+		.max_downscale_factor = 8,
+	},
+
+	{
+		.name = "Esmart3",
+		.phys_id = ROCKCHIP_VOP2_ESMART3,
+		.type = ESMART_LAYER,
+		.win_sel_port_offset = 14,
+		.layer_sel_win_id = { 3, 3, 0xff, 0xff },
+		.reg_offset = 0x600,
+		.axi_id = 0,
+		.axi_yrgb_id = 0x08,
+		.axi_uv_id = 0x0d,
+		.hsu_filter_mode = VOP2_SCALE_UP_BIC,
+		.hsd_filter_mode = VOP2_SCALE_DOWN_BIL,
+		.vsu_filter_mode = VOP2_SCALE_UP_BIL,
+		.vsd_filter_mode = VOP2_SCALE_DOWN_BIL,
+		.max_upscale_factor = 8,
+		.max_downscale_factor = 8,
+	},
+};
+
+static struct vop2_vp_data rk3562_vp_data[2] = {
+	{
+		.feature = VOP_FEATURE_ALPHA_SCALE | VOP_FEATURE_OVERSCAN,
+		.max_output = {2048, 4096},
+		.win_dly = 8,
+		.layer_mix_dly = 8,
+	},
+	{
+		.feature = VOP_FEATURE_ALPHA_SCALE | VOP_FEATURE_OVERSCAN,
+		.max_output = {2048, 1080},
+		.win_dly = 8,
+		.layer_mix_dly = 8,
+	},
+};
+
+const struct vop2_data rk3562_vop = {
+	.version = VOP_VERSION_RK3562,
+	.nr_vps = 2,
+	.vp_data = rk3562_vp_data,
+	.win_data = rk3562_win_data,
+	.plane_mask = rk3562_vp_plane_mask[0],
+	.plane_table = rk3562_plane_table,
+	.vp_primary_plane_order = rk3562_vp_primary_plane_order,
+	.nr_layers = 4,
+	.nr_mixers = 3,
+	.nr_gammas = 2,
+	.esmart_lb_mode = VOP3_ESMART_2K_2K_2K_2K_MODE,
+	.dump_regs = rk3562_dump_regs,
+	.dump_regs_size = ARRAY_SIZE(rk3562_dump_regs),
+};
+
+static struct vop2_dump_regs rk3568_dump_regs[] = {
+	{ RK3568_REG_CFG_DONE, "SYS", 0, 0, 0, 0 },
+	{ RK3568_OVL_CTRL, "OVL", 0, 0, 0, 0 },
+	{ RK3568_VP0_DSP_CTRL, "VP0", RK3568_VP1_DSP_CTRL, 0x1, 31, 0 },
+	{ RK3568_VP1_DSP_CTRL, "VP1", RK3568_VP1_DSP_CTRL, 0x1, 31, 0 },
+	{ RK3568_VP2_DSP_CTRL, "VP2", RK3568_VP2_DSP_CTRL, 0x1, 31, 0 },
+	{ RK3568_CLUSTER0_WIN0_CTRL0, "Cluster0", RK3568_CLUSTER0_WIN0_CTRL0, 0x1, 0, 1 },
+	{ RK3568_CLUSTER1_WIN0_CTRL0, "Cluster1", RK3568_CLUSTER1_WIN0_CTRL0, 0x1, 0, 1 },
+	{ RK3568_ESMART0_CTRL0, "Esmart0", RK3568_ESMART0_REGION0_CTRL, 0x1, 0, 1 },
+	{ RK3568_ESMART1_CTRL0, "Esmart1", RK3568_ESMART1_REGION0_CTRL, 0x1, 0, 1 },
+	{ RK3568_SMART0_CTRL0, "Smart0", RK3568_SMART0_REGION0_CTRL, 0x1, 0, 1 },
+	{ RK3568_SMART1_CTRL0, "Smart1", RK3568_SMART1_REGION0_CTRL, 0x1, 0, 1 },
+	{ RK3568_HDR_LUT_CTRL, "HDR", 0, 0, 0, 0 },
+};
+
+static u8 rk3568_vp_primary_plane_order[ROCKCHIP_VOP2_LAYER_MAX] = {
+	ROCKCHIP_VOP2_SMART0,
+	ROCKCHIP_VOP2_SMART1,
+	ROCKCHIP_VOP2_ESMART0,
+	ROCKCHIP_VOP2_ESMART1,
+};
+
+static struct vop2_plane_table rk356x_plane_table[ROCKCHIP_VOP2_LAYER_MAX] = {
+	{ROCKCHIP_VOP2_CLUSTER0, CLUSTER_LAYER},
+	{ROCKCHIP_VOP2_CLUSTER1, CLUSTER_LAYER},
+	{ROCKCHIP_VOP2_ESMART0, ESMART_LAYER},
+	{ROCKCHIP_VOP2_ESMART1, ESMART_LAYER},
+	{ROCKCHIP_VOP2_SMART0, SMART_LAYER},
+	{ROCKCHIP_VOP2_SMART0, SMART_LAYER},
+};
+
+static struct vop2_vp_plane_mask rk356x_vp_plane_mask[VOP2_VP_MAX][VOP2_VP_MAX] = {
+	{ /* one display policy */
+		{/* main display */
+			.primary_plane_id = ROCKCHIP_VOP2_SMART0,
+			.attached_layers_nr = 6,
+			.attached_layers = {
+				  ROCKCHIP_VOP2_CLUSTER0, ROCKCHIP_VOP2_ESMART0, ROCKCHIP_VOP2_SMART0,
+				  ROCKCHIP_VOP2_CLUSTER1, ROCKCHIP_VOP2_ESMART1, ROCKCHIP_VOP2_SMART1
+				},
+		},
+		{/* second display */},
+		{/* third  display */},
+		{/* fourth display */},
+	},
+
+	{ /* two display policy */
+		{/* main display */
+			.primary_plane_id = ROCKCHIP_VOP2_SMART0,
+			.attached_layers_nr = 3,
+			.attached_layers = {
+				  ROCKCHIP_VOP2_CLUSTER0, ROCKCHIP_VOP2_ESMART0, ROCKCHIP_VOP2_SMART0
+				},
+		},
+
+		{/* second display */
+			.primary_plane_id = ROCKCHIP_VOP2_SMART1,
+			.attached_layers_nr = 3,
+			.attached_layers = {
+				  ROCKCHIP_VOP2_CLUSTER1, ROCKCHIP_VOP2_ESMART1, ROCKCHIP_VOP2_SMART1
+				},
+		},
+		{/* third  display */},
+		{/* fourth display */},
+	},
+
+	{ /* three display policy */
+		{/* main display */
+			.primary_plane_id = ROCKCHIP_VOP2_SMART0,
+			.attached_layers_nr = 3,
+			.attached_layers = {
+				  ROCKCHIP_VOP2_CLUSTER0, ROCKCHIP_VOP2_ESMART0, ROCKCHIP_VOP2_SMART0
+				},
+		},
+
+		{/* second display */
+			.primary_plane_id = ROCKCHIP_VOP2_SMART1,
+			.attached_layers_nr = 2,
+			.attached_layers = {
+				  ROCKCHIP_VOP2_CLUSTER1, ROCKCHIP_VOP2_SMART1
+				},
+		},
+
+		{/* third  display */
+			.primary_plane_id = ROCKCHIP_VOP2_ESMART1,
+			.attached_layers_nr = 1,
+			.attached_layers = { ROCKCHIP_VOP2_ESMART1 },
+		},
+
+		{/* fourth display */},
+	},
+
+	{/* reserved for four display policy */},
+};
+
+static struct vop2_win_data rk3568_win_data[6] = {
+	{
+		.name = "Cluster0",
+		.phys_id = ROCKCHIP_VOP2_CLUSTER0,
+		.type = CLUSTER_LAYER,
+		.win_sel_port_offset = 0,
+		.layer_sel_win_id = { 0, 0, 0, 0xff },
+		.reg_offset = 0,
+		.hsu_filter_mode = VOP2_SCALE_UP_BIC,
+		.hsd_filter_mode = VOP2_SCALE_DOWN_BIL,
+		.vsu_filter_mode = VOP2_SCALE_UP_BIL,
+		.vsd_filter_mode = VOP2_SCALE_DOWN_BIL,
+		.max_upscale_factor = 4,
+		.max_downscale_factor = 4,
+	},
+
+	{
+		.name = "Cluster1",
+		.phys_id = ROCKCHIP_VOP2_CLUSTER1,
+		.type = CLUSTER_LAYER,
+		.win_sel_port_offset = 1,
+		.layer_sel_win_id = { 1, 1, 1, 0xff },
+		.reg_offset = 0x200,
+		.hsu_filter_mode = VOP2_SCALE_UP_BIC,
+		.hsd_filter_mode = VOP2_SCALE_DOWN_BIL,
+		.vsu_filter_mode = VOP2_SCALE_UP_BIL,
+		.vsd_filter_mode = VOP2_SCALE_DOWN_BIL,
+		.max_upscale_factor = 4,
+		.max_downscale_factor = 4,
+		.source_win_id = ROCKCHIP_VOP2_CLUSTER0,
+		.feature = WIN_FEATURE_MIRROR,
+	},
+
+	{
+		.name = "Esmart0",
+		.phys_id = ROCKCHIP_VOP2_ESMART0,
+		.type = ESMART_LAYER,
+		.win_sel_port_offset = 4,
+		.layer_sel_win_id = { 2, 2, 2, 0xff },
+		.reg_offset = 0,
+		.hsu_filter_mode = VOP2_SCALE_UP_BIC,
+		.hsd_filter_mode = VOP2_SCALE_DOWN_BIL,
+		.vsu_filter_mode = VOP2_SCALE_UP_BIL,
+		.vsd_filter_mode = VOP2_SCALE_DOWN_BIL,
+		.max_upscale_factor = 8,
+		.max_downscale_factor = 8,
+	},
+
+	{
+		.name = "Esmart1",
+		.phys_id = ROCKCHIP_VOP2_ESMART1,
+		.type = ESMART_LAYER,
+		.win_sel_port_offset = 5,
+		.layer_sel_win_id = { 6, 6, 6, 0xff },
+		.reg_offset = 0x200,
+		.hsu_filter_mode = VOP2_SCALE_UP_BIC,
+		.hsd_filter_mode = VOP2_SCALE_DOWN_BIL,
+		.vsu_filter_mode = VOP2_SCALE_UP_BIL,
+		.vsd_filter_mode = VOP2_SCALE_DOWN_BIL,
+		.max_upscale_factor = 8,
+		.max_downscale_factor = 8,
+		.source_win_id = ROCKCHIP_VOP2_ESMART0,
+		.feature = WIN_FEATURE_MIRROR,
+	},
+
+	{
+		.name = "Smart0",
+		.phys_id = ROCKCHIP_VOP2_SMART0,
+		.type = SMART_LAYER,
+		.win_sel_port_offset = 6,
+		.layer_sel_win_id = { 3, 3, 3, 0xff },
+		.reg_offset = 0x400,
+		.hsu_filter_mode = VOP2_SCALE_UP_BIC,
+		.hsd_filter_mode = VOP2_SCALE_DOWN_BIL,
+		.vsu_filter_mode = VOP2_SCALE_UP_BIL,
+		.vsd_filter_mode = VOP2_SCALE_DOWN_BIL,
+		.max_upscale_factor = 8,
+		.max_downscale_factor = 8,
+	},
+
+	{
+		.name = "Smart1",
+		.phys_id = ROCKCHIP_VOP2_SMART1,
+		.type = SMART_LAYER,
+		.win_sel_port_offset = 7,
+		.layer_sel_win_id = { 7, 7, 7, 0xff },
+		.reg_offset = 0x600,
+		.hsu_filter_mode = VOP2_SCALE_UP_BIC,
+		.hsd_filter_mode = VOP2_SCALE_DOWN_BIL,
+		.vsu_filter_mode = VOP2_SCALE_UP_BIL,
+		.vsd_filter_mode = VOP2_SCALE_DOWN_BIL,
+		.max_upscale_factor = 8,
+		.max_downscale_factor = 8,
+		.source_win_id = ROCKCHIP_VOP2_SMART0,
+		.feature = WIN_FEATURE_MIRROR,
+	},
+};
+
+static struct vop2_vp_data rk3568_vp_data[3] = {
+	{
+		.feature = VOP_FEATURE_OUTPUT_10BIT,
+		.pre_scan_max_dly = 42,
+		.max_output = {4096, 2304},
+	},
+	{
+		.feature = 0,
+		.pre_scan_max_dly = 40,
+		.max_output = {2048, 1536},
+	},
+	{
+		.feature = 0,
+		.pre_scan_max_dly = 40,
+		.max_output = {1920, 1080},
+	},
+};
+
+const struct vop2_data rk3568_vop = {
+	.version = VOP_VERSION_RK3568,
+	.nr_vps = 3,
+	.vp_data = rk3568_vp_data,
+	.win_data = rk3568_win_data,
+	.plane_mask = rk356x_vp_plane_mask[0],
+	.plane_table = rk356x_plane_table,
+	.vp_primary_plane_order = rk3568_vp_primary_plane_order,
+	.nr_layers = 6,
+	.nr_mixers = 5,
+	.nr_gammas = 1,
+	.dump_regs = rk3568_dump_regs,
+	.dump_regs_size = ARRAY_SIZE(rk3568_dump_regs),
+};
+
+static u8 rk3588_vp_primary_plane_order[ROCKCHIP_VOP2_LAYER_MAX] = {
+	ROCKCHIP_VOP2_ESMART0,
+	ROCKCHIP_VOP2_ESMART1,
+	ROCKCHIP_VOP2_ESMART2,
+	ROCKCHIP_VOP2_ESMART3,
+	ROCKCHIP_VOP2_CLUSTER0,
+	ROCKCHIP_VOP2_CLUSTER1,
+	ROCKCHIP_VOP2_CLUSTER2,
+	ROCKCHIP_VOP2_CLUSTER3,
+};
+
+static struct vop2_plane_table rk3588_plane_table[ROCKCHIP_VOP2_LAYER_MAX] = {
+	{ROCKCHIP_VOP2_CLUSTER0, CLUSTER_LAYER},
+	{ROCKCHIP_VOP2_CLUSTER1, CLUSTER_LAYER},
+	{ROCKCHIP_VOP2_CLUSTER2, CLUSTER_LAYER},
+	{ROCKCHIP_VOP2_CLUSTER3, CLUSTER_LAYER},
+	{ROCKCHIP_VOP2_ESMART0, ESMART_LAYER},
+	{ROCKCHIP_VOP2_ESMART1, ESMART_LAYER},
+	{ROCKCHIP_VOP2_ESMART2, ESMART_LAYER},
+	{ROCKCHIP_VOP2_ESMART3, ESMART_LAYER},
+};
+
+static struct vop2_dump_regs rk3588_dump_regs[] = {
+	{ RK3568_REG_CFG_DONE, "SYS", 0, 0, 0, 0 },
+	{ RK3568_OVL_CTRL, "OVL", 0, 0, 0, 0 },
+	{ RK3568_VP0_DSP_CTRL, "VP0", RK3568_VP0_DSP_CTRL, 0x1, 31, 0 },
+	{ RK3568_VP1_DSP_CTRL, "VP1", RK3568_VP1_DSP_CTRL, 0x1, 31, 0 },
+	{ RK3568_VP2_DSP_CTRL, "VP2", RK3568_VP2_DSP_CTRL, 0x1, 31, 0 },
+	{ RK3588_VP3_DSP_CTRL, "VP3", RK3588_VP3_DSP_CTRL, 0x1, 31, 0 },
+	{ RK3568_CLUSTER0_WIN0_CTRL0, "Cluster0", RK3568_CLUSTER0_WIN0_CTRL0, 0x1, 0, 1 },
+	{ RK3568_CLUSTER1_WIN0_CTRL0, "Cluster1", RK3568_CLUSTER1_WIN0_CTRL0, 0x1, 0, 1 },
+	{ RK3588_CLUSTER2_WIN0_CTRL0, "Cluster2", RK3588_CLUSTER2_WIN0_CTRL0, 0x1, 0, 1 },
+	{ RK3588_CLUSTER3_WIN0_CTRL0, "Cluster3", RK3588_CLUSTER3_WIN0_CTRL0, 0x1, 0, 1 },
+	{ RK3568_ESMART0_CTRL0, "Esmart0", RK3568_ESMART0_REGION0_CTRL, 0x1, 0, 1 },
+	{ RK3568_ESMART1_CTRL0, "Esmart1", RK3568_ESMART1_REGION0_CTRL, 0x1, 0, 1 },
+	{ RK3568_SMART0_CTRL0, "Esmart2", RK3568_SMART0_REGION0_CTRL, 0x1, 0, 1 },
+	{ RK3568_SMART1_CTRL0, "Esmart3", RK3568_SMART1_REGION0_CTRL, 0x1, 0, 1 },
+	{ RK3568_HDR_LUT_CTRL, "HDR", 0, 0, 0, 0 },
+};
+
+static struct vop2_vp_plane_mask rk3588_vp_plane_mask[VOP2_VP_MAX][VOP2_VP_MAX] = {
+	{ /* one display policy */
+		{/* main display */
+			.primary_plane_id = ROCKCHIP_VOP2_ESMART0,
+			.attached_layers_nr = 8,
+			.attached_layers = {
+				  ROCKCHIP_VOP2_CLUSTER0, ROCKCHIP_VOP2_ESMART0, ROCKCHIP_VOP2_ESMART2,
+				  ROCKCHIP_VOP2_CLUSTER1, ROCKCHIP_VOP2_ESMART1, ROCKCHIP_VOP2_ESMART3,
+				  ROCKCHIP_VOP2_CLUSTER2, ROCKCHIP_VOP2_CLUSTER3
+			},
+		},
+		{/* second display */},
+		{/* third  display */},
+		{/* fourth display */},
+	},
+
+	{ /* two display policy */
+		{/* main display */
+			.primary_plane_id = ROCKCHIP_VOP2_ESMART0,
+			.attached_layers_nr = 4,
+			.attached_layers = {
+				  ROCKCHIP_VOP2_CLUSTER0, ROCKCHIP_VOP2_ESMART0,
+				  ROCKCHIP_VOP2_CLUSTER1, ROCKCHIP_VOP2_ESMART1
+			},
+		},
+
+		{/* second display */
+			.primary_plane_id = ROCKCHIP_VOP2_ESMART2,
+			.attached_layers_nr = 4,
+			.attached_layers = {
+				  ROCKCHIP_VOP2_CLUSTER2, ROCKCHIP_VOP2_ESMART2,
+				  ROCKCHIP_VOP2_CLUSTER3, ROCKCHIP_VOP2_ESMART3
+			},
+		},
+		{/* third  display */},
+		{/* fourth display */},
+	},
+
+	{ /* three display policy */
+		{/* main display */
+			.primary_plane_id = ROCKCHIP_VOP2_ESMART0,
+			.attached_layers_nr = 3,
+			.attached_layers = {
+				  ROCKCHIP_VOP2_CLUSTER0, ROCKCHIP_VOP2_CLUSTER1, ROCKCHIP_VOP2_ESMART0
+			},
+		},
+
+		{/* second display */
+			.primary_plane_id = ROCKCHIP_VOP2_ESMART1,
+			.attached_layers_nr = 3,
+			.attached_layers = {
+				  ROCKCHIP_VOP2_CLUSTER2, ROCKCHIP_VOP2_CLUSTER3, ROCKCHIP_VOP2_ESMART1
+			},
+		},
+
+		{/* third  display */
+			.primary_plane_id = ROCKCHIP_VOP2_ESMART2,
+			.attached_layers_nr = 2,
+			.attached_layers = { ROCKCHIP_VOP2_ESMART2, ROCKCHIP_VOP2_ESMART3 },
+		},
+
+		{/* fourth display */},
+	},
+
+	{ /* four display policy */
+		{/* main display */
+			.primary_plane_id = ROCKCHIP_VOP2_ESMART0,
+			.attached_layers_nr = 2,
+			.attached_layers = { ROCKCHIP_VOP2_CLUSTER0, ROCKCHIP_VOP2_ESMART0 },
+		},
+
+		{/* second display */
+			.primary_plane_id = ROCKCHIP_VOP2_ESMART1,
+			.attached_layers_nr = 2,
+			.attached_layers = { ROCKCHIP_VOP2_CLUSTER1, ROCKCHIP_VOP2_ESMART1 },
+		},
+
+		{/* third  display */
+			.primary_plane_id = ROCKCHIP_VOP2_ESMART2,
+			.attached_layers_nr = 2,
+			.attached_layers = { ROCKCHIP_VOP2_CLUSTER2, ROCKCHIP_VOP2_ESMART2 },
+		},
+
+		{/* fourth display */
+			.primary_plane_id = ROCKCHIP_VOP2_ESMART3,
+			.attached_layers_nr = 2,
+			.attached_layers = { ROCKCHIP_VOP2_CLUSTER3, ROCKCHIP_VOP2_ESMART3 },
+		},
+	},
+
+};
+
+static struct vop2_win_data rk3588_win_data[8] = {
+	{
+		.name = "Cluster0",
+		.phys_id = ROCKCHIP_VOP2_CLUSTER0,
+		.splice_win_id = ROCKCHIP_VOP2_CLUSTER1,
+		.type = CLUSTER_LAYER,
+		.win_sel_port_offset = 0,
+		.layer_sel_win_id = { 0, 0, 0, 0 },
+		.reg_offset = 0,
+		.axi_id = 0,
+		.axi_yrgb_id = 2,
+		.axi_uv_id = 3,
+		.pd_id = VOP2_PD_CLUSTER0,
+		.hsu_filter_mode = VOP2_SCALE_UP_BIC,
+		.hsd_filter_mode = VOP2_SCALE_DOWN_BIL,
+		.vsu_filter_mode = VOP2_SCALE_UP_BIL,
+		.vsd_filter_mode = VOP2_SCALE_DOWN_BIL,
+		.max_upscale_factor = 4,
+		.max_downscale_factor = 4,
+	},
+
+	{
+		.name = "Cluster1",
+		.phys_id = ROCKCHIP_VOP2_CLUSTER1,
+		.type = CLUSTER_LAYER,
+		.win_sel_port_offset = 1,
+		.layer_sel_win_id = { 1, 1, 1, 1 },
+		.reg_offset = 0x200,
+		.axi_id = 0,
+		.axi_yrgb_id = 6,
+		.axi_uv_id = 7,
+		.pd_id = VOP2_PD_CLUSTER1,
+		.hsu_filter_mode = VOP2_SCALE_UP_BIC,
+		.hsd_filter_mode = VOP2_SCALE_DOWN_BIL,
+		.vsu_filter_mode = VOP2_SCALE_UP_BIL,
+		.vsd_filter_mode = VOP2_SCALE_DOWN_BIL,
+		.max_upscale_factor = 4,
+		.max_downscale_factor = 4,
+	},
+
+	{
+		.name = "Cluster2",
+		.phys_id = ROCKCHIP_VOP2_CLUSTER2,
+		.splice_win_id = ROCKCHIP_VOP2_CLUSTER3,
+		.type = CLUSTER_LAYER,
+		.win_sel_port_offset = 2,
+		.layer_sel_win_id = { 4, 4, 4, 4 },
+		.reg_offset = 0x400,
+		.axi_id = 1,
+		.axi_yrgb_id = 2,
+		.axi_uv_id = 3,
+		.pd_id = VOP2_PD_CLUSTER2,
+		.hsu_filter_mode = VOP2_SCALE_UP_BIC,
+		.hsd_filter_mode = VOP2_SCALE_DOWN_BIL,
+		.vsu_filter_mode = VOP2_SCALE_UP_BIL,
+		.vsd_filter_mode = VOP2_SCALE_DOWN_BIL,
+		.max_upscale_factor = 4,
+		.max_downscale_factor = 4,
+	},
+
+	{
+		.name = "Cluster3",
+		.phys_id = ROCKCHIP_VOP2_CLUSTER3,
+		.type = CLUSTER_LAYER,
+		.win_sel_port_offset = 3,
+		.layer_sel_win_id = { 5, 5, 5, 5 },
+		.reg_offset = 0x600,
+		.axi_id = 1,
+		.axi_yrgb_id = 6,
+		.axi_uv_id = 7,
+		.pd_id = VOP2_PD_CLUSTER3,
+		.hsu_filter_mode = VOP2_SCALE_UP_BIC,
+		.hsd_filter_mode = VOP2_SCALE_DOWN_BIL,
+		.vsu_filter_mode = VOP2_SCALE_UP_BIL,
+		.vsd_filter_mode = VOP2_SCALE_DOWN_BIL,
+		.max_upscale_factor = 4,
+		.max_downscale_factor = 4,
+	},
+
+	{
+		.name = "Esmart0",
+		.phys_id = ROCKCHIP_VOP2_ESMART0,
+		.splice_win_id = ROCKCHIP_VOP2_ESMART1,
+		.type = ESMART_LAYER,
+		.win_sel_port_offset = 4,
+		.layer_sel_win_id = { 2, 2, 2, 2 },
+		.reg_offset = 0,
+		.axi_id = 0,
+		.axi_yrgb_id = 0x0a,
+		.axi_uv_id = 0x0b,
+		.hsu_filter_mode = VOP2_SCALE_UP_BIC,
+		.hsd_filter_mode = VOP2_SCALE_DOWN_BIL,
+		.vsu_filter_mode = VOP2_SCALE_UP_BIL,
+		.vsd_filter_mode = VOP2_SCALE_DOWN_BIL,
+		.max_upscale_factor = 8,
+		.max_downscale_factor = 8,
+	},
+
+	{
+		.name = "Esmart1",
+		.phys_id = ROCKCHIP_VOP2_ESMART1,
+		.type = ESMART_LAYER,
+		.win_sel_port_offset = 5,
+		.layer_sel_win_id = { 3, 3, 3, 3 },
+		.reg_offset = 0x200,
+		.axi_id = 0,
+		.axi_yrgb_id = 0x0c,
+		.axi_uv_id = 0x0d,
+		.pd_id = VOP2_PD_ESMART,
+		.hsu_filter_mode = VOP2_SCALE_UP_BIC,
+		.hsd_filter_mode = VOP2_SCALE_DOWN_BIL,
+		.vsu_filter_mode = VOP2_SCALE_UP_BIL,
+		.vsd_filter_mode = VOP2_SCALE_DOWN_BIL,
+		.max_upscale_factor = 8,
+		.max_downscale_factor = 8,
+	},
+
+	{
+		.name = "Esmart2",
+		.phys_id = ROCKCHIP_VOP2_ESMART2,
+		.splice_win_id = ROCKCHIP_VOP2_ESMART3,
+		.type = ESMART_LAYER,
+		.win_sel_port_offset = 6,
+		.layer_sel_win_id = { 6, 6, 6, 6 },
+		.reg_offset = 0x400,
+		.axi_id = 1,
+		.axi_yrgb_id = 0x0a,
+		.axi_uv_id = 0x0b,
+		.pd_id = VOP2_PD_ESMART,
+		.hsu_filter_mode = VOP2_SCALE_UP_BIC,
+		.hsd_filter_mode = VOP2_SCALE_DOWN_BIL,
+		.vsu_filter_mode = VOP2_SCALE_UP_BIL,
+		.vsd_filter_mode = VOP2_SCALE_DOWN_BIL,
+		.max_upscale_factor = 8,
+		.max_downscale_factor = 8,
+	},
+
+	{
+		.name = "Esmart3",
+		.phys_id = ROCKCHIP_VOP2_ESMART3,
+		.type = ESMART_LAYER,
+		.win_sel_port_offset = 7,
+		.layer_sel_win_id = { 7, 7, 7, 7 },
+		.reg_offset = 0x600,
+		.axi_id = 1,
+		.axi_yrgb_id = 0x0c,
+		.axi_uv_id = 0x0d,
+		.pd_id = VOP2_PD_ESMART,
+		.hsu_filter_mode = VOP2_SCALE_UP_BIC,
+		.hsd_filter_mode = VOP2_SCALE_DOWN_BIL,
+		.vsu_filter_mode = VOP2_SCALE_UP_BIL,
+		.vsd_filter_mode = VOP2_SCALE_DOWN_BIL,
+		.max_upscale_factor = 8,
+		.max_downscale_factor = 8,
+	},
+};
+
+static struct dsc_error_info dsc_ecw[] = {
+	{0x00000000, "no error detected by DSC encoder"},
+	{0x0030ffff, "bits per component error"},
+	{0x0040ffff, "multiple mode error"},
+	{0x0050ffff, "line buffer depth error"},
+	{0x0060ffff, "minor version error"},
+	{0x0070ffff, "picture height error"},
+	{0x0080ffff, "picture width error"},
+	{0x0090ffff, "number of slices error"},
+	{0x00c0ffff, "slice height Error "},
+	{0x00d0ffff, "slice width error"},
+	{0x00e0ffff, "second line BPG offset error"},
+	{0x00f0ffff, "non second line BPG offset error"},
+	{0x0100ffff, "PPS ID error"},
+	{0x0110ffff, "bits per pixel (BPP) Error"},
+	{0x0120ffff, "buffer flow error"},  /* dsc_buffer_flow */
+
+	{0x01510001, "slice 0 RC buffer model overflow error"},
+	{0x01510002, "slice 1 RC buffer model overflow error"},
+	{0x01510004, "slice 2 RC buffer model overflow error"},
+	{0x01510008, "slice 3 RC buffer model overflow error"},
+	{0x01510010, "slice 4 RC buffer model overflow error"},
+	{0x01510020, "slice 5 RC buffer model overflow error"},
+	{0x01510040, "slice 6 RC buffer model overflow error"},
+	{0x01510080, "slice 7 RC buffer model overflow error"},
+
+	{0x01610001, "slice 0 RC buffer model underflow error"},
+	{0x01610002, "slice 1 RC buffer model underflow error"},
+	{0x01610004, "slice 2 RC buffer model underflow error"},
+	{0x01610008, "slice 3 RC buffer model underflow error"},
+	{0x01610010, "slice 4 RC buffer model underflow error"},
+	{0x01610020, "slice 5 RC buffer model underflow error"},
+	{0x01610040, "slice 6 RC buffer model underflow error"},
+	{0x01610080, "slice 7 RC buffer model underflow error"},
+
+	{0xffffffff, "unsuccessful RESET cycle status"},
+	{0x00a0ffff, "ICH full error precision settings error"},
+	{0x0020ffff, "native mode"},
+};
+
+static struct dsc_error_info dsc_buffer_flow[] = {
+	{0x00000000, "rate buffer status"},
+	{0x00000001, "line buffer status"},
+	{0x00000002, "decoder model status"},
+	{0x00000003, "pixel buffer status"},
+	{0x00000004, "balance fifo buffer status"},
+	{0x00000005, "syntax element fifo status"},
+};
+
+static struct vop2_dsc_data rk3588_dsc_data[] = {
+	{
+		.id = ROCKCHIP_VOP2_DSC_8K,
+		.pd_id = VOP2_PD_DSC_8K,
+		.max_slice_num = 8,
+		.max_linebuf_depth = 11,
+		.min_bits_per_pixel = 8,
+		.dsc_txp_clk_src_name = "dsc_8k_txp_clk_src",
+		.dsc_txp_clk_name = "dsc_8k_txp_clk",
+		.dsc_pxl_clk_name = "dsc_8k_pxl_clk",
+		.dsc_cds_clk_name = "dsc_8k_cds_clk",
+	},
+
+	{
+		.id = ROCKCHIP_VOP2_DSC_4K,
+		.pd_id = VOP2_PD_DSC_4K,
+		.max_slice_num = 2,
+		.max_linebuf_depth = 11,
+		.min_bits_per_pixel = 8,
+		.dsc_txp_clk_src_name = "dsc_4k_txp_clk_src",
+		.dsc_txp_clk_name = "dsc_4k_txp_clk",
+		.dsc_pxl_clk_name = "dsc_4k_pxl_clk",
+		.dsc_cds_clk_name = "dsc_4k_cds_clk",
+	},
+};
+
+static struct vop2_vp_data rk3588_vp_data[4] = {
+	{
+		.splice_vp_id = 1,
+		.feature = VOP_FEATURE_OUTPUT_10BIT,
+		.pre_scan_max_dly = 54,
+		.max_dclk = 600000,
+		.max_output = {7680, 4320},
+	},
+	{
+		.feature = VOP_FEATURE_OUTPUT_10BIT,
+		.pre_scan_max_dly = 54,
+		.max_dclk = 600000,
+		.max_output = {4096, 2304},
+	},
+	{
+		.feature = VOP_FEATURE_OUTPUT_10BIT,
+		.pre_scan_max_dly = 52,
+		.max_dclk = 600000,
+		.max_output = {4096, 2304},
+	},
+	{
+		.feature = 0,
+		.pre_scan_max_dly = 52,
+		.max_dclk = 200000,
+		.max_output = {1920, 1080},
+	},
+};
+
+static struct vop2_power_domain_data rk3588_vop_pd_data[] = {
+	{
+	  .id = VOP2_PD_CLUSTER0,
+	  .module_id_mask = BIT(ROCKCHIP_VOP2_CLUSTER0),
+	},
+	{
+	  .id = VOP2_PD_CLUSTER1,
+	  .module_id_mask = BIT(ROCKCHIP_VOP2_CLUSTER1),
+	  .parent_id = VOP2_PD_CLUSTER0,
+	},
+	{
+	  .id = VOP2_PD_CLUSTER2,
+	  .module_id_mask = BIT(ROCKCHIP_VOP2_CLUSTER2),
+	  .parent_id = VOP2_PD_CLUSTER0,
+	},
+	{
+	  .id = VOP2_PD_CLUSTER3,
+	  .module_id_mask = BIT(ROCKCHIP_VOP2_CLUSTER3),
+	  .parent_id = VOP2_PD_CLUSTER0,
+	},
+	{
+	  .id = VOP2_PD_ESMART,
+	  .module_id_mask = BIT(ROCKCHIP_VOP2_ESMART1) |
+			    BIT(ROCKCHIP_VOP2_ESMART2) |
+			    BIT(ROCKCHIP_VOP2_ESMART3),
+	},
+	{
+	  .id = VOP2_PD_DSC_8K,
+	  .module_id_mask = BIT(ROCKCHIP_VOP2_DSC_8K),
+	},
+	{
+	  .id = VOP2_PD_DSC_4K,
+	  .module_id_mask = BIT(ROCKCHIP_VOP2_DSC_4K),
+	},
+};
+
+const struct vop2_data rk3588_vop = {
+	.version = VOP_VERSION_RK3588,
+	.nr_vps = 4,
+	.vp_data = rk3588_vp_data,
+	.win_data = rk3588_win_data,
+	.plane_mask = rk3588_vp_plane_mask[0],
+	.plane_table = rk3588_plane_table,
+	.pd = rk3588_vop_pd_data,
+	.dsc = rk3588_dsc_data,
+	.dsc_error_ecw = dsc_ecw,
+	.dsc_error_buffer_flow = dsc_buffer_flow,
+	.vp_primary_plane_order = rk3588_vp_primary_plane_order,
+	.nr_layers = 8,
+	.nr_mixers = 7,
+	.nr_gammas = 4,
+	.nr_pd = ARRAY_SIZE(rk3588_vop_pd_data),
+	.nr_dscs = 2,
+	.nr_dsc_ecw = ARRAY_SIZE(dsc_ecw),
+	.nr_dsc_buffer_flow = ARRAY_SIZE(dsc_buffer_flow),
+	.dump_regs = rk3588_dump_regs,
+	.dump_regs_size = ARRAY_SIZE(rk3588_dump_regs),
+};
+
+const struct rockchip_crtc_funcs rockchip_vop2_funcs = {
+	.preinit = rockchip_vop2_preinit,
+	.prepare = rockchip_vop2_prepare,
+	.init = rockchip_vop2_init,
+	.set_plane = rockchip_vop2_set_plane,
+	.enable = rockchip_vop2_enable,
+	.disable = rockchip_vop2_disable,
+	.fixup_dts = rockchip_vop2_fixup_dts,
+	.send_mcu_cmd = rockchip_vop2_send_mcu_cmd,
+	.check = rockchip_vop2_check,
+	.mode_valid = rockchip_vop2_mode_valid,
+	.mode_fixup = rockchip_vop2_mode_fixup,
+	.plane_check = rockchip_vop2_plane_check,
+	.regs_dump = rockchip_vop2_regs_dump,
+	.active_regs_dump = rockchip_vop2_active_regs_dump,
+	.apply_soft_te = rockchip_vop2_apply_soft_te,
+};
diff --git a/drivers/video/drm/rockchip_vop_reg.c b/drivers/video/drm/rockchip_vop_reg.c
new file mode 100644
index 0000000000..4bfb85f850
--- /dev/null
+++ b/drivers/video/drm/rockchip_vop_reg.c
@@ -0,0 +1,920 @@
+/*
+ * (C) Copyright 2008-2017 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <config.h>
+#include <common.h>
+#include <errno.h>
+#include <malloc.h>
+#include <asm/unaligned.h>
+#include <asm/io.h>
+#include <linux/list.h>
+
+#include "rockchip_vop.h"
+#include "rockchip_vop_reg.h"
+
+#define VOP_REG_VER_MASK(off, _mask, s, _write_mask, _major, \
+		         _begin_minor, _end_minor) \
+		{.offset = off, \
+		 .mask = _mask, \
+		 .shift = s, \
+		 .write_mask = _write_mask, \
+		 .major = _major, \
+		 .begin_minor = _begin_minor, \
+		 .end_minor = _end_minor,}
+
+#define VOP_REG(off, _mask, s) \
+		VOP_REG_VER_MASK(off, _mask, s, false, 0, 0, -1)
+
+#define VOP_REG_MASK(off, _mask, s) \
+		VOP_REG_VER_MASK(off, _mask, s, true, 0, 0, -1)
+
+#define VOP_REG_VER(off, _mask, s, _major, _begin_minor, _end_minor) \
+		VOP_REG_VER_MASK(off, _mask, s, false, \
+				 _major, _begin_minor, _end_minor)
+
+static const struct vop_scl_extension rk3288_win_full_scl_ext = {
+	.cbcr_vsd_mode = VOP_REG(RK3288_WIN0_CTRL1, 0x1, 31),
+	.cbcr_vsu_mode = VOP_REG(RK3288_WIN0_CTRL1, 0x1, 30),
+	.cbcr_hsd_mode = VOP_REG(RK3288_WIN0_CTRL1, 0x3, 28),
+	.cbcr_ver_scl_mode = VOP_REG(RK3288_WIN0_CTRL1, 0x3, 26),
+	.cbcr_hor_scl_mode = VOP_REG(RK3288_WIN0_CTRL1, 0x3, 24),
+	.yrgb_vsd_mode = VOP_REG(RK3288_WIN0_CTRL1, 0x1, 23),
+	.yrgb_vsu_mode = VOP_REG(RK3288_WIN0_CTRL1, 0x1, 22),
+	.yrgb_hsd_mode = VOP_REG(RK3288_WIN0_CTRL1, 0x3, 20),
+	.yrgb_ver_scl_mode = VOP_REG(RK3288_WIN0_CTRL1, 0x3, 18),
+	.yrgb_hor_scl_mode = VOP_REG(RK3288_WIN0_CTRL1, 0x3, 16),
+	.line_load_mode = VOP_REG(RK3288_WIN0_CTRL1, 0x1, 15),
+	.cbcr_axi_gather_num = VOP_REG(RK3288_WIN0_CTRL1, 0x7, 12),
+	.yrgb_axi_gather_num = VOP_REG(RK3288_WIN0_CTRL1, 0xf, 8),
+	.vsd_cbcr_gt2 = VOP_REG(RK3288_WIN0_CTRL1, 0x1, 7),
+	.vsd_cbcr_gt4 = VOP_REG(RK3288_WIN0_CTRL1, 0x1, 6),
+	.vsd_yrgb_gt2 = VOP_REG(RK3288_WIN0_CTRL1, 0x1, 5),
+	.vsd_yrgb_gt4 = VOP_REG(RK3288_WIN0_CTRL1, 0x1, 4),
+	.bic_coe_sel = VOP_REG(RK3288_WIN0_CTRL1, 0x3, 2),
+	.cbcr_axi_gather_en = VOP_REG(RK3288_WIN0_CTRL1, 0x1, 1),
+	.yrgb_axi_gather_en = VOP_REG(RK3288_WIN0_CTRL1, 0x1, 0),
+	.lb_mode = VOP_REG(RK3288_WIN0_CTRL0, 0x7, 5),
+};
+
+static const struct vop_scl_regs rk3288_win_full_scl = {
+	.ext = &rk3288_win_full_scl_ext,
+	.scale_yrgb_x = VOP_REG(RK3288_WIN0_SCL_FACTOR_YRGB, 0xffff, 0x0),
+	.scale_yrgb_y = VOP_REG(RK3288_WIN0_SCL_FACTOR_YRGB, 0xffff, 16),
+	.scale_cbcr_x = VOP_REG(RK3288_WIN0_SCL_FACTOR_CBR, 0xffff, 0x0),
+	.scale_cbcr_y = VOP_REG(RK3288_WIN0_SCL_FACTOR_CBR, 0xffff, 16),
+};
+
+static const struct vop_win rk3288_win01_data = {
+	.scl = &rk3288_win_full_scl,
+	.enable = VOP_REG(RK3288_WIN0_CTRL0, 0x1, 0),
+	.format = VOP_REG(RK3288_WIN0_CTRL0, 0x7, 1),
+	.rb_swap = VOP_REG(RK3288_WIN0_CTRL0, 0x1, 12),
+	.ymirror = VOP_REG_VER(RK3368_WIN0_CTRL0, 0x1, 22, 3, 2, -1),
+	.act_info = VOP_REG(RK3288_WIN0_ACT_INFO, 0x1fff1fff, 0),
+	.dsp_info = VOP_REG(RK3288_WIN0_DSP_INFO, 0x0fff0fff, 0),
+	.dsp_st = VOP_REG(RK3288_WIN0_DSP_ST, 0x1fff1fff, 0),
+	.yrgb_mst = VOP_REG(RK3288_WIN0_YRGB_MST, 0xffffffff, 0),
+	.uv_mst = VOP_REG(RK3288_WIN0_CBR_MST, 0xffffffff, 0),
+	.yrgb_vir = VOP_REG(RK3288_WIN0_VIR, 0x3fff, 0),
+	.uv_vir = VOP_REG(RK3288_WIN0_VIR, 0x3fff, 16),
+	.src_alpha_ctl = VOP_REG(RK3288_WIN0_SRC_ALPHA_CTRL, 0xffffffff, 0),
+	.dst_alpha_ctl = VOP_REG(RK3288_WIN0_DST_ALPHA_CTRL, 0xffffffff, 0),
+};
+
+static const struct vop_ctrl rk3288_ctrl_data = {
+	.standby = VOP_REG(RK3288_SYS_CTRL, 0x1, 22),
+	.axi_outstanding_max_num = VOP_REG(RK3288_SYS_CTRL1, 0x1f, 13),
+	.axi_max_outstanding_en = VOP_REG(RK3288_SYS_CTRL1, 0x1, 12),
+	.reg_done_frm = VOP_REG_VER(RK3288_SYS_CTRL1, 0x1, 24, 3, 7, -1),
+	.htotal_pw = VOP_REG(RK3288_DSP_HTOTAL_HS_END, 0x1fff1fff, 0),
+	.hact_st_end = VOP_REG(RK3288_DSP_HACT_ST_END, 0x1fff1fff, 0),
+	.vtotal_pw = VOP_REG(RK3288_DSP_VTOTAL_VS_END, 0x1fff1fff, 0),
+	.vact_st_end = VOP_REG(RK3288_DSP_VACT_ST_END, 0x1fff1fff, 0),
+	.vact_st_end_f1 = VOP_REG(RK3288_DSP_VACT_ST_END_F1, 0x1fff1fff, 0),
+	.vs_st_end_f1 = VOP_REG(RK3288_DSP_VS_ST_END_F1, 0x1fff1fff, 0),
+	.hpost_st_end = VOP_REG(RK3288_POST_DSP_HACT_INFO, 0x1fff1fff, 0),
+	.vpost_st_end = VOP_REG(RK3288_POST_DSP_VACT_INFO, 0x1fff1fff, 0),
+	.vpost_st_end_f1 = VOP_REG(RK3288_POST_DSP_VACT_INFO_F1, 0x1fff1fff, 0),
+	.post_scl_factor = VOP_REG(RK3288_POST_SCL_FACTOR_YRGB, 0xffffffff, 0),
+	.post_scl_ctrl = VOP_REG(RK3288_POST_SCL_CTRL, 0x3, 0),
+
+	.dsp_interlace = VOP_REG(RK3288_DSP_CTRL0, 0x1, 10),
+	.auto_gate_en = VOP_REG(RK3288_SYS_CTRL, 0x1, 23),
+	.dsp_layer_sel = VOP_REG(RK3288_DSP_CTRL1, 0xff, 8),
+	.post_lb_mode = VOP_REG_VER(RK3288_SYS_CTRL, 0x1, 18, 3, 2, -1),
+	.global_regdone_en = VOP_REG_VER(RK3288_SYS_CTRL, 0x1, 11, 3, 2, -1),
+	.overlay_mode = VOP_REG_VER(RK3288_SYS_CTRL, 0x1, 16, 3, 2, -1),
+	.core_dclk_div = VOP_REG_VER(RK3399_DSP_CTRL0, 0x1, 4, 3, 4, -1),
+	.p2i_en = VOP_REG_VER(RK3399_DSP_CTRL0, 0x1, 5, 3, 4, -1),
+	.dclk_ddr = VOP_REG_VER(RK3399_DSP_CTRL0, 0x1, 8, 3, 4, -1),
+	.dp_en = VOP_REG(RK3399_SYS_CTRL, 0x1, 11),
+	.rgb_en = VOP_REG(RK3288_SYS_CTRL, 0x1, 12),
+	.hdmi_en = VOP_REG(RK3288_SYS_CTRL, 0x1, 13),
+	.edp_en = VOP_REG(RK3288_SYS_CTRL, 0x1, 14),
+	.mipi_en = VOP_REG(RK3288_SYS_CTRL, 0x1, 15),
+	.mipi_dual_channel_en = VOP_REG(RK3288_SYS_CTRL, 0x1, 3),
+	.data01_swap = VOP_REG_VER(RK3288_SYS_CTRL, 0x1, 17, 3, 5, -1),
+	.dclk_pol = VOP_REG_VER(RK3288_DSP_CTRL0, 0x1, 7, 3, 0, 1),
+	.pin_pol = VOP_REG_VER(RK3288_DSP_CTRL0, 0xf, 4, 3, 0, 1),
+	.dp_dclk_pol = VOP_REG_VER(RK3399_DSP_CTRL1, 0x1, 19, 3, 5, -1),
+	.dp_pin_pol = VOP_REG_VER(RK3399_DSP_CTRL1, 0x7, 16, 3, 5, -1),
+	.rgb_dclk_pol = VOP_REG_VER(RK3368_DSP_CTRL1, 0x1, 19, 3, 2, -1),
+	.rgb_pin_pol = VOP_REG_VER(RK3368_DSP_CTRL1, 0x7, 16, 3, 2, -1),
+	.tve_dclk_en = VOP_REG(RK3288_SYS_CTRL, 0x1, 24),
+	.tve_dclk_pol = VOP_REG(RK3288_SYS_CTRL, 0x1, 25),
+	.tve_sw_mode = VOP_REG(RK3288_SYS_CTRL, 0x1, 26),
+	.sw_uv_offset_en  = VOP_REG(RK3288_SYS_CTRL, 0x1, 27),
+	.sw_genlock   = VOP_REG(RK3288_SYS_CTRL, 0x1, 28),
+	.hdmi_dclk_pol = VOP_REG_VER(RK3368_DSP_CTRL1, 0x1, 23, 3, 2, -1),
+	.hdmi_pin_pol = VOP_REG_VER(RK3368_DSP_CTRL1, 0x7, 20, 3, 2, -1),
+	.edp_dclk_pol = VOP_REG_VER(RK3368_DSP_CTRL1, 0x1, 27, 3, 2, -1),
+	.edp_pin_pol = VOP_REG_VER(RK3368_DSP_CTRL1, 0x7, 24, 3, 2, -1),
+	.mipi_dclk_pol = VOP_REG_VER(RK3368_DSP_CTRL1, 0x1, 31, 3, 2, -1),
+	.mipi_pin_pol = VOP_REG_VER(RK3368_DSP_CTRL1, 0x7, 28, 3, 2, -1),
+
+	.dither_down = VOP_REG(RK3288_DSP_CTRL1, 0xf, 1),
+	.dither_up = VOP_REG(RK3288_DSP_CTRL1, 0x1, 6),
+
+	.dsp_out_yuv = VOP_REG_VER(RK3399_POST_SCL_CTRL, 0x1, 2, 3, 5, -1),
+	.dsp_data_swap = VOP_REG(RK3288_DSP_CTRL0, 0x1f, 12),
+	.dsp_bg_swap = VOP_REG(RK3288_DSP_CTRL0, 0x1, 12),
+	.dsp_rb_swap = VOP_REG(RK3288_DSP_CTRL0, 0x1, 13),
+	.dsp_rg_swap = VOP_REG(RK3288_DSP_CTRL0, 0x1, 14),
+	.dsp_delta_swap = VOP_REG(RK3288_DSP_CTRL0, 0x1, 15),
+	.dsp_dummy_swap = VOP_REG(RK3288_DSP_CTRL0, 0x1, 16),
+	.dsp_ccir656_avg = VOP_REG(RK3288_DSP_CTRL0, 0x1, 20),
+	.dsp_blank = VOP_REG(RK3288_DSP_CTRL0, 0x3, 18),
+	.dsp_lut_en = VOP_REG(RK3288_DSP_CTRL1, 0x1, 0),
+	.update_gamma_lut = VOP_REG_VER(RK3288_DSP_CTRL1, 0x1, 7, 3, 5, -1),
+	.out_mode = VOP_REG(RK3288_DSP_CTRL0, 0xf, 0),
+
+	.bcsh_brightness = VOP_REG(RK3288_BCSH_BCS, 0xff, 0),
+	.bcsh_contrast = VOP_REG(RK3288_BCSH_BCS, 0x1ff, 8),
+	.bcsh_sat_con = VOP_REG(RK3288_BCSH_BCS, 0x3ff, 20),
+	.bcsh_out_mode = VOP_REG(RK3288_BCSH_BCS, 0x3, 0),
+	.bcsh_sin_hue = VOP_REG(RK3288_BCSH_H, 0x1ff, 0),
+	.bcsh_cos_hue = VOP_REG(RK3288_BCSH_H, 0x1ff, 16),
+	.bcsh_r2y_csc_mode = VOP_REG_VER(RK3368_BCSH_CTRL, 0x1, 6, 3, 1, -1),
+	.bcsh_r2y_en = VOP_REG_VER(RK3368_BCSH_CTRL, 0x1, 4, 3, 1, -1),
+	.bcsh_y2r_csc_mode = VOP_REG_VER(RK3368_BCSH_CTRL, 0x3, 2, 3, 1, -1),
+	.bcsh_y2r_en = VOP_REG_VER(RK3368_BCSH_CTRL, 0x1, 0, 3, 1, -1),
+	.bcsh_color_bar = VOP_REG(RK3288_BCSH_COLOR_BAR, 0xffffff, 8),
+	.bcsh_en = VOP_REG(RK3288_BCSH_COLOR_BAR, 0x1, 0),
+
+	.xmirror = VOP_REG(RK3288_DSP_CTRL0, 0x1, 22),
+	.ymirror = VOP_REG(RK3288_DSP_CTRL0, 0x1, 23),
+
+	.dsp_background = VOP_REG(RK3288_DSP_BG, 0xffffffff, 0),
+
+	.cfg_done = VOP_REG(RK3288_REG_CFG_DONE, 0x1, 0),
+	.win_gate[0] = VOP_REG(RK3288_WIN2_CTRL0, 0x1, 0),
+	.win_gate[1] = VOP_REG(RK3288_WIN3_CTRL0, 0x1, 0),
+
+	.mcu_pix_total = VOP_REG(RK3288_MCU_CTRL, 0x3f, 0),
+	.mcu_cs_pst = VOP_REG(RK3288_MCU_CTRL, 0xf, 6),
+	.mcu_cs_pend = VOP_REG(RK3288_MCU_CTRL, 0x3f, 10),
+	.mcu_rw_pst = VOP_REG(RK3288_MCU_CTRL, 0xf, 16),
+	.mcu_rw_pend = VOP_REG(RK3288_MCU_CTRL, 0x3f, 20),
+	.mcu_clk_sel = VOP_REG(RK3288_MCU_CTRL, 0x1, 26),
+	.mcu_hold_mode = VOP_REG(RK3288_MCU_CTRL, 0x1, 27),
+	.mcu_frame_st = VOP_REG(RK3288_MCU_CTRL, 0x1, 28),
+	.mcu_rs = VOP_REG(RK3288_MCU_CTRL, 0x1, 29),
+	.mcu_bypass = VOP_REG(RK3288_MCU_CTRL, 0x1, 30),
+	.mcu_type = VOP_REG(RK3288_MCU_CTRL, 0x1, 31),
+	.mcu_rw_bypass_port = VOP_REG(RK3288_MCU_BYPASS_WPORT, 0xffffffff, 0),
+};
+
+static const struct vop_line_flag rk3288_vop_line_flag = {
+	.line_flag_num[0] = VOP_REG(RK3288_INTR_CTRL0, 0x1fff, 12),
+};
+
+static const struct vop_grf_ctrl rk3288_vop_big_grf_ctrl = {
+	.grf_dclk_inv = VOP_REG(RK3288_GRF_SOC_CON15, 0x1, 13),
+};
+
+static const struct vop_grf_ctrl rk3288_vop_lit_grf_ctrl = {
+	.grf_dclk_inv = VOP_REG(RK3288_GRF_SOC_CON15, 0x1, 15),
+};
+
+const struct vop_data rk3288_vop_big = {
+	.version = VOP_VERSION(3, 1),
+	.max_output = {3840, 2160},
+	.feature = VOP_FEATURE_OUTPUT_10BIT,
+	.ctrl = &rk3288_ctrl_data,
+	.grf_ctrl = &rk3288_vop_big_grf_ctrl,
+	.win = &rk3288_win01_data,
+	.line_flag = &rk3288_vop_line_flag,
+	.reg_len = RK3288_DSP_VACT_ST_END_F1 * 4,
+};
+
+const struct vop_data rk3288_vop_lit = {
+	.version = VOP_VERSION(3, 1),
+	.max_output = {2560, 1600},
+	.feature = VOP_FEATURE_OUTPUT_10BIT,
+	.ctrl = &rk3288_ctrl_data,
+	.grf_ctrl = &rk3288_vop_lit_grf_ctrl,
+	.win = &rk3288_win01_data,
+	.line_flag = &rk3288_vop_line_flag,
+	.reg_len = RK3288_DSP_VACT_ST_END_F1 * 4,
+};
+
+static const struct vop_win rk3368_win23_data = {
+	.enable = VOP_REG(RK3368_WIN2_CTRL0, 0x1, 4),
+	.format = VOP_REG(RK3368_WIN2_CTRL0, 0x3, 5),
+	.ymirror = VOP_REG(RK3368_WIN2_CTRL1, 0x1, 15),
+	.rb_swap = VOP_REG(RK3368_WIN2_CTRL0, 0x1, 20),
+	.dsp_info = VOP_REG(RK3368_WIN2_DSP_INFO0, 0x0fff0fff, 0),
+	.dsp_st = VOP_REG(RK3368_WIN2_DSP_ST0, 0x1fff1fff, 0),
+	.yrgb_mst = VOP_REG(RK3368_WIN2_MST0, 0xffffffff, 0),
+	.yrgb_vir = VOP_REG(RK3368_WIN2_VIR0_1, 0x1fff, 0),
+	.src_alpha_ctl = VOP_REG(RK3368_WIN2_SRC_ALPHA_CTRL, 0xffff, 0),
+	.dst_alpha_ctl = VOP_REG(RK3368_WIN2_DST_ALPHA_CTRL, 0xffffffff, 0),
+};
+
+static const struct vop_line_flag rk3368_vop_line_flag = {
+	.line_flag_num[0] = VOP_REG(RK3368_LINE_FLAG, 0xffff, 0),
+	.line_flag_num[1] = VOP_REG(RK3368_LINE_FLAG, 0xffff, 16),
+};
+
+static const struct vop_grf_ctrl rk3368_vop_grf_ctrl = {
+	.grf_dclk_inv = VOP_REG(RK3368_GRF_SOC_CON6, 0x1, 5),
+};
+
+const struct vop_data rk3368_vop = {
+	.version = VOP_VERSION(3, 2),
+	.max_output = {4096, 2160},
+	.ctrl = &rk3288_ctrl_data,
+	.grf_ctrl = &rk3368_vop_grf_ctrl,
+	.win = &rk3288_win01_data,
+	.line_flag = &rk3368_vop_line_flag,
+	.reg_len = RK3368_DSP_VACT_ST_END_F1 * 4,
+};
+
+static const struct vop_line_flag rk3366_vop_line_flag = {
+	.line_flag_num[0] = VOP_REG(RK3366_LINE_FLAG, 0xffff, 0),
+	.line_flag_num[1] = VOP_REG(RK3366_LINE_FLAG, 0xffff, 16),
+};
+
+const struct vop_data rk3366_vop = {
+	.version = VOP_VERSION(3, 4),
+	.max_output = {4096, 2160},
+	.ctrl = &rk3288_ctrl_data,
+	.win = &rk3288_win01_data,
+	.line_flag = &rk3366_vop_line_flag,
+	.reg_len = RK3366_DSP_VACT_ST_END_F1 * 4,
+};
+
+static const uint32_t vop_csc_r2y_bt601[] = {
+	0x02590132, 0xff530075, 0x0200fead, 0xfe530200,
+	0x0000ffad, 0x00000200, 0x00080200, 0x00080200,
+};
+
+static const uint32_t vop_csc_r2y_bt601_12_235[] = {
+	0x02040107, 0xff680064, 0x01c2fed6, 0xfe8701c2,
+	0x0000ffb7, 0x00010200, 0x00080200, 0x00080200,
+};
+
+static const uint32_t vop_csc_r2y_bt709[] = {
+	0x027500bb, 0xff99003f, 0x01c2fea5, 0xfe6801c2,
+	0x0000ffd7, 0x00010200, 0x00080200, 0x00080200,
+};
+
+static const uint32_t vop_csc_r2y_bt2020[] = {
+	0x025300e6, 0xff830034, 0x01c1febd, 0xfe6401c1,
+	0x0000ffdc, 0x00010200, 0x00080200, 0x00080200,
+};
+
+static const struct vop_csc_table rk3399_csc_table = {
+	.r2y_bt601		= vop_csc_r2y_bt601,
+	.r2y_bt601_12_235	= vop_csc_r2y_bt601_12_235,
+	.r2y_bt709		= vop_csc_r2y_bt709,
+	.r2y_bt2020		= vop_csc_r2y_bt2020,
+};
+
+static const struct vop_csc rk3399_win0_csc = {
+	.r2r_en = VOP_REG(RK3399_YUV2YUV_WIN, 0x1, 0),
+	.y2r_en = VOP_REG(RK3399_YUV2YUV_WIN, 0x1, 1),
+	.r2y_en = VOP_REG(RK3399_YUV2YUV_WIN, 0x1, 2),
+	.y2r_offset = RK3399_WIN0_YUV2YUV_Y2R,
+	.r2r_offset = RK3399_WIN0_YUV2YUV_3X3,
+	.r2y_offset = RK3399_WIN0_YUV2YUV_R2Y,
+};
+
+static const struct vop_csc rk3399_win2_csc = {
+	.r2r_en = VOP_REG(RK3399_YUV2YUV_WIN, 0x1, 16),
+	.r2y_en = VOP_REG(RK3399_YUV2YUV_WIN, 0x1, 18),
+	.r2r_offset = RK3399_WIN2_YUV2YUV_3X3,
+
+};
+
+const struct vop_data rk3399_vop_big = {
+	.version = VOP_VERSION(3, 5),
+	.max_output = {4096, 2160},
+	.feature = VOP_FEATURE_OUTPUT_10BIT,
+	.ctrl = &rk3288_ctrl_data,
+	.win = &rk3288_win01_data,
+	.line_flag = &rk3366_vop_line_flag,
+	.csc_table = &rk3399_csc_table,
+	.win_csc = &rk3399_win0_csc,
+	.reg_len = RK3399_DSP_VACT_ST_END_F1 * 4,
+};
+
+const struct vop_data rk3399_vop_lit = {
+	.version = VOP_VERSION(3, 6),
+	.max_output = {2560, 1600},
+	.ctrl = &rk3288_ctrl_data,
+	.win = &rk3368_win23_data,
+	.line_flag = &rk3366_vop_line_flag,
+	.csc_table = &rk3399_csc_table,
+	.win_csc = &rk3399_win2_csc,
+	.reg_len = RK3399_DSP_VACT_ST_END_F1 * 4,
+};
+
+const struct vop_data rk322x_vop = {
+	.version = VOP_VERSION(3, 7),
+	.max_output = {4096, 2160},
+	.feature = VOP_FEATURE_OUTPUT_10BIT,
+	.ctrl = &rk3288_ctrl_data,
+	.win = &rk3288_win01_data,
+	.line_flag = &rk3366_vop_line_flag,
+	.reg_len = RK3399_DSP_VACT_ST_END_F1 * 4,
+};
+
+static const struct vop_ctrl rk3328_ctrl_data = {
+	.standby = VOP_REG(RK3328_SYS_CTRL, 0x1, 22),
+	.axi_outstanding_max_num = VOP_REG(RK3328_SYS_CTRL1, 0x1f, 13),
+	.axi_max_outstanding_en = VOP_REG(RK3328_SYS_CTRL1, 0x1, 12),
+	.reg_done_frm = VOP_REG(RK3328_SYS_CTRL1, 0x1, 24),
+	.auto_gate_en = VOP_REG(RK3328_SYS_CTRL, 0x1, 23),
+	.htotal_pw = VOP_REG(RK3328_DSP_HTOTAL_HS_END, 0x1fff1fff, 0),
+	.hact_st_end = VOP_REG(RK3328_DSP_HACT_ST_END, 0x1fff1fff, 0),
+	.vtotal_pw = VOP_REG(RK3328_DSP_VTOTAL_VS_END, 0x1fff1fff, 0),
+	.vact_st_end = VOP_REG(RK3328_DSP_VACT_ST_END, 0x1fff1fff, 0),
+	.vact_st_end_f1 = VOP_REG(RK3328_DSP_VACT_ST_END_F1, 0x1fff1fff, 0),
+	.vs_st_end_f1 = VOP_REG(RK3328_DSP_VS_ST_END_F1, 0x1fff1fff, 0),
+	.hpost_st_end = VOP_REG(RK3328_POST_DSP_HACT_INFO, 0x1fff1fff, 0),
+	.vpost_st_end = VOP_REG(RK3328_POST_DSP_VACT_INFO, 0x1fff1fff, 0),
+	.vpost_st_end_f1 = VOP_REG(RK3328_POST_DSP_VACT_INFO_F1, 0x1fff1fff, 0),
+	.post_scl_factor = VOP_REG(RK3328_POST_SCL_FACTOR_YRGB, 0xffffffff, 0),
+	.post_scl_ctrl = VOP_REG(RK3328_POST_SCL_CTRL, 0x3, 0),
+	.dsp_out_yuv = VOP_REG(RK3328_POST_SCL_CTRL, 0x1, 2),
+	.dsp_interlace = VOP_REG(RK3328_DSP_CTRL0, 0x1, 10),
+	.dsp_layer_sel = VOP_REG(RK3328_DSP_CTRL1, 0xff, 8),
+	.post_lb_mode = VOP_REG(RK3328_SYS_CTRL, 0x1, 18),
+	.global_regdone_en = VOP_REG(RK3328_SYS_CTRL, 0x1, 11),
+	.overlay_mode = VOP_REG(RK3328_SYS_CTRL, 0x1, 16),
+	.core_dclk_div = VOP_REG(RK3328_DSP_CTRL0, 0x1, 4),
+	.dclk_ddr = VOP_REG(RK3328_DSP_CTRL0, 0x1, 8),
+	.p2i_en = VOP_REG(RK3328_DSP_CTRL0, 0x1, 5),
+	.rgb_en = VOP_REG(RK3328_SYS_CTRL, 0x1, 12),
+	.hdmi_en = VOP_REG(RK3328_SYS_CTRL, 0x1, 13),
+	.edp_en = VOP_REG(RK3328_SYS_CTRL, 0x1, 14),
+	.mipi_en = VOP_REG(RK3328_SYS_CTRL, 0x1, 15),
+	.tve_dclk_en = VOP_REG(RK3328_SYS_CTRL, 0x1, 24),
+	.tve_dclk_pol = VOP_REG(RK3328_SYS_CTRL, 0x1, 25),
+	.tve_sw_mode = VOP_REG(RK3328_SYS_CTRL, 0x1, 26),
+	.sw_uv_offset_en  = VOP_REG(RK3328_SYS_CTRL, 0x1, 27),
+	.sw_genlock   = VOP_REG(RK3328_SYS_CTRL, 0x1, 28),
+	.sw_dac_sel = VOP_REG(RK3328_SYS_CTRL, 0x1, 29),
+	.rgb_pin_pol = VOP_REG(RK3328_DSP_CTRL1, 0xf, 16),
+	.hdmi_pin_pol = VOP_REG(RK3328_DSP_CTRL1, 0xf, 20),
+	.edp_pin_pol = VOP_REG(RK3328_DSP_CTRL1, 0xf, 24),
+	.mipi_pin_pol = VOP_REG(RK3328_DSP_CTRL1, 0xf, 28),
+
+	.dither_down = VOP_REG(RK3328_DSP_CTRL1, 0xf, 1),
+	.dither_up = VOP_REG(RK3328_DSP_CTRL1, 0x1, 6),
+
+	.dsp_data_swap = VOP_REG(RK3328_DSP_CTRL0, 0x1f, 12),
+	.dsp_bg_swap = VOP_REG(RK3328_DSP_CTRL0, 0x1, 12),
+	.dsp_rb_swap = VOP_REG(RK3328_DSP_CTRL0, 0x1, 13),
+	.dsp_rg_swap = VOP_REG(RK3328_DSP_CTRL0, 0x1, 14),
+	.dsp_delta_swap = VOP_REG(RK3328_DSP_CTRL0, 0x1, 15),
+	.dsp_dummy_swap = VOP_REG(RK3328_DSP_CTRL0, 0x1, 16),
+	.dsp_ccir656_avg = VOP_REG(RK3328_DSP_CTRL0, 0x1, 20),
+	.dsp_blank = VOP_REG(RK3328_DSP_CTRL0, 0x3, 18),
+	.dsp_lut_en = VOP_REG(RK3328_DSP_CTRL1, 0x1, 0),
+	.out_mode = VOP_REG(RK3328_DSP_CTRL0, 0xf, 0),
+
+	.xmirror = VOP_REG(RK3328_DSP_CTRL0, 0x1, 22),
+	.ymirror = VOP_REG(RK3328_DSP_CTRL0, 0x1, 23),
+
+	.dsp_background = VOP_REG(RK3328_DSP_BG, 0xffffffff, 0),
+
+	.bcsh_brightness = VOP_REG(RK3328_BCSH_BCS, 0xff, 0),
+	.bcsh_contrast = VOP_REG(RK3328_BCSH_BCS, 0x1ff, 8),
+	.bcsh_sat_con = VOP_REG(RK3328_BCSH_BCS, 0x3ff, 20),
+	.bcsh_out_mode = VOP_REG(RK3328_BCSH_BCS, 0x3, 30),
+	.bcsh_sin_hue = VOP_REG(RK3328_BCSH_H, 0x1ff, 0),
+	.bcsh_cos_hue = VOP_REG(RK3328_BCSH_H, 0x1ff, 16),
+	.bcsh_r2y_csc_mode = VOP_REG(RK3328_BCSH_CTRL, 0x3, 6),
+	.bcsh_r2y_en = VOP_REG(RK3328_BCSH_CTRL, 0x1, 4),
+	.bcsh_y2r_csc_mode = VOP_REG(RK3328_BCSH_CTRL, 0x3, 2),
+	.bcsh_y2r_en = VOP_REG(RK3328_BCSH_CTRL, 0x1, 0),
+	.bcsh_color_bar = VOP_REG(RK3328_BCSH_COLOR_BAR, 0xffffff, 8),
+	.bcsh_en = VOP_REG(RK3328_BCSH_COLOR_BAR, 0x1, 0),
+	.win_channel[0] = VOP_REG_VER(RK3328_WIN0_CTRL2, 0xff, 0, 3, 8, 8),
+	.win_channel[1] = VOP_REG_VER(RK3328_WIN1_CTRL2, 0xff, 0, 3, 8, 8),
+	.win_channel[2] = VOP_REG_VER(RK3328_WIN2_CTRL2, 0xff, 0, 3, 8, 8),
+
+	.cfg_done = VOP_REG(RK3328_REG_CFG_DONE, 0x1, 0),
+};
+
+
+static const struct vop_line_flag rk3328_vop_line_flag = {
+	.line_flag_num[0] = VOP_REG(RK3328_LINE_FLAG, 0xffff, 0),
+	.line_flag_num[1] = VOP_REG(RK3328_LINE_FLAG, 0xffff, 16),
+};
+
+const struct vop_data rk3328_vop = {
+	.version = VOP_VERSION(3, 8),
+	.max_output = {4096, 2160},
+	.feature = VOP_FEATURE_OUTPUT_10BIT,
+	.ctrl = &rk3328_ctrl_data,
+	.win = &rk3288_win01_data,
+	.win_offset = 0xd0,
+	.line_flag = &rk3328_vop_line_flag,
+	.reg_len = RK3328_DSP_VACT_ST_END_F1 * 4,
+};
+
+static const struct vop_win rk3126_win1_data = {
+	.enable = VOP_REG(RK3036_SYS_CTRL, 0x1, 1),
+	.format = VOP_REG(RK3036_SYS_CTRL, 0x7, 6),
+	.rb_swap = VOP_REG(RK3036_SYS_CTRL, 0x1, 19),
+	.dsp_info = VOP_REG(RK3126_WIN1_DSP_INFO, 0x0fff0fff, 0),
+	.dsp_st = VOP_REG(RK3126_WIN1_DSP_ST, 0x1fff1fff, 0),
+	.yrgb_mst = VOP_REG(RK3126_WIN1_MST, 0xffffffff, 0),
+	.yrgb_vir = VOP_REG(RK3036_WIN1_VIR, 0xffff, 0),
+};
+
+static const struct vop_ctrl rk3036_ctrl_data = {
+	.standby = VOP_REG(RK3036_SYS_CTRL, 0x1, 30),
+	.out_mode = VOP_REG(RK3036_DSP_CTRL0, 0xf, 0),
+	.dsp_blank = VOP_REG(RK3036_DSP_CTRL1, 0x1, 24),
+	.dclk_pol = VOP_REG(RK3036_DSP_CTRL0, 0x1, 7),
+	.pin_pol = VOP_REG(RK3036_DSP_CTRL0, 0xf, 4),
+	.dither_down = VOP_REG(RK3036_DSP_CTRL0, 0x3, 10),
+	.dsp_layer_sel = VOP_REG(RK3036_DSP_CTRL0, 0x1, 8),
+	.htotal_pw = VOP_REG(RK3036_DSP_HTOTAL_HS_END, 0x1fff1fff, 0),
+	.hact_st_end = VOP_REG(RK3036_DSP_HACT_ST_END, 0x1fff1fff, 0),
+	.hdmi_en = VOP_REG(RK3036_AXI_BUS_CTRL, 0x1, 22),
+	.hdmi_dclk_pol = VOP_REG(RK3036_AXI_BUS_CTRL, 0x1, 23),
+	.hdmi_pin_pol = VOP_REG(RK3036_INT_SCALER, 0x7, 4),
+	.rgb_en = VOP_REG(RK3036_AXI_BUS_CTRL, 0x1, 24),
+	.rgb_dclk_pol = VOP_REG(RK3036_AXI_BUS_CTRL, 0x1, 25),
+	.lvds_en = VOP_REG(RK3036_AXI_BUS_CTRL, 0x1, 26),
+	.lvds_dclk_pol = VOP_REG(RK3036_AXI_BUS_CTRL, 0x1, 27),
+	.mipi_en = VOP_REG(RK3036_AXI_BUS_CTRL, 0x1, 28),
+	.mipi_dclk_pol = VOP_REG(RK3036_AXI_BUS_CTRL, 0x1, 29),
+	.vtotal_pw = VOP_REG(RK3036_DSP_VTOTAL_VS_END, 0x1fff1fff, 0),
+	.vact_st_end = VOP_REG(RK3036_DSP_VACT_ST_END, 0x1fff1fff, 0),
+	.cfg_done = VOP_REG(RK3036_REG_CFG_DONE, 0x1, 0),
+};
+
+static const struct vop_line_flag rk3036_vop_line_flag = {
+	.line_flag_num[0] = VOP_REG(RK3036_INT_STATUS, 0xfff, 12),
+};
+
+const struct vop_data rk3036_vop = {
+	.version = VOP_VERSION(2, 2),
+	.max_output = {1920, 1080},
+	.ctrl = &rk3036_ctrl_data,
+	.win = &rk3126_win1_data,
+	.line_flag = &rk3036_vop_line_flag,
+	.reg_len = RK3036_DSP_VACT_ST_END_F1 * 4,
+};
+
+static const struct vop_scl_regs rk3366_lit_win_scl = {
+	.scale_yrgb_x = VOP_REG(RK3366_LIT_WIN0_SCL_FACTOR_YRGB, 0xffff, 0x0),
+	.scale_yrgb_y = VOP_REG(RK3366_LIT_WIN0_SCL_FACTOR_YRGB, 0xffff, 16),
+	.scale_cbcr_x = VOP_REG(RK3366_LIT_WIN0_SCL_FACTOR_CBR, 0xffff, 0x0),
+	.scale_cbcr_y = VOP_REG(RK3366_LIT_WIN0_SCL_FACTOR_CBR, 0xffff, 16),
+};
+
+static const struct vop_win rk3366_win0_data = {
+	.scl = &rk3366_lit_win_scl,
+
+	.enable = VOP_REG(RK3366_LIT_WIN0_CTRL0, 0x1, 0),
+	.format = VOP_REG(RK3366_LIT_WIN0_CTRL0, 0x7, 1),
+	.rb_swap = VOP_REG(RK3366_LIT_WIN0_CTRL0, 0x1, 12),
+	.act_info = VOP_REG(RK3366_LIT_WIN0_ACT_INFO, 0xffffffff, 0),
+	.dsp_info = VOP_REG(RK3366_LIT_WIN0_DSP_INFO, 0xffffffff, 0),
+	.dsp_st = VOP_REG(RK3366_LIT_WIN0_DSP_ST, 0xffffffff, 0),
+	.yrgb_mst = VOP_REG(RK3366_LIT_WIN0_YRGB_MST0, 0xffffffff, 0),
+	.uv_mst = VOP_REG(RK3366_LIT_WIN0_CBR_MST0, 0xffffffff, 0),
+	.yrgb_vir = VOP_REG(RK3366_LIT_WIN0_VIR, 0x1fff, 0),
+	.uv_vir = VOP_REG(RK3366_LIT_WIN0_VIR, 0x1fff, 16),
+
+	.alpha_mode = VOP_REG(RK3366_LIT_WIN0_ALPHA_CTRL, 0x1, 1),
+	.alpha_en = VOP_REG(RK3366_LIT_WIN0_ALPHA_CTRL, 0x1, 0),
+};
+
+static const struct vop_win rk3366_win1_data = {
+	.enable = VOP_REG(RK3366_LIT_WIN1_CTRL0, 0x1, 0),
+	.format = VOP_REG(RK3366_LIT_WIN1_CTRL0, 0x7, 4),
+	.rb_swap = VOP_REG(RK3366_LIT_WIN1_CTRL0, 0x1, 12),
+	.dsp_info = VOP_REG(RK3366_LIT_WIN1_DSP_INFO, 0xffffffff, 0),
+	.dsp_st = VOP_REG(RK3366_LIT_WIN1_DSP_ST, 0xffffffff, 0),
+	.yrgb_mst = VOP_REG(RK3366_LIT_WIN1_MST, 0xffffffff, 0),
+	.yrgb_vir = VOP_REG(RK3366_LIT_WIN1_VIR, 0x1fff, 0),
+
+	.alpha_mode = VOP_REG(RK3366_LIT_WIN1_ALPHA_CTRL, 0x1, 1),
+	.alpha_en = VOP_REG(RK3366_LIT_WIN1_ALPHA_CTRL, 0x1, 0),
+};
+
+static const struct vop_ctrl px30_ctrl_data = {
+	.standby = VOP_REG(RK3366_LIT_SYS_CTRL2, 0x1, 1),
+	.htotal_pw = VOP_REG(RK3366_LIT_DSP_HTOTAL_HS_END, 0x0fff0fff, 0),
+	.hact_st_end = VOP_REG(RK3366_LIT_DSP_HACT_ST_END, 0x0fff0fff, 0),
+	.vtotal_pw = VOP_REG(RK3366_LIT_DSP_VTOTAL_VS_END, 0x0fff0fff, 0),
+	.vact_st_end = VOP_REG(RK3366_LIT_DSP_VACT_ST_END, 0x0fff0fff, 0),
+	.vact_st_end_f1 = VOP_REG(RK3366_LIT_DSP_VACT_ST_END_F1, 0x0fff0fff, 0),
+	.vs_st_end_f1 = VOP_REG(RK3366_LIT_DSP_VS_ST_END_F1, 0x0fff0fff, 0),
+	.dsp_interlace = VOP_REG(RK3366_LIT_DSP_CTRL2, 0x1, 0),
+	.global_regdone_en = VOP_REG(RK3366_LIT_SYS_CTRL2, 0x1, 13),
+	.auto_gate_en = VOP_REG(RK3366_LIT_SYS_CTRL2, 0x1, 0),
+	.dsp_layer_sel = VOP_REG(RK3366_LIT_DSP_CTRL2, 0xf, 22),
+	.overlay_mode = VOP_REG(RK3366_LIT_DSP_CTRL2, 0x1, 4),
+	.core_dclk_div = VOP_REG(RK3366_LIT_DSP_CTRL0, 0x1, 13),
+	.dclk_ddr = VOP_REG(RK3366_LIT_DSP_CTRL0, 0x1, 14),
+	.rgb_en = VOP_REG(RK3366_LIT_DSP_CTRL0, 0x1, 0),
+	.rgb_pin_pol = VOP_REG(RK3366_LIT_DSP_CTRL0, 0x7, 2),
+	.hdmi_en = VOP_REG(RK3366_LIT_DSP_CTRL0, 0x1, 8),
+	.hdmi_pin_pol = VOP_REG(RK3366_LIT_DSP_CTRL0, 0x7, 10),
+	.lvds_en = VOP_REG(RK3366_LIT_DSP_CTRL0, 0x1, 16),
+	.lvds_pin_pol = VOP_REG(RK3366_LIT_DSP_CTRL0, 0x7, 18),
+	.mipi_en = VOP_REG(RK3366_LIT_DSP_CTRL0, 0x1, 24),
+	.mipi_pin_pol = VOP_REG(RK3366_LIT_DSP_CTRL0, 0x7, 26),
+	.mipi_dclk_pol = VOP_REG(RK3366_LIT_DSP_CTRL0, 0x1, 25),
+	.lvds_dclk_pol = VOP_REG(RK3366_LIT_DSP_CTRL0, 0x1, 17),
+	.hdmi_dclk_pol = VOP_REG(RK3366_LIT_DSP_CTRL0, 0x1, 9),
+	.rgb_dclk_pol = VOP_REG(RK3366_LIT_DSP_CTRL0, 0x1, 1),
+	.dither_up = VOP_REG(RK3366_LIT_DSP_CTRL2, 0x1, 2),
+	.dither_down = VOP_REG(RK3366_LIT_DSP_CTRL2, 0x7, 6),
+	.dsp_data_swap = VOP_REG(RK3366_LIT_DSP_CTRL2, 0x1f, 9),
+	.dsp_bg_swap = VOP_REG(RK3366_LIT_DSP_CTRL2, 0x1, 9),
+	.dsp_rb_swap = VOP_REG(RK3366_LIT_DSP_CTRL2, 0x1, 11),
+	.dsp_rg_swap = VOP_REG(RK3366_LIT_DSP_CTRL2, 0x1, 12),
+	.dsp_ccir656_avg = VOP_REG(RK3366_LIT_SYS_CTRL2, 0x1, 5),
+	.dsp_black = VOP_REG(RK3366_LIT_DSP_CTRL2, 0x1, 15),
+	.dsp_blank = VOP_REG(RK3366_LIT_DSP_CTRL2, 0x1, 14),
+	.dsp_outzero = VOP_REG(RK3366_LIT_SYS_CTRL2, 0x1, 3),
+	.dsp_lut_en = VOP_REG(RK3366_LIT_DSP_CTRL2, 0x1, 5),
+	.out_mode = VOP_REG(RK3366_LIT_DSP_CTRL2, 0xf, 16),
+	.dsp_background = VOP_REG(RK3366_LIT_DSP_BG, 0x00ffffff, 0),
+	.cfg_done = VOP_REG(RK3366_LIT_REG_CFG_DONE, 0x1, 0),
+
+	.bcsh_en = VOP_REG(RK3366_LIT_BCSH_CTRL, 0x1, 0),
+	.bcsh_r2y_csc_mode = VOP_REG(RK3366_LIT_BCSH_CTRL, 0x1, 1),
+	.bcsh_out_mode = VOP_REG(RK3366_LIT_BCSH_CTRL, 0x3, 2),
+	.bcsh_y2r_csc_mode = VOP_REG(RK3366_LIT_BCSH_CTRL, 0x3, 4),
+	.bcsh_y2r_en = VOP_REG(RK3366_LIT_BCSH_CTRL, 0x1, 6),
+	.bcsh_r2y_en = VOP_REG(RK3366_LIT_BCSH_CTRL, 0x1, 7),
+	.bcsh_color_bar = VOP_REG(RK3366_LIT_BCSH_COL_BAR, 0xffffff, 0),
+	.bcsh_brightness = VOP_REG(RK3366_LIT_BCSH_BCS, 0xff, 0),
+	.bcsh_contrast = VOP_REG(RK3366_LIT_BCSH_BCS, 0x1ff, 8),
+	.bcsh_sat_con = VOP_REG(RK3366_LIT_BCSH_BCS, 0x3ff, 20),
+	.bcsh_sin_hue = VOP_REG(RK3366_LIT_BCSH_H, 0x1ff, 0),
+	.bcsh_cos_hue = VOP_REG(RK3366_LIT_BCSH_H, 0x1ff, 16),
+
+	.cabc_config_mode = VOP_REG(PX30_CABC_CTRL0, 0x3, 2),
+	.cabc_calc_pixel_num = VOP_REG(PX30_CABC_CTRL0, 0x7fffff, 4),
+	.cabc_handle_en = VOP_REG(PX30_CABC_CTRL0, 0x1, 1),
+	.cabc_en = VOP_REG(PX30_CABC_CTRL0, 0x1, 0),
+	.cabc_total_num = VOP_REG(PX30_CABC_CTRL1, 0x7fffff, 4),
+	.cabc_lut_en = VOP_REG(PX30_CABC_CTRL1, 0x1, 0),
+	.cabc_stage_up_mode = VOP_REG(PX30_CABC_CTRL2, 0x1, 19),
+	.cabc_stage_up = VOP_REG(PX30_CABC_CTRL2, 0x1ff, 8),
+	.cabc_stage_down = VOP_REG(PX30_CABC_CTRL2, 0xff, 0),
+	.cabc_global_dn = VOP_REG(PX30_CABC_CTRL3, 0xff, 0),
+	.cabc_global_dn_limit_en = VOP_REG(PX30_CABC_CTRL3, 0x1, 8),
+
+	.mcu_pix_total = VOP_REG(RK3366_LIT_MCU_CTRL, 0x3f, 0),
+	.mcu_cs_pst = VOP_REG(RK3366_LIT_MCU_CTRL, 0xf, 6),
+	.mcu_cs_pend = VOP_REG(RK3366_LIT_MCU_CTRL, 0x3f, 10),
+	.mcu_rw_pst = VOP_REG(RK3366_LIT_MCU_CTRL, 0xf, 16),
+	.mcu_rw_pend = VOP_REG(RK3366_LIT_MCU_CTRL, 0x3f, 20),
+	.mcu_clk_sel = VOP_REG(RK3366_LIT_MCU_CTRL, 0x1, 26),
+	.mcu_hold_mode = VOP_REG(RK3366_LIT_MCU_CTRL, 0x1, 27),
+	.mcu_frame_st = VOP_REG(RK3366_LIT_MCU_CTRL, 0x1, 28),
+	.mcu_rs = VOP_REG(RK3366_LIT_MCU_CTRL, 0x1, 29),
+	.mcu_bypass = VOP_REG(RK3366_LIT_MCU_CTRL, 0x1, 30),
+	.mcu_type = VOP_REG(RK3366_LIT_MCU_CTRL, 0x1, 31),
+	.mcu_rw_bypass_port = VOP_REG(RK3366_LIT_MCU_RW_BYPASS_PORT,
+				      0xffffffff, 0),
+};
+
+static const struct vop_line_flag rk3366_vop_lite_line_flag = {
+	.line_flag_num[0] = VOP_REG(RK3366_LIT_LINE_FLAG, 0xfff, 0),
+};
+
+static const struct vop_grf_ctrl px30_grf_ctrl = {
+	.grf_dclk_inv = VOP_REG(PX30_GRF_PD_VO_CON1, 0x1, 4),
+};
+
+const struct vop_data px30_vop_lit = {
+	.version = VOP_VERSION(2, 5),
+	.max_output = {1920, 1080},
+	.ctrl = &px30_ctrl_data,
+	.grf_ctrl = &px30_grf_ctrl,
+	.win = &rk3366_win1_data,
+	.line_flag = &rk3366_vop_lite_line_flag,
+	.reg_len = RK3366_LIT_FRC_LOWER01_0 * 4,
+};
+
+const struct vop_data px30_vop_big = {
+	.version = VOP_VERSION(2, 6),
+	.max_output = {1920, 1080},
+	.ctrl = &px30_ctrl_data,
+	.grf_ctrl = &px30_grf_ctrl,
+	.win = &rk3366_win1_data,
+	.line_flag = &rk3366_vop_lite_line_flag,
+	.reg_len = RK3366_LIT_FRC_LOWER01_0 * 4,
+};
+
+static const struct vop_ctrl rk3308_ctrl_data = {
+	.standby = VOP_REG(RK3366_LIT_SYS_CTRL2, 0x1, 1),
+	.axi_outstanding_max_num = VOP_REG(RK3366_LIT_SYS_CTRL1, 0x1f, 16),
+	.axi_max_outstanding_en = VOP_REG(RK3366_LIT_SYS_CTRL1, 0x1, 12),
+	.htotal_pw = VOP_REG(RK3366_LIT_DSP_HTOTAL_HS_END, 0x0fff0fff, 0),
+	.hact_st_end = VOP_REG(RK3366_LIT_DSP_HACT_ST_END, 0x0fff0fff, 0),
+	.vtotal_pw = VOP_REG(RK3366_LIT_DSP_VTOTAL_VS_END, 0x0fff0fff, 0),
+	.vact_st_end = VOP_REG(RK3366_LIT_DSP_VACT_ST_END, 0x0fff0fff, 0),
+	.vact_st_end_f1 = VOP_REG(RK3366_LIT_DSP_VACT_ST_END_F1, 0x0fff0fff, 0),
+	.vs_st_end_f1 = VOP_REG(RK3366_LIT_DSP_VS_ST_END_F1, 0x0fff0fff, 0),
+	.global_regdone_en = VOP_REG(RK3366_LIT_SYS_CTRL2, 0x1, 13),
+	.auto_gate_en = VOP_REG(RK3366_LIT_SYS_CTRL2, 0x1, 0),
+	.dsp_layer_sel = VOP_REG(RK3366_LIT_DSP_CTRL2, 0x1, 3),
+	.overlay_mode = VOP_REG(RK3366_LIT_DSP_CTRL2, 0x1, 4),
+	.dclk_ddr = VOP_REG(RK3366_LIT_DSP_CTRL0, 0x1, 14),
+	.rgb_en = VOP_REG(RK3366_LIT_DSP_CTRL0, 0x1, 0),
+	.rgb_pin_pol = VOP_REG(RK3366_LIT_DSP_CTRL0, 0x7, 2),
+	.rgb_dclk_pol = VOP_REG(RK3366_LIT_DSP_CTRL0, 0x1, 1),
+	.dither_up = VOP_REG(RK3366_LIT_DSP_CTRL2, 0x1, 2),
+	.dither_down = VOP_REG(RK3366_LIT_DSP_CTRL2, 0x7, 6),
+	.dsp_data_swap = VOP_REG(RK3366_LIT_DSP_CTRL2, 0x1f, 9),
+	.dsp_bg_swap = VOP_REG(RK3366_LIT_DSP_CTRL2, 0x1, 9),
+	.dsp_rb_swap = VOP_REG(RK3366_LIT_DSP_CTRL2, 0x1, 11),
+	.dsp_rg_swap = VOP_REG(RK3366_LIT_DSP_CTRL2, 0x1, 12),
+	.dsp_ccir656_avg = VOP_REG(RK3366_LIT_SYS_CTRL2, 0x1, 5),
+	.dsp_black = VOP_REG(RK3366_LIT_DSP_CTRL2, 0x1, 15),
+	.dsp_blank = VOP_REG(RK3366_LIT_DSP_CTRL2, 0x1, 14),
+	.dsp_outzero = VOP_REG(RK3366_LIT_SYS_CTRL2, 0x1, 3),
+	.dsp_lut_en = VOP_REG(RK3366_LIT_DSP_CTRL2, 0x1, 5),
+	.out_mode = VOP_REG(RK3366_LIT_DSP_CTRL2, 0xf, 16),
+	.dsp_background = VOP_REG(RK3366_LIT_DSP_BG, 0x00ffffff, 0),
+	.cfg_done = VOP_REG(RK3366_LIT_REG_CFG_DONE, 0x1, 0),
+
+	.bcsh_en = VOP_REG(RK3366_LIT_BCSH_CTRL, 0x1, 0),
+	.bcsh_r2y_csc_mode = VOP_REG(RK3366_LIT_BCSH_CTRL, 0x1, 1),
+	.bcsh_out_mode = VOP_REG(RK3366_LIT_BCSH_CTRL, 0x3, 2),
+	.bcsh_y2r_csc_mode = VOP_REG(RK3366_LIT_BCSH_CTRL, 0x3, 4),
+	.bcsh_y2r_en = VOP_REG(RK3366_LIT_BCSH_CTRL, 0x1, 6),
+	.bcsh_r2y_en = VOP_REG(RK3366_LIT_BCSH_CTRL, 0x1, 7),
+	.bcsh_color_bar = VOP_REG(RK3366_LIT_BCSH_COL_BAR, 0xffffff, 0),
+	.bcsh_brightness = VOP_REG(RK3366_LIT_BCSH_BCS, 0xff, 0),
+	.bcsh_contrast = VOP_REG(RK3366_LIT_BCSH_BCS, 0x1ff, 8),
+	.bcsh_sat_con = VOP_REG(RK3366_LIT_BCSH_BCS, 0x3ff, 20),
+	.bcsh_sin_hue = VOP_REG(RK3366_LIT_BCSH_H, 0x1ff, 0),
+	.bcsh_cos_hue = VOP_REG(RK3366_LIT_BCSH_H, 0x1ff, 16),
+
+	.mcu_pix_total = VOP_REG(RK3366_LIT_MCU_CTRL, 0x3f, 0),
+	.mcu_cs_pst = VOP_REG(RK3366_LIT_MCU_CTRL, 0xf, 6),
+	.mcu_cs_pend = VOP_REG(RK3366_LIT_MCU_CTRL, 0x3f, 10),
+	.mcu_rw_pst = VOP_REG(RK3366_LIT_MCU_CTRL, 0xf, 16),
+	.mcu_rw_pend = VOP_REG(RK3366_LIT_MCU_CTRL, 0x3f, 20),
+	.mcu_clk_sel = VOP_REG(RK3366_LIT_MCU_CTRL, 0x1, 26),
+	.mcu_hold_mode = VOP_REG(RK3366_LIT_MCU_CTRL, 0x1, 27),
+	.mcu_frame_st = VOP_REG(RK3366_LIT_MCU_CTRL, 0x1, 28),
+	.mcu_rs = VOP_REG(RK3366_LIT_MCU_CTRL, 0x1, 29),
+	.mcu_bypass = VOP_REG(RK3366_LIT_MCU_CTRL, 0x1, 30),
+	.mcu_type = VOP_REG(RK3366_LIT_MCU_CTRL, 0x1, 31),
+	.mcu_rw_bypass_port = VOP_REG(RK3366_LIT_MCU_RW_BYPASS_PORT,
+				      0xffffffff, 0),
+};
+
+const struct vop_data rk3308_vop = {
+	.version = VOP_VERSION(2, 7),
+	.max_output = {1920, 1080},
+	.ctrl = &rk3308_ctrl_data,
+	.win = &rk3366_win0_data,
+	.line_flag = &rk3366_vop_lite_line_flag,
+	.reg_len = RK3366_LIT_FRC_LOWER01_0 * 4,
+};
+
+static const struct vop_grf_ctrl rk1808_grf_ctrl = {
+	.grf_dclk_inv = VOP_REG(RK1808_GRF_PD_VO_CON1, 0x1, 4),
+};
+
+const struct vop_data rk1808_vop = {
+	.version = VOP_VERSION(2, 8),
+	.max_output = {1920, 1080},
+	.ctrl = &px30_ctrl_data,
+	.grf_ctrl = &rk1808_grf_ctrl,
+	.win = &rk3366_win1_data,
+	.line_flag = &rk3366_vop_lite_line_flag,
+	.reg_len = RK3366_LIT_FRC_LOWER01_0 * 4,
+};
+
+const struct vop_data rv1108_vop = {
+	.version = VOP_VERSION(2, 4),
+	.max_output = {1920, 1080},
+	.ctrl = &rk3308_ctrl_data,
+	.win = &rk3366_win0_data,
+	.line_flag = &rk3366_vop_lite_line_flag,
+	.reg_len = RK3366_LIT_FRC_LOWER01_0 * 4,
+};
+
+static const struct vop_win rv1126_win2_data = {
+	.gate = VOP_REG(RV1126_WIN2_CTRL0, 0x1, 0),
+	.enable = VOP_REG(RV1126_WIN2_CTRL0, 0x1, 4),
+	.format = VOP_REG(RV1126_WIN2_CTRL0, 0x3, 5),
+	.rb_swap = VOP_REG(RV1126_WIN2_CTRL0, 0x1, 20),
+	.dsp_info = VOP_REG(RV1126_WIN2_DSP_INFO0, 0x0fff0fff, 0),
+	.dsp_st = VOP_REG(RV1126_WIN2_DSP_ST0, 0x1fff1fff, 0),
+	.yrgb_mst = VOP_REG(RV1126_WIN2_MST0, 0xffffffff, 0),
+	.yrgb_vir = VOP_REG(RV1126_WIN2_VIR0_1, 0x1fff, 0),
+};
+
+static const struct vop_ctrl rv1126_ctrl_data = {
+	.standby = VOP_REG(RK3366_LIT_SYS_CTRL2, 0x1, 1),
+	.axi_outstanding_max_num = VOP_REG(RK3366_LIT_SYS_CTRL1, 0x1f, 16),
+	.axi_max_outstanding_en = VOP_REG(RK3366_LIT_SYS_CTRL1, 0x1, 12),
+	.htotal_pw = VOP_REG(RK3366_LIT_DSP_HTOTAL_HS_END, 0x0fff0fff, 0),
+	.hact_st_end = VOP_REG(RK3366_LIT_DSP_HACT_ST_END, 0x0fff0fff, 0),
+	.vtotal_pw = VOP_REG(RK3366_LIT_DSP_VTOTAL_VS_END, 0x0fff0fff, 0),
+	.vact_st_end = VOP_REG(RK3366_LIT_DSP_VACT_ST_END, 0x0fff0fff, 0),
+	.vact_st_end_f1 = VOP_REG(RK3366_LIT_DSP_VACT_ST_END_F1, 0x0fff0fff, 0),
+	.vs_st_end_f1 = VOP_REG(RK3366_LIT_DSP_VS_ST_END_F1, 0x0fff0fff, 0),
+	.dsp_interlace = VOP_REG(RK3366_LIT_DSP_CTRL2, 0x1, 0),
+	.global_regdone_en = VOP_REG(RK3366_LIT_SYS_CTRL2, 0x1, 13),
+	.auto_gate_en = VOP_REG(RK3366_LIT_SYS_CTRL2, 0x1, 0),
+	.dsp_layer_sel = VOP_REG(RK3366_LIT_DSP_CTRL2, 0xff, 22),
+	.overlay_mode = VOP_REG(RK3366_LIT_DSP_CTRL2, 0x1, 4),
+	.core_dclk_div = VOP_REG(RK3366_LIT_DSP_CTRL0, 0x1, 13),
+	.dclk_ddr = VOP_REG(RK3366_LIT_DSP_CTRL0, 0x1, 14),
+	.rgb_en = VOP_REG(RK3366_LIT_DSP_CTRL0, 0x1, 0),
+	.rgb_pin_pol = VOP_REG(RK3366_LIT_DSP_CTRL0, 0x7, 2),
+	.hdmi_en = VOP_REG(RK3366_LIT_DSP_CTRL0, 0x1, 8),
+	.hdmi_pin_pol = VOP_REG(RK3366_LIT_DSP_CTRL0, 0x7, 10),
+	.lvds_en = VOP_REG(RK3366_LIT_DSP_CTRL0, 0x1, 16),
+	.lvds_pin_pol = VOP_REG(RK3366_LIT_DSP_CTRL0, 0x7, 18),
+	.mipi_en = VOP_REG(RK3366_LIT_DSP_CTRL0, 0x1, 24),
+	.mipi_pin_pol = VOP_REG(RK3366_LIT_DSP_CTRL0, 0x7, 26),
+	.mipi_dclk_pol = VOP_REG(RK3366_LIT_DSP_CTRL0, 0x1, 25),
+	.lvds_dclk_pol = VOP_REG(RK3366_LIT_DSP_CTRL0, 0x1, 17),
+	.hdmi_dclk_pol = VOP_REG(RK3366_LIT_DSP_CTRL0, 0x1, 9),
+	.rgb_dclk_pol = VOP_REG(RK3366_LIT_DSP_CTRL0, 0x1, 1),
+	.dither_down = VOP_REG(RK3366_LIT_DSP_CTRL2, 0x1, 8),
+	.dither_up = VOP_REG(RK3366_LIT_DSP_CTRL2, 0x1, 2),
+	.dsp_data_swap = VOP_REG(RK3366_LIT_DSP_CTRL2, 0x1f, 9),
+	.dsp_bg_swap = VOP_REG(RK3366_LIT_DSP_CTRL2, 0x1, 9),
+	.dsp_rb_swap = VOP_REG(RK3366_LIT_DSP_CTRL2, 0x1, 11),
+	.dsp_rg_swap = VOP_REG(RK3366_LIT_DSP_CTRL2, 0x1, 12),
+	.dsp_ccir656_avg = VOP_REG(RK3366_LIT_SYS_CTRL2, 0x1, 5),
+	.dsp_black = VOP_REG(RK3366_LIT_DSP_CTRL2, 0x1, 15),
+	.dsp_blank = VOP_REG(RK3366_LIT_DSP_CTRL2, 0x1, 14),
+	.dsp_outzero = VOP_REG(RK3366_LIT_SYS_CTRL2, 0x1, 3),
+	.dsp_lut_en = VOP_REG(RK3366_LIT_DSP_CTRL2, 0x1, 5),
+	.out_mode = VOP_REG(RK3366_LIT_DSP_CTRL2, 0xf, 16),
+	.dsp_background = VOP_REG(RK3366_LIT_DSP_BG, 0x00ffffff, 0),
+	.cfg_done = VOP_REG(RK3366_LIT_REG_CFG_DONE, 0x1, 0),
+
+	.bcsh_en = VOP_REG(RK3366_LIT_BCSH_CTRL, 0x1, 0),
+	.bcsh_r2y_csc_mode = VOP_REG(RK3366_LIT_BCSH_CTRL, 0x1, 1),
+	.bcsh_out_mode = VOP_REG(RK3366_LIT_BCSH_CTRL, 0x3, 2),
+	.bcsh_y2r_csc_mode = VOP_REG(RK3366_LIT_BCSH_CTRL, 0x3, 4),
+	.bcsh_y2r_en = VOP_REG(RK3366_LIT_BCSH_CTRL, 0x1, 6),
+	.bcsh_r2y_en = VOP_REG(RK3366_LIT_BCSH_CTRL, 0x1, 7),
+	.bcsh_color_bar = VOP_REG(RK3366_LIT_BCSH_COL_BAR, 0xffffff, 0),
+	.bcsh_brightness = VOP_REG(RK3366_LIT_BCSH_BCS, 0xff, 0),
+	.bcsh_contrast = VOP_REG(RK3366_LIT_BCSH_BCS, 0x1ff, 8),
+	.bcsh_sat_con = VOP_REG(RK3366_LIT_BCSH_BCS, 0x3ff, 20),
+	.bcsh_sin_hue = VOP_REG(RK3366_LIT_BCSH_H, 0x1ff, 0),
+	.bcsh_cos_hue = VOP_REG(RK3366_LIT_BCSH_H, 0x1ff, 16),
+
+	.mcu_pix_total = VOP_REG(RK3366_LIT_MCU_CTRL, 0x3f, 0),
+	.mcu_cs_pst = VOP_REG(RK3366_LIT_MCU_CTRL, 0xf, 6),
+	.mcu_cs_pend = VOP_REG(RK3366_LIT_MCU_CTRL, 0x3f, 10),
+	.mcu_rw_pst = VOP_REG(RK3366_LIT_MCU_CTRL, 0xf, 16),
+	.mcu_rw_pend = VOP_REG(RK3366_LIT_MCU_CTRL, 0x3f, 20),
+	.mcu_clk_sel = VOP_REG(RK3366_LIT_MCU_CTRL, 0x1, 26),
+	.mcu_hold_mode = VOP_REG(RK3366_LIT_MCU_CTRL, 0x1, 27),
+	.mcu_frame_st = VOP_REG(RK3366_LIT_MCU_CTRL, 0x1, 28),
+	.mcu_rs = VOP_REG(RK3366_LIT_MCU_CTRL, 0x1, 29),
+	.mcu_bypass = VOP_REG(RK3366_LIT_MCU_CTRL, 0x1, 30),
+	.mcu_type = VOP_REG(RK3366_LIT_MCU_CTRL, 0x1, 31),
+	.mcu_rw_bypass_port = VOP_REG(RK3366_LIT_MCU_RW_BYPASS_PORT,
+				      0xffffffff, 0),
+};
+
+static const struct vop_grf_ctrl rv1126_grf_ctrl = {
+	.grf_dclk_inv = VOP_REG(0x1026c, 0x1, 2),
+};
+
+const struct vop_data rv1126_vop = {
+	.version = VOP_VERSION(2, 7),
+	.max_output = {1920, 1080},
+	.ctrl = &rv1126_ctrl_data,
+	.grf_ctrl = &rv1126_grf_ctrl,
+	.win = &rv1126_win2_data,
+	.line_flag = &rk3366_vop_lite_line_flag,
+	.reg_len = RK3366_LIT_FLAG_REG * 4,
+};
+
+static const struct vop_ctrl rv1106_ctrl_data = {
+	.standby = VOP_REG(RK3366_LIT_SYS_CTRL2, 0x1, 1),
+	.axi_outstanding_max_num = VOP_REG(RK3366_LIT_SYS_CTRL1, 0x1f, 16),
+	.axi_max_outstanding_en = VOP_REG(RK3366_LIT_SYS_CTRL1, 0x1, 12),
+	.htotal_pw = VOP_REG(RK3366_LIT_DSP_HTOTAL_HS_END, 0x0fff0fff, 0),
+	.hact_st_end = VOP_REG(RK3366_LIT_DSP_HACT_ST_END, 0x0fff0fff, 0),
+	.vtotal_pw = VOP_REG(RK3366_LIT_DSP_VTOTAL_VS_END, 0x0fff0fff, 0),
+	.vact_st_end = VOP_REG(RK3366_LIT_DSP_VACT_ST_END, 0x0fff0fff, 0),
+	.vact_st_end_f1 = VOP_REG(RK3366_LIT_DSP_VACT_ST_END_F1, 0x0fff0fff, 0),
+	.vs_st_end_f1 = VOP_REG(RK3366_LIT_DSP_VS_ST_END_F1, 0x0fff0fff, 0),
+	.dsp_interlace = VOP_REG(RK3366_LIT_DSP_CTRL2, 0x1, 0),
+	.auto_gate_en = VOP_REG(RK3366_LIT_SYS_CTRL2, 0x1, 0),
+	.overlay_mode = VOP_REG(RK3366_LIT_DSP_CTRL2, 0x1, 4),
+	.core_dclk_div = VOP_REG(RK3366_LIT_DSP_CTRL0, 0x1, 13),
+	.dclk_ddr = VOP_REG(RK3366_LIT_DSP_CTRL0, 0x1, 14),
+	.rgb_en = VOP_REG(RK3366_LIT_DSP_CTRL0, 0x1, 0),
+	.rgb_dclk_pol = VOP_REG(RK3366_LIT_DSP_CTRL0, 0x1, 1),
+	.rgb_pin_pol = VOP_REG(RK3366_LIT_DSP_CTRL0, 0x7, 2),
+	.dither_down = VOP_REG(RK3366_LIT_DSP_CTRL2, 0x1, 8),
+	.dither_up = VOP_REG(RK3366_LIT_DSP_CTRL2, 0x1, 2),
+	.dsp_data_swap = VOP_REG(RK3366_LIT_DSP_CTRL2, 0x1f, 9),
+	.dsp_bg_swap = VOP_REG(RK3366_LIT_DSP_CTRL2, 0x1, 9),
+	.dsp_rb_swap = VOP_REG(RK3366_LIT_DSP_CTRL2, 0x1, 11),
+	.dsp_rg_swap = VOP_REG(RK3366_LIT_DSP_CTRL2, 0x1, 12),
+	.dsp_black = VOP_REG(RK3366_LIT_DSP_CTRL2, 0x1, 15),
+	.dsp_blank = VOP_REG(RK3366_LIT_DSP_CTRL2, 0x1, 14),
+	.dsp_outzero = VOP_REG(RK3366_LIT_SYS_CTRL2, 0x1, 3),
+	.out_mode = VOP_REG(RK3366_LIT_DSP_CTRL2, 0xf, 16),
+	.dsp_background = VOP_REG(RK3366_LIT_DSP_BG, 0x00ffffff, 0),
+	.cfg_done = VOP_REG(RK3366_LIT_REG_CFG_DONE, 0x1, 0),
+
+	.bcsh_en = VOP_REG(RK3366_LIT_BCSH_CTRL, 0x1, 0),
+	.bcsh_r2y_csc_mode = VOP_REG(RK3366_LIT_BCSH_CTRL, 0x1, 1),
+	.bcsh_out_mode = VOP_REG(RK3366_LIT_BCSH_CTRL, 0x3, 2),
+	.bcsh_y2r_csc_mode = VOP_REG(RK3366_LIT_BCSH_CTRL, 0x3, 4),
+	.bcsh_y2r_en = VOP_REG(RK3366_LIT_BCSH_CTRL, 0x1, 6),
+	.bcsh_r2y_en = VOP_REG(RK3366_LIT_BCSH_CTRL, 0x1, 7),
+	.bcsh_color_bar = VOP_REG(RK3366_LIT_BCSH_COL_BAR, 0xffffff, 0),
+	.bcsh_brightness = VOP_REG(RK3366_LIT_BCSH_BCS, 0xff, 0),
+	.bcsh_contrast = VOP_REG(RK3366_LIT_BCSH_BCS, 0x1ff, 8),
+	.bcsh_sat_con = VOP_REG(RK3366_LIT_BCSH_BCS, 0x3ff, 20),
+	.bcsh_sin_hue = VOP_REG(RK3366_LIT_BCSH_H, 0x1ff, 0),
+	.bcsh_cos_hue = VOP_REG(RK3366_LIT_BCSH_H, 0x1ff, 16),
+
+	.mcu_pix_total = VOP_REG(RK3366_LIT_MCU_CTRL, 0x3f, 0),
+	.mcu_cs_pst = VOP_REG(RK3366_LIT_MCU_CTRL, 0xf, 6),
+	.mcu_cs_pend = VOP_REG(RK3366_LIT_MCU_CTRL, 0x3f, 10),
+	.mcu_rw_pst = VOP_REG(RK3366_LIT_MCU_CTRL, 0xf, 16),
+	.mcu_rw_pend = VOP_REG(RK3366_LIT_MCU_CTRL, 0x3f, 20),
+	.mcu_clk_sel = VOP_REG(RK3366_LIT_MCU_CTRL, 0x1, 26),
+	.mcu_hold_mode = VOP_REG(RK3366_LIT_MCU_CTRL, 0x1, 27),
+	.mcu_frame_st = VOP_REG(RK3366_LIT_MCU_CTRL, 0x1, 28),
+	.mcu_rs = VOP_REG(RK3366_LIT_MCU_CTRL, 0x1, 29),
+	.mcu_bypass = VOP_REG(RK3366_LIT_MCU_CTRL, 0x1, 30),
+	.mcu_type = VOP_REG(RK3366_LIT_MCU_CTRL, 0x1, 31),
+	.mcu_rw_bypass_port = VOP_REG(RK3366_LIT_MCU_RW_BYPASS_PORT,
+				      0xffffffff, 0),
+	.bt1120_yc_swap = VOP_REG(RK3366_LIT_DSP_CTRL0, 0x1, 30),
+	.bt1120_en = VOP_REG(RK3366_LIT_DSP_CTRL0, 0x1, 31),
+	.bt656_en = VOP_REG(RK3366_LIT_DSP_CTRL0, 0x1, 6),
+};
+
+static const struct vop_grf_ctrl rv1106_grf_ctrl = {
+	.grf_dclk_inv = VOP_REG(0x1000c, 0x1, 2),
+};
+
+static const struct vop_win rv1106_win1_data = {
+	.enable = VOP_REG(RK3366_LIT_WIN1_CTRL0, 0x1, 0),
+	.format = VOP_REG(RK3366_LIT_WIN1_CTRL0, 0x7, 4),
+	.interlace_read = VOP_REG(RK3366_LIT_WIN1_CTRL0, 0x1, 8),
+	.rb_swap = VOP_REG(RK3366_LIT_WIN1_CTRL0, 0x1, 12),
+	.dsp_info = VOP_REG(RK3366_LIT_WIN1_DSP_INFO, 0x0fff0fff, 0),
+	.dsp_st = VOP_REG(RK3366_LIT_WIN1_DSP_ST, 0xffffffff, 0),
+	.yrgb_mst = VOP_REG(RK3366_LIT_WIN1_MST, 0xffffffff, 0),
+	.yrgb_vir = VOP_REG(RK3366_LIT_WIN1_VIR, 0x1fff, 0),
+
+	.alpha_mode = VOP_REG(RK3366_LIT_WIN1_ALPHA_CTRL, 0x1, 1),
+	.alpha_en = VOP_REG(RK3366_LIT_WIN1_ALPHA_CTRL, 0x1, 0),
+};
+
+static const struct vop_line_flag rv1106_vop_lite_line_flag = {
+	.line_flag_num[0] = VOP_REG(RK3366_LIT_LINE_FLAG, 0xfff, 0),
+	.line_flag_num[1] = VOP_REG(RK3366_LIT_LINE_FLAG, 0xfff, 16),
+};
+
+const struct vop_data rv1106_vop = {
+	.version = VOP_VERSION(2, 12),
+	.max_output = {1280, 1280},
+	.ctrl = &rv1106_ctrl_data,
+	.grf_ctrl = &rv1106_grf_ctrl,
+	.win = &rv1106_win1_data,
+	.line_flag = &rv1106_vop_lite_line_flag,
+	.reg_len = RK3366_LIT_FLAG_REG * 4,
+};
diff --git a/drivers/video/drm/rockchip_vop_reg.h b/drivers/video/drm/rockchip_vop_reg.h
new file mode 100644
index 0000000000..d0ce98041c
--- /dev/null
+++ b/drivers/video/drm/rockchip_vop_reg.h
@@ -0,0 +1,983 @@
+/*
+ * (C) Copyright 2008-2017 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _ROCKCHIP_VOP_REG_H
+#define _ROCKCHIP_VOP_REG_H
+
+/* rk3288 register definition */
+#define RK3288_REG_CFG_DONE			0x0000
+#define RK3288_VERSION_INFO			0x0004
+#define RK3288_SYS_CTRL				0x0008
+#define RK3288_SYS_CTRL1			0x000c
+#define RK3288_DSP_CTRL0			0x0010
+#define RK3288_DSP_CTRL1			0x0014
+#define RK3288_DSP_BG				0x0018
+#define RK3288_MCU_CTRL				0x001c
+#define RK3288_INTR_CTRL0			0x0020
+#define RK3288_INTR_CTRL1			0x0024
+#define RK3288_WIN0_CTRL0			0x0030
+#define RK3288_WIN0_CTRL1			0x0034
+#define RK3288_WIN0_COLOR_KEY			0x0038
+#define RK3288_WIN0_VIR				0x003c
+#define RK3288_WIN0_YRGB_MST			0x0040
+#define RK3288_WIN0_CBR_MST			0x0044
+#define RK3288_WIN0_ACT_INFO			0x0048
+#define RK3288_WIN0_DSP_INFO			0x004c
+#define RK3288_WIN0_DSP_ST			0x0050
+#define RK3288_WIN0_SCL_FACTOR_YRGB		0x0054
+#define RK3288_WIN0_SCL_FACTOR_CBR		0x0058
+#define RK3288_WIN0_SCL_OFFSET			0x005c
+#define RK3288_WIN0_SRC_ALPHA_CTRL		0x0060
+#define RK3288_WIN0_DST_ALPHA_CTRL		0x0064
+#define RK3288_WIN0_FADING_CTRL			0x0068
+
+/* win1 register */
+#define RK3288_WIN1_CTRL0			0x0070
+#define RK3288_WIN1_CTRL1			0x0074
+#define RK3288_WIN1_COLOR_KEY			0x0078
+#define RK3288_WIN1_VIR				0x007c
+#define RK3288_WIN1_YRGB_MST			0x0080
+#define RK3288_WIN1_CBR_MST			0x0084
+#define RK3288_WIN1_ACT_INFO			0x0088
+#define RK3288_WIN1_DSP_INFO			0x008c
+#define RK3288_WIN1_DSP_ST			0x0090
+#define RK3288_WIN1_SCL_FACTOR_YRGB		0x0094
+#define RK3288_WIN1_SCL_FACTOR_CBR		0x0098
+#define RK3288_WIN1_SCL_OFFSET			0x009c
+#define RK3288_WIN1_SRC_ALPHA_CTRL		0x00a0
+#define RK3288_WIN1_DST_ALPHA_CTRL		0x00a4
+#define RK3288_WIN1_FADING_CTRL			0x00a8
+/* win2 register */
+#define RK3288_WIN2_CTRL0			0x00b0
+#define RK3288_WIN2_CTRL1			0x00b4
+#define RK3288_WIN2_VIR0_1			0x00b8
+#define RK3288_WIN2_VIR2_3			0x00bc
+#define RK3288_WIN2_MST0			0x00c0
+#define RK3288_WIN2_DSP_INFO0			0x00c4
+#define RK3288_WIN2_DSP_ST0			0x00c8
+#define RK3288_WIN2_COLOR_KEY			0x00cc
+#define RK3288_WIN2_MST1			0x00d0
+#define RK3288_WIN2_DSP_INFO1			0x00d4
+#define RK3288_WIN2_DSP_ST1			0x00d8
+#define RK3288_WIN2_SRC_ALPHA_CTRL		0x00dc
+#define RK3288_WIN2_MST2			0x00e0
+#define RK3288_WIN2_DSP_INFO2			0x00e4
+#define RK3288_WIN2_DSP_ST2			0x00e8
+#define RK3288_WIN2_DST_ALPHA_CTRL		0x00ec
+#define RK3288_WIN2_MST3			0x00f0
+#define RK3288_WIN2_DSP_INFO3			0x00f4
+#define RK3288_WIN2_DSP_ST3			0x00f8
+#define RK3288_WIN2_FADING_CTRL			0x00fc
+/* win3 register */
+#define RK3288_WIN3_CTRL0			0x0100
+#define RK3288_WIN3_CTRL1			0x0104
+#define RK3288_WIN3_VIR0_1			0x0108
+#define RK3288_WIN3_VIR2_3			0x010c
+#define RK3288_WIN3_MST0			0x0110
+#define RK3288_WIN3_DSP_INFO0			0x0114
+#define RK3288_WIN3_DSP_ST0			0x0118
+#define RK3288_WIN3_COLOR_KEY			0x011c
+#define RK3288_WIN3_MST1			0x0120
+#define RK3288_WIN3_DSP_INFO1			0x0124
+#define RK3288_WIN3_DSP_ST1			0x0128
+#define RK3288_WIN3_SRC_ALPHA_CTRL		0x012c
+#define RK3288_WIN3_MST2			0x0130
+#define RK3288_WIN3_DSP_INFO2			0x0134
+#define RK3288_WIN3_DSP_ST2			0x0138
+#define RK3288_WIN3_DST_ALPHA_CTRL		0x013c
+#define RK3288_WIN3_MST3			0x0140
+#define RK3288_WIN3_DSP_INFO3			0x0144
+#define RK3288_WIN3_DSP_ST3			0x0148
+#define RK3288_WIN3_FADING_CTRL			0x014c
+/* hwc register */
+#define RK3288_HWC_CTRL0			0x0150
+#define RK3288_HWC_CTRL1			0x0154
+#define RK3288_HWC_MST				0x0158
+#define RK3288_HWC_DSP_ST			0x015c
+#define RK3288_HWC_SRC_ALPHA_CTRL		0x0160
+#define RK3288_HWC_DST_ALPHA_CTRL		0x0164
+#define RK3288_HWC_FADING_CTRL			0x0168
+/* post process register */
+#define RK3288_POST_DSP_HACT_INFO		0x0170
+#define RK3288_POST_DSP_VACT_INFO		0x0174
+#define RK3288_POST_SCL_FACTOR_YRGB		0x0178
+#define RK3288_POST_SCL_CTRL			0x0180
+#define RK3288_POST_DSP_VACT_INFO_F1		0x0184
+#define RK3288_DSP_HTOTAL_HS_END		0x0188
+#define RK3288_DSP_HACT_ST_END			0x018c
+#define RK3288_DSP_VTOTAL_VS_END		0x0190
+#define RK3288_DSP_VACT_ST_END			0x0194
+#define RK3288_DSP_VS_ST_END_F1			0x0198
+#define RK3288_DSP_VACT_ST_END_F1		0x019c
+
+#define RK3288_BCSH_COLOR_BAR			0x01b0
+#define RK3288_BCSH_BCS				0x01b4
+#define RK3288_BCSH_H				0x01b8
+#define RK3288_GRF_SOC_CON15			0x03a4
+
+#define RK3288_MCU_BYPASS_WPORT			0x2200
+/* register definition end */
+
+/* rk3368 register definition */
+#define RK3368_REG_CFG_DONE			0x0000
+#define RK3368_VERSION_INFO			0x0004
+#define RK3368_SYS_CTRL				0x0008
+#define RK3368_SYS_CTRL1			0x000c
+#define RK3368_DSP_CTRL0			0x0010
+#define RK3368_DSP_CTRL1			0x0014
+#define RK3368_DSP_BG				0x0018
+#define RK3368_MCU_CTRL				0x001c
+#define RK3368_LINE_FLAG			0x0020
+#define RK3368_INTR_EN				0x0024
+#define RK3368_INTR_CLEAR			0x0028
+#define RK3368_INTR_STATUS			0x002c
+#define RK3368_WIN0_CTRL0			0x0030
+#define RK3368_WIN0_CTRL1			0x0034
+#define RK3368_WIN0_COLOR_KEY			0x0038
+#define RK3368_WIN0_VIR				0x003c
+#define RK3368_WIN0_YRGB_MST			0x0040
+#define RK3368_WIN0_CBR_MST			0x0044
+#define RK3368_WIN0_ACT_INFO			0x0048
+#define RK3368_WIN0_DSP_INFO			0x004c
+#define RK3368_WIN0_DSP_ST			0x0050
+#define RK3368_WIN0_SCL_FACTOR_YRGB		0x0054
+#define RK3368_WIN0_SCL_FACTOR_CBR		0x0058
+#define RK3368_WIN0_SCL_OFFSET			0x005c
+#define RK3368_WIN0_SRC_ALPHA_CTRL		0x0060
+#define RK3368_WIN0_DST_ALPHA_CTRL		0x0064
+#define RK3368_WIN0_FADING_CTRL			0x0068
+#define RK3368_WIN0_CTRL2			0x006c
+#define RK3368_WIN1_CTRL0			0x0070
+#define RK3368_WIN1_CTRL1			0x0074
+#define RK3368_WIN1_COLOR_KEY			0x0078
+#define RK3368_WIN1_VIR				0x007c
+#define RK3368_WIN1_YRGB_MST			0x0080
+#define RK3368_WIN1_CBR_MST			0x0084
+#define RK3368_WIN1_ACT_INFO			0x0088
+#define RK3368_WIN1_DSP_INFO			0x008c
+#define RK3368_WIN1_DSP_ST			0x0090
+#define RK3368_WIN1_SCL_FACTOR_YRGB		0x0094
+#define RK3368_WIN1_SCL_FACTOR_CBR		0x0098
+#define RK3368_WIN1_SCL_OFFSET			0x009c
+#define RK3368_WIN1_SRC_ALPHA_CTRL		0x00a0
+#define RK3368_WIN1_DST_ALPHA_CTRL		0x00a4
+#define RK3368_WIN1_FADING_CTRL			0x00a8
+#define RK3368_WIN1_CTRL2			0x00ac
+#define RK3368_WIN2_CTRL0			0x00b0
+#define RK3368_WIN2_CTRL1			0x00b4
+#define RK3368_WIN2_VIR0_1			0x00b8
+#define RK3368_WIN2_VIR2_3			0x00bc
+#define RK3368_WIN2_MST0			0x00c0
+#define RK3368_WIN2_DSP_INFO0			0x00c4
+#define RK3368_WIN2_DSP_ST0			0x00c8
+#define RK3368_WIN2_COLOR_KEY			0x00cc
+#define RK3368_WIN2_MST1			0x00d0
+#define RK3368_WIN2_DSP_INFO1			0x00d4
+#define RK3368_WIN2_DSP_ST1			0x00d8
+#define RK3368_WIN2_SRC_ALPHA_CTRL		0x00dc
+#define RK3368_WIN2_MST2			0x00e0
+#define RK3368_WIN2_DSP_INFO2			0x00e4
+#define RK3368_WIN2_DSP_ST2			0x00e8
+#define RK3368_WIN2_DST_ALPHA_CTRL		0x00ec
+#define RK3368_WIN2_MST3			0x00f0
+#define RK3368_WIN2_DSP_INFO3			0x00f4
+#define RK3368_WIN2_DSP_ST3			0x00f8
+#define RK3368_WIN2_FADING_CTRL			0x00fc
+#define RK3368_WIN3_CTRL0			0x0100
+#define RK3368_WIN3_CTRL1			0x0104
+#define RK3368_WIN3_VIR0_1			0x0108
+#define RK3368_WIN3_VIR2_3			0x010c
+#define RK3368_WIN3_MST0			0x0110
+#define RK3368_WIN3_DSP_INFO0			0x0114
+#define RK3368_WIN3_DSP_ST0			0x0118
+#define RK3368_WIN3_COLOR_KEY			0x011c
+#define RK3368_WIN3_MST1			0x0120
+#define RK3368_WIN3_DSP_INFO1			0x0124
+#define RK3368_WIN3_DSP_ST1			0x0128
+#define RK3368_WIN3_SRC_ALPHA_CTRL		0x012c
+#define RK3368_WIN3_MST2			0x0130
+#define RK3368_WIN3_DSP_INFO2			0x0134
+#define RK3368_WIN3_DSP_ST2			0x0138
+#define RK3368_WIN3_DST_ALPHA_CTRL		0x013c
+#define RK3368_WIN3_MST3			0x0140
+#define RK3368_WIN3_DSP_INFO3			0x0144
+#define RK3368_WIN3_DSP_ST3			0x0148
+#define RK3368_WIN3_FADING_CTRL			0x014c
+#define RK3368_HWC_CTRL0			0x0150
+#define RK3368_HWC_CTRL1			0x0154
+#define RK3368_HWC_MST				0x0158
+#define RK3368_HWC_DSP_ST			0x015c
+#define RK3368_HWC_SRC_ALPHA_CTRL		0x0160
+#define RK3368_HWC_DST_ALPHA_CTRL		0x0164
+#define RK3368_HWC_FADING_CTRL			0x0168
+#define RK3368_HWC_RESERVED1			0x016c
+#define RK3368_POST_DSP_HACT_INFO		0x0170
+#define RK3368_POST_DSP_VACT_INFO		0x0174
+#define RK3368_POST_SCL_FACTOR_YRGB		0x0178
+#define RK3368_POST_RESERVED			0x017c
+#define RK3368_POST_SCL_CTRL			0x0180
+#define RK3368_POST_DSP_VACT_INFO_F1		0x0184
+#define RK3368_DSP_HTOTAL_HS_END		0x0188
+#define RK3368_DSP_HACT_ST_END			0x018c
+#define RK3368_DSP_VTOTAL_VS_END		0x0190
+#define RK3368_DSP_VACT_ST_END			0x0194
+#define RK3368_DSP_VS_ST_END_F1			0x0198
+#define RK3368_DSP_VACT_ST_END_F1		0x019c
+#define RK3368_PWM_CTRL				0x01a0
+#define RK3368_PWM_PERIOD_HPR			0x01a4
+#define RK3368_PWM_DUTY_LPR			0x01a8
+#define RK3368_PWM_CNT				0x01ac
+#define RK3368_BCSH_COLOR_BAR			0x01b0
+#define RK3368_BCSH_BCS				0x01b4
+#define RK3368_BCSH_H				0x01b8
+#define RK3368_BCSH_CTRL			0x01bc
+#define RK3368_CABC_CTRL0			0x01c0
+#define RK3368_CABC_CTRL1			0x01c4
+#define RK3368_CABC_CTRL2			0x01c8
+#define RK3368_CABC_CTRL3			0x01cc
+#define RK3368_CABC_GAUSS_LINE0_0		0x01d0
+#define RK3368_CABC_GAUSS_LINE0_1		0x01d4
+#define RK3368_CABC_GAUSS_LINE1_0		0x01d8
+#define RK3368_CABC_GAUSS_LINE1_1		0x01dc
+#define RK3368_CABC_GAUSS_LINE2_0		0x01e0
+#define RK3368_CABC_GAUSS_LINE2_1		0x01e4
+#define RK3368_FRC_LOWER01_0			0x01e8
+#define RK3368_FRC_LOWER01_1			0x01ec
+#define RK3368_FRC_LOWER10_0			0x01f0
+#define RK3368_FRC_LOWER10_1			0x01f4
+#define RK3368_FRC_LOWER11_0			0x01f8
+#define RK3368_FRC_LOWER11_1			0x01fc
+#define RK3368_IFBDC_CTRL			0x0200
+#define RK3368_IFBDC_TILES_NUM			0x0204
+#define RK3368_IFBDC_FRAME_RST_CYCLE		0x0208
+#define RK3368_IFBDC_BASE_ADDR			0x020c
+#define RK3368_IFBDC_MB_SIZE			0x0210
+#define RK3368_IFBDC_CMP_INDEX_INIT		0x0214
+#define RK3368_IFBDC_VIR			0x0220
+#define RK3368_IFBDC_DEBUG0			0x0230
+#define RK3368_IFBDC_DEBUG1			0x0234
+#define RK3368_LATENCY_CTRL0			0x0250
+#define RK3368_RD_MAX_LATENCY_NUM0		0x0254
+#define RK3368_RD_LATENCY_THR_NUM0		0x0258
+#define RK3368_RD_LATENCY_SAMP_NUM0		0x025c
+#define RK3368_WIN0_DSP_BG			0x0260
+#define RK3368_WIN1_DSP_BG			0x0264
+#define RK3368_WIN2_DSP_BG			0x0268
+#define RK3368_WIN3_DSP_BG			0x026c
+#define RK3368_SCAN_LINE_NUM			0x0270
+#define RK3368_CABC_DEBUG0			0x0274
+#define RK3368_CABC_DEBUG1			0x0278
+#define RK3368_CABC_DEBUG2			0x027c
+#define RK3368_DBG_REG_000			0x0280
+#define RK3368_DBG_REG_001			0x0284
+#define RK3368_DBG_REG_002			0x0288
+#define RK3368_DBG_REG_003			0x028c
+#define RK3368_DBG_REG_004			0x0290
+#define RK3368_DBG_REG_005			0x0294
+#define RK3368_DBG_REG_006			0x0298
+#define RK3368_DBG_REG_007			0x029c
+#define RK3368_DBG_REG_008			0x02a0
+#define RK3368_DBG_REG_016			0x02c0
+#define RK3368_DBG_REG_017			0x02c4
+#define RK3368_DBG_REG_018			0x02c8
+#define RK3368_DBG_REG_019			0x02cc
+#define RK3368_DBG_REG_020			0x02d0
+#define RK3368_DBG_REG_021			0x02d4
+#define RK3368_DBG_REG_022			0x02d8
+#define RK3368_DBG_REG_023			0x02dc
+#define RK3368_DBG_REG_028			0x02f0
+#define RK3368_MMU_DTE_ADDR			0x0300
+#define RK3368_MMU_STATUS			0x0304
+#define RK3368_MMU_COMMAND			0x0308
+#define RK3368_MMU_PAGE_FAULT_ADDR		0x030c
+#define RK3368_MMU_ZAP_ONE_LINE			0x0310
+#define RK3368_MMU_INT_RAWSTAT			0x0314
+#define RK3368_MMU_INT_CLEAR			0x0318
+#define RK3368_MMU_INT_MASK			0x031c
+#define RK3368_MMU_INT_STATUS			0x0320
+#define RK3368_MMU_AUTO_GATING			0x0324
+#define RK3368_WIN2_LUT_ADDR			0x0400
+#define RK3368_WIN3_LUT_ADDR			0x0800
+#define RK3368_HWC_LUT_ADDR			0x0c00
+#define RK3368_GAMMA_LUT_ADDR			0x1000
+#define RK3368_CABC_GAMMA_LUT_ADDR		0x1800
+#define RK3368_MCU_BYPASS_WPORT			0x2200
+#define RK3368_MCU_BYPASS_RPORT			0x2300
+#define RK3368_GRF_SOC_CON6			0x0418
+/* rk3368 register definition end */
+
+#define RK3366_REG_CFG_DONE			0x0000
+#define RK3366_VERSION_INFO			0x0004
+#define RK3366_SYS_CTRL				0x0008
+#define RK3366_SYS_CTRL1			0x000c
+#define RK3366_DSP_CTRL0			0x0010
+#define RK3366_DSP_CTRL1			0x0014
+#define RK3366_DSP_BG				0x0018
+#define RK3366_MCU_CTRL				0x001c
+#define RK3366_WB_CTRL0				0x0020
+#define RK3366_WB_CTRL1				0x0024
+#define RK3366_WB_YRGB_MST			0x0028
+#define RK3366_WB_CBR_MST			0x002c
+#define RK3366_WIN0_CTRL0			0x0030
+#define RK3366_WIN0_CTRL1			0x0034
+#define RK3366_WIN0_COLOR_KEY			0x0038
+#define RK3366_WIN0_VIR				0x003c
+#define RK3366_WIN0_YRGB_MST			0x0040
+#define RK3366_WIN0_CBR_MST			0x0044
+#define RK3366_WIN0_ACT_INFO			0x0048
+#define RK3366_WIN0_DSP_INFO			0x004c
+#define RK3366_WIN0_DSP_ST			0x0050
+#define RK3366_WIN0_SCL_FACTOR_YRGB		0x0054
+#define RK3366_WIN0_SCL_FACTOR_CBR		0x0058
+#define RK3366_WIN0_SCL_OFFSET			0x005c
+#define RK3366_WIN0_SRC_ALPHA_CTRL		0x0060
+#define RK3366_WIN0_DST_ALPHA_CTRL		0x0064
+#define RK3366_WIN0_FADING_CTRL			0x0068
+#define RK3366_WIN0_CTRL2			0x006c
+#define RK3366_WIN1_CTRL0			0x0070
+#define RK3366_WIN1_CTRL1			0x0074
+#define RK3366_WIN1_COLOR_KEY			0x0078
+#define RK3366_WIN1_VIR				0x007c
+#define RK3366_WIN1_YRGB_MST			0x0080
+#define RK3366_WIN1_CBR_MST			0x0084
+#define RK3366_WIN1_ACT_INFO			0x0088
+#define RK3366_WIN1_DSP_INFO			0x008c
+#define RK3366_WIN1_DSP_ST			0x0090
+#define RK3366_WIN1_SCL_FACTOR_YRGB		0x0094
+#define RK3366_WIN1_SCL_FACTOR_CBR		0x0098
+#define RK3366_WIN1_SCL_OFFSET			0x009c
+#define RK3366_WIN1_SRC_ALPHA_CTRL		0x00a0
+#define RK3366_WIN1_DST_ALPHA_CTRL		0x00a4
+#define RK3366_WIN1_FADING_CTRL			0x00a8
+#define RK3366_WIN1_CTRL2			0x00ac
+#define RK3366_WIN2_CTRL0			0x00b0
+#define RK3366_WIN2_CTRL1			0x00b4
+#define RK3366_WIN2_VIR0_1			0x00b8
+#define RK3366_WIN2_VIR2_3			0x00bc
+#define RK3366_WIN2_MST0			0x00c0
+#define RK3366_WIN2_DSP_INFO0			0x00c4
+#define RK3366_WIN2_DSP_ST0			0x00c8
+#define RK3366_WIN2_COLOR_KEY			0x00cc
+#define RK3366_WIN2_MST1			0x00d0
+#define RK3366_WIN2_DSP_INFO1			0x00d4
+#define RK3366_WIN2_DSP_ST1			0x00d8
+#define RK3366_WIN2_SRC_ALPHA_CTRL		0x00dc
+#define RK3366_WIN2_MST2			0x00e0
+#define RK3366_WIN2_DSP_INFO2			0x00e4
+#define RK3366_WIN2_DSP_ST2			0x00e8
+#define RK3366_WIN2_DST_ALPHA_CTRL		0x00ec
+#define RK3366_WIN2_MST3			0x00f0
+#define RK3366_WIN2_DSP_INFO3			0x00f4
+#define RK3366_WIN2_DSP_ST3			0x00f8
+#define RK3366_WIN2_FADING_CTRL			0x00fc
+#define RK3366_WIN3_CTRL0			0x0100
+#define RK3366_WIN3_CTRL1			0x0104
+#define RK3366_WIN3_VIR0_1			0x0108
+#define RK3366_WIN3_VIR2_3			0x010c
+#define RK3366_WIN3_MST0			0x0110
+#define RK3366_WIN3_DSP_INFO0			0x0114
+#define RK3366_WIN3_DSP_ST0			0x0118
+#define RK3366_WIN3_COLOR_KEY			0x011c
+#define RK3366_WIN3_MST1			0x0120
+#define RK3366_WIN3_DSP_INFO1			0x0124
+#define RK3366_WIN3_DSP_ST1			0x0128
+#define RK3366_WIN3_SRC_ALPHA_CTRL		0x012c
+#define RK3366_WIN3_MST2			0x0130
+#define RK3366_WIN3_DSP_INFO2			0x0134
+#define RK3366_WIN3_DSP_ST2			0x0138
+#define RK3366_WIN3_DST_ALPHA_CTRL		0x013c
+#define RK3366_WIN3_MST3			0x0140
+#define RK3366_WIN3_DSP_INFO3			0x0144
+#define RK3366_WIN3_DSP_ST3			0x0148
+#define RK3366_WIN3_FADING_CTRL			0x014c
+#define RK3366_HWC_CTRL0			0x0150
+#define RK3366_HWC_CTRL1			0x0154
+#define RK3366_HWC_MST				0x0158
+#define RK3366_HWC_DSP_ST			0x015c
+#define RK3366_HWC_SRC_ALPHA_CTRL		0x0160
+#define RK3366_HWC_DST_ALPHA_CTRL		0x0164
+#define RK3366_HWC_FADING_CTRL			0x0168
+#define RK3366_HWC_RESERVED1			0x016c
+#define RK3366_POST_DSP_HACT_INFO		0x0170
+#define RK3366_POST_DSP_VACT_INFO		0x0174
+#define RK3366_POST_SCL_FACTOR_YRGB		0x0178
+#define RK3366_POST_RESERVED			0x017c
+#define RK3366_POST_SCL_CTRL			0x0180
+#define RK3366_POST_DSP_VACT_INFO_F1		0x0184
+#define RK3366_DSP_HTOTAL_HS_END		0x0188
+#define RK3366_DSP_HACT_ST_END			0x018c
+#define RK3366_DSP_VTOTAL_VS_END		0x0190
+#define RK3366_DSP_VACT_ST_END			0x0194
+#define RK3366_DSP_VS_ST_END_F1			0x0198
+#define RK3366_DSP_VACT_ST_END_F1		0x019c
+#define RK3366_PWM_CTRL				0x01a0
+#define RK3366_PWM_PERIOD_HPR			0x01a4
+#define RK3366_PWM_DUTY_LPR			0x01a8
+#define RK3366_PWM_CNT				0x01ac
+#define RK3366_BCSH_COLOR_BAR			0x01b0
+#define RK3366_BCSH_BCS				0x01b4
+#define RK3366_BCSH_H				0x01b8
+#define RK3366_BCSH_CTRL			0x01bc
+#define RK3366_CABC_CTRL0			0x01c0
+#define RK3366_CABC_CTRL1			0x01c4
+#define RK3366_CABC_CTRL2			0x01c8
+#define RK3366_CABC_CTRL3			0x01cc
+#define RK3366_CABC_GAUSS_LINE0_0		0x01d0
+#define RK3366_CABC_GAUSS_LINE0_1		0x01d4
+#define RK3366_CABC_GAUSS_LINE1_0		0x01d8
+#define RK3366_CABC_GAUSS_LINE1_1		0x01dc
+#define RK3366_CABC_GAUSS_LINE2_0		0x01e0
+#define RK3366_CABC_GAUSS_LINE2_1		0x01e4
+#define RK3366_FRC_LOWER01_0			0x01e8
+#define RK3366_FRC_LOWER01_1			0x01ec
+#define RK3366_FRC_LOWER10_0			0x01f0
+#define RK3366_FRC_LOWER10_1			0x01f4
+#define RK3366_FRC_LOWER11_0			0x01f8
+#define RK3366_FRC_LOWER11_1			0x01fc
+#define RK3366_INTR_EN0				0x0280
+#define RK3366_INTR_CLEAR0			0x0284
+#define RK3366_INTR_STATUS0			0x0288
+#define RK3366_INTR_RAW_STATUS0			0x028c
+#define RK3366_INTR_EN1				0x0290
+#define RK3366_INTR_CLEAR1			0x0294
+#define RK3366_INTR_STATUS1			0x0298
+#define RK3366_INTR_RAW_STATUS1			0x029c
+#define RK3366_LINE_FLAG			0x02a0
+#define RK3366_VOP_STATUS			0x02a4
+#define RK3366_BLANKING_VALUE			0x02a8
+#define RK3366_WIN0_DSP_BG			0x02b0
+#define RK3366_WIN1_DSP_BG			0x02b4
+#define RK3366_WIN2_DSP_BG			0x02b8
+#define RK3366_WIN3_DSP_BG			0x02bc
+#define RK3366_WIN2_LUT_ADDR			0x0400
+#define RK3366_WIN3_LUT_ADDR			0x0800
+#define RK3366_HWC_LUT_ADDR			0x0c00
+#define RK3366_GAMMA0_LUT_ADDR			0x1000
+#define RK3366_GAMMA1_LUT_ADDR			0x1400
+#define RK3366_CABC_GAMMA_LUT_ADDR		0x1800
+#define RK3366_MCU_BYPASS_WPORT			0x2200
+#define RK3366_MCU_BYPASS_RPORT			0x2300
+#define RK3366_MMU_DTE_ADDR			0x2400
+#define RK3366_MMU_STATUS			0x2404
+#define RK3366_MMU_COMMAND			0x2408
+#define RK3366_MMU_PAGE_FAULT_ADDR		0x240c
+#define RK3366_MMU_ZAP_ONE_LINE 		0x2410
+#define RK3366_MMU_INT_RAWSTAT			0x2414
+#define RK3366_MMU_INT_CLEAR			0x2418
+#define RK3366_MMU_INT_MASK			0x241c
+#define RK3366_MMU_INT_STATUS			0x2420
+#define RK3366_MMU_AUTO_GATING			0x2424
+
+/* rk3399 register definition */
+#define RK3399_REG_CFG_DONE			0x0000
+#define RK3399_VERSION_INFO			0x0004
+#define RK3399_SYS_CTRL				0x0008
+#define RK3399_SYS_CTRL1			0x000c
+#define RK3399_DSP_CTRL0			0x0010
+#define RK3399_DSP_CTRL1			0x0014
+#define RK3399_DSP_BG				0x0018
+#define RK3399_MCU_CTRL				0x001c
+#define RK3399_WB_CTRL0				0x0020
+#define RK3399_WB_CTRL1				0x0024
+#define RK3399_WB_YRGB_MST			0x0028
+#define RK3399_WB_CBR_MST			0x002c
+#define RK3399_WIN0_CTRL0			0x0030
+#define RK3399_WIN0_CTRL1			0x0034
+#define RK3399_WIN0_COLOR_KEY			0x0038
+#define RK3399_WIN0_VIR				0x003c
+#define RK3399_WIN0_YRGB_MST			0x0040
+#define RK3399_WIN0_CBR_MST			0x0044
+#define RK3399_WIN0_ACT_INFO			0x0048
+#define RK3399_WIN0_DSP_INFO			0x004c
+#define RK3399_WIN0_DSP_ST			0x0050
+#define RK3399_WIN0_SCL_FACTOR_YRGB		0x0054
+#define RK3399_WIN0_SCL_FACTOR_CBR		0x0058
+#define RK3399_WIN0_SCL_OFFSET			0x005c
+#define RK3399_WIN0_SRC_ALPHA_CTRL		0x0060
+#define RK3399_WIN0_DST_ALPHA_CTRL		0x0064
+#define RK3399_WIN0_FADING_CTRL			0x0068
+#define RK3399_WIN0_CTRL2			0x006c
+#define RK3399_WIN1_CTRL0			0x0070
+#define RK3399_WIN1_CTRL1			0x0074
+#define RK3399_WIN1_COLOR_KEY			0x0078
+#define RK3399_WIN1_VIR				0x007c
+#define RK3399_WIN1_YRGB_MST			0x0080
+#define RK3399_WIN1_CBR_MST			0x0084
+#define RK3399_WIN1_ACT_INFO			0x0088
+#define RK3399_WIN1_DSP_INFO			0x008c
+#define RK3399_WIN1_DSP_ST			0x0090
+#define RK3399_WIN1_SCL_FACTOR_YRGB		0x0094
+#define RK3399_WIN1_SCL_FACTOR_CBR		0x0098
+#define RK3399_WIN1_SCL_OFFSET			0x009c
+#define RK3399_WIN1_SRC_ALPHA_CTRL		0x00a0
+#define RK3399_WIN1_DST_ALPHA_CTRL		0x00a4
+#define RK3399_WIN1_FADING_CTRL			0x00a8
+#define RK3399_WIN1_CTRL2			0x00ac
+#define RK3399_WIN2_CTRL0			0x00b0
+#define RK3399_WIN2_CTRL1			0x00b4
+#define RK3399_WIN2_VIR0_1			0x00b8
+#define RK3399_WIN2_VIR2_3			0x00bc
+#define RK3399_WIN2_MST0			0x00c0
+#define RK3399_WIN2_DSP_INFO0			0x00c4
+#define RK3399_WIN2_DSP_ST0			0x00c8
+#define RK3399_WIN2_COLOR_KEY			0x00cc
+#define RK3399_WIN2_MST1			0x00d0
+#define RK3399_WIN2_DSP_INFO1			0x00d4
+#define RK3399_WIN2_DSP_ST1			0x00d8
+#define RK3399_WIN2_SRC_ALPHA_CTRL		0x00dc
+#define RK3399_WIN2_MST2			0x00e0
+#define RK3399_WIN2_DSP_INFO2			0x00e4
+#define RK3399_WIN2_DSP_ST2			0x00e8
+#define RK3399_WIN2_DST_ALPHA_CTRL		0x00ec
+#define RK3399_WIN2_MST3			0x00f0
+#define RK3399_WIN2_DSP_INFO3			0x00f4
+#define RK3399_WIN2_DSP_ST3			0x00f8
+#define RK3399_WIN2_FADING_CTRL			0x00fc
+#define RK3399_WIN3_CTRL0			0x0100
+#define RK3399_WIN3_CTRL1			0x0104
+#define RK3399_WIN3_VIR0_1			0x0108
+#define RK3399_WIN3_VIR2_3			0x010c
+#define RK3399_WIN3_MST0			0x0110
+#define RK3399_WIN3_DSP_INFO0			0x0114
+#define RK3399_WIN3_DSP_ST0			0x0118
+#define RK3399_WIN3_COLOR_KEY			0x011c
+#define RK3399_WIN3_MST1			0x0120
+#define RK3399_WIN3_DSP_INFO1			0x0124
+#define RK3399_WIN3_DSP_ST1			0x0128
+#define RK3399_WIN3_SRC_ALPHA_CTRL		0x012c
+#define RK3399_WIN3_MST2			0x0130
+#define RK3399_WIN3_DSP_INFO2			0x0134
+#define RK3399_WIN3_DSP_ST2			0x0138
+#define RK3399_WIN3_DST_ALPHA_CTRL		0x013c
+#define RK3399_WIN3_MST3			0x0140
+#define RK3399_WIN3_DSP_INFO3			0x0144
+#define RK3399_WIN3_DSP_ST3			0x0148
+#define RK3399_WIN3_FADING_CTRL			0x014c
+#define RK3399_HWC_CTRL0			0x0150
+#define RK3399_HWC_CTRL1			0x0154
+#define RK3399_HWC_MST				0x0158
+#define RK3399_HWC_DSP_ST			0x015c
+#define RK3399_HWC_SRC_ALPHA_CTRL		0x0160
+#define RK3399_HWC_DST_ALPHA_CTRL		0x0164
+#define RK3399_HWC_FADING_CTRL			0x0168
+#define RK3399_HWC_RESERVED1			0x016c
+#define RK3399_POST_DSP_HACT_INFO		0x0170
+#define RK3399_POST_DSP_VACT_INFO		0x0174
+#define RK3399_POST_SCL_FACTOR_YRGB		0x0178
+#define RK3399_POST_RESERVED			0x017c
+#define RK3399_POST_SCL_CTRL			0x0180
+#define RK3399_POST_DSP_VACT_INFO_F1		0x0184
+#define RK3399_DSP_HTOTAL_HS_END		0x0188
+#define RK3399_DSP_HACT_ST_END			0x018c
+#define RK3399_DSP_VTOTAL_VS_END		0x0190
+#define RK3399_DSP_VACT_ST_END			0x0194
+#define RK3399_DSP_VS_ST_END_F1			0x0198
+#define RK3399_DSP_VACT_ST_END_F1		0x019c
+#define RK3399_PWM_CTRL				0x01a0
+#define RK3399_PWM_PERIOD_HPR			0x01a4
+#define RK3399_PWM_DUTY_LPR			0x01a8
+#define RK3399_PWM_CNT				0x01ac
+#define RK3399_BCSH_COLOR_BAR			0x01b0
+#define RK3399_BCSH_BCS				0x01b4
+#define RK3399_BCSH_H				0x01b8
+#define RK3399_BCSH_CTRL			0x01bc
+#define RK3399_CABC_CTRL0			0x01c0
+#define RK3399_CABC_CTRL1			0x01c4
+#define RK3399_CABC_CTRL2			0x01c8
+#define RK3399_CABC_CTRL3			0x01cc
+#define RK3399_CABC_GAUSS_LINE0_0		0x01d0
+#define RK3399_CABC_GAUSS_LINE0_1		0x01d4
+#define RK3399_CABC_GAUSS_LINE1_0		0x01d8
+#define RK3399_CABC_GAUSS_LINE1_1		0x01dc
+#define RK3399_CABC_GAUSS_LINE2_0		0x01e0
+#define RK3399_CABC_GAUSS_LINE2_1		0x01e4
+#define RK3399_FRC_LOWER01_0			0x01e8
+#define RK3399_FRC_LOWER01_1			0x01ec
+#define RK3399_FRC_LOWER10_0			0x01f0
+#define RK3399_FRC_LOWER10_1			0x01f4
+#define RK3399_FRC_LOWER11_0			0x01f8
+#define RK3399_FRC_LOWER11_1			0x01fc
+#define RK3399_AFBCD0_CTRL			0x0200
+#define RK3399_AFBCD0_HDR_PTR			0x0204
+#define RK3399_AFBCD0_PIC_SIZE			0x0208
+#define RK3399_AFBCD0_STATUS			0x020c
+#define RK3399_AFBCD1_CTRL			0x0220
+#define RK3399_AFBCD1_HDR_PTR			0x0224
+#define RK3399_AFBCD1_PIC_SIZE			0x0228
+#define RK3399_AFBCD1_STATUS			0x022c
+#define RK3399_AFBCD2_CTRL			0x0240
+#define RK3399_AFBCD2_HDR_PTR			0x0244
+#define RK3399_AFBCD2_PIC_SIZE			0x0248
+#define RK3399_AFBCD2_STATUS			0x024c
+#define RK3399_AFBCD3_CTRL			0x0260
+#define RK3399_AFBCD3_HDR_PTR			0x0264
+#define RK3399_AFBCD3_PIC_SIZE			0x0268
+#define RK3399_AFBCD3_STATUS			0x026c
+#define RK3399_INTR_EN0				0x0280
+#define RK3399_INTR_CLEAR0			0x0284
+#define RK3399_INTR_STATUS0			0x0288
+#define RK3399_INTR_RAW_STATUS0			0x028c
+#define RK3399_INTR_EN1				0x0290
+#define RK3399_INTR_CLEAR1			0x0294
+#define RK3399_INTR_STATUS1			0x0298
+#define RK3399_INTR_RAW_STATUS1			0x029c
+#define RK3399_LINE_FLAG			0x02a0
+#define RK3399_VOP_STATUS			0x02a4
+#define RK3399_BLANKING_VALUE			0x02a8
+#define RK3399_MCU_BYPASS_PORT			0x02ac
+#define RK3399_WIN0_DSP_BG			0x02b0
+#define RK3399_WIN1_DSP_BG			0x02b4
+#define RK3399_WIN2_DSP_BG			0x02b8
+#define RK3399_WIN3_DSP_BG			0x02bc
+#define RK3399_YUV2YUV_WIN			0x02c0
+#define RK3399_YUV2YUV_POST			0x02c4
+#define RK3399_AUTO_GATING_EN			0x02cc
+#define RK3399_WIN0_CSC_COE			0x03a0
+#define RK3399_WIN1_CSC_COE			0x03c0
+#define RK3399_WIN2_CSC_COE			0x03e0
+#define RK3399_WIN3_CSC_COE			0x0400
+#define RK3399_HWC_CSC_COE			0x0420
+#define RK3399_BCSH_R2Y_CSC_COE			0x0440
+#define RK3399_BCSH_Y2R_CSC_COE			0x0460
+#define RK3399_POST_YUV2YUV_Y2R_COE		0x0480
+#define RK3399_POST_YUV2YUV_3X3_COE		0x04a0
+#define RK3399_POST_YUV2YUV_R2Y_COE		0x04c0
+#define RK3399_WIN0_YUV2YUV_Y2R			0x04e0
+#define RK3399_WIN0_YUV2YUV_3X3			0x0500
+#define RK3399_WIN0_YUV2YUV_R2Y			0x0520
+#define RK3399_WIN1_YUV2YUV_Y2R			0x0540
+#define RK3399_WIN1_YUV2YUV_3X3			0x0560
+#define RK3399_WIN1_YUV2YUV_R2Y			0x0580
+#define RK3399_WIN2_YUV2YUV_Y2R			0x05a0
+#define RK3399_WIN2_YUV2YUV_3X3			0x05c0
+#define RK3399_WIN2_YUV2YUV_R2Y			0x05e0
+#define RK3399_WIN3_YUV2YUV_Y2R			0x0600
+#define RK3399_WIN3_YUV2YUV_3X3			0x0620
+#define RK3399_WIN3_YUV2YUV_R2Y			0x0640
+#define RK3399_WIN2_LUT_ADDR			0x1000
+#define RK3399_WIN3_LUT_ADDR			0x1400
+#define RK3399_HWC_LUT_ADDR			0x1800
+#define RK3399_CABC_GAMMA_LUT_ADDR		0x1c00
+#define RK3399_GAMMA_LUT_ADDR			0x2000
+/* rk3399 register definition end */
+
+/* rk3328 register definition end */
+#define RK3328_REG_CFG_DONE			0x00000000
+#define RK3328_VERSION_INFO			0x00000004
+#define RK3328_SYS_CTRL				0x00000008
+#define RK3328_SYS_CTRL1			0x0000000c
+#define RK3328_DSP_CTRL0			0x00000010
+#define RK3328_DSP_CTRL1			0x00000014
+#define RK3328_DSP_BG				0x00000018
+#define RK3328_AUTO_GATING_EN			0x0000003c
+#define RK3328_LINE_FLAG			0x00000040
+#define RK3328_VOP_STATUS			0x00000044
+#define RK3328_BLANKING_VALUE			0x00000048
+#define RK3328_WIN0_DSP_BG			0x00000050
+#define RK3328_WIN1_DSP_BG			0x00000054
+#define RK3328_DBG_PERF_LATENCY_CTRL0		0x000000c0
+#define RK3328_DBG_PERF_RD_MAX_LATENCY_NUM0	0x000000c4
+#define RK3328_DBG_PERF_RD_LATENCY_THR_NUM0	0x000000c8
+#define RK3328_DBG_PERF_RD_LATENCY_SAMP_NUM0	0x000000cc
+#define RK3328_INTR_EN0				0x000000e0
+#define RK3328_INTR_CLEAR0			0x000000e4
+#define RK3328_INTR_STATUS0			0x000000e8
+#define RK3328_INTR_RAW_STATUS0			0x000000ec
+#define RK3328_INTR_EN1				0x000000f0
+#define RK3328_INTR_CLEAR1			0x000000f4
+#define RK3328_INTR_STATUS1			0x000000f8
+#define RK3328_INTR_RAW_STATUS1			0x000000fc
+#define RK3328_WIN0_CTRL0			0x00000100
+#define RK3328_WIN0_CTRL1			0x00000104
+#define RK3328_WIN0_COLOR_KEY			0x00000108
+#define RK3328_WIN0_VIR				0x0000010c
+#define RK3328_WIN0_YRGB_MST			0x00000110
+#define RK3328_WIN0_CBR_MST			0x00000114
+#define RK3328_WIN0_ACT_INFO			0x00000118
+#define RK3328_WIN0_DSP_INFO			0x0000011c
+#define RK3328_WIN0_DSP_ST			0x00000120
+#define RK3328_WIN0_SCL_FACTOR_YRGB		0x00000124
+#define RK3328_WIN0_SCL_FACTOR_CBR		0x00000128
+#define RK3328_WIN0_SCL_OFFSET			0x0000012c
+#define RK3328_WIN0_SRC_ALPHA_CTRL		0x00000130
+#define RK3328_WIN0_DST_ALPHA_CTRL		0x00000134
+#define RK3328_WIN0_FADING_CTRL			0x00000138
+#define RK3328_WIN0_CTRL2			0x0000013c
+#define RK3328_DBG_WIN0_REG0			0x000001f0
+#define RK3328_DBG_WIN0_REG1			0x000001f4
+#define RK3328_DBG_WIN0_REG2			0x000001f8
+#define RK3328_DBG_WIN0_RESERVED		0x000001fc
+#define RK3328_WIN1_CTRL0			0x00000200
+#define RK3328_WIN1_CTRL1			0x00000204
+#define RK3328_WIN1_COLOR_KEY			0x00000208
+#define RK3328_WIN1_VIR				0x0000020c
+#define RK3328_WIN1_YRGB_MST			0x00000210
+#define RK3328_WIN1_CBR_MST			0x00000214
+#define RK3328_WIN1_ACT_INFO			0x00000218
+#define RK3328_WIN1_DSP_INFO			0x0000021c
+#define RK3328_WIN1_DSP_ST			0x00000220
+#define RK3328_WIN1_SCL_FACTOR_YRGB		0x00000224
+#define RK3328_WIN1_SCL_FACTOR_CBR		0x00000228
+#define RK3328_WIN1_SCL_OFFSET			0x0000022c
+#define RK3328_WIN1_SRC_ALPHA_CTRL		0x00000230
+#define RK3328_WIN1_DST_ALPHA_CTRL		0x00000234
+#define RK3328_WIN1_FADING_CTRL			0x00000238
+#define RK3328_WIN1_CTRL2			0x0000023c
+#define RK3328_DBG_WIN1_REG0			0x000002f0
+#define RK3328_DBG_WIN1_REG1			0x000002f4
+#define RK3328_DBG_WIN1_REG2			0x000002f8
+#define RK3328_DBG_WIN1_RESERVED		0x000002fc
+#define RK3328_WIN2_CTRL0			0x00000300
+#define RK3328_WIN2_CTRL1			0x00000304
+#define RK3328_WIN2_COLOR_KEY			0x00000308
+#define RK3328_WIN2_VIR				0x0000030c
+#define RK3328_WIN2_YRGB_MST			0x00000310
+#define RK3328_WIN2_CBR_MST			0x00000314
+#define RK3328_WIN2_ACT_INFO			0x00000318
+#define RK3328_WIN2_DSP_INFO			0x0000031c
+#define RK3328_WIN2_DSP_ST			0x00000320
+#define RK3328_WIN2_SCL_FACTOR_YRGB		0x00000324
+#define RK3328_WIN2_SCL_FACTOR_CBR		0x00000328
+#define RK3328_WIN2_SCL_OFFSET			0x0000032c
+#define RK3328_WIN2_SRC_ALPHA_CTRL		0x00000330
+#define RK3328_WIN2_DST_ALPHA_CTRL		0x00000334
+#define RK3328_WIN2_FADING_CTRL			0x00000338
+#define RK3328_WIN2_CTRL2			0x0000033c
+#define RK3328_DBG_WIN2_REG0			0x000003f0
+#define RK3328_DBG_WIN2_REG1			0x000003f4
+#define RK3328_DBG_WIN2_REG2			0x000003f8
+#define RK3328_DBG_WIN2_RESERVED		0x000003fc
+#define RK3328_WIN3_CTRL0			0x00000400
+#define RK3328_WIN3_CTRL1			0x00000404
+#define RK3328_WIN3_COLOR_KEY			0x00000408
+#define RK3328_WIN3_VIR				0x0000040c
+#define RK3328_WIN3_YRGB_MST			0x00000410
+#define RK3328_WIN3_CBR_MST			0x00000414
+#define RK3328_WIN3_ACT_INFO			0x00000418
+#define RK3328_WIN3_DSP_INFO			0x0000041c
+#define RK3328_WIN3_DSP_ST			0x00000420
+#define RK3328_WIN3_SCL_FACTOR_YRGB		0x00000424
+#define RK3328_WIN3_SCL_FACTOR_CBR		0x00000428
+#define RK3328_WIN3_SCL_OFFSET			0x0000042c
+#define RK3328_WIN3_SRC_ALPHA_CTRL		0x00000430
+#define RK3328_WIN3_DST_ALPHA_CTRL		0x00000434
+#define RK3328_WIN3_FADING_CTRL			0x00000438
+#define RK3328_WIN3_CTRL2			0x0000043c
+#define RK3328_DBG_WIN3_REG0			0x000004f0
+#define RK3328_DBG_WIN3_REG1			0x000004f4
+#define RK3328_DBG_WIN3_REG2			0x000004f8
+#define RK3328_DBG_WIN3_RESERVED		0x000004fc
+
+#define RK3328_HWC_CTRL0			0x00000500
+#define RK3328_HWC_CTRL1			0x00000504
+#define RK3328_HWC_MST				0x00000508
+#define RK3328_HWC_DSP_ST			0x0000050c
+#define RK3328_HWC_SRC_ALPHA_CTRL		0x00000510
+#define RK3328_HWC_DST_ALPHA_CTRL		0x00000514
+#define RK3328_HWC_FADING_CTRL			0x00000518
+#define RK3328_HWC_RESERVED1			0x0000051c
+#define RK3328_POST_DSP_HACT_INFO		0x00000600
+#define RK3328_POST_DSP_VACT_INFO		0x00000604
+#define RK3328_POST_SCL_FACTOR_YRGB		0x00000608
+#define RK3328_POST_RESERVED			0x0000060c
+#define RK3328_POST_SCL_CTRL			0x00000610
+#define RK3328_POST_DSP_VACT_INFO_F1		0x00000614
+#define RK3328_DSP_HTOTAL_HS_END		0x00000618
+#define RK3328_DSP_HACT_ST_END			0x0000061c
+#define RK3328_DSP_VTOTAL_VS_END		0x00000620
+#define RK3328_DSP_VACT_ST_END			0x00000624
+#define RK3328_DSP_VS_ST_END_F1			0x00000628
+#define RK3328_DSP_VACT_ST_END_F1		0x0000062c
+#define RK3328_BCSH_COLOR_BAR			0x00000640
+#define RK3328_BCSH_BCS				0x00000644
+#define RK3328_BCSH_H				0x00000648
+#define RK3328_BCSH_CTRL			0x0000064c
+#define RK3328_FRC_LOWER01_0			0x00000678
+#define RK3328_FRC_LOWER01_1			0x0000067c
+#define RK3328_FRC_LOWER10_0			0x00000680
+#define RK3328_FRC_LOWER10_1			0x00000684
+#define RK3328_FRC_LOWER11_0			0x00000688
+#define RK3328_FRC_LOWER11_1			0x0000068c
+#define RK3328_DBG_POST_REG0			0x000006e8
+#define RK3328_DBG_POST_RESERVED		0x000006ec
+#define RK3328_DBG_DATAO			0x000006f0
+#define RK3328_DBG_DATAO_2			0x000006f4
+
+/* sdr to hdr */
+#define RK3328_SDR2HDR_CTRL			0x00000700
+#define RK3328_EOTF_OETF_Y0			0x00000704
+#define RK3328_RESERVED0001			0x00000708
+#define RK3328_RESERVED0002			0x0000070c
+#define RK3328_EOTF_OETF_Y1			0x00000710
+#define RK3328_EOTF_OETF_Y64			0x0000080c
+#define RK3328_OETF_DX_DXPOW1			0x00000810
+#define RK3328_OETF_DX_DXPOW64			0x0000090c
+#define RK3328_OETF_XN1				0x00000910
+#define RK3328_OETF_XN63			0x00000a08
+
+/* hdr to sdr */
+#define RK3328_HDR2SDR_CTRL			0x00000a10
+#define RK3328_HDR2SDR_SRC_RANGE		0x00000a14
+#define RK3328_HDR2SDR_NORMFACEETF		0x00000a18
+#define RK3328_RESERVED0003			0x00000a1c
+#define RK3328_HDR2SDR_DST_RANGE		0x00000a20
+#define RK3328_HDR2SDR_NORMFACCGAMMA		0x00000a24
+#define RK3328_EETF_OETF_Y0			0x00000a28
+#define RK3328_SAT_Y0				0x00000a2c
+#define RK3328_EETF_OETF_Y1			0x00000a30
+#define RK3328_SAT_Y1				0x00000ab0
+#define RK3328_SAT_Y8				0x00000acc
+
+#define RK3328_HWC_LUT_ADDR			0x00000c00
+
+/* rk3036 register definition */
+#define RK3036_SYS_CTRL			0x00
+#define RK3036_DSP_CTRL0		0x04
+#define RK3036_DSP_CTRL1		0x08
+#define RK3036_INT_SCALER		0x0c
+#define RK3036_INT_STATUS		0x10
+#define RK3036_ALPHA_CTRL		0x14
+#define RK3036_WIN0_COLOR_KEY		0x18
+#define RK3036_WIN1_COLOR_KEY		0x1c
+#define RK3036_WIN0_YRGB_MST		0x20
+#define RK3036_WIN0_CBR_MST		0x24
+#define RK3036_WIN1_VIR			0x28
+#define RK3036_AXI_BUS_CTRL		0x2c
+#define RK3036_WIN0_VIR			0x30
+#define RK3036_WIN0_ACT_INFO		0x34
+#define RK3036_WIN0_DSP_INFO		0x38
+#define RK3036_WIN0_DSP_ST		0x3c
+#define RK3036_WIN0_SCL_FACTOR_YRGB	0x40
+#define RK3036_WIN0_SCL_FACTOR_CBR	0x44
+#define RK3036_WIN0_SCL_OFFSET		0x48
+#define RK3036_HWC_MST			0x58
+#define RK3036_HWC_DSP_ST		0x5c
+#define RK3036_DSP_HTOTAL_HS_END	0x6c
+#define RK3036_DSP_HACT_ST_END		0x70
+#define RK3036_DSP_VTOTAL_VS_END	0x74
+#define RK3036_DSP_VACT_ST_END		0x78
+#define RK3036_DSP_VS_ST_END_F1		0x7c
+#define RK3036_DSP_VACT_ST_END_F1	0x80
+#define RK3036_GATHER_TRANSFER		0x84
+#define RK3036_VERSION_INFO		0x94
+#define RK3036_REG_CFG_DONE		0x90
+#define RK3036_WIN1_MST			0xa0
+#define RK3036_WIN1_ACT_INFO		0xb4
+#define RK3036_WIN1_DSP_INFO		0xb8
+#define RK3036_WIN1_DSP_ST		0xbc
+#define RK3036_WIN1_SCL_FACTOR_YRGB	0xc0
+#define RK3036_WIN1_SCL_OFFSET		0xc8
+#define RK3036_BCSH_CTRL		0xd0
+#define RK3036_BCSH_COLOR_BAR		0xd4
+#define RK3036_BCSH_BCS			0xd8
+#define RK3036_BCSH_H			0xdc
+#define RK3036_WIN1_LUT_ADDR		0x400
+#define RK3036_HWC_LUT_ADDR		0x800
+/* rk3036 register definition end */
+
+/* rk3126 register definition */
+#define RK3126_WIN1_MST				0x0004c
+#define RK3126_WIN1_DSP_INFO			0x00050
+#define RK3126_WIN1_DSP_ST			0x00054
+/* rk3126 register definition end */
+
+/* rk3366 register definition */
+#define RK3366_LIT_REG_CFG_DONE			0x00000
+#define RK3366_LIT_VERSION			0x00004
+#define RK3366_LIT_DSP_BG			0x00008
+#define RK3366_LIT_MCU_CTRL			0x0000c
+#define RK3366_LIT_SYS_CTRL0			0x00010
+#define RK3366_LIT_SYS_CTRL1			0x00014
+#define RK3366_LIT_SYS_CTRL2			0x00018
+#define RK3366_LIT_DSP_CTRL0			0x00020
+#define RK3366_LIT_DSP_CTRL2			0x00028
+#define RK3366_LIT_VOP_STATUS			0x0002c
+#define RK3366_LIT_LINE_FLAG			0x00030
+#define RK3366_LIT_INTR_EN			0x00034
+#define RK3366_LIT_INTR_CLEAR			0x00038
+#define RK3366_LIT_INTR_STATUS			0x0003c
+#define RK3366_LIT_WIN0_CTRL0			0x00050
+#define RK3366_LIT_WIN0_CTRL1			0x00054
+#define RK3366_LIT_WIN0_COLOR_KEY		0x00058
+#define RK3366_LIT_WIN0_VIR			0x0005c
+#define RK3366_LIT_WIN0_YRGB_MST0		0x00060
+#define RK3366_LIT_WIN0_CBR_MST0		0x00064
+#define RK3366_LIT_WIN0_ACT_INFO		0x00068
+#define RK3366_LIT_WIN0_DSP_INFO		0x0006c
+#define RK3366_LIT_WIN0_DSP_ST			0x00070
+#define RK3366_LIT_WIN0_SCL_FACTOR_YRGB		0x00074
+#define RK3366_LIT_WIN0_SCL_FACTOR_CBR		0x00078
+#define RK3366_LIT_WIN0_SCL_OFFSET		0x0007c
+#define RK3366_LIT_WIN0_ALPHA_CTRL		0x00080
+#define RK3366_LIT_WIN1_CTRL0			0x00090
+#define RK3366_LIT_WIN1_CTRL1			0x00094
+#define RK3366_LIT_WIN1_VIR			0x00098
+#define RK3366_LIT_WIN1_MST			0x000a0
+#define RK3366_LIT_WIN1_DSP_INFO		0x000a4
+#define RK3366_LIT_WIN1_DSP_ST			0x000a8
+#define RK3366_LIT_WIN1_COLOR_KEY		0x000ac
+#define RK3366_LIT_WIN1_ALPHA_CTRL		0x000bc
+#define RK3366_LIT_HWC_CTRL0			0x000e0
+#define RK3366_LIT_HWC_CTRL1			0x000e4
+#define RK3366_LIT_HWC_MST			0x000e8
+#define RK3366_LIT_HWC_DSP_ST			0x000ec
+#define RK3366_LIT_HWC_ALPHA_CTRL		0x000f0
+#define RK3366_LIT_DSP_HTOTAL_HS_END		0x00100
+#define RK3366_LIT_DSP_HACT_ST_END		0x00104
+#define RK3366_LIT_DSP_VTOTAL_VS_END		0x00108
+#define RK3366_LIT_DSP_VACT_ST_END		0x0010c
+#define RK3366_LIT_DSP_VS_ST_END_F1		0x00110
+#define RK3366_LIT_DSP_VACT_ST_END_F1		0x00114
+#define RK3366_LIT_BCSH_CTRL			0x00160
+#define RK3366_LIT_BCSH_COL_BAR			0x00164
+#define RK3366_LIT_BCSH_BCS			0x00168
+#define RK3366_LIT_BCSH_H			0x0016c
+#define RK3366_LIT_FRC_LOWER01_0		0x00170
+#define RK3366_LIT_FRC_LOWER01_1		0x00174
+#define RK3366_LIT_FRC_LOWER10_0		0x00178
+#define RK3366_LIT_FRC_LOWER10_1		0x0017c
+#define RK3366_LIT_FRC_LOWER11_0		0x00180
+#define RK3366_LIT_FRC_LOWER11_1		0x00184
+#define RK3366_LIT_MCU_RW_BYPASS_PORT		0x0018c
+#define RK3366_LIT_DBG_REG_000			0x00190
+#define RK3366_LIT_BLANKING_VALUE		0x001f4
+#define RK3366_LIT_FLAG_REG_FRM_VALID		0x001f8
+#define RK3366_LIT_FLAG_REG			0x001fc
+#define RK3366_LIT_HWC_LUT_ADDR			0x00600
+#define RK3366_LIT_GAMMA_LUT_ADDR		0x00a00
+/* rk3366 register definition end */
+
+/* px30 register definition */
+#define PX30_CABC_CTRL0				0x00200
+#define PX30_CABC_CTRL1				0x00204
+#define PX30_CABC_CTRL2				0x00208
+#define PX30_CABC_CTRL3				0x0020c
+#define PX30_CABC_GAUSS_LINE0_0			0x00210
+#define PX30_CABC_GAUSS_LINE0_1			0x00214
+#define PX30_CABC_GAUSS_LINE1_0			0x00218
+#define PX30_CABC_GAUSS_LINE1_1			0x0021c
+#define PX30_CABC_GAUSS_LINE2_0			0x00220
+#define PX30_CABC_GAUSS_LINE2_1			0x00224
+#define PX30_AFBCD0_CTRL			0x00240
+#define PX30_AFBCD0_HDR_PTR			0x00244
+#define PX30_AFBCD0_PIC_SIZE			0x00248
+#define PX30_AFBCD0_PIC_OFFSET			0x0024c
+#define PX30_AFBCD0_AXI_CTRL			0x00250
+#define PX30_GRF_PD_VO_CON1			0x00438
+/* px30 register definition end */
+
+/* rk1808 register definition start*/
+#define RK1808_GRF_PD_VO_CON1			0x00000444
+/* rk1808 register definition end*/
+
+/* RV1126 register definition start */
+#define RV1126_WIN2_CTRL0			0x0190
+#define RV1126_WIN2_VIR0_1			0x0198
+#define RV1126_WIN2_MST0			0x01a0
+#define RV1126_WIN2_DSP_INFO0			0x01a4
+#define RV1126_WIN2_DSP_ST0			0x01a8
+/* RV1126 register definition end   */
+#endif /* _ROCKCHIP_VOP_REG_H */
diff --git a/drivers/video/drm/rohm-bu18rl82.c b/drivers/video/drm/rohm-bu18rl82.c
new file mode 100644
index 0000000000..db35848889
--- /dev/null
+++ b/drivers/video/drm/rohm-bu18rl82.c
@@ -0,0 +1,213 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * (C) Copyright 2022 Rockchip Electronics Co., Ltd
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <errno.h>
+#include <i2c.h>
+#include <video_bridge.h>
+#include <asm/unaligned.h>
+#include <linux/media-bus-format.h>
+#include <power/regulator.h>
+
+#include "rockchip_bridge.h"
+#include "rockchip_display.h"
+#include "rockchip_panel.h"
+
+#define BU18RL82_REG_RESET 0X000E
+
+#define BU18RL82_SWRST_REG BIT(0)
+#define BU18RL82_SWRST_EXCREG BIT(1)
+#define BU18RL82_SWRST_ALL BIT(7)
+
+struct des_reg_sequence {
+	uint reg;
+	uint def;
+};
+
+struct serdes_init_seq {
+	struct des_reg_sequence *reg_sequence;
+	uint reg_seq_cnt;
+};
+
+struct bu18rl82_priv {
+	struct udevice *dev;
+	struct serdes_init_seq *serdes_init_seq;
+};
+
+static void bu18rl82_bridge_reset(struct rockchip_bridge *bridge)
+{
+	int ret = 0;
+	struct udevice *dev = bridge->dev;
+	struct udevice *bus = dev_get_parent(dev);
+
+	ret = dm_i2c_reg_write(dev, BU18RL82_REG_RESET,
+			       (BU18RL82_SWRST_REG | BU18RL82_SWRST_EXCREG | BU18RL82_SWRST_ALL));
+	if (ret < 0)
+		printf("failed to reset bu18rl82(%s) ret=%d\n", bus->name, ret);
+	mdelay(5);
+}
+
+static int bu18rl82_serdes_init_sequence_write(struct bu18rl82_priv *priv)
+{
+	struct serdes_init_seq *serdes_init_seq = priv->serdes_init_seq;
+	struct des_reg_sequence *reg_sequence =  serdes_init_seq->reg_sequence;
+	uint cnt = serdes_init_seq->reg_seq_cnt;
+	struct udevice *dev = priv->dev;
+	uint i;
+	int ret = 0;
+
+	for (i = 0; i < cnt; i++) {
+		ret = dm_i2c_reg_write(dev, reg_sequence[i].reg, reg_sequence[i].def);
+		if (ret < 0) {
+			dev_err(priv->dev, "failed write reg: 0x%04x value: 0x%04x\n",
+				reg_sequence[i].reg, reg_sequence[i].def);
+			break;
+		}
+	}
+
+	return ret;
+}
+
+static void bu18rl82_bridge_enable(struct rockchip_bridge *bridge)
+{
+	struct udevice *dev = bridge->dev;
+	struct bu18rl82_priv *priv = dev_get_priv(dev);
+	struct udevice *bus = dev_get_parent(dev);
+	int i;
+	int ret;
+
+	for (i = 0; i < 10; i++) {
+		ret = bu18rl82_serdes_init_sequence_write(priv);
+		if (ret < 0) {
+			dev_err(priv->dev, "%s ret=%d\n", bus->name, ret);
+			continue;
+		}
+
+		break;
+	}
+}
+
+static const struct rockchip_bridge_funcs bu18rl82_bridge_funcs = {
+	.enable = bu18rl82_bridge_enable,
+};
+
+static int bu18rl82_parse_init_seq(struct udevice *dev, const u16 *data,
+				   int length, struct serdes_init_seq *seq)
+{
+	struct des_reg_sequence *reg_sequence;
+	u16 *buf, *d;
+	unsigned int i, cnt;
+	int ret;
+
+	if (!seq)
+		return -EINVAL;
+
+	buf = calloc(1, length);
+	if (!buf)
+		return -ENOMEM;
+
+	memcpy(buf, data, length);
+
+	d = buf;
+	cnt = length / 4;
+	seq->reg_seq_cnt = cnt;
+
+	seq->reg_sequence = calloc(cnt, sizeof(struct des_reg_sequence));
+	if (!seq->reg_sequence) {
+		ret = -ENOMEM;
+		goto free_buf;
+	}
+
+	for (i = 0; i < cnt; i++) {
+		reg_sequence = &seq->reg_sequence[i];
+		reg_sequence->reg = get_unaligned_be16(&d[0]);
+		reg_sequence->def = get_unaligned_be16(&d[1]);
+		d += 2;
+	}
+
+	return 0;
+
+free_buf:
+	free(buf);
+
+	return ret;
+}
+
+static int bu18rl82_get_init_seq(struct bu18rl82_priv *priv)
+{
+	const void *data = NULL;
+	int len, err;
+
+	data = dev_read_prop(priv->dev, "serdes-init-sequence", &len);
+	if (!data) {
+		printf("failed to get serdes-init-sequence\n");
+		return -EINVAL;
+	}
+
+	priv->serdes_init_seq = calloc(1, sizeof(*priv->serdes_init_seq));
+	if (!priv->serdes_init_seq)
+		return -ENOMEM;
+
+	err = bu18rl82_parse_init_seq(priv->dev, data, len, priv->serdes_init_seq);
+	if (err) {
+		printf("failed to parse serdes-init-sequence\n");
+		goto free_init_seq;
+	}
+
+	return 0;
+
+free_init_seq:
+	free(priv->serdes_init_seq);
+
+	return err;
+}
+
+static int bu18rl82_probe(struct udevice *dev)
+{
+	struct bu18rl82_priv *priv = dev_get_priv(dev);
+	struct rockchip_bridge *bridge;
+	int ret;
+
+	ret = i2c_set_chip_offset_len(dev, 2);
+	if (ret)
+		return ret;
+
+	priv->dev = dev;
+
+	bridge = calloc(1, sizeof(*bridge));
+	if (!bridge)
+		return -ENOMEM;
+
+	ret = bu18rl82_get_init_seq(priv);
+	if (ret)
+		goto free_bridge;
+
+	dev->driver_data = (ulong)bridge;
+	bridge->dev = dev;
+	bridge->funcs = &bu18rl82_bridge_funcs;
+
+	bu18rl82_bridge_reset(bridge);
+
+	return 0;
+
+free_bridge:
+	free(bridge);
+
+	return ret;
+}
+
+static const struct udevice_id bu18rl82_of_match[] = {
+	{ .compatible = "rohm,bu18rl82", },
+	{}
+};
+
+U_BOOT_DRIVER(bu18rl82) = {
+	.name = "bu18rl82",
+	.id = UCLASS_VIDEO_BRIDGE,
+	.of_match = bu18rl82_of_match,
+	.probe = bu18rl82_probe,
+	.priv_auto_alloc_size = sizeof(struct bu18rl82_priv),
+};
diff --git a/drivers/video/drm/rohm-bu18tl82.c b/drivers/video/drm/rohm-bu18tl82.c
new file mode 100644
index 0000000000..04b44e530f
--- /dev/null
+++ b/drivers/video/drm/rohm-bu18tl82.c
@@ -0,0 +1,270 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * (C) Copyright 2022 Rockchip Electronics Co., Ltd
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <errno.h>
+#include <i2c.h>
+#include <drm/drm_mipi_dsi.h>
+#include <video_bridge.h>
+#include <asm/unaligned.h>
+#include <linux/media-bus-format.h>
+#include <power/regulator.h>
+
+#include "rockchip_bridge.h"
+#include "rockchip_display.h"
+#include "rockchip_panel.h"
+
+struct ser_reg_sequence {
+	uint reg;
+	uint def;
+};
+
+struct serdes_init_seq {
+	struct ser_reg_sequence *reg_sequence;
+	uint reg_seq_cnt;
+};
+
+struct bu18tl82_priv {
+	struct udevice *dev;
+	struct udevice *power_supply;
+	struct gpio_desc enable_gpio;
+	struct serdes_init_seq *serdes_init_seq;
+	bool sel_mipi;
+};
+
+static void bu18tl82_bridge_reset(struct rockchip_bridge *bridge)
+{
+	int ret = 0;
+	struct udevice *dev = bridge->dev;
+	struct udevice *bus = dev_get_parent(dev);
+
+	ret = dm_i2c_reg_write(dev, 0x0011, 0x007f);
+	if (ret < 0)
+		printf("%s: failed to reset bu18tl82(%s) 0x11 ret=%d\n", __func__, bus->name, ret);
+
+	ret = dm_i2c_reg_write(dev, 0x0012, 0x0003);
+	if (ret < 0)
+		printf("%s: failed to reset bu18tl82(%s) 0x12 ret=%d\n", __func__, bus->name, ret);
+
+	mdelay(10);
+}
+
+static int bu18tl82_serdes_init_sequence_write(struct bu18tl82_priv *priv)
+{
+	struct serdes_init_seq *serdes_init_seq = priv->serdes_init_seq;
+	struct ser_reg_sequence *reg_sequence =  serdes_init_seq->reg_sequence;
+	uint cnt = serdes_init_seq->reg_seq_cnt;
+	struct udevice *dev = priv->dev;
+	uint i;
+	int ret = 0;
+
+	for (i = 0; i < cnt; i++) {
+		ret = dm_i2c_reg_write(dev, reg_sequence[i].reg, reg_sequence[i].def);
+		if (ret < 0) {
+			dev_err(priv->dev, "failed to write reg: 0x%04x\n", reg_sequence[i].reg);
+			return ret;
+		}
+	}
+
+	return ret;
+}
+
+static void bu18tl82_serdes_init(struct rockchip_bridge *bridge)
+{
+	struct udevice *dev = bridge->dev;
+	struct bu18tl82_priv *priv = dev_get_priv(dev);
+	uint i;
+	int ret;
+
+	for (i = 0; i < 10; i++) {
+		ret = bu18tl82_serdes_init_sequence_write(priv);
+		if (ret < 0) {
+			mdelay(100);
+			continue;
+		}
+
+		break;
+	}
+}
+
+static void bu18tl82_bridge_enable(struct rockchip_bridge *bridge)
+{
+}
+
+static void bu18tl82_bridge_disable(struct rockchip_bridge *bridge)
+{
+}
+
+static void bu18tl82_bridge_init(struct rockchip_bridge *bridge)
+{
+	struct udevice *dev = bridge->dev;
+	struct bu18tl82_priv *priv = dev_get_priv(dev);
+
+	if (priv->power_supply)
+		regulator_set_enable(priv->power_supply, true);
+
+	if (dm_gpio_is_valid(&priv->enable_gpio))
+		dm_gpio_set_value(&priv->enable_gpio, 1);
+
+	mdelay(5);
+
+	video_bridge_set_active(priv->dev, true);
+
+	bu18tl82_serdes_init(bridge);
+}
+
+static const struct rockchip_bridge_funcs bu18tl82_bridge_funcs = {
+	.enable = bu18tl82_bridge_enable,
+	.disable = bu18tl82_bridge_disable,
+};
+
+static int bu18tl82_parse_init_seq(struct udevice *dev, const u16 *data,
+				   int length, struct serdes_init_seq *seq)
+{
+	struct ser_reg_sequence *reg_sequence;
+	u16 *buf, *d;
+	unsigned int i, cnt;
+	int ret;
+
+	if (!seq)
+		return -EINVAL;
+
+	buf = calloc(1, length);
+	if (!buf)
+		return -ENOMEM;
+
+	memcpy(buf, data, length);
+
+	d = buf;
+	cnt = length / 4;
+	seq->reg_seq_cnt = cnt;
+
+	seq->reg_sequence = calloc(cnt, sizeof(struct ser_reg_sequence));
+	if (!seq->reg_sequence) {
+		ret = -ENOMEM;
+		goto free_buf;
+	}
+
+	for (i = 0; i < cnt; i++) {
+		reg_sequence = &seq->reg_sequence[i];
+		reg_sequence->reg = get_unaligned_be16(&d[0]);
+		reg_sequence->def = get_unaligned_be16(&d[1]);
+		d += 2;
+	}
+
+	return 0;
+
+free_buf:
+	free(buf);
+
+	return ret;
+}
+
+static int bu18tl82_get_init_seq(struct bu18tl82_priv *priv)
+{
+	const void *data = NULL;
+	int len, err;
+
+	data = dev_read_prop(priv->dev, "serdes-init-sequence", &len);
+	if (!data) {
+		printf("failed to get serdes-init-sequence\n");
+		return -EINVAL;
+	}
+
+	priv->serdes_init_seq = calloc(1, sizeof(*priv->serdes_init_seq));
+	if (!priv->serdes_init_seq)
+		return -ENOMEM;
+
+	err = bu18tl82_parse_init_seq(priv->dev, data, len, priv->serdes_init_seq);
+	if (err) {
+		printf("failed to parse serdes-init-sequence\n");
+		goto free_init_seq;
+	}
+
+	return 0;
+
+free_init_seq:
+	free(priv->serdes_init_seq);
+
+	return err;
+}
+
+static int bu18tl82_probe(struct udevice *dev)
+{
+	struct bu18tl82_priv *priv = dev_get_priv(dev);
+	struct rockchip_bridge *bridge;
+	int ret;
+
+	ret = i2c_set_chip_offset_len(dev, 2);
+	if (ret)
+		return ret;
+
+	priv->dev = dev;
+
+	ret = uclass_get_device_by_phandle(UCLASS_REGULATOR, dev,
+					   "power-supply", &priv->power_supply);
+	if (ret && ret != -ENOENT) {
+		printf("%s: Cannot get power supply: %d\n", __func__, ret);
+		return ret;
+	}
+
+	ret = gpio_request_by_name(dev, "enable-gpios", 0,
+				   &priv->enable_gpio, GPIOD_IS_OUT);
+	if (ret && ret != -ENOENT) {
+		dev_err(dev, "%s: failed to get enable GPIO: %d\n", __func__, ret);
+		return ret;
+	}
+
+	priv->sel_mipi = dev_read_bool(dev, "sel-mipi");
+	if (priv->sel_mipi) {
+		struct mipi_dsi_device *device = dev_get_platdata(dev);
+
+		device->dev = dev;
+		device->lanes = dev_read_u32_default(dev, "dsi,lanes", 4);
+		device->format = dev_read_u32_default(dev, "dsi,format",
+						      MIPI_DSI_FMT_RGB888);
+		device->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+				     MIPI_DSI_MODE_VIDEO_HBP | MIPI_DSI_MODE_LPM |
+				     MIPI_DSI_MODE_EOT_PACKET;
+		device->channel = dev_read_u32_default(dev, "reg", 0);
+	}
+
+	bridge = calloc(1, sizeof(*bridge));
+	if (!bridge)
+		return -ENOMEM;
+
+	ret = bu18tl82_get_init_seq(priv);
+	if (ret)
+		goto free_bridge;
+
+	dev->driver_data = (ulong)bridge;
+	bridge->dev = dev;
+	bridge->funcs = &bu18tl82_bridge_funcs;
+
+	bu18tl82_bridge_reset(bridge);
+	bu18tl82_bridge_init(bridge);
+
+	return 0;
+
+free_bridge:
+	free(bridge);
+
+	return ret;
+}
+
+static const struct udevice_id bu18tl82_of_match[] = {
+	{ .compatible = "rohm,bu18tl82", },
+	{}
+};
+
+U_BOOT_DRIVER(bu18tl82) = {
+	.name = "bu18tl82",
+	.id = UCLASS_VIDEO_BRIDGE,
+	.of_match = bu18tl82_of_match,
+	.probe = bu18tl82_probe,
+	.priv_auto_alloc_size = sizeof(struct bu18tl82_priv),
+	.platdata_auto_alloc_size = sizeof(struct mipi_dsi_device),
+};
diff --git a/drivers/video/drm/samsung_mipi_dcphy.c b/drivers/video/drm/samsung_mipi_dcphy.c
new file mode 100644
index 0000000000..1310553947
--- /dev/null
+++ b/drivers/video/drm/samsung_mipi_dcphy.c
@@ -0,0 +1,1857 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * (C) Copyright 2008-2018 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * Author: Guochun Huang <hero.huang@rock-chips.com>
+ */
+
+#include <config.h>
+#include <common.h>
+#include <errno.h>
+#include <dm.h>
+#include <div64.h>
+#include <asm/io.h>
+#include <asm/arch-rockchip/clock.h>
+#include <linux/ioport.h>
+#include <linux/iopoll.h>
+#include <linux/math64.h>
+#include <reset.h>
+#include <regmap.h>
+#include <syscon.h>
+
+#include "rockchip_phy.h"
+
+#define MAX_DPHY_BW	4500000L
+#define MAX_CPHY_BW	2000000L
+
+#define MSEC_PER_SEC	1000L
+#define USEC_PER_SEC	1000000LL
+#define PSEC_PER_SEC	1000000000000LL
+
+#define UPDATE(x, h, l)	(((x) << (l)) & GENMASK((h), (l)))
+#define HIWORD_UPDATE(v, h, l)	(((v) << (l)) | (GENMASK((h), (l)) << 16))
+
+#define BIAS_CON0		0x0000
+#define BIAS_CON1		0x0004
+#define BIAS_CON2		0x0008
+#define BIAS_CON4		0x0010
+#define I_MUX_SEL_MASK		GENMASK(6, 5)
+#define I_MUX_SEL(x)		UPDATE(x, 6, 5)
+
+#define PLL_CON0		0x0100
+#define PLL_EN			BIT(12)
+#define S_MASK			GENMASK(10, 8)
+#define S(x)			UPDATE(x, 10, 8)
+#define P_MASK			GENMASK(5, 0)
+#define P(x)			UPDATE(x, 5, 0)
+#define PLL_CON1		0x0104
+#define PLL_CON2		0x0108
+#define M_MASK			GENMASK(9, 0)
+#define M(x)			UPDATE(x, 9, 0)
+#define PLL_CON3		0x010c
+#define MRR_MASK		GENMASK(13, 8)
+#define MRR(x)			UPDATE(x, 13, 8)
+#define MFR_MASK                GENMASK(7, 0)
+#define MFR(x)			UPDATE(x, 7, 0)
+#define PLL_CON4		0x0110
+#define SSCG_EN			BIT(11)
+#define PLL_CON5		0x0114
+#define RESET_N_SEL		BIT(10)
+#define PLL_ENABLE_SEL		BIT(8)
+#define PLL_CON6		0x0118
+#define PLL_CON7		0x011c
+#define PLL_LOCK_CNT(x)		UPDATE(x, 15, 0)
+#define PLL_CON8		0x0120
+#define PLL_STB_CNT(x)		UPDATE(x, 15, 0)
+#define PLL_STAT0		0x0140
+#define PLL_LOCK		BIT(0)
+
+#define DPHY_MC_GNR_CON0	0x0300
+#define PHY_READY		BIT(1)
+#define PHY_ENABLE		BIT(0)
+#define DPHY_MC_GNR_CON1	0x0304
+#define T_PHY_READY(x)		UPDATE(x, 15, 0)
+#define DPHY_MC_ANA_CON0	0x0308
+#define DPHY_MC_ANA_CON1	0x030c
+#define DPHY_MC_ANA_CON2	0x0310
+#define HS_VREG_AMP_ICON(x)	UPDATE(x, 1, 0)
+#define DPHY_MC_TIME_CON0	0x0330
+#define HSTX_CLK_SEL		BIT(12)
+#define T_LPX(x)		UPDATE(x, 11, 4)
+#define DPHY_MC_TIME_CON1	0x0334
+#define T_CLK_ZERO(x)		UPDATE(x, 15, 8)
+#define T_CLK_PREPARE(x)	UPDATE(x, 7, 0)
+#define DPHY_MC_TIME_CON2	0x0338
+#define T_HS_EXIT(x)		UPDATE(x, 15, 8)
+#define T_CLK_TRAIL(x)		UPDATE(x, 7, 0)
+#define DPHY_MC_TIME_CON3	0x033c
+#define T_CLK_POST(x)		UPDATE(x, 7, 0)
+#define DPHY_MC_TIME_CON4	0x0340
+#define T_ULPS_EXIT(x)		UPDATE(x, 9, 0)
+#define DPHY_MC_DESKEW_CON0	0x0350
+#define SKEW_CAL_RUN_TIME(x)	UPDATE(x, 15, 12)
+
+#define SKEW_CAL_INIT_RUN_TIME(x)	UPDATE(x, 11, 8)
+#define SKEW_CAL_INIT_WAIT_TIME(x)	UPDATE(x, 7, 4)
+#define SKEW_CAL_EN			BIT(0)
+
+#define COMBO_MD0_GNR_CON0	0x0400
+#define COMBO_MD0_GNR_CON1	0x0404
+#define COMBO_MD0_ANA_CON0	0x0408
+#define COMBO_MD0_ANA_CON1      0x040C
+#define COMBO_MD0_ANA_CON2	0x0410
+
+#define COMBO_MD0_TIME_CON0	0x0430
+#define COMBO_MD0_TIME_CON1	0x0434
+#define COMBO_MD0_TIME_CON2	0x0438
+#define COMBO_MD0_TIME_CON3	0x043C
+#define COMBO_MD0_TIME_CON4	0x0440
+#define COMBO_MD0_DATA_CON0	0x0444
+
+#define COMBO_MD1_GNR_CON0	0x0500
+#define COMBO_MD1_GNR_CON1	0x0504
+#define COMBO_MD1_ANA_CON0	0x0508
+#define COMBO_MD1_ANA_CON1	0x050c
+#define COMBO_MD1_ANA_CON2	0x0510
+#define COMBO_MD1_TIME_CON0	0x0530
+#define COMBO_MD1_TIME_CON1	0x0534
+#define COMBO_MD1_TIME_CON2	0x0538
+#define COMBO_MD1_TIME_CON3	0x053C
+#define COMBO_MD1_TIME_CON4	0x0540
+#define COMBO_MD1_DATA_CON0	0x0544
+
+#define COMBO_MD2_GNR_CON0	0x0600
+#define COMBO_MD2_GNR_CON1	0x0604
+#define COMBO_MD2_ANA_CON0	0X0608
+#define COMBO_MD2_ANA_CON1	0X060C
+#define COMBO_MD2_ANA_CON2	0X0610
+#define COMBO_MD2_TIME_CON0	0x0630
+#define COMBO_MD2_TIME_CON1	0x0634
+#define COMBO_MD2_TIME_CON2	0x0638
+#define COMBO_MD2_TIME_CON3	0x063C
+#define COMBO_MD2_TIME_CON4	0x0640
+#define COMBO_MD2_DATA_CON0	0x0644
+
+#define DPHY_MD3_GNR_CON0	0x0700
+#define DPHY_MD3_GNR_CON1	0x0704
+#define DPHY_MD3_ANA_CON0	0X0708
+#define DPHY_MD3_ANA_CON1	0X070C
+#define DPHY_MD3_ANA_CON2	0X0710
+#define DPHY_MD3_TIME_CON0	0x0730
+#define DPHY_MD3_TIME_CON1	0x0734
+#define DPHY_MD3_TIME_CON2	0x0738
+#define DPHY_MD3_TIME_CON3	0x073C
+#define DPHY_MD3_TIME_CON4	0x0740
+#define DPHY_MD3_DATA_CON0	0x0744
+
+#define T_LP_EXIT_SKEW(x)	UPDATE(x, 3, 2)
+#define T_LP_ENTRY_SKEW(x)	UPDATE(x, 1, 0)
+#define T_HS_ZERO(x)		UPDATE(x, 15, 8)
+#define T_HS_PREPARE(x)		UPDATE(x, 7, 0)
+#define T_HS_EXIT(x)		UPDATE(x, 15, 8)
+#define T_HS_TRAIL(x)		UPDATE(x, 7, 0)
+#define T_TA_GET(x)		UPDATE(x, 7, 4)
+#define T_TA_GO(x)		UPDATE(x, 3, 0)
+
+/* MIPI_CDPHY_GRF registers */
+#define MIPI_DCPHY_GRF_CON0	0x0000
+#define S_CPHY_MODE		HIWORD_UPDATE(1, 3, 3)
+#define M_CPHY_MODE		HIWORD_UPDATE(1, 0, 0)
+
+struct samsung_mipi_dphy_timing {
+	unsigned int max_lane_mbps;
+	u8 clk_prepare;
+	u8 clk_zero;
+	u8 clk_post;
+	u8 clk_trail_eot;
+	u8 hs_prepare;
+	u8 hs_zero;
+	u8 hs_trail_eot;
+	u8 lpx;
+	u8 hs_exit;
+	u8 hs_settle;
+};
+
+struct samsung_mipi_cphy_timing {
+	unsigned int max_lane_msps;
+	u8 prepare_3;
+	u8 prebegin_3;
+	u8 post_3;
+	u8 lpx;
+	u8 hs_exit;
+	u8 settle_3;
+};
+
+struct samsung_mipi_dcphy {
+	enum phy_mode mode;
+	void *base;
+	void *grf;
+	int lanes;
+	bool c_option;
+	struct reset_ctl m_phy_rst;
+
+	struct {
+		unsigned long long rate;
+		u8 prediv;
+		u16 fbdiv;
+		long dsm;
+		u8 scaler;
+
+		bool ssc_en;
+		u8 mfr;
+		u8 mrr;
+	} pll;
+};
+
+static const
+struct samsung_mipi_dphy_timing samsung_mipi_dphy_timing_table[] = {
+	{6500, 32, 117, 31, 28, 30, 56, 27, 24, 44, 37},
+	{6490, 32, 116, 31, 28, 30, 56, 27, 24, 44, 37},
+	{6480, 32, 116, 31, 28, 30, 56, 27, 24, 44, 37},
+	{6470, 32, 116, 31, 28, 30, 56, 27, 24, 44, 37},
+	{6460, 32, 116, 31, 28, 30, 56, 27, 24, 44, 37},
+	{6450, 32, 115, 31, 28, 30, 56, 27, 24, 44, 37},
+	{6440, 32, 115, 31, 28, 30, 56, 27, 24, 44, 37},
+	{6430, 31, 116, 31, 28, 30, 55, 27, 24, 44, 37},
+	{6420, 31, 116, 31, 28, 30, 55, 27, 24, 44, 37},
+	{6410, 31, 116, 31, 27, 30, 55, 27, 24, 44, 37},
+	{6400, 31, 115, 30, 27, 30, 55, 27, 23, 43, 36},
+	{6390, 31, 115, 30, 27, 30, 55, 27, 23, 43, 36},
+	{6380, 31, 115, 30, 27, 30, 55, 27, 23, 43, 36},
+	{6370, 31, 115, 30, 27, 30, 55, 26, 23, 43, 36},
+	{6360, 31, 114, 30, 27, 30, 54, 26, 23, 43, 36},
+	{6350, 31, 114, 30, 27, 30, 54, 26, 23, 43, 36},
+	{6340, 31, 114, 30, 27, 30, 54, 26, 23, 43, 36},
+	{6330, 31, 114, 30, 27, 30, 54, 26, 23, 43, 36},
+	{6320, 31, 113, 30, 27, 30, 54, 26, 23, 43, 36},
+	{6310, 31, 113, 30, 27, 30, 54, 26, 23, 43, 36},
+	{6300, 31, 113, 30, 27, 30, 54, 26, 23, 43, 36},
+	{6290, 31, 113, 30, 27, 29, 54, 26, 23, 43, 36},
+	{6280, 31, 112, 30, 27, 29, 54, 26, 23, 43, 36},
+	{6270, 31, 112, 30, 27, 29, 54, 26, 23, 43, 36},
+	{6260, 31, 112, 30, 27, 29, 54, 26, 23, 43, 36},
+	{6250, 31, 112, 30, 27, 29, 54, 26, 23, 42, 36},
+	{6240, 30, 113, 30, 27, 29, 54, 26, 23, 42, 36},
+	{6230, 30, 112, 30, 27, 29, 54, 26, 23, 42, 35},
+	{6220, 30, 112, 30, 27, 29, 53, 26, 23, 42, 35},
+	{6210, 30, 112, 30, 27, 29, 53, 26, 23, 42, 35},
+	{6200, 30, 112, 29, 27, 29, 53, 26, 23, 42, 35},
+	{6190, 30, 111, 29, 27, 29, 53, 26, 23, 42, 35},
+	{6180, 30, 111, 29, 27, 29, 53, 26, 23, 42, 35},
+	{6170, 30, 111, 29, 26, 29, 53, 26, 23, 42, 35},
+	{6160, 30, 111, 29, 26, 29, 53, 26, 23, 42, 35},
+	{6150, 30, 110, 29, 26, 29, 53, 26, 23, 42, 35},
+	{6140, 30, 110, 29, 26, 29, 52, 26, 23, 42, 35},
+	{6130, 30, 110, 29, 26, 29, 52, 25, 22, 42, 35},
+	{6120, 30, 110, 29, 26, 29, 52, 25, 22, 42, 35},
+	{6110, 30, 110, 29, 26, 29, 52, 25, 22, 42, 35},
+	{6100, 30, 109, 29, 26, 29, 52, 25, 22, 41, 35},
+	{6090, 30, 109, 29, 26, 29, 52, 25, 22, 41, 35},
+	{6080, 30, 109, 29, 26, 28, 53, 25, 22, 41, 35},
+	{6070, 30, 109, 29, 26, 28, 52, 25, 22, 41, 34},
+	{6060, 30, 108, 29, 26, 28, 52, 25, 22, 41, 34},
+	{6050, 30, 108, 29, 26, 28, 52, 25, 22, 41, 34},
+	{6040, 29, 109, 29, 26, 28, 52, 25, 22, 41, 34},
+	{6030, 29, 109, 29, 26, 28, 52, 25, 22, 41, 34},
+	{6020, 29, 108, 29, 26, 28, 52, 25, 22, 41, 34},
+	{6010, 29, 108, 29, 26, 28, 52, 25, 22, 41, 34},
+	{6000, 29, 108, 28, 26, 28, 51, 25, 22, 41, 34},
+	{5990, 29, 108, 28, 26, 28, 51, 25, 22, 41, 34},
+	{5980, 29, 107, 28, 26, 28, 51, 25, 22, 41, 34},
+	{5970, 29, 107, 28, 26, 28, 51, 25, 22, 41, 34},
+	{5960, 29, 107, 28, 26, 28, 51, 25, 22, 40, 34},
+	{5950, 29, 107, 28, 26, 28, 51, 25, 22, 40, 34},
+	{5940, 29, 107, 28, 25, 28, 51, 25, 22, 40, 34},
+	{5930, 29, 106, 28, 25, 28, 50, 25, 22, 40, 34},
+	{5920, 29, 106, 28, 25, 28, 50, 25, 22, 40, 34},
+	{5910, 29, 106, 28, 25, 28, 50, 25, 22, 40, 34},
+	{5900, 29, 106, 28, 25, 28, 50, 24, 22, 40, 33},
+	{5890, 29, 105, 28, 25, 28, 50, 24, 22, 40, 33},
+	{5880, 29, 105, 28, 25, 28, 50, 24, 22, 40, 33},
+	{5870, 29, 105, 28, 25, 27, 51, 24, 22, 40, 33},
+	{5860, 29, 105, 28, 25, 27, 51, 24, 21, 40, 33},
+	{5850, 29, 104, 28, 25, 27, 50, 24, 21, 40, 33},
+	{5840, 28, 105, 28, 25, 27, 50, 24, 21, 40, 33},
+	{5830, 28, 105, 28, 25, 27, 50, 24, 21, 40, 33},
+	{5820, 28, 105, 28, 25, 27, 50, 24, 21, 40, 33},
+	{5810, 28, 104, 28, 25, 27, 50, 24, 21, 39, 33},
+	{5800, 28, 104, 27, 25, 27, 50, 24, 21, 39, 33},
+	{5790, 28, 104, 27, 25, 27, 50, 24, 21, 39, 33},
+	{5780, 28, 104, 27, 25, 27, 49, 24, 21, 39, 33},
+	{5770, 28, 104, 27, 25, 27, 49, 24, 21, 39, 33},
+	{5760, 28, 103, 27, 25, 27, 49, 24, 21, 39, 33},
+	{5750, 28, 103, 27, 25, 27, 49, 24, 21, 39, 33},
+	{5740, 28, 103, 27, 25, 27, 49, 24, 21, 39, 33},
+	{5730, 28, 103, 27, 25, 27, 49, 24, 21, 39, 32},
+	{5720, 28, 102, 27, 25, 27, 49, 24, 21, 39, 32},
+	{5710, 28, 102, 27, 25, 27, 48, 24, 21, 39, 32},
+	{5700, 28, 102, 27, 24, 27, 48, 24, 21, 39, 32},
+	{5690, 28, 102, 27, 24, 27, 48, 24, 21, 39, 32},
+	{5680, 28, 101, 27, 24, 27, 48, 24, 21, 39, 32},
+	{5670, 28, 101, 27, 24, 27, 48, 23, 21, 38, 32},
+	{5660, 28, 101, 27, 24, 26, 49, 23, 21, 38, 32},
+	{5650, 28, 101, 27, 24, 26, 49, 23, 21, 38, 32},
+	{5640, 27, 101, 27, 24, 26, 48, 23, 21, 38, 32},
+	{5630, 27, 101, 27, 24, 26, 48, 23, 21, 38, 32},
+	{5620, 27, 101, 27, 24, 26, 48, 23, 21, 38, 32},
+	{5610, 27, 101, 27, 24, 26, 48, 23, 21, 38, 32},
+	{5600, 27, 101, 26, 24, 26, 48, 23, 20, 38, 32},
+	{5590, 27, 100, 26, 24, 26, 48, 23, 20, 38, 32},
+	{5580, 27, 100, 26, 24, 26, 48, 23, 20, 38, 32},
+	{5570, 27, 100, 26, 24, 26, 48, 23, 20, 38, 31},
+	{5560, 27, 100, 26, 24, 26, 47, 23, 20, 38, 31},
+	{5550, 27,  99, 26, 24, 26, 47, 23, 20, 38, 31},
+	{5540, 27,  99, 26, 24, 26, 47, 23, 20, 38, 31},
+	{5530, 27,  99, 26, 24, 26, 47, 23, 20, 38, 31},
+	{5520, 27,  99, 26, 24, 26, 47, 23, 20, 37, 31},
+	{5510, 27,  98, 26, 24, 26, 47, 23, 20, 37, 31},
+	{5500, 27,  98, 26, 24, 26, 47, 23, 20, 37, 31},
+	{5490, 27,  98, 26, 24, 26, 46, 23, 20, 37, 31},
+	{5480, 27,  98, 26, 24, 26, 46, 23, 20, 37, 31},
+	{5470, 27,  97, 26, 23, 26, 46, 23, 20, 37, 31},
+	{5460, 27,  97, 26, 23, 26, 46, 23, 20, 37, 31},
+	{5450, 27,  97, 26, 23, 25, 47, 23, 20, 37, 31},
+	{5440, 26,  98, 26, 23, 25, 47, 23, 20, 37, 31},
+	{5430, 26,  98, 26, 23, 25, 47, 22, 20, 37, 31},
+	{5420, 26,  97, 26, 23, 25, 46, 22, 20, 37, 31},
+	{5410, 26,  97, 26, 23, 25, 46, 22, 20, 37, 31},
+	{5400, 26,  97, 25, 23, 25, 46, 22, 20, 37, 30},
+	{5390, 26,  97, 25, 23, 25, 46, 22, 20, 37, 30},
+	{5380, 26,  96, 25, 23, 25, 46, 22, 20, 36, 30},
+	{5370, 26,  96, 25, 23, 25, 46, 22, 20, 36, 30},
+	{5360, 26,  96, 25, 23, 25, 46, 22, 20, 36, 30},
+	{5350, 26,  96, 25, 23, 25, 46, 22, 20, 36, 30},
+	{5340, 26,  95, 25, 23, 25, 45, 22, 20, 36, 30},
+	{5330, 26,  95, 25, 23, 25, 45, 22, 19, 36, 30},
+	{5320, 26,  95, 25, 23, 25, 45, 22, 19, 36, 30},
+	{5310, 26,  95, 25, 23, 25, 45, 22, 19, 36, 30},
+	{5300, 26,  95, 25, 23, 25, 45, 22, 19, 36, 30},
+	{5290, 26,  94, 25, 23, 25, 45, 22, 19, 36, 30},
+	{5280, 26,  94, 25, 23, 25, 45, 22, 19, 36, 30},
+	{5270, 26,  94, 25, 23, 25, 44, 22, 19, 36, 30},
+	{5260, 26,  94, 25, 23, 25, 44, 22, 19, 36, 30},
+	{5250, 25,  94, 25, 23, 24, 45, 22, 19, 36, 30},
+	{5240, 25,  94, 25, 23, 24, 45, 22, 19, 36, 29},
+	{5230, 25,  94, 25, 22, 24, 45, 22, 19, 35, 29},
+	{5220, 25,  94, 25, 22, 24, 45, 22, 19, 35, 29},
+	{5210, 25,  93, 25, 22, 24, 45, 22, 19, 35, 29},
+	{5200, 25,  93, 24, 22, 24, 44, 21, 19, 35, 29},
+	{5190, 25,  93, 24, 22, 24, 44, 21, 19, 35, 29},
+	{5180, 25,  93, 24, 22, 24, 44, 21, 19, 35, 29},
+	{5170, 25,  92, 24, 22, 24, 44, 21, 19, 35, 29},
+	{5160, 25,  92, 24, 22, 24, 44, 21, 19, 35, 29},
+	{5150, 25,  92, 24, 22, 24, 44, 21, 19, 35, 29},
+	{5140, 25,  92, 24, 22, 24, 44, 21, 19, 35, 29},
+	{5130, 25,  92, 24, 22, 24, 43, 21, 19, 35, 29},
+	{5120, 25,  91, 24, 22, 24, 43, 21, 19, 35, 29},
+	{5110, 25,  91, 24, 22, 24, 43, 21, 19, 35, 29},
+	{5100, 25,  91, 24, 22, 24, 43, 21, 19, 35, 29},
+	{5090, 25,  91, 24, 22, 24, 43, 21, 19, 34, 29},
+	{5080, 25,  90, 24, 22, 24, 43, 21, 19, 34, 29},
+	{5070, 25,  90, 24, 22, 24, 43, 21, 19, 34, 28},
+	{5060, 25,  90, 24, 22, 24, 43, 21, 18, 34, 28},
+	{5050, 24,  91, 24, 22, 24, 42, 21, 18, 34, 28},
+	{5040, 24,  90, 24, 22, 23, 43, 21, 18, 34, 28},
+	{5030, 24,  90, 24, 22, 23, 43, 21, 18, 34, 28},
+	{5020, 24,  90, 24, 22, 23, 43, 21, 18, 34, 28},
+	{5010, 24,  90, 24, 22, 23, 43, 21, 18, 34, 28},
+	{5000, 24,  89, 23, 21, 23, 43, 21, 18, 34, 28},
+	{4990, 24,  89, 23, 21, 23, 43, 21, 18, 34, 28},
+	{4980, 24,  89, 23, 21, 23, 42, 21, 18, 34, 28},
+	{4970, 24,  89, 23, 21, 23, 42, 21, 18, 34, 28},
+	{4960, 24,  89, 23, 21, 23, 42, 20, 18, 34, 28},
+	{4950, 24,  88, 23, 21, 23, 42, 20, 18, 34, 28},
+	{4940, 24,  88, 23, 21, 23, 42, 20, 18, 33, 28},
+	{4930, 24,  88, 23, 21, 23, 42, 20, 18, 33, 28},
+	{4920, 24,  88, 23, 21, 23, 42, 20, 18, 33, 28},
+	{4910, 24,  87, 23, 21, 23, 41, 20, 18, 33, 28},
+	{4900, 24,  87, 23, 21, 23, 41, 20, 18, 33, 27},
+	{4890, 24,  87, 23, 21, 23, 41, 20, 18, 33, 27},
+	{4880, 24,  87, 23, 21, 23, 41, 20, 18, 33, 27},
+	{4870, 24,  86, 23, 21, 23, 41, 20, 18, 33, 27},
+	{4860, 24,  86, 23, 21, 23, 41, 20, 18, 33, 27},
+	{4850, 23,  87, 23, 21, 23, 41, 20, 18, 33, 27},
+	{4840, 23,  87, 23, 21, 23, 40, 20, 18, 33, 27},
+	{4830, 23,  86, 23, 21, 22, 41, 20, 18, 33, 27},
+	{4820, 23,  86, 23, 21, 22, 41, 20, 18, 33, 27},
+	{4810, 23,  86, 23, 21, 22, 41, 20, 18, 33, 27},
+	{4800, 23,  86, 22, 21, 22, 41, 20, 17, 32, 27},
+	{4790, 23,  86, 22, 21, 22, 41, 20, 17, 32, 27},
+	{4780, 23,  85, 22, 21, 22, 41, 20, 17, 32, 27},
+	{4770, 23,  85, 22, 21, 22, 41, 20, 17, 32, 27},
+	{4760, 23,  85, 22, 20, 22, 40, 20, 17, 32, 27},
+	{4750, 23,  85, 22, 20, 22, 40, 20, 17, 32, 27},
+	{4740, 23,  84, 22, 20, 22, 40, 20, 17, 32, 26},
+	{4730, 23,  84, 22, 20, 22, 40, 19, 17, 32, 26},
+	{4720, 23,  84, 22, 20, 22, 40, 19, 17, 32, 26},
+	{4710, 23,  84, 22, 20, 22, 40, 19, 17, 32, 26},
+	{4700, 23,  83, 22, 20, 22, 40, 19, 17, 32, 26},
+	{4690, 23,  83, 22, 20, 22, 39, 19, 17, 32, 26},
+	{4680, 23,  83, 22, 20, 22, 39, 19, 17, 32, 26},
+	{4670, 23,  83, 22, 20, 22, 39, 19, 17, 32, 26},
+	{4660, 23,  82, 22, 20, 22, 39, 19, 17, 32, 26},
+	{4650, 22,  83, 22, 20, 22, 39, 19, 17, 31, 26},
+	{4640, 22,  83, 22, 20, 22, 39, 19, 17, 31, 26},
+	{4630, 22,  83, 22, 20, 22, 39, 19, 17, 31, 26},
+	{4620, 22,  83, 22, 20, 21, 39, 19, 17, 31, 26},
+	{4610, 22,  82, 22, 20, 21, 39, 19, 17, 31, 26},
+	{4600, 22,  82, 21, 20, 21, 39, 19, 17, 31, 26},
+	{4590, 22,  82, 21, 20, 21, 39, 19, 17, 31, 26},
+	{4580, 22,  82, 21, 20, 21, 39, 19, 17, 31, 26},
+	{4570, 22,  81, 21, 20, 21, 39, 19, 17, 31, 25},
+	{4560, 22,  81, 21, 20, 21, 39, 19, 17, 31, 25},
+	{4550, 22,  81, 21, 20, 21, 38, 19, 17, 31, 25},
+	{4540, 22,  81, 21, 20, 21, 38, 19, 17, 31, 25},
+	{4530, 22,  80, 21, 19, 21, 38, 19, 16, 31, 25},
+	{4520, 22,  80, 21, 19, 21, 38, 19, 16, 31, 25},
+	{4510, 22,  80, 21, 19, 21, 38, 19, 16, 31, 25},
+	{4500, 22,  80, 21, 19, 21, 38, 19, 16, 30, 25},
+	{4490, 22,  80, 21, 19, 21, 38, 18, 16, 30, 25},
+	{4480, 22,  79, 21, 19, 21, 38, 18, 16, 30, 25},
+	{4470, 22,  79, 21, 19, 21, 37, 18, 16, 30, 25},
+	{4460, 22,  79, 21, 19, 21, 37, 18, 16, 30, 25},
+	{4450, 21,  80, 21, 19, 21, 37, 18, 16, 30, 25},
+	{4440, 21,  79, 21, 19, 21, 37, 18, 16, 30, 25},
+	{4430, 21,  79, 21, 19, 21, 37, 18, 16, 30, 25},
+	{4420, 21,  79, 21, 19, 21, 37, 18, 16, 30, 25},
+	{4410, 21,  79, 21, 19, 20, 38, 18, 16, 30, 25},
+	{4400, 21,  78, 20, 19, 20, 37, 18, 16, 30, 24},
+	{4390, 21,  78, 20, 19, 20, 37, 18, 16, 30, 24},
+	{4380, 21,  78, 20, 19, 20, 37, 18, 16, 30, 24},
+	{4370, 21,  78, 20, 19, 20, 37, 18, 16, 30, 24},
+	{4360, 21,  77, 20, 19, 20, 37, 18, 16, 29, 24},
+	{4350, 21,  77, 20, 19, 20, 37, 18, 16, 29, 24},
+	{4340, 21,  77, 20, 19, 20, 37, 18, 16, 29, 24},
+	{4330, 21,  77, 20, 19, 20, 36, 18, 16, 29, 24},
+	{4320, 21,  77, 20, 19, 20, 36, 18, 16, 29, 24},
+	{4310, 21,  76, 20, 19, 20, 36, 18, 16, 29, 24},
+	{4300, 21,  76, 20, 18, 20, 36, 18, 16, 29, 24},
+	{4290, 21,  76, 20, 18, 20, 36, 18, 16, 29, 24},
+	{4280, 21,  76, 20, 18, 20, 36, 18, 16, 29, 24},
+	{4270, 21,  75, 20, 18, 20, 36, 18, 16, 29, 24},
+	{4260, 21,  75, 20, 18, 20, 35, 17, 15, 29, 24},
+	{4250, 20,  76, 20, 18, 20, 35, 17, 15, 29, 24},
+	{4240, 20,  76, 20, 18, 20, 35, 17, 15, 29, 23},
+	{4230, 20,  75, 20, 18, 20, 35, 17, 15, 29, 23},
+	{4220, 20,  75, 20, 18, 20, 35, 17, 15, 29, 23},
+	{4210, 20,  75, 20, 18, 20, 35, 17, 15, 28, 23},
+	{4200, 20,  75, 19, 18, 19, 36, 17, 15, 28, 23},
+	{4190, 20,  74, 19, 18, 19, 36, 17, 15, 28, 23},
+	{4180, 20,  74, 19, 18, 19, 35, 17, 15, 28, 23},
+	{4170, 20,  74, 19, 18, 19, 35, 17, 15, 28, 23},
+	{4160, 20,  74, 19, 18, 19, 35, 17, 15, 28, 23},
+	{4150, 20,  74, 19, 18, 19, 35, 17, 15, 28, 23},
+	{4140, 20,  73, 19, 18, 19, 35, 17, 15, 28, 23},
+	{4130, 20,  73, 19, 18, 19, 35, 17, 15, 28, 23},
+	{4120, 20,  73, 19, 18, 19, 35, 17, 15, 28, 23},
+	{4110, 20,  73, 19, 18, 19, 34, 17, 15, 28, 23},
+	{4100, 20,  72, 19, 18, 19, 34, 17, 15, 28, 23},
+	{4090, 20,  72, 19, 18, 19, 34, 17, 15, 28, 23},
+	{4080, 20,  72, 19, 18, 19, 34, 17, 15, 28, 23},
+	{4070, 20,  72, 19, 18, 19, 34, 17, 15, 27, 22},
+	{4060, 19,  72, 19, 17, 19, 34, 17, 15, 27, 22},
+	{4050, 19,  72, 19, 17, 19, 34, 17, 15, 27, 22},
+	{4040, 19,  72, 19, 17, 19, 33, 17, 15, 27, 22},
+	{4030, 19,  72, 19, 17, 19, 33, 17, 15, 27, 22},
+	{4020, 19,  71, 19, 17, 19, 33, 16, 15, 27, 22},
+	{4010, 19,  71, 19, 17, 19, 33, 16, 15, 27, 22},
+	{4000, 19,  71, 18, 17, 19, 33, 16, 14, 27, 22},
+	{3990, 19,  71, 18, 17, 18, 34, 16, 14, 27, 22},
+	{3980, 19,  71, 18, 17, 18, 34, 16, 14, 27, 22},
+	{3970, 19,  70, 18, 17, 18, 33, 16, 14, 27, 22},
+	{3960, 19,  70, 18, 17, 18, 33, 16, 14, 27, 22},
+	{3950, 19,  70, 18, 17, 18, 33, 16, 14, 27, 22},
+	{3940, 19,  70, 18, 17, 18, 33, 16, 14, 27, 22},
+	{3930, 19,  69, 18, 17, 18, 33, 16, 14, 27, 22},
+	{3920, 19,  69, 18, 17, 18, 33, 16, 14, 26, 22},
+	{3910, 19,  69, 18, 17, 18, 33, 16, 14, 26, 22},
+	{3900, 19,  69, 18, 17, 18, 33, 16, 14, 26, 21},
+	{3890, 19,  68, 18, 17, 18, 32, 16, 14, 26, 21},
+	{3880, 19,  68, 18, 17, 18, 32, 16, 14, 26, 21},
+	{3870, 19,  68, 18, 17, 18, 32, 16, 14, 26, 21},
+	{3860, 18,  69, 18, 17, 18, 32, 16, 14, 26, 21},
+	{3850, 18,  68, 18, 17, 18, 32, 16, 14, 26, 21},
+	{3840, 18,  68, 18, 17, 18, 32, 16, 14, 26, 21},
+	{3830, 18,  68, 18, 16, 18, 32, 16, 14, 26, 21},
+	{3820, 18,  68, 18, 16, 18, 31, 16, 14, 26, 21},
+	{3810, 18,  68, 18, 16, 18, 31, 16, 14, 26, 21},
+	{3800, 18,  67, 17, 16, 18, 31, 16, 14, 26, 21},
+	{3790, 18,  67, 17, 16, 17, 32, 15, 14, 26, 21},
+	{3780, 18,  67, 17, 16, 17, 32, 15, 14, 25, 21},
+	{3770, 18,  67, 17, 16, 17, 32, 15, 14, 25, 21},
+	{3760, 18,  66, 17, 16, 17, 32, 15, 14, 25, 21},
+	{3750, 18,  66, 17, 16, 17, 31, 15, 14, 25, 21},
+	{3740, 18,  66, 17, 16, 17, 31, 15, 14, 25, 20},
+	{3730, 18,  66, 17, 16, 17, 31, 15, 13, 25, 20},
+	{3720, 18,  65, 17, 16, 17, 31, 15, 13, 25, 20},
+	{3710, 18,  65, 17, 16, 17, 31, 15, 13, 25, 20},
+	{3700, 18,  65, 17, 16, 17, 31, 15, 13, 25, 20},
+	{3690, 18,  65, 17, 16, 17, 31, 15, 13, 25, 20},
+	{3680, 18,  64, 17, 16, 17, 31, 15, 13, 25, 20},
+	{3670, 18,  64, 17, 16, 17, 30, 15, 13, 25, 20},
+	{3660, 17,  65, 17, 16, 17, 30, 15, 13, 25, 20},
+	{3650, 17,  65, 17, 16, 17, 30, 15, 13, 25, 20},
+	{3640, 17,  65, 17, 16, 17, 30, 15, 13, 25, 20},
+	{3630, 17,  64, 17, 16, 17, 30, 15, 13, 24, 20},
+	{3620, 17,  64, 17, 16, 17, 30, 15, 13, 24, 20},
+	{3610, 17,  64, 17, 16, 17, 30, 15, 13, 24, 20},
+	{3600, 17,  64, 16, 16, 17, 29, 15, 13, 24, 20},
+	{3590, 17,  63, 16, 15, 17, 29, 15, 13, 24, 20},
+	{3580, 17,  63, 16, 15, 16, 30, 15, 13, 24, 20},
+	{3570, 17,  63, 16, 15, 16, 30, 15, 13, 24, 19},
+	{3560, 17,  63, 16, 15, 16, 30, 14, 13, 24, 19},
+	{3550, 17,  62, 16, 15, 16, 30, 14, 13, 24, 19},
+	{3540, 17,  62, 16, 15, 16, 30, 14, 13, 24, 19},
+	{3530, 17,  62, 16, 15, 16, 29, 14, 13, 24, 19},
+	{3520, 17,  62, 16, 15, 16, 29, 14, 13, 24, 19},
+	{3510, 17,  62, 16, 15, 16, 29, 14, 13, 24, 19},
+	{3500, 17,  61, 16, 15, 16, 29, 14, 13, 24, 19},
+	{3490, 17,  61, 16, 15, 16, 29, 14, 13, 23, 19},
+	{3480, 17,  61, 16, 15, 16, 29, 14, 13, 23, 19},
+	{3470, 17,  61, 16, 15, 16, 29, 14, 13, 23, 19},
+	{3460, 16,  61, 16, 15, 16, 28, 14, 12, 23, 19},
+	{3450, 16,  61, 16, 15, 16, 28, 14, 12, 23, 19},
+	{3440, 16,  61, 16, 15, 16, 28, 14, 12, 23, 19},
+	{3430, 16,  61, 16, 15, 16, 28, 14, 12, 23, 19},
+	{3420, 16,  60, 16, 15, 16, 28, 14, 12, 23, 19},
+	{3410, 16,  60, 16, 15, 16, 28, 14, 12, 23, 18},
+	{3400, 16,  60, 15, 15, 16, 28, 14, 12, 23, 18},
+	{3390, 16,  60, 15, 15, 16, 28, 14, 12, 23, 18},
+	{3380, 16,  59, 15, 15, 16, 27, 14, 12, 23, 18},
+	{3370, 16,  59, 15, 15, 15, 28, 14, 12, 23, 18},
+	{3360, 16,  59, 15, 14, 15, 28, 14, 12, 23, 18},
+	{3350, 16,  59, 15, 14, 15, 28, 14, 12, 23, 18},
+	{3340, 16,  59, 15, 14, 15, 28, 14, 12, 22, 18},
+	{3330, 16,  58, 15, 14, 15, 28, 14, 12, 22, 18},
+	{3320, 16,  58, 15, 14, 15, 28, 13, 12, 22, 18},
+	{3310, 16,  58, 15, 14, 15, 27, 13, 12, 22, 18},
+	{3300, 16,  58, 15, 14, 15, 27, 13, 12, 22, 18},
+	{3290, 16,  57, 15, 14, 15, 27, 13, 12, 22, 18},
+	{3280, 16,  57, 15, 14, 15, 27, 13, 12, 22, 18},
+	{3270, 16,  57, 15, 14, 15, 27, 13, 12, 22, 18},
+	{3260, 15,  58, 15, 14, 15, 27, 13, 12, 22, 18},
+	{3250, 15,  57, 15, 14, 15, 27, 13, 12, 22, 18},
+	{3240, 15,  57, 15, 14, 15, 26, 13, 12, 22, 17},
+	{3230, 15,  57, 15, 14, 15, 26, 13, 12, 22, 17},
+	{3220, 15,  57, 15, 14, 15, 26, 13, 12, 22, 17},
+	{3210, 15,  56, 15, 14, 15, 26, 13, 12, 22, 17},
+	{3200, 15,  56, 14, 14, 15, 26, 13, 11, 21, 17},
+	{3190, 15,  56, 14, 14, 15, 26, 13, 11, 21, 17},
+	{3180, 15,  56, 14, 14, 15, 26, 13, 11, 21, 17},
+	{3170, 15,  56, 14, 14, 15, 25, 13, 11, 21, 17},
+	{3160, 15,  55, 14, 14, 14, 26, 13, 11, 21, 17},
+	{3150, 15,  55, 14, 14, 14, 26, 13, 11, 21, 17},
+	{3140, 15,  55, 14, 14, 14, 26, 13, 11, 21, 17},
+	{3130, 15,  55, 14, 14, 14, 26, 13, 11, 21, 17},
+	{3120, 15,  54, 14, 13, 14, 26, 13, 11, 21, 17},
+	{3110, 15,  54, 14, 13, 14, 26, 13, 11, 21, 17},
+	{3100, 15,  54, 14, 13, 14, 26, 13, 11, 21, 17},
+	{3090, 15,  54, 14, 13, 14, 25, 12, 11, 21, 17},
+	{3080, 15,  53, 14, 13, 14, 25, 12, 11, 21, 17},
+	{3070, 14,  54, 14, 13, 14, 25, 12, 11, 21, 16},
+	{3060, 14,  54, 14, 13, 14, 25, 12, 11, 21, 16},
+	{3050, 14,  54, 14, 13, 14, 25, 12, 11, 20, 16},
+	{3040, 14,  53, 14, 13, 14, 25, 12, 11, 20, 16},
+	{3030, 14,  53, 14, 13, 14, 25, 12, 11, 20, 16},
+	{3020, 14,  53, 14, 13, 14, 24, 12, 11, 20, 16},
+	{3010, 14,  53, 14, 13, 14, 24, 12, 11, 20, 16},
+	{3000, 14,  53, 13, 13, 14, 24, 12, 11, 20, 16},
+	{2990, 14,  52, 13, 13, 14, 24, 12, 11, 20, 16},
+	{2980, 14,  52, 13, 13, 14, 24, 12, 11, 20, 16},
+	{2970, 14,  52, 13, 13, 14, 24, 12, 11, 20, 16},
+	{2960, 14,  52, 13, 13, 14, 24, 12, 11, 20, 16},
+	{2950, 14,  51, 13, 13, 13, 24, 12, 11, 20, 16},
+	{2940, 14,  51, 13, 13, 13, 24, 12, 11, 20, 16},
+	{2930, 14,  51, 13, 13, 13, 24, 12, 10, 20, 16},
+	{2920, 14,  51, 13, 13, 13, 24, 12, 10, 20, 16},
+	{2910, 14,  50, 13, 13, 13, 24, 12, 10, 20, 15},
+	{2900, 14,  50, 13, 13, 13, 24, 12, 10, 19, 15},
+	{2890, 14,  50, 13, 12, 13, 24, 12, 10, 19, 15},
+	{2880, 14,  50, 13, 12, 13, 23, 12, 10, 19, 15},
+	{2870, 13,  50, 13, 12, 13, 23, 12, 10, 19, 15},
+	{2860, 13,  50, 13, 12, 13, 23, 12, 10, 19, 15},
+	{2850, 13,  50, 13, 12, 13, 23, 11, 10, 19, 15},
+	{2840, 13,  50, 13, 12, 13, 23, 11, 10, 19, 15},
+	{2830, 13,  50, 13, 12, 13, 23, 11, 10, 19, 15},
+	{2820, 13,  49, 13, 12, 13, 23, 11, 10, 19, 15},
+	{2810, 13,  49, 13, 12, 13, 23, 11, 10, 19, 15},
+	{2800, 13,  49, 12, 12, 13, 22, 11, 10, 19, 15},
+	{2790, 13,  49, 12, 12, 13, 22, 11, 10, 19, 15},
+	{2780, 13,  48, 12, 12, 13, 22, 11, 10, 19, 15},
+	{2770, 13,  48, 12, 12, 13, 22, 11, 10, 19, 15},
+	{2760, 13,  48, 12, 12, 13, 22, 11, 10, 18, 15},
+	{2750, 13,  48, 12, 12, 13, 22, 11, 10, 18, 15},
+	{2740, 13,  47, 12, 12, 12, 23, 11, 10, 18, 14},
+	{2730, 13,  47, 12, 12, 12, 22, 11, 10, 18, 14},
+	{2720, 13,  47, 12, 12, 12, 22, 11, 10, 18, 14},
+	{2710, 13,  47, 12, 12, 12, 22, 11, 10, 18, 14},
+	{2700, 13,  47, 12, 12, 12, 22, 11, 10, 18, 14},
+	{2690, 13,  46, 12, 12, 12, 22, 11, 10, 18, 14},
+	{2680, 13,  46, 12, 12, 12, 22, 11, 10, 18, 14},
+	{2670, 12,  47, 12, 12, 12, 22, 11, 10, 18, 14},
+	{2660, 12,  47, 12, 12, 12, 21, 11,  9, 18, 14},
+	{2650, 12,  46, 12, 11, 12, 21, 11,  9, 18, 14},
+	{2640, 12,  46, 12, 11, 12, 21, 11,  9, 18, 14},
+	{2630, 12,  46, 12, 11, 12, 21, 11,  9, 18, 14},
+	{2620, 12,  46, 12, 11, 12, 21, 10,  9, 18, 14},
+	{2610, 12,  45, 12, 11, 12, 21, 10,  9, 17, 14},
+	{2600, 12,  45, 11, 11, 12, 21, 10,  9, 17, 14},
+	{2590, 12,  45, 11, 11, 12, 20, 10,  9, 17, 14},
+	{2580, 12,  45, 11, 11, 12, 20, 10,  9, 17, 14},
+	{2570, 12,  44, 11, 11, 12, 20, 10,  9, 17, 13},
+	{2560, 12,  44, 11, 11, 12, 20, 10,  9, 17, 13},
+	{2550, 12,  44, 11, 11, 12, 20, 10,  9, 17, 13},
+	{2540, 12,  44, 11, 11, 11, 21, 10,  9, 17, 13},
+	{2530, 12,  44, 11, 11, 11, 21, 10,  9, 17, 13},
+	{2520, 12,  43, 11, 11, 11, 21, 10,  9, 17, 13},
+	{2510, 12,  43, 11, 11, 11, 20, 10,  9, 17, 13},
+	{2500, 12,  43, 11, 11, 11, 20, 10,  9, 17, 13},
+	{2490, 12,  43, 11, 11, 11, 20, 10,  9, 17, 13},
+	{2480, 12,  42, 11, 11, 11, 20, 10,  9, 17, 13},
+	{2470, 11,  43, 11, 11, 11, 20, 10,  9, 16, 13},
+	{2460, 11,  43, 11, 11, 11, 20, 10,  9, 16, 13},
+	{2450, 11,  43, 11, 11, 11, 20, 10,  9, 16, 13},
+	{2440, 11,  42, 11, 11, 11, 19, 10,  9, 16, 13},
+	{2430, 11,  42, 11, 11, 11, 19, 10,  9, 16, 13},
+	{2420, 11,  42, 11, 10, 11, 19, 10,  9, 16, 13},
+	{2410, 11,  42, 11, 10, 11, 19, 10,  9, 16, 12},
+	{2400, 11,  41, 10, 10, 11, 19, 10,  8, 16, 12},
+	{2390, 11,  41, 10, 10, 11, 19, 10,  8, 16, 12},
+	{2380, 11,  41, 10, 10, 11, 19,  9,  8, 16, 12},
+	{2370, 11,  41, 10, 10, 11, 18,  9,  8, 16, 12},
+	{2360, 11,  41, 10, 10, 11, 18,  9,  8, 16, 12},
+	{2350, 11,  40, 10, 10, 11, 18,  9,  8, 16, 12},
+	{2340, 11,  40, 10, 10, 11, 18,  9,  8, 16, 12},
+	{2330, 11,  40, 10, 10, 10, 19,  9,  8, 16, 12},
+	{2320, 11,  40, 10, 10, 10, 19,  9,  8, 15, 12},
+	{2310, 11,  39, 10, 10, 10, 19,  9,  8, 15, 12},
+	{2300, 11,  39, 10, 10, 10, 18,  9,  8, 15, 12},
+	{2290, 11,  39, 10, 10, 10, 18,  9,  8, 15, 12},
+	{2280, 11,  39, 10, 10, 10, 18,  9,  8, 15, 12},
+	{2270, 10,  39, 10, 10, 10, 18,  9,  8, 15, 12},
+	{2260, 10,  39, 10, 10, 10, 18,  9,  8, 15, 12},
+	{2250, 10,  39, 10, 10, 10, 18,  9,  8, 15, 12},
+	{2240, 10,  39, 10, 10, 10, 18,  9,  8, 15, 11},
+	{2230, 10,  38, 10, 10, 10, 18,  9,  8, 15, 11},
+	{2220, 10,  38, 10, 10, 10, 17,  9,  8, 15, 11},
+	{2210, 10,  38, 10, 10, 10, 17,  9,  8, 15, 11},
+	{2200, 10,  38,  9, 10, 10, 17,  9,  8, 15, 11},
+	{2190, 10,  38,  9,  9, 10, 17,  9,  8, 15, 11},
+	{2180, 10,  37,  9,  9, 10, 17,  9,  8, 14, 11},
+	{2170, 10,  37,  9,  9, 10, 17,  9,  8, 14, 11},
+	{2160, 10,  37,  9,  9, 10, 17,  9,  8, 14, 11},
+	{2150, 10,  37,  9,  9, 10, 16,  8,  8, 14, 11},
+	{2140, 10,  36,  9,  9, 10, 16,  8,  8, 14, 11},
+	{2130, 10,  36,  9,  9, 10, 16,  8,  7, 14, 11},
+	{2120, 10,  36,  9,  9,  9, 17,  8,  7, 14, 11},
+	{2110, 10,  36,  9,  9,  9, 17,  8,  7, 14, 11},
+	{2100, 10,  35,  9,  9,  9, 17,  8,  7, 14, 11},
+	{2090, 10,  35,  9,  9,  9, 17,  8,  7, 14, 11},
+	{2080,  9,  36,  9,  9,  9, 16,  8,  7, 14, 11},
+	{2070,  9,  36,  9,  9,  9, 16,  8,  7, 14, 10},
+	{2060,  9,  35,  9,  9,  9, 16,  8,  7, 14, 10},
+	{2050,  9,  35,  9,  9,  9, 16,  8,  7, 14, 10},
+	{2040,  9,  35,  9,  9,  9, 16,  8,  7, 14, 10},
+	{2030,  9,  35,  9,  9,  9, 16,  8,  7, 13, 10},
+	{2020,  9,  35,  9,  9,  9, 16,  8,  7, 13, 10},
+	{2010,  9,  34,  9,  9,  9, 15,  8,  7, 13, 10},
+	{2000,  9,  34,  8,  9,  9, 15,  8,  7, 13, 10},
+	{1990,  9,  34,  8,  9,  9, 15,  8,  7, 13, 10},
+	{1980,  9,  34,  8,  9,  9, 15,  8,  7, 13, 10},
+	{1970,  9,  33,  8,  9,  9, 15,  8,  7, 13, 10},
+	{1960,  9,  33,  8,  9,  9, 15,  8,  7, 13, 10},
+	{1950,  9,  33,  8,  8,  9, 15,  8,  7, 13, 10},
+	{1940,  9,  33,  8,  8,  9, 15,  8,  7, 13, 10},
+	{1930,  9,  32,  8,  8,  9, 14,  8,  7, 13, 10},
+	{1920,  9,  32,  8,  8,  9, 14,  8,  7, 13, 10},
+	{1910,  9,  32,  8,  8,  8, 15,  7,  7, 13,  9},
+	{1900,  9,  32,  8,  8,  8, 15,  7,  7, 13,  9},
+	{1890,  9,  31,  8,  8,  8, 15,  7,  7, 12,  9},
+	{1880,  8,  32,  8,  8,  8, 15,  7,  7, 12,  9},
+	{1870,  8,  32,  8,  8,  8, 15,  7,  7, 12,  9},
+	{1860,  8,  32,  8,  8,  8, 14,  7,  6, 12,  9},
+	{1850,  8,  32,  8,  8,  8, 14,  7,  6, 12,  9},
+	{1840,  8,  31,  8,  8,  8, 14,  7,  6, 12,  9},
+	{1830,  8,  31,  8,  8,  8, 14,  7,  6, 12,  9},
+	{1820,  8,  31,  8,  8,  8, 14,  7,  6, 12,  9},
+	{1810,  8,  31,  8,  8,  8, 14,  7,  6, 12,  9},
+	{1800,  8,  30,  7,  8,  8, 14,  7,  6, 12,  9},
+	{1790,  8,  30,  7,  8,  8, 13,  7,  6, 12,  9},
+	{1780,  8,  30,  7,  8,  8, 13,  7,  6, 12,  9},
+	{1770,  8,  30,  7,  8,  8, 13,  7,  6, 12,  9},
+	{1760,  8,  29,  7,  8,  8, 13,  7,  6, 12,  9},
+	{1750,  8,  29,  7,  8,  8, 13,  7,  6, 12,  9},
+	{1740,  8,  29,  7,  8,  8, 13,  7,  6, 11,  8},
+	{1730,  8,  29,  7,  8,  8, 13,  7,  6, 11,  8},
+	{1720,  8,  29,  7,  7,  8, 13,  7,  6, 11,  8},
+	{1710,  8,  28,  7,  7,  8, 12,  7,  6, 11,  8},
+	{1700,  8,  28,  7,  7,  7, 13,  7,  6, 11,  8},
+	{1690,  8,  28,  7,  7,  7, 13,  7,  6, 11,  8},
+	{1680,  7,  29,  7,  7,  7, 13,  6,  6, 11,  8},
+	{1670,  7,  28,  7,  7,  7, 13,  6,  6, 11,  8},
+	{1660,  7,  28,  7,  7,  7, 13,  6,  6, 11,  8},
+	{1650,  7,  28,  7,  7,  7, 13,  6,  6, 11,  8},
+	{1640,  7,  28,  7,  7,  7, 12,  6,  6, 11,  8},
+	{1630,  7,  27,  7,  7,  7, 12,  6,  6, 11,  8},
+	{1620,  7,  27,  7,  7,  7, 12,  6,  6, 11,  8},
+	{1610,  7,  27,  7,  7,  7, 12,  6,  6, 11,  8},
+	{1600,  7,  27,  6,  7,  7, 12,  6,  5, 10,  8},
+	{1590,  7,  26,  6,  7,  7, 12,  6,  5, 10,  8},
+	{1580,  7,  26,  6,  7,  7, 12,  6,  5, 10,  7},
+	{1570,  7,  26,  6,  7,  7, 11,  6,  5, 10,  7},
+	{1560,  7,  26,  6,  7,  7, 11,  6,  5, 10,  7},
+	{1550,  7,  26,  6,  7,  7, 11,  6,  5, 10,  7},
+	{1540,  7,  25,  6,  7,  7, 11,  6,  5, 10,  7},
+	{1530,  7,  25,  6,  7,  7, 11,  6,  5, 10,  7},
+	{1520,  7,  25,  6,  7,  7, 11,  6,  5, 10,  7},
+	{1510,  7,  25,  6,  7,  7, 11,  6,  5, 10,  7},
+	{1500,  7,  24,  6,  7,  7, 10,  6,  5, 10,  7},
+	{1490, 59,  25,  6, 77, 59, 10, 70, 44,  9, 73},
+	{1480, 59,  24,  6, 76, 58, 10, 70, 44,  9, 73},
+	{1470, 58,  24,  6, 76, 58, 10, 69, 44,  9, 72},
+	{1460, 58,  24,  6, 76, 58, 10, 69, 43,  9, 72},
+	{1450, 58,  24,  6, 75, 57, 10, 68, 43,  9, 71},
+	{1440, 57,  24,  6, 75, 57, 10, 68, 43,  9, 71},
+	{1430, 57,  23,  6, 75, 57, 10, 68, 43,  8, 70},
+	{1420, 56,  23,  6, 74, 57,  9, 67, 43,  8, 70},
+	{1410, 56,  23,  6, 74, 57,  9, 67, 43,  8, 69},
+	{1400, 56,  23,  5, 74, 55,  9, 67, 41,  8, 69},
+	{1390, 55,  23,  5, 73, 55,  9, 66, 41,  8, 68},
+	{1380, 55,  23,  5, 73, 54,  9, 66, 41,  8, 68},
+	{1370, 54,  22,  5, 72, 54,  9, 66, 41,  8, 67},
+	{1360, 54,  22,  5, 72, 54,  9, 65, 40,  8, 67},
+	{1350, 54,  22,  5, 72, 53,  9, 65, 40,  8, 66},
+	{1340, 53,  22,  5, 71, 53,  9, 65, 40,  8, 66},
+	{1330, 53,  22,  5, 71, 53,  9, 64, 39,  8, 65},
+	{1320, 52,  22,  5, 71, 53,  8, 64, 40,  8, 65},
+	{1310, 52,  21,  5, 70, 53,  8, 64, 40,  8, 64},
+	{1300, 51,  21,  5, 70, 51,  8, 63, 38,  8, 64},
+	{1290, 51,  21,  5, 70, 51,  8, 63, 38,  7, 64},
+	{1280, 51,  21,  5, 69, 51,  8, 63, 38,  7, 63},
+	{1270, 50,  21,  5, 69, 50,  8, 62, 38,  7, 63},
+	{1260, 50,  20,  5, 69, 50,  8, 62, 37,  7, 62},
+	{1250, 49,  20,  5, 68, 49,  8, 62, 37,  7, 62},
+	{1240, 49,  20,  5, 68, 49,  8, 61, 37,  7, 61},
+	{1230, 49,  20,  5, 68, 49,  8, 61, 36,  7, 61},
+	{1220, 48,  20,  5, 67, 48,  8, 61, 36,  7, 60},
+	{1210, 48,  19,  5, 67, 48,  7, 60, 36,  7, 60},
+	{1200, 49,  19,  4, 67, 49,  7, 60, 36,  7, 59},
+	{1190, 48,  19,  4, 66, 48,  7, 60, 36,  7, 59},
+	{1180, 48,  19,  4, 66, 48,  7, 59, 36,  7, 58},
+	{1170, 46,  19,  4, 66, 46,  7, 59, 35,  7, 58},
+	{1160, 46,  18,  4, 65, 46,  7, 59, 34,  7, 57},
+	{1150, 45,  18,  4, 65, 46,  7, 58, 34,  7, 57},
+	{1140, 45,  18,  4, 65, 45,  7, 58, 34,  6, 56},
+	{1130, 45,  18,  4, 64, 45,  7, 58, 33,  6, 56},
+	{1120, 44,  18,  4, 64, 44,  7, 57, 33,  6, 55},
+	{1110, 44,  18,  4, 64, 44,  7, 57, 33,  6, 55},
+	{1100, 43,  17,  4, 63, 44,  6, 57, 32,  6, 54},
+	{1090, 43,  17,  4, 63, 44,  6, 56, 33,  6, 54},
+	{1080, 43,  17,  4, 63, 44,  6, 56, 33,  6, 53},
+	{1070, 42,  17,  4, 62, 44,  6, 56, 33,  6, 53},
+	{1060, 42,  17,  4, 62, 42,  6, 55, 31,  6, 52},
+	{1050, 41,  17,  4, 62, 42,  6, 55, 31,  6, 52},
+	{1040, 41,  16,  4, 61, 41,  6, 54, 31,  6, 52},
+	{1030, 41,  16,  4, 61, 41,  6, 54, 30,  6, 51},
+	{1020, 40,  16,  4, 61, 41,  6, 54, 30,  6, 51},
+	{1010, 40,  16,  4, 60, 40,  6, 53, 30,  6, 50},
+	{1000, 39,  16,  3, 60, 40,  6, 53, 29,  5, 50},
+	{ 990, 39,  15,  3, 60, 39,  6, 53, 29,  5, 49},
+	{ 980, 39,  15,  3, 59, 39,  5, 52, 29,  5, 49},
+	{ 970, 38,  15,  3, 59, 39,  5, 52, 29,  5, 48},
+	{ 960, 38,  15,  3, 59, 39,  5, 52, 29,  5, 48},
+	{ 950, 37,  15,  3, 58, 39,  5, 51, 29,  5, 47},
+	{ 940, 37,  14,  3, 58, 39,  5, 51, 29,  5, 47},
+	{ 930, 37,  14,  3, 57, 37,  5, 51, 27,  5, 46},
+	{ 920, 36,  14,  3, 57, 37,  5, 50, 27,  5, 46},
+	{ 910, 36,  14,  3, 57, 36,  5, 50, 27,  5, 45},
+	{ 900, 35,  14,  3, 56, 36,  5, 50, 26,  5, 45},
+	{ 890, 35,  14,  3, 56, 36,  5, 49, 26,  5, 44},
+	{ 880, 35,  13,  3, 56, 35,  5, 49, 26,  5, 44},
+	{ 870, 34,  13,  3, 55, 35,  4, 49, 26,  5, 43},
+	{ 860, 34,  13,  3, 55, 35,  4, 48, 25,  5, 43},
+	{ 850, 33,  13,  3, 55, 35,  4, 48, 26,  4, 42},
+	{ 840, 33,  13,  3, 54, 35,  4, 48, 26,  4, 42},
+	{ 830, 33,  12,  3, 54, 33,  4, 47, 24,  4, 41},
+	{ 820, 32,  12,  3, 54, 33,  4, 47, 24,  4, 41},
+	{ 810, 32,  12,  3, 53, 33,  4, 47, 24,  4, 40},
+	{ 800, 31,  12,  2, 53, 32,  4, 46, 23,  4, 40},
+	{ 790, 31,  12,  2, 53, 32,  4, 46, 23,  4, 39},
+	{ 780, 30,  12,  2, 52, 31,  4, 46, 23,  4, 39},
+	{ 770, 30,  11,  2, 52, 31,  4, 45, 23,  4, 39},
+	{ 760, 30,  11,  2, 52, 31,  3, 45, 22,  4, 38},
+	{ 750, 29,  11,  2, 51, 30,  3, 45, 22,  4, 38},
+	{ 740, 29,  11,  2, 51, 30,  3, 44, 22,  4, 37},
+	{ 730, 28,  11,  2, 51, 31,  3, 44, 22,  4, 37},
+	{ 720, 28,  10,  2, 50, 30,  3, 44, 22,  4, 36},
+	{ 710, 28,  10,  2, 50, 30,  3, 43, 22,  4, 36},
+	{ 700, 27,  10,  2, 50, 28,  3, 43, 20,  3, 35},
+	{ 690, 27,  10,  2, 49, 28,  3, 43, 20,  3, 35},
+	{ 680, 26,  10,  2, 49, 28,  3, 42, 20,  3, 34},
+	{ 670, 26,  10,  2, 49, 27,  3, 42, 20,  3, 34},
+	{ 660, 26,   9,  2, 48, 27,  3, 42, 19,  3, 33},
+	{ 650, 25,   9,  2, 48, 26,  3, 41, 19,  3, 33},
+	{ 640, 25,   9,  2, 48, 26,  2, 41, 19,  3, 32},
+	{ 630, 24,   9,  2, 47, 26,  2, 40, 18,  3, 32},
+	{ 620, 24,   9,  2, 47, 26,  2, 40, 19,  3, 31},
+	{ 610, 24,   8,  2, 47, 26,  2, 40, 19,  3, 31},
+	{ 600, 23,   8,  1, 46, 26,  2, 39, 18,  3, 30},
+	{ 590, 23,   8,  1, 46, 24,  2, 39, 17,  3, 30},
+	{ 580, 22,   8,  1, 46, 24,  2, 39, 17,  3, 29},
+	{ 570, 22,   8,  1, 45, 23,  2, 38, 17,  3, 29},
+	{ 560, 22,   7,  1, 45, 23,  2, 38, 16,  2, 28},
+	{ 550, 21,   7,  1, 45, 23,  2, 38, 16,  2, 28},
+	{ 540, 21,   7,  1, 44, 22,  2, 37, 16,  2, 27},
+	{ 530, 20,   7,  1, 44, 22,  1, 37, 15,  2, 27},
+	{ 520, 20,   7,  1, 43, 21,  1, 37, 15,  2, 27},
+	{ 510, 20,   6,  1, 43, 21,  1, 36, 15,  2, 26},
+	{ 500, 19,   6,  1, 43, 22,  1, 36, 15,  2, 26},
+	{ 490, 19,   6,  1, 42, 21,  1, 36, 15,  2, 25},
+	{ 480, 18,   6,  1, 42, 21,  1, 35, 15,  2, 25},
+	{ 470, 18,   6,  1, 42, 21,  1, 35, 15,  2, 24},
+	{ 460, 18,   6,  1, 41, 19,  1, 35, 13,  2, 24},
+	{ 450, 17,   5,  1, 41, 19,  1, 34, 13,  2, 23},
+	{ 440, 17,   5,  1, 41, 18,  1, 34, 13,  2, 23},
+	{ 430, 16,   5,  1, 40, 18,  0, 34, 12,  2, 22},
+	{ 420, 16,   5,  1, 40, 18,  0, 33, 12,  2, 22},
+	{ 410, 16,   5,  1, 40, 17,  0, 33, 12,  1, 21},
+	{ 400, 15,   5,  0, 39, 17,  0, 33, 11,  1, 21},
+	{ 390, 15,   4,  0, 39, 17,  0, 32, 12,  1, 20},
+	{ 380, 14,   4,  0, 39, 17,  0, 32, 12,  1, 20},
+	{ 370, 14,   4,  0, 38, 17,  0, 32, 12,  1, 19},
+	{ 360, 14,   4,  0, 38, 15,  0, 31, 10,  1, 19},
+	{ 350, 13,   4,  0, 38, 15,  0, 31, 10,  1, 18},
+	{ 340, 13,   3,  0, 37, 15,  0, 31, 10,  1, 18},
+	{ 330, 12,   3,  0, 37, 14,  0, 30,  9,  1, 17},
+	{ 320, 12,   3,  0, 37, 14,  0, 30,  9,  1, 17},
+	{ 310, 12,   3,  0, 36, 13,  0, 30,  9,  1, 16},
+	{ 300, 11,   3,  0, 36, 13,  0, 29,  8,  1, 16},
+	{ 290, 11,   2,  0, 36, 13,  0, 29,  8,  1, 15},
+	{ 280, 10,   2,  0, 35, 12,  0, 29,  8,  1, 15},
+	{ 270, 10,   2,  0, 35, 12,  0, 28,  8,  0, 14},
+	{ 260,  9,   2,  0, 35, 12,  0, 28,  8,  0, 14},
+	{ 250,  9,   2,  0, 34, 12,  0, 28,  8,  0, 14},
+	{ 240,  9,   2,  0, 34, 12,  0, 27,  8,  0, 13},
+	{ 230,  8,   1,  0, 34, 10,  0, 27,  6,  0, 13},
+	{ 220,  8,   1,  0, 33, 10,  0, 27,  6,  0, 12},
+	{ 210,  7,   1,  0, 33, 10,  0, 26,  6,  0, 12},
+	{ 200,  7,   1,  0, 33,  9,  0, 26,  5,  0, 11},
+	{ 190,  7,   1,  0, 32,  9,  0, 25,  5,  0, 11},
+	{ 180,  6,   1,  0, 32,  8,  0, 25,  5,  0, 10},
+	{ 170,  6,   0,  0, 32,  8,  0, 25,  5,  0, 10},
+	{ 160,  5,   0,  0, 31,  8,  0, 24,  4,  0,  9},
+	{ 150,  5,   0,  0, 31,  8,  0, 24,  5,  0,  9},
+	{ 140,  5,   0,  0, 31,  8,  0, 24,  5,  0,  8},
+	{ 130,  4,   0,  0, 30,  6,  0, 23,  3,  0,  8},
+	{ 120,  4,   0,  0, 30,  6,  0, 23,  3,  0,  7},
+	{ 110,  3,   0,  0, 30,  6,  0, 23,  3,  0,  7},
+	{ 100,  3,   0,  0, 29,  5,  0, 22,  2,  0,  6},
+	{  90,  3,   0,  0, 29,  5,  0, 22,  2,  0,  6},
+	{  80,  2,   0,  0, 28,  5,  0, 22,  2,  0,  5},
+};
+
+static const
+struct samsung_mipi_cphy_timing samsung_mipi_cphy_timing_table[] = {
+	{ 3500, 39, 50, 25, 29, 54, 1 },
+	{ 3490, 39, 50, 25, 29, 54, 1 },
+	{ 3480, 39, 50, 25, 29, 54, 1 },
+	{ 3470, 39, 50, 25, 29, 54, 1 },
+	{ 3460, 39, 50, 25, 29, 54, 1 },
+	{ 3450, 39, 50, 25, 29, 54, 1 },
+	{ 3440, 38, 50, 25, 29, 54, 1 },
+	{ 3430, 38, 50, 25, 29, 53, 1 },
+	{ 3420, 38, 50, 25, 29, 53, 1 },
+	{ 3410, 38, 50, 25, 29, 53, 1 },
+	{ 3400, 38, 50, 25, 29, 53, 1 },
+	{ 3390, 38, 50, 25, 29, 53, 1 },
+	{ 3380, 38, 50, 25, 28, 53, 1 },
+	{ 3370, 38, 50, 25, 28, 52, 1 },
+	{ 3360, 37, 50, 25, 28, 52, 1 },
+	{ 3350, 37, 50, 25, 28, 52, 1 },
+	{ 3340, 37, 50, 25, 28, 52, 1 },
+	{ 3330, 37, 50, 25, 28, 52, 1 },
+	{ 3320, 37, 50, 25, 28, 52, 1 },
+	{ 3310, 37, 50, 25, 28, 52, 1 },
+	{ 3300, 37, 50, 25, 28, 51, 1 },
+	{ 3290, 37, 50, 25, 28, 51, 1 },
+	{ 3280, 37, 50, 25, 28, 51, 1 },
+	{ 3270, 36, 50, 25, 28, 51, 1 },
+	{ 3260, 36, 50, 25, 27, 51, 1 },
+	{ 3250, 36, 50, 25, 27, 51, 1 },
+	{ 3240, 36, 50, 25, 27, 50, 1 },
+	{ 3230, 36, 50, 25, 27, 50, 1 },
+	{ 3220, 36, 50, 25, 27, 50, 1 },
+	{ 3210, 36, 50, 25, 27, 50, 1 },
+	{ 3200, 36, 50, 25, 27, 50, 1 },
+	{ 3190, 36, 50, 25, 27, 50, 1 },
+	{ 3180, 35, 50, 25, 27, 49, 1 },
+	{ 3170, 35, 50, 25, 27, 49, 1 },
+	{ 3160, 35, 50, 25, 27, 49, 1 },
+	{ 3150, 35, 50, 25, 26, 49, 1 },
+	{ 3140, 35, 50, 25, 26, 49, 1 },
+	{ 3130, 35, 50, 25, 26, 49, 1 },
+	{ 3120, 35, 50, 25, 26, 49, 1 },
+	{ 3110, 35, 50, 25, 26, 48, 1 },
+	{ 3100, 34, 50, 25, 26, 48, 1 },
+	{ 3090, 34, 50, 25, 26, 48, 1 },
+	{ 3080, 34, 50, 25, 26, 48, 1 },
+	{ 3070, 34, 50, 25, 26, 48, 1 },
+	{ 3060, 34, 50, 25, 26, 48, 1 },
+	{ 3050, 34, 50, 25, 26, 47, 1 },
+	{ 3040, 34, 50, 25, 26, 47, 1 },
+	{ 3030, 34, 50, 25, 25, 47, 1 },
+	{ 3020, 34, 50, 25, 25, 47, 1 },
+	{ 3010, 33, 50, 25, 25, 47, 1 },
+	{ 3000, 33, 50, 25, 25, 47, 1 },
+	{ 2990, 33, 50, 25, 25, 46, 1 },
+	{ 2980, 33, 50, 25, 25, 46, 1 },
+	{ 2970, 33, 50, 25, 25, 46, 1 },
+	{ 2960, 33, 50, 25, 25, 46, 1 },
+	{ 2950, 33, 50, 25, 25, 46, 1 },
+	{ 2940, 33, 50, 25, 25, 46, 1 },
+	{ 2930, 33, 50, 25, 25, 46, 1 },
+	{ 2920, 32, 50, 25, 25, 45, 1 },
+	{ 2910, 32, 50, 25, 24, 45, 1 },
+	{ 2900, 32, 50, 25, 24, 45, 1 },
+	{ 2890, 32, 50, 25, 24, 45, 1 },
+	{ 2880, 32, 50, 25, 24, 45, 1 },
+	{ 2870, 32, 50, 25, 24, 45, 1 },
+	{ 2860, 32, 50, 25, 24, 44, 1 },
+	{ 2850, 32, 50, 25, 24, 44, 1 },
+	{ 2840, 31, 50, 25, 24, 44, 1 },
+	{ 2830, 31, 50, 25, 24, 44, 1 },
+	{ 2820, 31, 50, 25, 24, 44, 1 },
+	{ 2810, 31, 50, 25, 24, 44, 1 },
+	{ 2800, 31, 50, 25, 23, 43, 1 },
+	{ 2790, 31, 50, 25, 23, 43, 1 },
+	{ 2780, 31, 50, 25, 23, 43, 1 },
+	{ 2770, 31, 50, 25, 23, 43, 1 },
+	{ 2760, 31, 50, 25, 23, 43, 1 },
+	{ 2750, 30, 50, 25, 23, 43, 1 },
+	{ 2740, 30, 50, 25, 23, 43, 1 },
+	{ 2730, 30, 50, 25, 23, 42, 1 },
+	{ 2720, 30, 50, 25, 23, 42, 1 },
+	{ 2710, 30, 50, 25, 23, 42, 1 },
+	{ 2700, 30, 50, 25, 23, 42, 1 },
+	{ 2690, 30, 50, 25, 23, 42, 1 },
+	{ 2680, 30, 50, 25, 22, 42, 1 },
+	{ 2670, 30, 50, 25, 22, 41, 1 },
+	{ 2660, 29, 50, 25, 22, 41, 1 },
+	{ 2650, 29, 50, 25, 22, 41, 1 },
+	{ 2640, 29, 50, 25, 22, 41, 1 },
+	{ 2630, 29, 50, 25, 22, 41, 1 },
+	{ 2620, 29, 50, 25, 22, 41, 1 },
+	{ 2610, 29, 50, 25, 22, 41, 1 },
+	{ 2600, 29, 50, 25, 22, 40, 1 },
+	{ 2590, 29, 50, 25, 22, 40, 1 },
+	{ 2580, 28, 50, 25, 22, 40, 1 },
+	{ 2570, 28, 50, 25, 22, 40, 1 },
+	{ 2560, 28, 50, 25, 21, 40, 1 },
+	{ 2550, 28, 50, 25, 21, 40, 1 },
+	{ 2540, 28, 50, 25, 21, 39, 1 },
+	{ 2530, 28, 50, 25, 21, 39, 1 },
+	{ 2520, 28, 50, 25, 21, 39, 1 },
+	{ 2510, 28, 50, 25, 21, 39, 1 },
+	{ 2500, 28, 50, 25, 21, 39, 1 },
+	{ 2490, 27, 50, 25, 21, 39, 1 },
+	{ 2480, 27, 50, 25, 21, 38, 1 },
+	{ 2470, 27, 50, 25, 21, 38, 1 },
+	{ 2460, 27, 50, 25, 21, 38, 1 },
+	{ 2450, 27, 50, 25, 20, 38, 1 },
+	{ 2440, 27, 50, 25, 20, 38, 1 },
+	{ 2430, 27, 50, 25, 20, 38, 1 },
+	{ 2420, 27, 50, 25, 20, 38, 1 },
+	{ 2410, 27, 50, 25, 20, 37, 1 },
+	{ 2400, 26, 50, 25, 20, 37, 1 },
+	{ 2390, 26, 50, 25, 20, 37, 1 },
+	{ 2380, 26, 50, 25, 20, 37, 1 },
+	{ 2370, 26, 50, 25, 20, 37, 1 },
+	{ 2360, 26, 50, 25, 20, 37, 1 },
+	{ 2350, 26, 50, 25, 20, 36, 1 },
+	{ 2340, 26, 50, 25, 20, 36, 1 },
+	{ 2330, 26, 50, 25, 19, 36, 1 },
+	{ 2320, 25, 50, 25, 19, 36, 1 },
+	{ 2310, 25, 50, 25, 19, 36, 1 },
+	{ 2300, 25, 50, 25, 19, 36, 1 },
+	{ 2290, 25, 50, 25, 19, 35, 1 },
+	{ 2280, 25, 50, 25, 19, 35, 1 },
+	{ 2270, 25, 50, 25, 19, 35, 1 },
+	{ 2260, 25, 50, 25, 19, 35, 1 },
+	{ 2250, 25, 50, 25, 19, 35, 1 },
+	{ 2240, 25, 50, 25, 19, 35, 1 },
+	{ 2230, 24, 50, 25, 19, 35, 1 },
+	{ 2220, 24, 50, 25, 19, 34, 1 },
+	{ 2210, 24, 50, 25, 18, 34, 1 },
+	{ 2200, 24, 50, 25, 18, 34, 1 },
+	{ 2190, 24, 50, 25, 18, 34, 1 },
+	{ 2180, 24, 50, 25, 18, 34, 1 },
+	{ 2170, 24, 50, 25, 18, 34, 1 },
+	{ 2160, 24, 50, 25, 18, 33, 1 },
+	{ 2150, 24, 50, 25, 18, 33, 1 },
+	{ 2140, 23, 50, 25, 18, 33, 1 },
+	{ 2130, 23, 50, 25, 18, 33, 1 },
+	{ 2120, 23, 50, 25, 18, 33, 1 },
+	{ 2110, 23, 50, 25, 18, 33, 1 },
+	{ 2100, 23, 50, 25, 17, 32, 1 },
+	{ 2090, 23, 50, 25, 17, 32, 1 },
+	{ 2080, 23, 50, 25, 17, 32, 1 },
+	{ 2070, 23, 50, 25, 17, 32, 1 },
+	{ 2060, 22, 50, 25, 17, 32, 1 },
+	{ 2050, 22, 50, 25, 17, 32, 1 },
+	{ 2040, 22, 50, 25, 17, 32, 1 },
+	{ 2030, 22, 50, 25, 17, 31, 1 },
+	{ 2020, 22, 50, 25, 17, 31, 1 },
+	{ 2010, 22, 50, 25, 17, 31, 1 },
+	{ 2000, 22, 50, 25, 17, 31, 1 },
+	{ 1990, 22, 50, 25, 17, 31, 1 },
+	{ 1980, 22, 50, 25, 16, 31, 1 },
+	{ 1970, 21, 50, 25, 16, 30, 1 },
+	{ 1960, 21, 50, 25, 16, 30, 1 },
+	{ 1950, 21, 50, 25, 16, 30, 1 },
+	{ 1940, 21, 50, 25, 16, 30, 1 },
+	{ 1930, 21, 50, 25, 16, 30, 1 },
+	{ 1920, 21, 50, 25, 16, 30, 1 },
+	{ 1910, 21, 50, 25, 16, 30, 1 },
+	{ 1900, 21, 50, 25, 16, 29, 1 },
+	{ 1890, 21, 50, 25, 16, 29, 1 },
+	{ 1880, 20, 50, 25, 16, 29, 1 },
+	{ 1870, 20, 50, 25, 16, 29, 1 },
+	{ 1860, 20, 50, 25, 15, 29, 1 },
+	{ 1850, 20, 50, 25, 15, 29, 1 },
+	{ 1840, 20, 50, 25, 15, 28, 1 },
+	{ 1830, 20, 50, 25, 15, 28, 1 },
+	{ 1820, 20, 50, 25, 15, 28, 1 },
+	{ 1810, 20, 50, 25, 15, 28, 1 },
+	{ 1800, 19, 50, 25, 15, 28, 1 },
+	{ 1790, 19, 50, 25, 15, 28, 1 },
+	{ 1780, 19, 50, 25, 15, 27, 1 },
+	{ 1770, 19, 50, 25, 15, 27, 1 },
+	{ 1760, 19, 50, 25, 15, 27, 1 },
+	{ 1750, 19, 50, 25, 14, 27, 1 },
+	{ 1740, 19, 50, 25, 14, 27, 1 },
+	{ 1730, 19, 50, 25, 14, 27, 1 },
+	{ 1720, 19, 50, 25, 14, 27, 1 },
+	{ 1710, 18, 50, 25, 14, 26, 1 },
+	{ 1700, 18, 50, 25, 14, 26, 1 },
+	{ 1690, 18, 50, 25, 14, 26, 1 },
+	{ 1680, 18, 50, 25, 14, 26, 1 },
+	{ 1670, 18, 50, 25, 14, 26, 1 },
+	{ 1660, 18, 50, 25, 14, 26, 1 },
+	{ 1650, 18, 50, 25, 14, 25, 1 },
+	{ 1640, 18, 50, 25, 14, 25, 1 },
+	{ 1630, 18, 50, 25, 13, 25, 1 },
+	{ 1620, 17, 50, 25, 13, 25, 1 },
+	{ 1610, 17, 50, 25, 13, 25, 1 },
+	{ 1600, 17, 50, 25, 13, 25, 1 },
+	{ 1590, 17, 50, 25, 13, 24, 1 },
+	{ 1580, 17, 50, 25, 13, 24, 1 },
+	{ 1570, 17, 50, 25, 13, 24, 1 },
+	{ 1560, 17, 50, 25, 13, 24, 1 },
+	{ 1550, 17, 50, 25, 13, 24, 1 },
+	{ 1540, 16, 50, 25, 13, 24, 1 },
+	{ 1530, 16, 50, 25, 13, 24, 1 },
+	{ 1520, 16, 50, 25, 13, 23, 1 },
+	{ 1510, 16, 50, 25, 12, 23, 1 },
+	{ 1500, 16, 50, 25, 12, 23, 1 },
+	{ 1490, 16, 50, 25, 12, 23, 1 },
+	{ 1480, 16, 50, 25, 12, 23, 1 },
+	{ 1470, 16, 50, 25, 12, 23, 1 },
+	{ 1460, 16, 50, 25, 12, 22, 1 },
+	{ 1450, 15, 50, 25, 12, 22, 1 },
+	{ 1440, 15, 50, 25, 12, 22, 1 },
+	{ 1430, 15, 50, 25, 12, 22, 1 },
+	{ 1420, 15, 50, 25, 12, 22, 1 },
+	{ 1410, 15, 50, 25, 12, 22, 1 },
+	{ 1400, 15, 50, 25, 11, 21, 1 },
+	{ 1390, 15, 50, 25, 11, 21, 1 },
+	{ 1380, 15, 50, 25, 11, 21, 1 },
+	{ 1370, 15, 50, 25, 11, 21, 1 },
+	{ 1360, 14, 50, 25, 11, 21, 1 },
+	{ 1350, 14, 50, 25, 11, 21, 1 },
+	{ 1340, 14, 50, 25, 11, 21, 1 },
+	{ 1330, 14, 50, 25, 11, 20, 1 },
+	{ 1320, 14, 50, 25, 11, 20, 1 },
+	{ 1310, 14, 50, 25, 11, 20, 1 },
+	{ 1300, 14, 50, 25, 11, 20, 1 },
+	{ 1290, 14, 50, 25, 11, 20, 1 },
+	{ 1280, 13, 50, 25, 10, 20, 1 },
+	{ 1270, 13, 50, 25, 10, 19, 1 },
+	{ 1260, 13, 50, 25, 10, 19, 1 },
+	{ 1250, 13, 50, 25, 10, 19, 1 },
+	{ 1240, 13, 50, 25, 10, 19, 1 },
+	{ 1230, 13, 50, 25, 10, 19, 1 },
+	{ 1220, 13, 50, 25, 10, 19, 1 },
+	{ 1210, 13, 50, 25, 10, 19, 1 },
+	{ 1200, 13, 50, 25, 10, 18, 1 },
+	{ 1190, 12, 50, 25, 10, 18, 1 },
+	{ 1180, 12, 50, 25, 10, 18, 1 },
+	{ 1170, 12, 50, 25, 10, 18, 1 },
+	{ 1160, 12, 50, 25,  9, 18, 1 },
+	{ 1150, 12, 50, 25,  9, 18, 1 },
+	{ 1140, 12, 50, 25,  9, 17, 1 },
+	{ 1130, 12, 50, 25,  9, 17, 1 },
+	{ 1120, 12, 50, 25,  9, 17, 1 },
+	{ 1110, 12, 50, 25,  9, 17, 1 },
+	{ 1100, 11, 50, 25,  9, 17, 1 },
+	{ 1090, 11, 50, 25,  9, 17, 1 },
+	{ 1080, 11, 50, 25,  9, 16, 1 },
+	{ 1070, 11, 50, 25,  9, 16, 1 },
+	{ 1060, 11, 50, 25,  9, 16, 1 },
+	{ 1050, 11, 50, 25,  8, 16, 1 },
+	{ 1040, 11, 50, 25,  8, 16, 1 },
+	{ 1030, 11, 50, 25,  8, 16, 1 },
+	{ 1020, 10, 50, 25,  8, 16, 1 },
+	{ 1010, 10, 50, 25,  8, 15, 1 },
+	{ 1000, 10, 50, 25,  8, 15, 1 },
+	{  990, 10, 50, 25,  8, 15, 2 },
+	{  980, 10, 50, 25,  8, 15, 2 },
+	{  970, 10, 50, 25,  8, 15, 2 },
+	{  960, 10, 50, 25,  8, 15, 2 },
+	{  950, 10, 50, 25,  8, 14, 2 },
+	{  940, 10, 50, 25,  8, 14, 2 },
+	{  930,  9, 50, 25,  7, 14, 2 },
+	{  920,  9, 50, 25,  7, 14, 2 },
+	{  910,  9, 50, 25,  7, 14, 2 },
+	{  900,  9, 50, 25,  7, 14, 2 },
+	{  890,  9, 50, 25,  7, 13, 2 },
+	{  880,  9, 50, 25,  7, 13, 2 },
+	{  870,  9, 50, 25,  7, 13, 2 },
+	{  860,  9, 50, 25,  7, 13, 2 },
+	{  850,  9, 50, 25,  7, 13, 2 },
+	{  840,  8, 50, 25,  7, 13, 2 },
+	{  830,  8, 50, 25,  7, 13, 2 },
+	{  820,  8, 50, 25,  7, 12, 2 },
+	{  810,  8, 50, 25,  6, 12, 2 },
+	{  800,  8, 50, 25,  6, 12, 2 },
+	{  790,  8, 50, 25,  6, 12, 2 },
+	{  780,  8, 50, 25,  6, 12, 2 },
+	{  770,  8, 50, 25,  6, 12, 2 },
+	{  760,  7, 50, 25,  6, 11, 2 },
+	{  750,  7, 50, 25,  6, 11, 2 },
+	{  740,  7, 50, 25,  6, 11, 2 },
+	{  730,  7, 50, 25,  6, 11, 2 },
+	{  720,  7, 50, 25,  6, 11, 2 },
+	{  710,  7, 50, 25,  6, 11, 2 },
+	{  700,  7, 50, 25,  5, 10, 2 },
+	{  690,  7, 50, 25,  5, 10, 2 },
+	{  680,  7, 50, 25,  5, 10, 2 },
+	{  670,  6, 50, 25,  5, 10, 2 },
+	{  660,  6, 50, 25,  5, 10, 2 },
+	{  650,  6, 50, 25,  5, 10, 2 },
+	{  640,  6, 50, 25,  5, 10, 2 },
+	{  630,  6, 50, 25,  5,  9, 2 },
+	{  620,  6, 50, 25,  5,  9, 2 },
+	{  610,  6, 50, 25,  5,  9, 2 },
+	{  600,  6, 50, 25,  5,  9, 2 },
+	{  590,  6, 50, 25,  5,  9, 2 },
+	{  580,  5, 50, 25,  4,  9, 2 },
+	{  570,  5, 50, 25,  4,  8, 2 },
+	{  560,  5, 50, 25,  4,  8, 2 },
+	{  550,  5, 50, 25,  4,  8, 2 },
+	{  540,  5, 50, 25,  4,  8, 2 },
+	{  530,  5, 50, 25,  4,  8, 2 },
+	{  520,  5, 50, 25,  4,  8, 2 },
+	{  510,  5, 50, 25,  4,  8, 2 },
+	{  500,  4, 50, 25,  4,  7, 2 },
+	{  490, 18, 50, 25, 14,  6, 2 },
+	{  480, 17, 50, 25, 14,  6, 2 },
+	{  470, 17, 50, 25, 14,  6, 2 },
+	{  460, 17, 50, 25, 13,  6, 2 },
+	{  450, 16, 50, 25, 13,  6, 2 },
+	{  440, 16, 50, 25, 13,  6, 2 },
+	{  430, 15, 50, 25, 12,  6, 2 },
+	{  420, 15, 50, 25, 12,  5, 2 },
+	{  410, 15, 50, 25, 12,  5, 2 },
+	{  400, 14, 50, 25, 11,  5, 2 },
+	{  390, 14, 50, 25, 11,  5, 2 },
+	{  380, 13, 50, 25, 11,  5, 2 },
+	{  370, 13, 50, 25, 11,  5, 2 },
+	{  360, 13, 50, 25, 10,  4, 2 },
+	{  350, 12, 50, 25, 10,  4, 2 },
+	{  340, 12, 50, 25, 10,  4, 2 },
+	{  330, 11, 50, 25,  9,  4, 2 },
+	{  320, 11, 50, 25,  9,  4, 2 },
+	{  310, 11, 50, 25,  9,  4, 2 },
+	{  300, 10, 50, 25,  8,  3, 2 },
+	{  290, 10, 50, 25,  8,  3, 2 },
+	{  280,  9, 50, 25,  8,  3, 2 },
+	{  270,  9, 50, 25,  8,  3, 2 },
+	{  260,  8, 50, 25,  7,  3, 2 },
+	{  250,  8, 50, 25,  7,  3, 2 },
+	{  240,  8, 50, 25,  7,  3, 2 },
+	{  230,  7, 50, 25,  6,  2, 2 },
+	{  220,  7, 50, 25,  6,  2, 2 },
+	{  210,  6, 50, 25,  6,  2, 2 },
+	{  200,  6, 50, 25,  5,  2, 2 },
+	{  190,  6, 50, 25,  5,  2, 2 },
+	{  180,  5, 50, 25,  5,  2, 2 },
+	{  170,  5, 50, 25,  5,  1, 2 },
+	{  160,  4, 50, 25,  4,  1, 2 },
+	{  150,  4, 50, 25,  4,  1, 2 },
+	{  140,  4, 50, 25,  4,  1, 2 },
+	{  130,  3, 50, 25,  3,  1, 2 },
+	{  120,  3, 50, 25,  3,  1, 2 },
+	{  110,  2, 50, 25,  3,  1, 2 },
+	{  100,  2, 50, 25,  2,  0, 2 },
+	{   90,  2, 50, 25,  2,  0, 2 },
+	{   80,  1, 50, 25,  2,  0, 2 },
+};
+
+static inline void
+phy_write(struct samsung_mipi_dcphy *samsung, u32 reg, u32 val)
+{
+	writel(val, samsung->base + reg);
+}
+
+static inline u32 phy_read(struct samsung_mipi_dcphy *samsung, u32 reg)
+{
+	return readl(samsung->base + reg);
+}
+
+static inline void phy_update_bits(struct samsung_mipi_dcphy *samsung,
+				   u32 reg, u32 mask, u32 val)
+{
+	u32 orig, tmp;
+
+	orig = phy_read(samsung, reg);
+	tmp = orig & ~mask;
+	tmp |= val & mask;
+	phy_write(samsung, reg, tmp);
+}
+
+static inline void grf_write(struct samsung_mipi_dcphy *samsung,
+			     u32 reg, u32 val)
+{
+	regmap_write(samsung->grf, reg, val);
+}
+
+static const struct samsung_mipi_dphy_timing *
+samsung_mipi_dphy_get_timing(struct samsung_mipi_dcphy *samsung)
+{
+	const struct samsung_mipi_dphy_timing *timings;
+	unsigned int num_timings;
+	unsigned int lane_mbps = samsung->pll.rate / USEC_PER_SEC;
+	unsigned int i;
+
+	timings = samsung_mipi_dphy_timing_table;
+	num_timings = ARRAY_SIZE(samsung_mipi_dphy_timing_table);
+
+	for (i = num_timings; i > 0; i--)
+		if (lane_mbps <= timings[i - 1].max_lane_mbps)
+			break;
+
+	if (i == 0)
+		++i;
+
+	return &timings[i - 1];
+}
+
+static const struct samsung_mipi_cphy_timing *
+samsung_mipi_cphy_get_timing(struct samsung_mipi_dcphy *samsung)
+{
+	const struct samsung_mipi_cphy_timing *timings;
+	unsigned int num_timings;
+	unsigned int lane_msps = div64_ul(samsung->pll.rate, USEC_PER_SEC);
+	unsigned int i;
+
+	timings = samsung_mipi_cphy_timing_table;
+	num_timings = ARRAY_SIZE(samsung_mipi_cphy_timing_table);
+
+	for (i = num_timings; i > 0; i--)
+		if (lane_msps <= timings[i - 1].max_lane_msps)
+			break;
+
+	if (i == 0)
+		++i;
+
+	return &timings[i - 1];
+}
+
+static void samsung_mipi_dcphy_bias_block_enable(struct samsung_mipi_dcphy *samsung)
+{
+	phy_write(samsung, BIAS_CON0, 0x0010);
+	phy_write(samsung, BIAS_CON1, 0x0110);
+	phy_write(samsung, BIAS_CON2, 0x3223);
+
+	if (samsung->c_option)
+		phy_update_bits(samsung, BIAS_CON4, I_MUX_SEL_MASK, I_MUX_SEL(2));
+}
+
+static void samsung_mipi_dcphy_bias_block_disable(struct samsung_mipi_dcphy *samsung)
+{
+}
+
+static void samsung_mipi_dcphy_pll_configure(struct samsung_mipi_dcphy *samsung)
+{
+	phy_update_bits(samsung, PLL_CON0, S_MASK | P_MASK,
+			S(samsung->pll.scaler) | P(samsung->pll.prediv));
+
+	if (samsung->pll.dsm < 0) {
+		u16 dsm_tmp;
+
+		/* Using opposite number subtraction to find complement */
+		dsm_tmp = abs(samsung->pll.dsm);
+		dsm_tmp = dsm_tmp - 1;
+		dsm_tmp ^= 0xffff;
+		phy_write(samsung, PLL_CON1, dsm_tmp);
+	} else {
+		phy_write(samsung, PLL_CON1, samsung->pll.dsm);
+	}
+
+	phy_update_bits(samsung, PLL_CON2, M_MASK, M(samsung->pll.fbdiv));
+
+	if (samsung->pll.ssc_en) {
+		phy_write(samsung, PLL_CON3,
+			  MRR(samsung->pll.mrr) | MFR(samsung->pll.mfr));
+		phy_update_bits(samsung, PLL_CON4, SSCG_EN, SSCG_EN);
+	}
+
+	phy_write(samsung, PLL_CON5, RESET_N_SEL | PLL_ENABLE_SEL);
+	phy_write(samsung, PLL_CON7, PLL_LOCK_CNT(0xf000));
+	phy_write(samsung, PLL_CON8, PLL_STB_CNT(0xf000));
+}
+
+static void
+samsung_mipi_dphy_clk_lane_timing_init(struct samsung_mipi_dcphy *samsung)
+{
+	const struct samsung_mipi_dphy_timing *timing;
+	unsigned int lane_hs_rate = div64_ul(samsung->pll.rate, USEC_PER_SEC);
+	u32 val = 0;
+
+	timing = samsung_mipi_dphy_get_timing(samsung);
+	phy_write(samsung, DPHY_MC_GNR_CON0, 0xf000);
+	phy_write(samsung, DPHY_MC_ANA_CON0, 0x7133);
+
+	if (lane_hs_rate >= 4500)
+		phy_write(samsung, DPHY_MC_ANA_CON1, 0x0001);
+
+	/*
+	 * Divide-by-2 Clock from Serial Clock. Use this when data rate is under
+	 * 1500Mbps, otherwise divide-by-16 Clock from Serial Clock
+	 */
+	if (lane_hs_rate < 1500)
+		val = HSTX_CLK_SEL;
+
+	val |= T_LPX(timing->lpx);
+	/*  T_LP_EXIT_SKEW/T_LP_ENTRY_SKEW unconfig */
+	phy_write(samsung, DPHY_MC_TIME_CON0, val);
+
+	val = T_CLK_ZERO(timing->clk_zero) | T_CLK_PREPARE(timing->clk_prepare);
+	phy_write(samsung, DPHY_MC_TIME_CON1, val);
+
+	val = T_HS_EXIT(timing->hs_exit) | T_CLK_TRAIL(timing->clk_trail_eot);
+	phy_write(samsung, DPHY_MC_TIME_CON2, val);
+
+	val = T_CLK_POST(timing->clk_post);
+	phy_write(samsung, DPHY_MC_TIME_CON3, val);
+
+	/* Escape Clock is 20.00MHz */
+	phy_write(samsung, DPHY_MC_TIME_CON4, 0x1f4);
+
+	/*
+	 * skew calibration should be off, if the operation data rate is
+	 * under 1.5Gbps or equal to 1.5Gbps.
+	 */
+	if (lane_hs_rate > 1500)
+		phy_write(samsung, DPHY_MC_DESKEW_CON0, 0x9cb1);
+}
+
+static void
+samsung_mipi_dphy_data_lane_timing_init(struct samsung_mipi_dcphy *samsung)
+{
+	const struct samsung_mipi_dphy_timing *timing;
+	unsigned int lane_hs_rate = div64_ul(samsung->pll.rate, USEC_PER_SEC);
+	u32 val = 0;
+
+	timing = samsung_mipi_dphy_get_timing(samsung);
+
+	phy_write(samsung, COMBO_MD0_ANA_CON0, 0x7133);
+	phy_write(samsung, COMBO_MD1_ANA_CON0, 0x7133);
+	phy_write(samsung, COMBO_MD2_ANA_CON0, 0x7133);
+	phy_write(samsung, DPHY_MD3_ANA_CON0, 0x7133);
+
+	if (lane_hs_rate >= 1500) {
+		phy_write(samsung, COMBO_MD0_ANA_CON1, 0x0001);
+		phy_write(samsung, COMBO_MD1_ANA_CON1, 0x0001);
+		phy_write(samsung, COMBO_MD2_ANA_CON1, 0x0001);
+		phy_write(samsung, DPHY_MD3_ANA_CON1, 0x0001);
+	}
+
+	/*
+	 * Divide-by-2 Clock from Serial Clock. Use this when data rate is under
+	 * 1500Mbps, otherwise divide-by-16 Clock from Serial Clock
+	 */
+	if (lane_hs_rate < 1500)
+		val = HSTX_CLK_SEL;
+
+	val |= T_LPX(timing->lpx);
+	/*  T_LP_EXIT_SKEW/T_LP_ENTRY_SKEW unconfig */
+	phy_write(samsung, COMBO_MD0_TIME_CON0, val);
+	phy_write(samsung, COMBO_MD1_TIME_CON0, val);
+	phy_write(samsung, COMBO_MD2_TIME_CON0, val);
+	phy_write(samsung, DPHY_MD3_TIME_CON0, val);
+
+	val = T_HS_ZERO(timing->hs_zero) | T_HS_PREPARE(timing->hs_prepare);
+	phy_write(samsung, COMBO_MD0_TIME_CON1, val);
+	phy_write(samsung, COMBO_MD1_TIME_CON1, val);
+	phy_write(samsung, COMBO_MD2_TIME_CON1, val);
+	phy_write(samsung, DPHY_MD3_TIME_CON1, val);
+
+	val = T_HS_EXIT(timing->hs_exit) | T_HS_TRAIL(timing->hs_trail_eot);
+	phy_write(samsung, COMBO_MD0_TIME_CON2, val);
+	phy_write(samsung, COMBO_MD1_TIME_CON2, val);
+	phy_write(samsung, COMBO_MD2_TIME_CON2, val);
+	phy_write(samsung, DPHY_MD3_TIME_CON2, val);
+
+	/* TTA-GET/TTA-GO Timing Counter register use default value */
+	val = T_TA_GET(0x3) | T_TA_GO(0x0);
+	phy_write(samsung, COMBO_MD0_TIME_CON3, val);
+	phy_write(samsung, COMBO_MD1_TIME_CON3, val);
+	phy_write(samsung, COMBO_MD2_TIME_CON3, val);
+	phy_write(samsung, DPHY_MD3_TIME_CON3, val);
+
+	/* Escape Clock is 20.00MHz */
+	phy_write(samsung, COMBO_MD0_TIME_CON4, 0x1f4);
+	phy_write(samsung, COMBO_MD1_TIME_CON4, 0x1f4);
+	phy_write(samsung, COMBO_MD2_TIME_CON4, 0x1f4);
+	phy_write(samsung, DPHY_MD3_TIME_CON4, 0x1f4);
+}
+
+static void samsung_mipi_dcphy_pll_enable(struct samsung_mipi_dcphy *samsung)
+{
+	u32 sts;
+	int ret;
+
+	phy_update_bits(samsung, PLL_CON0, PLL_EN, PLL_EN);
+
+	ret = readl_poll_timeout(samsung->base + PLL_STAT0,
+				 sts, (sts & PLL_LOCK), 20000);
+	if (ret < 0)
+		dev_err(samsung->dev, "DC-PHY pll is not locked\n");
+}
+
+static void samsung_mipi_dcphy_pll_disable(struct samsung_mipi_dcphy *samsung)
+{
+	phy_update_bits(samsung, PLL_CON0, PLL_EN, 0);
+}
+
+static void samsung_mipi_dphy_lane_enable(struct samsung_mipi_dcphy *samsung)
+{
+	phy_write(samsung, DPHY_MC_GNR_CON1, T_PHY_READY(0x2000));
+	phy_update_bits(samsung, DPHY_MC_GNR_CON0, PHY_ENABLE, PHY_ENABLE);
+
+	switch (samsung->lanes) {
+	case 4:
+		phy_write(samsung, DPHY_MD3_GNR_CON1, T_PHY_READY(0x2000));
+		phy_update_bits(samsung, DPHY_MD3_GNR_CON0,
+				PHY_ENABLE, PHY_ENABLE);
+		//fallthrough;
+	case 3:
+		phy_write(samsung, COMBO_MD2_GNR_CON1, T_PHY_READY(0x2000));
+		phy_update_bits(samsung, COMBO_MD2_GNR_CON0,
+				PHY_ENABLE, PHY_ENABLE);
+		//fallthrough;
+	case 2:
+		phy_write(samsung, COMBO_MD1_GNR_CON1, T_PHY_READY(0x2000));
+		phy_update_bits(samsung, COMBO_MD1_GNR_CON0,
+				PHY_ENABLE, PHY_ENABLE);
+		//fallthrough;
+	case 1:
+	default:
+		phy_write(samsung, COMBO_MD0_GNR_CON1, T_PHY_READY(0x2000));
+		phy_update_bits(samsung, COMBO_MD0_GNR_CON0,
+				PHY_ENABLE, PHY_ENABLE);
+		break;
+	}
+}
+
+static void samsung_mipi_cphy_timing_init(struct samsung_mipi_dcphy *samsung)
+{
+	const struct samsung_mipi_cphy_timing *timing;
+	unsigned int lane_hs_rate = div64_ul(samsung->pll.rate, USEC_PER_SEC);
+	u32 val = 0;
+
+	timing = samsung_mipi_cphy_get_timing(samsung);
+
+	/*
+	 * Divide-by-2 Clock from Serial Clock. Use this when data rate is under
+	 * 500Msps, otherwise divide-by-16 Clock from Serial Clock
+	 */
+	if (lane_hs_rate < 500)
+		val = HSTX_CLK_SEL;
+
+	val |= T_LPX(timing->lpx);
+	/*  T_LP_EXIT_SKEW/T_LP_ENTRY_SKEW unconfig */
+	phy_write(samsung, COMBO_MD0_TIME_CON0, val);
+	phy_write(samsung, COMBO_MD1_TIME_CON0, val);
+	phy_write(samsung, COMBO_MD2_TIME_CON0, val);
+
+	val = T_HS_ZERO(timing->prebegin_3) | T_HS_PREPARE(timing->prepare_3);
+	phy_write(samsung, COMBO_MD0_TIME_CON1, val);
+	phy_write(samsung, COMBO_MD1_TIME_CON1, val);
+	phy_write(samsung, COMBO_MD2_TIME_CON1, val);
+
+	val = T_HS_EXIT(timing->hs_exit) | T_HS_TRAIL(timing->post_3);
+	phy_write(samsung, DPHY_MD3_TIME_CON2, val);
+	phy_write(samsung, COMBO_MD0_TIME_CON2, val);
+	phy_write(samsung, COMBO_MD1_TIME_CON2, val);
+	phy_write(samsung, COMBO_MD2_TIME_CON2, val);
+
+	/* TTA-GET/TTA-GO Timing Counter register use default value */
+	val = T_TA_GET(0x3) | T_TA_GO(0x0);
+	phy_write(samsung, COMBO_MD0_TIME_CON3, val);
+	phy_write(samsung, COMBO_MD1_TIME_CON3, val);
+	phy_write(samsung, COMBO_MD2_TIME_CON3, val);
+
+	/* Escape Clock is 20.00MHz */
+	phy_write(samsung, COMBO_MD0_TIME_CON4, 0x1f4);
+	phy_write(samsung, COMBO_MD1_TIME_CON4, 0x1f4);
+	phy_write(samsung, COMBO_MD2_TIME_CON4, 0x1f4);
+
+	/* set T_ERR_SOT_SYNC default value */
+}
+
+static void samsung_mipi_cphy_lane_enable(struct samsung_mipi_dcphy *samsung)
+{
+	phy_write(samsung, COMBO_MD0_GNR_CON1, T_PHY_READY(0x2000));
+	phy_write(samsung, COMBO_MD1_GNR_CON1, T_PHY_READY(0x2000));
+	phy_write(samsung, COMBO_MD2_GNR_CON1, T_PHY_READY(0x2000));
+
+	phy_update_bits(samsung, COMBO_MD0_GNR_CON0, PHY_ENABLE, PHY_ENABLE);
+	phy_update_bits(samsung, COMBO_MD1_GNR_CON0, PHY_ENABLE, PHY_ENABLE);
+	phy_update_bits(samsung, COMBO_MD2_GNR_CON0, PHY_ENABLE, PHY_ENABLE);
+}
+
+static void
+samsung_mipi_dcphy_hs_vreg_amp_config(struct samsung_mipi_dcphy *samsung)
+{
+	phy_write(samsung, DPHY_MC_ANA_CON2, HS_VREG_AMP_ICON(2));
+}
+
+static void samsung_mipi_dphy_power_on(struct samsung_mipi_dcphy *samsung)
+{
+	reset_assert(&samsung->m_phy_rst);
+
+	samsung_mipi_dcphy_bias_block_enable(samsung);
+	samsung_mipi_dcphy_pll_configure(samsung);
+	samsung_mipi_dphy_clk_lane_timing_init(samsung);
+	samsung_mipi_dphy_data_lane_timing_init(samsung);
+	samsung_mipi_dcphy_pll_enable(samsung);
+	samsung_mipi_dphy_lane_enable(samsung);
+
+	reset_deassert(&samsung->m_phy_rst);
+
+	/* The Tskewcal maximum is 100 usec at initial calibration. */
+	udelay(100);
+}
+
+static void samsung_mipi_cphy_power_on(struct samsung_mipi_dcphy *samsung)
+{
+	grf_write(samsung, MIPI_DCPHY_GRF_CON0, M_CPHY_MODE);
+	reset_assert(&samsung->m_phy_rst);
+
+	samsung_mipi_dcphy_bias_block_enable(samsung);
+	samsung_mipi_dcphy_hs_vreg_amp_config(samsung);
+	samsung_mipi_dcphy_pll_configure(samsung);
+	samsung_mipi_cphy_timing_init(samsung);
+	samsung_mipi_dcphy_pll_enable(samsung);
+	samsung_mipi_cphy_lane_enable(samsung);
+
+	reset_deassert(&samsung->m_phy_rst);
+}
+
+static void samsung_mipi_dphy_lane_disable(struct samsung_mipi_dcphy *samsung)
+{
+	phy_update_bits(samsung, DPHY_MC_GNR_CON0, PHY_ENABLE, 0);
+	phy_update_bits(samsung, COMBO_MD0_GNR_CON0, PHY_ENABLE, 0);
+	phy_update_bits(samsung, COMBO_MD1_GNR_CON0, PHY_ENABLE, 0);
+	phy_update_bits(samsung, COMBO_MD2_GNR_CON0, PHY_ENABLE, 0);
+	phy_update_bits(samsung, DPHY_MD3_GNR_CON0, PHY_ENABLE, 0);
+}
+
+static void samsung_mipi_cphy_lane_disable(struct samsung_mipi_dcphy *samsung)
+{
+	phy_update_bits(samsung, COMBO_MD0_GNR_CON0, PHY_ENABLE, 0);
+	phy_update_bits(samsung, COMBO_MD1_GNR_CON0, PHY_ENABLE, 0);
+	phy_update_bits(samsung, COMBO_MD2_GNR_CON0, PHY_ENABLE, 0);
+}
+
+static int samsung_mipi_dcphy_power_on(struct rockchip_phy *phy)
+{
+	struct samsung_mipi_dcphy *samsung = dev_get_priv(phy->dev);
+
+	if (samsung->mode == PHY_MODE_MIPI_DPHY)
+		samsung_mipi_dphy_power_on(samsung);
+	else
+		samsung_mipi_cphy_power_on(samsung);
+
+	return 0;
+}
+
+static int samsung_mipi_dcphy_power_off(struct rockchip_phy *phy)
+{
+	struct samsung_mipi_dcphy *samsung = dev_get_priv(phy->dev);
+
+	if (samsung->mode == PHY_MODE_MIPI_DPHY)
+		samsung_mipi_dphy_lane_disable(samsung);
+	else
+		samsung_mipi_cphy_lane_disable(samsung);
+
+	samsung_mipi_dcphy_pll_disable(samsung);
+	samsung_mipi_dcphy_bias_block_disable(samsung);
+
+	return 0;
+}
+
+static int
+samsung_mipi_dcphy_pll_ssc_modulation_calc(struct samsung_mipi_dcphy *samsung,
+					   u8 *mfr, u8 *mrr)
+{
+	unsigned long fin = 24000;
+	u16 prediv = samsung->pll.prediv;
+	u16 fbdiv = samsung->pll.fbdiv;
+	u16 min_mfr, max_mfr;
+	u16 _mfr, best_mfr = 0;
+	u16 mr, _mrr, best_mrr = 0;
+
+	/* 20KHz ≤ MF ≤ 150KHz */
+	max_mfr = DIV_ROUND_UP(fin, (20 * prediv) << 5);
+	min_mfr = div64_ul(fin, ((150 * prediv) << 5));
+	/*0 ≤ mfr ≤ 255 */
+	if (max_mfr > 256)
+		max_mfr = 256;
+
+	for (_mfr = min_mfr; _mfr < max_mfr; _mfr++) {
+		/* 1 ≤ mrr ≤ 31 */
+		for (_mrr = 1; _mrr < 32; _mrr++) {
+			mr = DIV_ROUND_UP(_mfr * _mrr * 100, fbdiv << 6);
+			/* 0 ≤ MR ≤ 5% */
+			if (mr > 5)
+				continue;
+
+			if (_mfr * _mrr < 513) {
+				best_mfr = _mfr;
+				best_mrr = _mrr;
+				break;
+			}
+		}
+	}
+
+	if (best_mrr) {
+		*mfr = best_mfr & 0xff;
+		*mrr = best_mrr & 0x3f;
+	} else {
+		dev_err(samsung->dev, "failed to calc ssc parameter mfr and mrr\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static unsigned long
+samsung_mipi_dcphy_pll_round_rate(struct samsung_mipi_dcphy *samsung,
+				  unsigned long prate, unsigned long rate,
+				  u8 *prediv, u16 *fbdiv, int *dsm, u8 *scaler)
+{
+	u64 max_fout = samsung->c_option ? MAX_CPHY_BW : MAX_DPHY_BW;
+	u64 best_freq = 0;
+	u64 fin, fvco, fout;
+	u8 min_prediv, max_prediv;
+	u8 _prediv, best_prediv = 1;
+	u16 _fbdiv, best_fbdiv = 1;
+	u8 _scaler, best_scaler = 0;
+	long _dsm, best_dsm = 0;
+	u32 min_delta = 0xffffffff;
+
+	/*
+	 * The PLL output frequency can be calculated using a simple formula:
+	 * Fvco = ((m+k/65536) x 2 x Fin) / p
+	 * Fout = ((m+k/65536) x 2 x Fin) / (p x 2^s)
+	 */
+	fin = div64_ul(prate, MSEC_PER_SEC);
+
+	while (!best_freq) {
+		fout = div64_ul(rate, MSEC_PER_SEC);
+		if (fout > max_fout)
+			fout = max_fout;
+
+		/* 0 ≤ S[2:0] ≤ 6 */
+		for (_scaler = 0; _scaler < 7; _scaler++) {
+			fvco = fout << _scaler;
+
+			/*
+			 * 2600MHz ≤ FVCO ≤ 6600MHz
+			 */
+			if (fvco < 2600 * MSEC_PER_SEC || fvco > 6600 * MSEC_PER_SEC)
+				continue;
+
+			/* 6MHz ≤ Fref(Fin / p) ≤ 30MHz */
+			min_prediv = DIV_ROUND_UP(fin, 30 * MSEC_PER_SEC);
+			max_prediv = DIV_ROUND_CLOSEST(fin, 6 * MSEC_PER_SEC);
+
+			for (_prediv = min_prediv; _prediv <= max_prediv; _prediv++) {
+				u64 delta, tmp;
+
+				_fbdiv = DIV_ROUND_CLOSEST(fvco * _prediv, 2 * fin);
+
+				 /* 64 ≤ M[9:0] ≤ 1023 */
+				if ((_fbdiv < 64) || (_fbdiv > 1023))
+					continue;
+
+				/* -32767 ≤ K[15:0] ≤ 32767 */
+				_dsm = ((_prediv * fvco) - (2 * _fbdiv * fin));
+				_dsm = DIV_ROUND_UP(_dsm << 15, fin);
+				if (abs(_dsm) > 32767)
+					continue;
+
+				tmp = DIV_ROUND_CLOSEST((_fbdiv * fin * 2 * 1000), _prediv);
+				tmp += DIV_ROUND_CLOSEST((_dsm * fin * 1000), _prediv << 15);
+
+				delta = abs(fvco * MSEC_PER_SEC - tmp);
+				if (delta < min_delta) {
+					best_prediv = _prediv;
+					best_fbdiv = _fbdiv;
+					best_dsm = _dsm;
+					best_scaler = _scaler;
+					min_delta = delta;
+					best_freq = DIV_ROUND_CLOSEST(tmp, 1000) * MSEC_PER_SEC;
+				}
+			}
+		}
+
+		rate += 100 * MSEC_PER_SEC;
+	}
+
+	*prediv = best_prediv;
+	*fbdiv = best_fbdiv;
+	*dsm = (int)best_dsm & 0xffff;
+	*scaler = best_scaler;
+	dev_info(samsung->dev, "p: %d, m: %d, dsm:%ld, scaler: %d\n",
+		 best_prediv, best_fbdiv, best_dsm, best_scaler);
+
+	return best_freq >> best_scaler;
+}
+
+static unsigned long samsung_mipi_dcphy_set_pll(struct rockchip_phy *phy,
+						unsigned long rate)
+{
+	struct samsung_mipi_dcphy *samsung = dev_get_priv(phy->dev);
+	unsigned long fin = 24000000, fout;
+	u8 scaler = 0, mfr = 0, mrr = 0;
+	u16 fbdiv = 1;
+	u8 prediv = 1;
+	int dsm = 0;
+	int ret;
+
+	samsung->c_option = (samsung->mode == PHY_MODE_MIPI_DPHY) ? false : true;
+	fout = samsung_mipi_dcphy_pll_round_rate(samsung, fin, rate, &prediv,
+						 &fbdiv, &dsm, &scaler);
+
+	dev_info(samsung->dev, "fin=%lu, req_rate=%lu\n", fin, rate);
+	dev_info(samsung->dev, "fout=%lu, prediv=%u, fbdiv=%u\n", fout, prediv, fbdiv);
+
+	samsung->pll.prediv = prediv;
+	samsung->pll.fbdiv = fbdiv;
+	samsung->pll.dsm = dsm;
+	samsung->pll.scaler = scaler;
+	samsung->pll.rate = fout;
+
+	/*
+	 * All DPHY 2.0 compliant Transmitters shall support SSC operating above
+	 * 2.5 Gbps
+	 */
+	if (fout > 2500000000LL) {
+		ret = samsung_mipi_dcphy_pll_ssc_modulation_calc(samsung,
+								 &mfr, &mrr);
+		if (!ret) {
+			samsung->pll.ssc_en = true;
+			samsung->pll.mfr = mfr;
+			samsung->pll.mrr = mrr;
+		}
+	}
+
+	return fout;
+}
+
+static int samsung_mipi_dcphy_set_mode(struct rockchip_phy *phy,
+				       enum phy_mode mode)
+{
+	struct samsung_mipi_dcphy *samsung = dev_get_priv(phy->dev);
+
+	samsung->mode = mode;
+
+	return 0;
+}
+
+static int samsung_mipi_dcphy_probe(struct udevice *dev)
+{
+	struct samsung_mipi_dcphy *samsung = dev_get_priv(dev);
+	struct rockchip_phy *tmp_phy;
+	struct rockchip_phy *phy;
+	struct udevice *syscon;
+	int ret;
+
+	phy = calloc(1, sizeof(*phy));
+	if (!phy)
+		return -ENOMEM;
+
+	tmp_phy = (struct rockchip_phy *)dev_get_driver_data(dev);
+	dev->driver_data = (ulong)phy;
+	memcpy(phy, tmp_phy, sizeof(*phy));
+
+	samsung->lanes = ofnode_read_u32_default(dev->node, "samsung,lanes", 4);
+
+	samsung->base = dev_read_addr_ptr(dev);
+	if (IS_ERR(samsung->base)) {
+		dev_err(dev, "resource \"phy\" not found\n");
+		return PTR_ERR(samsung->base);
+	}
+
+	ret = uclass_get_device_by_phandle(UCLASS_SYSCON, dev, "rockchip,grf",
+					   &syscon);
+	if (!ret) {
+		samsung->grf = syscon_get_regmap(syscon);
+		if (!samsung->grf)
+			return -ENODEV;
+	}
+
+	ret = reset_get_by_name(dev, "m_phy", &samsung->m_phy_rst);
+	if (ret) {
+		ret = reset_get_by_name(dev, "phy", &samsung->m_phy_rst);
+		if (ret) {
+			pr_err("reset_get_by_name(phy) failed: %d\n", ret);
+			return ret;
+		}
+	}
+
+	phy->dev = dev;
+
+	return 0;
+}
+
+static const struct rockchip_phy_funcs samsung_mipi_dcphy_funcs = {
+	.power_on = samsung_mipi_dcphy_power_on,
+	.power_off = samsung_mipi_dcphy_power_off,
+	.set_pll = samsung_mipi_dcphy_set_pll,
+	.set_mode = samsung_mipi_dcphy_set_mode,
+};
+
+static struct rockchip_phy rk3588_samsung_mipi_dcphy_driver_data = {
+	 .funcs = &samsung_mipi_dcphy_funcs,
+};
+
+static const struct udevice_id samsung_mipi_dcphy_ids[] = {
+	{
+		.compatible = "rockchip,rk3588-mipi-dcphy",
+		.data = (ulong)&rk3588_samsung_mipi_dcphy_driver_data,
+	},
+	{}
+};
+
+U_BOOT_DRIVER(samsung_mipi_dcphy) = {
+	.name = "samsung-mipi-dcphy",
+	.id = UCLASS_PHY,
+	.of_match = samsung_mipi_dcphy_ids,
+	.probe = samsung_mipi_dcphy_probe,
+	.priv_auto_alloc_size = sizeof(struct samsung_mipi_dcphy),
+};
diff --git a/dts/upstream/include/dt-bindings/clock/rockchip,rk3588-cru.h b/dts/upstream/include/dt-bindings/clock/rockchip,rk3588-cru.h
index 5790b13912..b6a43e136b 100644
--- a/dts/upstream/include/dt-bindings/clock/rockchip,rk3588-cru.h
+++ b/dts/upstream/include/dt-bindings/clock/rockchip,rk3588-cru.h
@@ -733,6 +733,7 @@
 #define ACLK_AV1_PRE			718
 #define PCLK_AV1_PRE			719
 #define HCLK_SDIO_PRE			720
+#define PCLK_VO1GRF			721
 
 #define CLK_NR_CLKS			(HCLK_SDIO_PRE + 1)
 
diff --git a/dts/upstream/include/dt-bindings/display/rockchip_vop.h b/dts/upstream/include/dt-bindings/display/rockchip_vop.h
new file mode 100644
index 0000000000..3e14128e7a
--- /dev/null
+++ b/dts/upstream/include/dt-bindings/display/rockchip_vop.h
@@ -0,0 +1,21 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2021 Rockchip Electronics Co., Ltd.
+ */
+
+
+#ifndef _DT_BINDINGS_ROCKCHIP_VOP_H
+#define _DT_BINDINGS_ROCKCHIP_VOP_H
+
+#define	ROCKCHIP_VOP2_CLUSTER0	0
+#define	ROCKCHIP_VOP2_CLUSTER1	1
+#define	ROCKCHIP_VOP2_ESMART0	2
+#define	ROCKCHIP_VOP2_ESMART1	3
+#define	ROCKCHIP_VOP2_SMART0	4
+#define	ROCKCHIP_VOP2_SMART1	5
+#define	ROCKCHIP_VOP2_CLUSTER2	6
+#define	ROCKCHIP_VOP2_CLUSTER3	7
+#define	ROCKCHIP_VOP2_ESMART2	8
+#define	ROCKCHIP_VOP2_ESMART3	9
+
+#endif
diff --git a/dts/upstream/src/arm64/rockchip/rk3588-hinlink-h88k.dts b/dts/upstream/src/arm64/rockchip/rk3588-hinlink-h88k.dts
new file mode 100644
index 0000000000..80b505c734
--- /dev/null
+++ b/dts/upstream/src/arm64/rockchip/rk3588-hinlink-h88k.dts
@@ -0,0 +1,1044 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2023 Ondřej Jirman <megi@xff.cz>
+ */
+
+ /dts-v1/;
+
+ #include <dt-bindings/gpio/gpio.h>
+ #include <dt-bindings/leds/common.h>
+ #include <dt-bindings/input/input.h>
+ #include <dt-bindings/pinctrl/rockchip.h>
+ #include <dt-bindings/display/rockchip_vop.h>
+ #include <dt-bindings/usb/pd.h>
+ #include "rk3588.dtsi"
+ 
+ / {
+	 model = "HINLINK H88K";
+	 compatible = "hinlink,h88k", "rockchip,rk3588";
+ 
+	 smbios {
+		compatible = "u-boot,sysinfo-smbios";
+
+		smbios {
+			system {
+				manufacturer = "HINLINK";
+				product = "HINLINK H88K";
+				family = "Rockchip/RK3588";
+			};
+
+			baseboard {
+				manufacturer = "HINLINK";
+				product = "HINLINK H88K";
+			};
+
+			chassis {
+				manufacturer = "HINLINK";
+				product = "HINLINK H88K";
+			};
+		};
+	};
+
+	 aliases {
+		 ethernet0 = &gmac0;
+		 mmc0 = &sdhci;
+		 mmc1 = &sdmmc;
+		 hdmi0 = &hdmi0;
+		 hdmi1 = &hdmi1;
+		 hdptxhdmi1 = &hdptxphy_hdmi1;
+		 hdptxhdmi0 = &hdptxphy_hdmi0;
+		 dp0 = &dp0;
+		 usbdp0 = &usbdp_phy0;
+		 usbdp1 = &usbdp_phy1;
+	 };
+ 
+	 chosen {
+		 stdout-path = "serial2:1500000n8";
+	 };
+ 
+	 adc-keys-0 {
+		 compatible = "adc-keys";
+		 io-channels = <&saradc 0>;
+		 io-channel-names = "buttons";
+		 keyup-threshold-microvolt = <1800000>;
+		 poll-interval = <100>;
+ 
+		 button-maskrom {
+			 label = "Mask Rom";
+			 linux,code = <KEY_SETUP>;
+			 press-threshold-microvolt = <2000>;
+		 };
+	 };
+ 
+	 adc-keys-1 {
+		 compatible = "adc-keys";
+		 io-channels = <&saradc 1>;
+		 io-channel-names = "buttons";
+		 keyup-threshold-microvolt = <1800000>;
+		 poll-interval = <100>;
+ 
+		 button-recovery {
+			 label = "Recovery";
+			 linux,code = <KEY_VENDOR>;
+			 press-threshold-microvolt = <2000>;
+		 };
+	 };
+ 
+	 speaker_amp: speaker-audio-amplifier {
+		 compatible = "simple-audio-amplifier";
+		 enable-gpios = <&gpio3 RK_PC0 GPIO_ACTIVE_HIGH>;
+		 sound-name-prefix = "Speaker Amp";
+	 };
+ 
+	 headphone_amp: headphones-audio-amplifier {
+		 compatible = "simple-audio-amplifier";
+		 enable-gpios = <&gpio3 RK_PA7 GPIO_ACTIVE_HIGH>;
+		 sound-name-prefix = "Headphones Amp";
+	 };
+ 
+	 ir-receiver {
+		 compatible = "gpio-ir-receiver";
+		 gpios = <&gpio4 RK_PB3 GPIO_ACTIVE_LOW>;
+		 pinctrl-names = "default";
+		 pinctrl-0 = <&ir_receiver_pin>;
+	 };
+ 
+	 gpio-leds {
+		 compatible = "gpio-leds";
+		 pinctrl-names = "default";
+		 pinctrl-0 = <&blue_led_pin>;
+ 
+		 led {
+			 color = <LED_COLOR_ID_BLUE>;
+			 function = LED_FUNCTION_INDICATOR;
+			 function-enumerator = <1>;
+			 gpios = <&gpio3 RK_PA6 GPIO_ACTIVE_HIGH>;
+		 };
+	 };
+ 
+	 fan: pwm-fan {
+		 compatible = "pwm-fan";
+		 cooling-levels = <0 70 75 80 100>;
+		 fan-supply = <&vcc5v0_sys>;
+		 pwms = <&pwm3 0 50000 0>;
+		 #cooling-cells = <2>;
+	 };
+ 
+	 pwm-leds {
+		 compatible = "pwm-leds";
+ 
+		 led {
+			 color = <LED_COLOR_ID_GREEN>;
+			 function = LED_FUNCTION_INDICATOR;
+			 function-enumerator = <2>;
+			 max-brightness = <255>;
+			 pwms = <&pwm2 0 25000 0>;
+		 };
+	 };
+ 
+	 sound {
+		 compatible = "simple-audio-card";
+		 pinctrl-names = "default";
+		 pinctrl-0 = <&hp_detect>;
+		 simple-audio-card,name = "Analog";
+		 simple-audio-card,aux-devs = <&speaker_amp>, <&headphone_amp>;
+		 simple-audio-card,format = "i2s";
+		 simple-audio-card,mclk-fs = <256>;
+		 simple-audio-card,hp-det-gpio = <&gpio1 RK_PD3 GPIO_ACTIVE_LOW>;
+		 simple-audio-card,bitclock-master = <&daicpu>;
+		 simple-audio-card,frame-master = <&daicpu>;
+		 /*TODO: SARADC_IN3 is used as MIC detection / key input */
+ 
+		 simple-audio-card,widgets =
+			 "Microphone", "Onboard Microphone",
+			 "Microphone", "Microphone Jack",
+			 "Speaker", "Speaker",
+			 "Headphone", "Headphones";
+ 
+		 simple-audio-card,routing =
+			 "Headphones", "LOUT1",
+			 "Headphones", "ROUT1",
+			 "Speaker", "LOUT2",
+			 "Speaker", "ROUT2",
+ 
+			 "Headphones", "Headphones Amp OUTL",
+			 "Headphones", "Headphones Amp OUTR",
+			 "Headphones Amp INL", "LOUT1",
+			 "Headphones Amp INR", "ROUT1",
+ 
+			 "Speaker", "Speaker Amp OUTL",
+			 "Speaker", "Speaker Amp OUTR",
+			 "Speaker Amp INL", "LOUT2",
+			 "Speaker Amp INR", "ROUT2",
+ 
+			 /* single ended signal to LINPUT1 */
+			 "LINPUT1", "Microphone Jack",
+			 "RINPUT1", "Microphone Jack",
+			 /* differential signal */
+			 "LINPUT2", "Onboard Microphone",
+			 "RINPUT2", "Onboard Microphone";
+ 
+		 daicpu: simple-audio-card,cpu {
+			 sound-dai = <&i2s0_8ch>;
+			 system-clock-frequency = <12288000>;
+		 };
+ 
+		 daicodec: simple-audio-card,codec {
+			 sound-dai = <&es8388>;
+			 system-clock-frequency = <12288000>;
+		 };
+	 };
+ 
+	 vcc3v3_pcie30: vcc3v3-pcie30 {
+		 compatible = "regulator-fixed";
+		 enable-active-high;
+		 gpios = <&gpio3 RK_PD5 GPIO_ACTIVE_HIGH>;
+		 regulator-min-microvolt = <3300000>;
+		 regulator-max-microvolt = <3300000>;
+		 regulator-name = "vcc3v3_pcie30";
+		 startup-delay-us = <5000>;
+		 vin-supply = <&vcc12v_dcin>;
+	 };
+ 
+	 vcc3v3_pcie_eth: vcc3v3-pcie-eth-regulator {
+		 compatible = "regulator-fixed";
+		 gpios = <&gpio3 RK_PB4 GPIO_ACTIVE_LOW>;
+		 regulator-name = "vcc3v3_pcie_eth";
+		 regulator-min-microvolt = <3300000>;
+		 regulator-max-microvolt = <3300000>;
+		 startup-delay-us = <50000>;
+		 vin-supply = <&vcc5v0_sys>;
+	 };
+ 
+	 vcc3v3_wf: vcc3v3-wf-regulator {
+		 compatible = "regulator-fixed";
+		 enable-active-high;
+		 gpios = <&gpio2 RK_PC5 GPIO_ACTIVE_HIGH>;
+		 regulator-name = "vcc3v3_wf";
+		 regulator-min-microvolt = <3300000>;
+		 regulator-max-microvolt = <3300000>;
+		 startup-delay-us = <50000>;
+		 vin-supply = <&vcc5v0_sys>;
+	 };
+ 
+	 vcc5v0_sys: vcc5v0-sys-regulator {
+		 compatible = "regulator-fixed";
+		 regulator-name = "vcc5v0_sys";
+		 regulator-always-on;
+		 regulator-boot-on;
+		 regulator-min-microvolt = <5000000>;
+		 regulator-max-microvolt = <5000000>;
+		 vin-supply = <&vcc12v_dcin>;
+	 };
+ 
+	 vcc12v_dcin: vcc12v-dcin {
+		 compatible = "regulator-fixed";
+		 regulator-always-on;
+		 regulator-boot-on;
+		 regulator-min-microvolt = <12000000>;
+		 regulator-max-microvolt = <12000000>;
+		 regulator-name = "vcc12v_dcin";
+	 };
+ 
+	 // vcc5v0_usb: vcc5v0-usb {
+	 // 	compatible = "regulator-fixed";
+	 // 	regulator-always-on;
+	 // 	regulator-boot-on;
+	 // 	regulator-min-microvolt = <5000000>;
+	 // 	regulator-max-microvolt = <5000000>;
+	 // 	regulator-name = "vcc5v0_usb";
+	 // 	vin-supply = <&vcc12v_dcin>;
+	 // };
+ 
+	 vcc5v0_usb_host: vcc5v0-usb-host {
+		 compatible = "regulator-fixed";
+		 enable-active-high;
+		 gpio = <&gpio4 RK_PB0 GPIO_ACTIVE_HIGH>;
+		 pinctrl-names = "default";
+		 pinctrl-0 = <&vcc5v0_usb_host_en>;
+		 regulator-min-microvolt = <5000000>;
+		 regulator-max-microvolt = <5000000>;
+		 regulator-name = "vcc5v0_usb_host";
+		 vin-supply = <&vcc5v0_sys>;
+	 };
+ 
+	 vcc5v0_usb20: vcc5v0-usb20-regulator {
+		 compatible = "regulator-fixed";
+		 enable-active-high;
+		 gpio = <&gpio3 RK_PB7 GPIO_ACTIVE_HIGH>;
+		 pinctrl-names = "default";
+		 pinctrl-0 = <&vcc5v0_usb20_en>;
+		 regulator-name = "vcc5v0_usb20";
+		 regulator-min-microvolt = <5000000>;
+		 regulator-max-microvolt = <5000000>;
+		 vin-supply = <&vcc5v0_sys>;
+	 };
+ };
+ 
+ &mdio0 {
+	 rgmii_phy: ethernet-phy@1 {
+		 /* RTL8211F */
+		 compatible = "ethernet-phy-id001c.c916";
+		 reg = <0x1>;
+		 pinctrl-names = "default";
+		 pinctrl-0 = <&rtl8211f_rst>;
+		 reset-assert-us = <20000>;
+		 reset-deassert-us = <100000>;
+		 reset-gpios = <&gpio4 RK_PB3 GPIO_ACTIVE_LOW>;
+	 };
+ };
+ 
+ &gmac0 {
+	 clock_in_out = "output";
+	 phy-handle = <&rgmii_phy>;
+	 phy-mode = "rgmii-rxid";
+	 pinctrl-0 = <&gmac0_miim
+			  &gmac0_tx_bus2
+			  &gmac0_rx_bus2
+			  &gmac0_rgmii_clk
+			  &gmac0_rgmii_bus>;
+	 pinctrl-names = "default";
+	 rx_delay = <0x00>;
+	 tx_delay = <0x43>;
+	 status = "okay";
+ };
+ 
+ &combphy0_ps {
+	 status = "okay";
+ };
+ 
+ &combphy1_ps {
+	 status = "okay";
+ };
+ 
+ &combphy2_psu {
+	 status = "okay";
+ };
+ 
+ &cpu_b0 {
+	 cpu-supply = <&vdd_cpu_big0_s0>;
+ };
+ 
+ &cpu_b1 {
+	 cpu-supply = <&vdd_cpu_big0_s0>;
+ };
+ 
+ &cpu_b2 {
+	 cpu-supply = <&vdd_cpu_big1_s0>;
+ };
+ 
+ &cpu_b3 {
+	 cpu-supply = <&vdd_cpu_big1_s0>;
+ };
+ 
+ &cpu_l0 {
+	 cpu-supply = <&vdd_cpu_lit_s0>;
+ };
+ 
+ &cpu_l1 {
+	 cpu-supply = <&vdd_cpu_lit_s0>;
+ };
+ 
+ &cpu_l2 {
+	 cpu-supply = <&vdd_cpu_lit_s0>;
+ };
+ 
+ &cpu_l3 {
+	 cpu-supply = <&vdd_cpu_lit_s0>;
+ };
+ 
+ &i2c0 {
+	 pinctrl-names = "default";
+	 pinctrl-0 = <&i2c0m2_xfer>;
+	 status = "okay";
+ 
+	 vdd_cpu_big0_s0: regulator@42 {
+		 compatible = "rockchip,rk8602";
+		 reg = <0x42>;
+		 fcs,suspend-voltage-selector = <1>;
+		 regulator-name = "vdd_cpu_big0_s0";
+		 regulator-always-on;
+		 regulator-boot-on;
+		 regulator-min-microvolt = <550000>;
+		 regulator-max-microvolt = <1050000>;
+		 regulator-ramp-delay = <2300>;
+		 vin-supply = <&vcc5v0_sys>;
+ 
+		 regulator-state-mem {
+			 regulator-off-in-suspend;
+		 };
+	 };
+ 
+	 vdd_cpu_big1_s0: regulator@43 {
+		 compatible = "rockchip,rk8603", "rockchip,rk8602";
+		 reg = <0x43>;
+		 fcs,suspend-voltage-selector = <1>;
+		 regulator-name = "vdd_cpu_big1_s0";
+		 regulator-always-on;
+		 regulator-boot-on;
+		 regulator-min-microvolt = <550000>;
+		 regulator-max-microvolt = <1050000>;
+		 regulator-ramp-delay = <2300>;
+		 vin-supply = <&vcc5v0_sys>;
+ 
+		 regulator-state-mem {
+			 regulator-off-in-suspend;
+		 };
+	 };
+ };
+ 
+ &i2c6 {
+	 clock-frequency = <400000>;
+	 status = "okay";
+ 
+	 hym8563: rtc@51 {
+		 compatible = "haoyu,hym8563";
+		 reg = <0x51>;
+		 interrupt-parent = <&gpio0>;
+		 interrupts = <RK_PB0 IRQ_TYPE_LEVEL_LOW>;
+		 #clock-cells = <0>;
+		 clock-output-names = "hym8563";
+		 pinctrl-names = "default";
+		 pinctrl-0 = <&hym8563_int>;
+		 wakeup-source;
+	 };
+ };
+ 
+ &i2c7 {
+	 status = "okay";
+ 
+	 /* PLDO2 vcca 1.8V, BUCK8 gated by PLDO2 being enabled */
+	 es8388: audio-codec@11 {
+		 compatible = "everest,es8388";
+		 reg = <0x11>;
+		 clocks = <&cru I2S0_8CH_MCLKOUT>;
+		 clock-names = "mclk";
+		 AVDD-supply = <&vcc_1v8_s0>;
+		 DVDD-supply = <&vcc_1v8_s0>;
+		 HPVDD-supply = <&vcc_3v3_s0>;
+		 PVDD-supply = <&vcc_3v3_s0>;
+		 assigned-clocks = <&cru I2S0_8CH_MCLKOUT>;
+		 assigned-clock-rates = <12288000>;
+		 #sound-dai-cells = <0>;
+	 };
+ };
+ 
+ &i2s0_8ch {
+	 pinctrl-names = "default";
+	 pinctrl-0 = <&i2s0_lrck
+			  &i2s0_mclk
+			  &i2s0_sclk
+			  &i2s0_sdi0
+			  &i2s0_sdo0>;
+	 status = "okay";
+ };
+ 
+ &i2s2_2ch {
+	 pinctrl-names = "default";
+	 pinctrl-0 = <&i2s2m0_lrck
+			  &i2s2m0_sclk
+			  &i2s2m0_sdi
+			  &i2s2m0_sdo>;
+	 status = "okay";
+ };
+ 
+//  &pcie2x1l0 {
+//  	reset-gpios = <&gpio0 RK_PB0 GPIO_ACTIVE_HIGH>;
+//  	status = "okay";
+//  };
+ 
+//  &pcie2x1l1 {
+//  	reset-gpios = <&gpio4 RK_PA2 GPIO_ACTIVE_HIGH>;
+//  	status = "okay";
+//  };
+ 
+//  &pcie2x1l2 {
+//  	reset-gpios = <&gpio4 RK_PA5 GPIO_ACTIVE_HIGH>;
+//  	status = "okay";
+//  };
+ 
+ &pcie30phy {
+	 status = "okay";
+ };
+ 
+ &pcie3x4 {
+	 reset-gpios = <&gpio4 RK_PB6 GPIO_ACTIVE_HIGH>;
+	 vpcie3v3-supply = <&vcc3v3_pcie30>;
+	 status = "okay";
+ };
+ 
+ &pinctrl {
+	 hym8563 {
+		 hym8563_int: hym8563-int {
+			 rockchip,pins = <0 RK_PB0 RK_FUNC_GPIO &pcfg_pull_none>;
+		 };
+	 };
+ 
+	 leds {
+		 blue_led_pin: blue-led {
+			 rockchip,pins = <3 RK_PA6 RK_FUNC_GPIO &pcfg_pull_up>;
+		 };
+	 };
+ 
+	 ir-receiver {
+		 ir_receiver_pin: ir-receiver-pin {
+			 rockchip,pins = <4 RK_PB3 RK_FUNC_GPIO &pcfg_pull_none>;
+		 };
+	 };
+ 
+	 sound {
+		 hp_detect: hp-detect {
+			 rockchip,pins = <1 RK_PD3 RK_FUNC_GPIO &pcfg_pull_none>;
+		 };
+	 };
+ 
+	 usb {
+		 vcc5v0_usb_host_en: vcc5v0_usb_host_en {
+			 rockchip,pins = <4 RK_PB0 RK_FUNC_GPIO &pcfg_pull_none>;
+		 };
+ 
+		 vcc5v0_usb20_en: vcc5v0-usb20-en {
+			 rockchip,pins = <3 RK_PB7 RK_FUNC_GPIO &pcfg_pull_none>;
+		 };
+	 };
+ 
+	 rtl8211f {
+		 rtl8211f_rst: rtl8211f-rst {
+			 rockchip,pins = <4 RK_PB3 RK_FUNC_GPIO &pcfg_pull_none>;
+		 };
+ 
+	 };
+ };
+ 
+ &pwm2 {
+	 pinctrl-0 = <&pwm2m1_pins>;
+	 pinctrl-names = "default";
+	 status = "okay";
+ };
+ 
+ &pwm3 {
+	 pinctrl-0 = <&pwm3m1_pins>;
+	 status = "okay";
+ };
+ 
+ &saradc {
+	 vref-supply = <&vcc_1v8_s0>;
+	 status = "okay";
+ };
+ 
+ &sdhci {
+	 bus-width = <8>;
+	 no-sdio;
+	 no-sd;
+	 non-removable;
+	 max-frequency = <200000000>;
+	 mmc-hs400-1_8v;
+	 mmc-hs400-enhanced-strobe;
+	 status = "okay";
+ };
+ 
+ &sdmmc {
+	 bus-width = <4>;
+	 cap-sd-highspeed;
+	 cd-gpios = <&gpio0 RK_PA4 GPIO_ACTIVE_LOW>;
+	 disable-wp;
+	 max-frequency = <50000000>;
+	 no-sdio;
+	 no-mmc;
+	 sd-uhs-sdr104;
+	 vmmc-supply = <&vcc_3v3_s3>;
+	 vqmmc-supply = <&vccio_sd_s0>;
+	 status = "okay";
+ };
+ 
+ &sfc {
+	 pinctrl-names = "default";
+	 pinctrl-0 = <&fspim1_pins>;
+	 status = "okay";
+ 
+	 spi_flash: flash@0 {
+		 compatible = "jedec,spi-nor";
+		 reg = <0x0>;
+		 spi-max-frequency = <100000000>;
+		 spi-rx-bus-width = <4>;
+		 spi-tx-bus-width = <1>;
+	 };
+ };
+ 
+ &spi2 {
+	 assigned-clocks = <&cru CLK_SPI2>;
+	 assigned-clock-rates = <200000000>;
+	 num-cs = <1>;
+	 pinctrl-names = "default";
+	 pinctrl-0 = <&spi2m2_cs0 &spi2m2_pins>;
+	 status = "okay";
+ 
+	 pmic@0 {
+		 compatible = "rockchip,rk806";
+		 reg = <0x0>;
+		 interrupt-parent = <&gpio0>;
+		 interrupts = <7 IRQ_TYPE_LEVEL_LOW>;
+		 pinctrl-names = "default";
+		 pinctrl-0 = <&pmic_pins>, <&rk806_dvs1_null>,
+				 <&rk806_dvs2_null>, <&rk806_dvs3_null>;
+		 spi-max-frequency = <1000000>;
+ 
+		 vcc1-supply = <&vcc5v0_sys>;
+		 vcc2-supply = <&vcc5v0_sys>;
+		 vcc3-supply = <&vcc5v0_sys>;
+		 vcc4-supply = <&vcc5v0_sys>;
+		 vcc5-supply = <&vcc5v0_sys>;
+		 vcc6-supply = <&vcc5v0_sys>;
+		 vcc7-supply = <&vcc5v0_sys>;
+		 vcc8-supply = <&vcc5v0_sys>;
+		 vcc9-supply = <&vcc5v0_sys>;
+		 vcc10-supply = <&vcc5v0_sys>;
+		 vcc11-supply = <&vcc_2v0_pldo_s3>;
+		 vcc12-supply = <&vcc5v0_sys>;
+		 vcc13-supply = <&vdd2_ddr_s3>;
+		 vcc14-supply = <&vdd2_ddr_s3>;
+		 vcca-supply = <&vcc5v0_sys>;
+ 
+		 gpio-controller;
+		 #gpio-cells = <2>;
+ 
+		 rk806_dvs1_null: dvs1-null-pins {
+			 pins = "gpio_pwrctrl2";
+			 function = "pin_fun0";
+		 };
+ 
+		 rk806_dvs2_null: dvs2-null-pins {
+			 pins = "gpio_pwrctrl2";
+			 function = "pin_fun0";
+		 };
+ 
+		 rk806_dvs3_null: dvs3-null-pins {
+			 pins = "gpio_pwrctrl3";
+			 function = "pin_fun0";
+		 };
+ 
+		 regulators {
+			 vdd_gpu_s0: dcdc-reg1 {
+				 regulator-name = "vdd_gpu_s0";
+				 regulator-boot-on;
+				 regulator-enable-ramp-delay = <400>;
+				 regulator-min-microvolt = <550000>;
+				 regulator-max-microvolt = <950000>;
+				 regulator-ramp-delay = <12500>;
+ 
+				 regulator-state-mem {
+					 regulator-off-in-suspend;
+				 };
+			 };
+ 
+			 vdd_cpu_lit_s0: dcdc-reg2 {
+				 regulator-name = "vdd_cpu_lit_s0";
+				 regulator-always-on;
+				 regulator-boot-on;
+				 regulator-min-microvolt = <550000>;
+				 regulator-max-microvolt = <950000>;
+				 regulator-ramp-delay = <12500>;
+ 
+				 regulator-state-mem {
+					 regulator-off-in-suspend;
+				 };
+			 };
+ 
+			 vdd_log_s0: dcdc-reg3 {
+				 regulator-name = "vdd_log_s0";
+				 regulator-always-on;
+				 regulator-boot-on;
+				 regulator-min-microvolt = <675000>;
+				 regulator-max-microvolt = <825000>;
+				 regulator-ramp-delay = <12500>;
+ 
+				 regulator-state-mem {
+					 regulator-off-in-suspend;
+					 regulator-suspend-microvolt = <750000>;
+				 };
+			 };
+ 
+			 vdd_vdenc_s0: dcdc-reg4 {
+				 regulator-name = "vdd_vdenc_s0";
+				 regulator-always-on;
+				 regulator-boot-on;
+				 regulator-min-microvolt = <550000>;
+				 regulator-max-microvolt = <825000>;
+				 regulator-ramp-delay = <12500>;
+ 
+				 regulator-state-mem {
+					 regulator-off-in-suspend;
+				 };
+			 };
+ 
+			 vdd_ddr_s0: dcdc-reg5 {
+				 regulator-name = "vdd_ddr_s0";
+				 regulator-always-on;
+				 regulator-boot-on;
+				 regulator-min-microvolt = <675000>;
+				 regulator-max-microvolt = <900000>;
+				 regulator-ramp-delay = <12500>;
+ 
+				 regulator-state-mem {
+					 regulator-off-in-suspend;
+					 regulator-suspend-microvolt = <850000>;
+				 };
+			 };
+ 
+			 vdd2_ddr_s3: dcdc-reg6 {
+				 regulator-name = "vdd2_ddr_s3";
+				 regulator-always-on;
+				 regulator-boot-on;
+ 
+				 regulator-state-mem {
+					 regulator-on-in-suspend;
+				 };
+			 };
+ 
+			 vcc_2v0_pldo_s3: dcdc-reg7 {
+				 regulator-name = "vdd_2v0_pldo_s3";
+				 regulator-always-on;
+				 regulator-boot-on;
+				 regulator-min-microvolt = <2000000>;
+				 regulator-max-microvolt = <2000000>;
+				 regulator-ramp-delay = <12500>;
+ 
+				 regulator-state-mem {
+					 regulator-on-in-suspend;
+					 regulator-suspend-microvolt = <2000000>;
+				 };
+			 };
+ 
+			 vcc_3v3_s3: dcdc-reg8 {
+				 regulator-name = "vcc_3v3_s3";
+				 regulator-always-on;
+				 regulator-boot-on;
+				 regulator-min-microvolt = <3300000>;
+				 regulator-max-microvolt = <3300000>;
+ 
+				 regulator-state-mem {
+					 regulator-on-in-suspend;
+					 regulator-suspend-microvolt = <3300000>;
+				 };
+			 };
+ 
+			 vddq_ddr_s0: dcdc-reg9 {
+				 regulator-name = "vddq_ddr_s0";
+				 regulator-always-on;
+				 regulator-boot-on;
+ 
+				 regulator-state-mem {
+					 regulator-off-in-suspend;
+				 };
+			 };
+ 
+			 vcc_1v8_s3: dcdc-reg10 {
+				 regulator-name = "vcc_1v8_s3";
+				 regulator-always-on;
+				 regulator-boot-on;
+				 regulator-min-microvolt = <1800000>;
+				 regulator-max-microvolt = <1800000>;
+ 
+				 regulator-state-mem {
+					 regulator-on-in-suspend;
+					 regulator-suspend-microvolt = <1800000>;
+				 };
+			 };
+ 
+			 avcc_1v8_s0: pldo-reg1 {
+				 regulator-name = "avcc_1v8_s0";
+				 regulator-always-on;
+				 regulator-boot-on;
+				 regulator-min-microvolt = <1800000>;
+				 regulator-max-microvolt = <1800000>;
+ 
+				 regulator-state-mem {
+					 regulator-off-in-suspend;
+					 regulator-suspend-microvolt = <1800000>;
+				 };
+			 };
+ 
+			 /* shorted to avcc_1v8_s0 on the board */
+			 vcc_1v8_s0: pldo-reg2 {
+				 regulator-name = "vcc_1v8_s0";
+				 regulator-always-on;
+				 regulator-boot-on;
+				 regulator-min-microvolt = <1800000>;
+				 regulator-max-microvolt = <1800000>;
+ 
+				 regulator-state-mem {
+					 regulator-off-in-suspend;
+					 regulator-suspend-microvolt = <1800000>;
+				 };
+			 };
+ 
+			 avdd_1v2_s0: pldo-reg3 {
+				 regulator-name = "avdd_1v2_s0";
+				 regulator-always-on;
+				 regulator-boot-on;
+				 regulator-min-microvolt = <1200000>;
+				 regulator-max-microvolt = <1200000>;
+ 
+				 regulator-state-mem {
+					 regulator-off-in-suspend;
+				 };
+			 };
+ 
+			 vcc_3v3_s0: pldo-reg4 {
+				 regulator-name = "vcc_3v3_s0";
+				 regulator-always-on;
+				 regulator-boot-on;
+				 regulator-min-microvolt = <3300000>;
+				 regulator-max-microvolt = <3300000>;
+				 regulator-ramp-delay = <12500>;
+ 
+				 regulator-state-mem {
+					 regulator-off-in-suspend;
+				 };
+			 };
+ 
+			 vccio_sd_s0: pldo-reg5 {
+				 regulator-name = "vccio_sd_s0";
+				 regulator-always-on;
+				 regulator-boot-on;
+				 regulator-min-microvolt = <1800000>;
+				 regulator-max-microvolt = <3300000>;
+				 regulator-ramp-delay = <12500>;
+ 
+				 regulator-state-mem {
+					 regulator-off-in-suspend;
+				 };
+			 };
+ 
+			 pldo6_s3: pldo-reg6 {
+				 regulator-name = "pldo6_s3";
+				 regulator-always-on;
+				 regulator-boot-on;
+				 regulator-min-microvolt = <1800000>;
+				 regulator-max-microvolt = <1800000>;
+ 
+				 regulator-state-mem {
+					 regulator-on-in-suspend;
+					 regulator-suspend-microvolt = <1800000>;
+				 };
+			 };
+ 
+			 vdd_0v75_s3: nldo-reg1 {
+				 regulator-name = "vdd_0v75_s3";
+				 regulator-always-on;
+				 regulator-boot-on;
+				 regulator-min-microvolt = <750000>;
+				 regulator-max-microvolt = <750000>;
+ 
+				 regulator-state-mem {
+					 regulator-on-in-suspend;
+					 regulator-suspend-microvolt = <750000>;
+				 };
+			 };
+ 
+			 vdd_ddr_pll_s0: nldo-reg2 {
+				 regulator-name = "vdd_ddr_pll_s0";
+				 regulator-always-on;
+				 regulator-boot-on;
+				 regulator-min-microvolt = <850000>;
+				 regulator-max-microvolt = <850000>;
+ 
+				 regulator-state-mem {
+					 regulator-off-in-suspend;
+					 regulator-suspend-microvolt = <850000>;
+				 };
+			 };
+ 
+			 avdd_0v75_s0: nldo-reg3 {
+				 regulator-name = "avdd_0v75_s0";
+				 regulator-always-on;
+				 regulator-boot-on;
+				 /*
+				  * The schematic mentions that actual setting
+				  * should be 0.8375V. RK3588 datasheet specifies
+				  * maximum as 0.825V. So we set datasheet max
+				  * here.
+				  */
+				 regulator-min-microvolt = <825000>;
+				 regulator-max-microvolt = <825000>;
+ 
+				 regulator-state-mem {
+					 regulator-off-in-suspend;
+				 };
+			 };
+ 
+			 vdd_0v85_s0: nldo-reg4 {
+				 regulator-name = "vdd_0v85_s0";
+				 regulator-always-on;
+				 regulator-boot-on;
+				 regulator-min-microvolt = <850000>;
+				 regulator-max-microvolt = <850000>;
+ 
+				 regulator-state-mem {
+					 regulator-off-in-suspend;
+				 };
+			 };
+ 
+			 vdd_0v75_s0: nldo-reg5 {
+				 regulator-name = "vdd_0v75_s0";
+				 regulator-always-on;
+				 regulator-boot-on;
+				 regulator-min-microvolt = <750000>;
+				 regulator-max-microvolt = <750000>;
+ 
+				 regulator-state-mem {
+					 regulator-off-in-suspend;
+				 };
+			 };
+		 };
+	 };
+ };
+ 
+ &tsadc {
+	 status = "okay";
+ };
+ 
+ &u2phy3 {
+	 status = "okay";
+ };
+ 
+ &u2phy3_host {
+	 phy-supply = <&vcc5v0_usb_host>;
+	 status = "okay";
+ };
+ 
+ &uart2 {
+	 pinctrl-0 = <&uart2m0_xfer>;
+	 status = "okay";
+ };
+ 
+ &usb_host1_ehci {
+	 status = "okay";
+ };
+ 
+ &usb_host1_ohci {
+	 status = "okay";
+ };
+ 
+ &usb_host1_xhci {
+	 status = "okay";
+	 dr_mode = "host";
+ };
+ 
+ &u2phy1 {
+	 status = "okay";
+ };
+ 
+ &u2phy1_otg {
+	 phy-supply = <&vcc5v0_usb_host>;
+	 status = "okay";
+ };
+ 
+ &usbdp_phy1 {
+	 status = "okay";
+ };
+ 
+ &usbdp_phy0 {
+	//  rockchip,dp-lane-mux = < 0 1 2 3 >;
+	 status = "okay";
+ };
+ 
+ &usb_host0_xhci {
+	status = "okay";
+	dr_mode = "host";
+};
+
+&u2phy0 {
+	status = "okay";
+};
+
+&u2phy0_otg {
+	status = "okay";
+};
+
+ &usbdp_phy0_dp {
+	 status = "okay";
+ };
+ 
+ &vop {
+	 status = "okay";
+ };
+ 
+ &vop_mmu {
+	 status = "okay";
+ };
+ 
+ /* vp0 & vp1 splice for 8K output */
+ &vp0 {
+	 rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER0 | 1 << ROCKCHIP_VOP2_ESMART0)>;
+	 rockchip,primary-plane = <ROCKCHIP_VOP2_ESMART0>;
+	//  rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER0>;
+	//  cursor-win-id = <ROCKCHIP_VOP2_ESMART0>;
+ };
+ 
+ &vp1 {
+	 rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER1 | 1 << ROCKCHIP_VOP2_ESMART1)>;
+	 rockchip,primary-plane = <ROCKCHIP_VOP2_ESMART1>;
+	//  rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER1>;
+	//  cursor-win-id = <ROCKCHIP_VOP2_ESMART1>;
+ };
+ 
+ &vp2 {
+	 rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER2 | 1 << ROCKCHIP_VOP2_ESMART2)>;
+	 rockchip,primary-plane = <ROCKCHIP_VOP2_ESMART2>;
+	//  rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER2>;
+	//  cursor-win-id = <ROCKCHIP_VOP2_ESMART2>;
+ };
+ 
+ &vp3 {
+	 rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER3 | 1 << ROCKCHIP_VOP2_ESMART3)>;
+	 rockchip,primary-plane = <ROCKCHIP_VOP2_ESMART3>;
+	//  rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER3>;
+	//  cursor-win-id = <ROCKCHIP_VOP2_ESMART3>;
+ };
+ 
+ &hdptxphy_hdmi0 {
+	 status = "okay";
+ };
+ 
+ &hdmi0 {
+	 enable-gpios = <&gpio4 RK_PB1 GPIO_ACTIVE_HIGH>;
+	 status = "okay";
+ };
+ 
+ &hdmi0_in_vp0 {
+	 status = "okay";
+ };
+ 
+ &route_hdmi0 {
+	 status = "okay";
+ };
+ 
+ &hdptxphy_hdmi1 {
+ 	status = "okay";
+ };
+ 
+ &hdmi1 {
+ 	enable-gpios = <&gpio4 RK_PB2 GPIO_ACTIVE_HIGH>;
+ 	status = "okay";
+ };
+ 
+ &hdmi1_in_vp1 {
+ 	status = "okay";
+ };
+ 
+ &route_hdmi1 {
+ 	status = "okay";
+ };
+ 
+//  &dp0 {
+// 	status = "okay";
+// };
+
+//  &dp0_in_vp2 {
+// 	status = "okay";
+// };
+
+//  &route_dp0 {
+// 	status = "okay";
+// };
diff --git a/dts/upstream/src/arm64/rockchip/rk3588-rock-5b.dts b/dts/upstream/src/arm64/rockchip/rk3588-rock-5b.dts
index a0e303c3a1..1b50d35d12 100644
--- a/dts/upstream/src/arm64/rockchip/rk3588-rock-5b.dts
+++ b/dts/upstream/src/arm64/rockchip/rk3588-rock-5b.dts
@@ -4,6 +4,7 @@
 
 #include <dt-bindings/gpio/gpio.h>
 #include <dt-bindings/leds/common.h>
+#include <dt-bindings/display/rockchip_vop.h>
 #include "rk3588.dtsi"
 
 / {
@@ -14,6 +15,10 @@
 		mmc0 = &sdhci;
 		mmc1 = &sdmmc;
 		mmc2 = &sdio;
+		hdmi0 = &hdmi0;
+		hdmi1 = &hdmi1;
+		hdptxhdmi1 = &hdptxphy_hdmi1;
+		hdptxhdmi0 = &hdptxphy_hdmi0;
 	};
 
 	chosen {
@@ -774,3 +779,75 @@
 &usb_host2_xhci {
 	status = "okay";
 };
+
+ /* vp0 & vp1 splice for 8K output */
+ &vp0 {
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER0 | 1 << ROCKCHIP_VOP2_ESMART0)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_ESMART0>;
+   //  rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER0>;
+   //  cursor-win-id = <ROCKCHIP_VOP2_ESMART0>;
+};
+
+&vp1 {
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER1 | 1 << ROCKCHIP_VOP2_ESMART1)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_ESMART1>;
+   //  rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER1>;
+   //  cursor-win-id = <ROCKCHIP_VOP2_ESMART1>;
+};
+
+&vp2 {
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER2 | 1 << ROCKCHIP_VOP2_ESMART2)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_ESMART2>;
+   //  rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER2>;
+   //  cursor-win-id = <ROCKCHIP_VOP2_ESMART2>;
+};
+
+&vp3 {
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER3 | 1 << ROCKCHIP_VOP2_ESMART3)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_ESMART3>;
+   //  rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER3>;
+   //  cursor-win-id = <ROCKCHIP_VOP2_ESMART3>;
+};
+
+&hdptxphy_hdmi0 {
+	status = "okay";
+};
+
+&hdmi0 {
+	enable-gpios = <&gpio4 RK_PB1 GPIO_ACTIVE_HIGH>;
+	cec-enable = "true";
+	status = "okay";
+};
+
+&hdmi0_in_vp0 {
+	status = "okay";
+};
+
+&route_hdmi0 {
+	status = "okay";
+};
+
+&hdptxphy_hdmi1 {
+	status = "okay";
+};
+
+ &hdptxphy_hdmi1 {
+ 	status = "okay";
+ };
+ 
+ &hdmi1 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&hdmim0_tx1_cec &hdmim0_tx1_hpd &hdmim1_tx1_scl &hdmim1_tx1_sda>;
+	cec-enable = "true";
+	enable-gpios = <&gpio4 RK_PA1 GPIO_ACTIVE_HIGH>;
+};
+ 
+ &hdmi1_in_vp1 {
+ 	status = "okay";
+ };
+ 
+ &route_hdmi1 {
+ 	status = "okay";
+ };
+ 
\ No newline at end of file
diff --git a/dts/upstream/src/arm64/rockchip/rk3588.dtsi b/dts/upstream/src/arm64/rockchip/rk3588.dtsi
index 5519c1430c..752bb714a4 100644
--- a/dts/upstream/src/arm64/rockchip/rk3588.dtsi
+++ b/dts/upstream/src/arm64/rockchip/rk3588.dtsi
@@ -3,339 +3,633 @@
  * Copyright (c) 2021 Rockchip Electronics Co., Ltd.
  */
 
-#include "rk3588s.dtsi"
-#include "rk3588-pinctrl.dtsi"
-
-/ {
-	pcie30_phy_grf: syscon@fd5b8000 {
-		compatible = "rockchip,rk3588-pcie3-phy-grf", "syscon";
-		reg = <0x0 0xfd5b8000 0x0 0x10000>;
-	};
-
-	pipe_phy1_grf: syscon@fd5c0000 {
-		compatible = "rockchip,rk3588-pipe-phy-grf", "syscon";
-		reg = <0x0 0xfd5c0000 0x0 0x100>;
-	};
-
-	i2s8_8ch: i2s@fddc8000 {
-		compatible = "rockchip,rk3588-i2s-tdm";
-		reg = <0x0 0xfddc8000 0x0 0x1000>;
-		interrupts = <GIC_SPI 188 IRQ_TYPE_LEVEL_HIGH 0>;
-		clocks = <&cru MCLK_I2S8_8CH_TX>, <&cru MCLK_I2S8_8CH_TX>, <&cru HCLK_I2S8_8CH>;
-		clock-names = "mclk_tx", "mclk_rx", "hclk";
-		assigned-clocks = <&cru CLK_I2S8_8CH_TX_SRC>;
-		assigned-clock-parents = <&cru PLL_AUPLL>;
-		dmas = <&dmac2 22>;
-		dma-names = "tx";
-		power-domains = <&power RK3588_PD_VO0>;
-		resets = <&cru SRST_M_I2S8_8CH_TX>;
-		reset-names = "tx-m";
-		#sound-dai-cells = <0>;
-		status = "disabled";
-	};
-
-	i2s6_8ch: i2s@fddf4000 {
-		compatible = "rockchip,rk3588-i2s-tdm";
-		reg = <0x0 0xfddf4000 0x0 0x1000>;
-		interrupts = <GIC_SPI 186 IRQ_TYPE_LEVEL_HIGH 0>;
-		clocks = <&cru MCLK_I2S6_8CH_TX>, <&cru MCLK_I2S6_8CH_TX>, <&cru HCLK_I2S6_8CH>;
-		clock-names = "mclk_tx", "mclk_rx", "hclk";
-		assigned-clocks = <&cru CLK_I2S6_8CH_TX_SRC>;
-		assigned-clock-parents = <&cru PLL_AUPLL>;
-		dmas = <&dmac2 4>;
-		dma-names = "tx";
-		power-domains = <&power RK3588_PD_VO1>;
-		resets = <&cru SRST_M_I2S6_8CH_TX>;
-		reset-names = "tx-m";
-		#sound-dai-cells = <0>;
-		status = "disabled";
-	};
-
-	i2s7_8ch: i2s@fddf8000 {
-		compatible = "rockchip,rk3588-i2s-tdm";
-		reg = <0x0 0xfddf8000 0x0 0x1000>;
-		interrupts = <GIC_SPI 187 IRQ_TYPE_LEVEL_HIGH 0>;
-		clocks = <&cru MCLK_I2S7_8CH_RX>, <&cru MCLK_I2S7_8CH_RX>, <&cru HCLK_I2S7_8CH>;
-		clock-names = "mclk_tx", "mclk_rx", "hclk";
-		assigned-clocks = <&cru CLK_I2S7_8CH_RX_SRC>;
-		assigned-clock-parents = <&cru PLL_AUPLL>;
-		dmas = <&dmac2 21>;
-		dma-names = "rx";
-		power-domains = <&power RK3588_PD_VO1>;
-		resets = <&cru SRST_M_I2S7_8CH_RX>;
-		reset-names = "rx-m";
-		#sound-dai-cells = <0>;
-		status = "disabled";
-	};
-
-	i2s10_8ch: i2s@fde00000 {
-		compatible = "rockchip,rk3588-i2s-tdm";
-		reg = <0x0 0xfde00000 0x0 0x1000>;
-		interrupts = <GIC_SPI 190 IRQ_TYPE_LEVEL_HIGH 0>;
-		clocks = <&cru MCLK_I2S10_8CH_RX>, <&cru MCLK_I2S10_8CH_RX>, <&cru HCLK_I2S10_8CH>;
-		clock-names = "mclk_tx", "mclk_rx", "hclk";
-		assigned-clocks = <&cru CLK_I2S10_8CH_RX_SRC>;
-		assigned-clock-parents = <&cru PLL_AUPLL>;
-		dmas = <&dmac2 24>;
-		dma-names = "rx";
-		power-domains = <&power RK3588_PD_VO1>;
-		resets = <&cru SRST_M_I2S10_8CH_RX>;
-		reset-names = "rx-m";
-		#sound-dai-cells = <0>;
-		status = "disabled";
-	};
-
-	pcie3x4: pcie@fe150000 {
-		compatible = "rockchip,rk3588-pcie", "rockchip,rk3568-pcie";
-		#address-cells = <3>;
-		#size-cells = <2>;
-		bus-range = <0x00 0x0f>;
-		clocks = <&cru ACLK_PCIE_4L_MSTR>, <&cru ACLK_PCIE_4L_SLV>,
-			 <&cru ACLK_PCIE_4L_DBI>, <&cru PCLK_PCIE_4L>,
-			 <&cru CLK_PCIE_AUX0>, <&cru CLK_PCIE4L_PIPE>;
-		clock-names = "aclk_mst", "aclk_slv",
-			      "aclk_dbi", "pclk",
-			      "aux", "pipe";
-		device_type = "pci";
-		interrupts = <GIC_SPI 263 IRQ_TYPE_LEVEL_HIGH 0>,
-			     <GIC_SPI 262 IRQ_TYPE_LEVEL_HIGH 0>,
-			     <GIC_SPI 261 IRQ_TYPE_LEVEL_HIGH 0>,
-			     <GIC_SPI 260 IRQ_TYPE_LEVEL_HIGH 0>,
-			     <GIC_SPI 259 IRQ_TYPE_LEVEL_HIGH 0>;
-		interrupt-names = "sys", "pmc", "msg", "legacy", "err";
-		#interrupt-cells = <1>;
-		interrupt-map-mask = <0 0 0 7>;
-		interrupt-map = <0 0 0 1 &pcie3x4_intc 0>,
-				<0 0 0 2 &pcie3x4_intc 1>,
-				<0 0 0 3 &pcie3x4_intc 2>,
-				<0 0 0 4 &pcie3x4_intc 3>;
-		linux,pci-domain = <0>;
-		max-link-speed = <3>;
-		msi-map = <0x0000 &its1 0x0000 0x1000>;
-		num-lanes = <4>;
-		phys = <&pcie30phy>;
-		phy-names = "pcie-phy";
-		power-domains = <&power RK3588_PD_PCIE>;
-		ranges = <0x01000000 0x0 0xf0100000 0x0 0xf0100000 0x0 0x00100000>,
-			 <0x02000000 0x0 0xf0200000 0x0 0xf0200000 0x0 0x00e00000>,
-			 <0x03000000 0x0 0x40000000 0x9 0x00000000 0x0 0x40000000>;
-		reg = <0xa 0x40000000 0x0 0x00400000>,
-		      <0x0 0xfe150000 0x0 0x00010000>,
-		      <0x0 0xf0000000 0x0 0x00100000>;
-		reg-names = "dbi", "apb", "config";
-		resets = <&cru SRST_PCIE0_POWER_UP>, <&cru SRST_P_PCIE0>;
-		reset-names = "pwr", "pipe";
-		status = "disabled";
-
-		pcie3x4_intc: legacy-interrupt-controller {
-			interrupt-controller;
-			#address-cells = <0>;
-			#interrupt-cells = <1>;
-			interrupt-parent = <&gic>;
-			interrupts = <GIC_SPI 260 IRQ_TYPE_EDGE_RISING 0>;
-		};
-	};
-
-	pcie3x2: pcie@fe160000 {
-		compatible = "rockchip,rk3588-pcie", "rockchip,rk3568-pcie";
-		#address-cells = <3>;
-		#size-cells = <2>;
-		bus-range = <0x10 0x1f>;
-		clocks = <&cru ACLK_PCIE_2L_MSTR>, <&cru ACLK_PCIE_2L_SLV>,
-			 <&cru ACLK_PCIE_2L_DBI>, <&cru PCLK_PCIE_2L>,
-			 <&cru CLK_PCIE_AUX1>, <&cru CLK_PCIE2L_PIPE>;
-		clock-names = "aclk_mst", "aclk_slv",
-			      "aclk_dbi", "pclk",
-			      "aux", "pipe";
-		device_type = "pci";
-		interrupts = <GIC_SPI 258 IRQ_TYPE_LEVEL_HIGH 0>,
-			     <GIC_SPI 257 IRQ_TYPE_LEVEL_HIGH 0>,
-			     <GIC_SPI 256 IRQ_TYPE_LEVEL_HIGH 0>,
-			     <GIC_SPI 255 IRQ_TYPE_LEVEL_HIGH 0>,
-			     <GIC_SPI 254 IRQ_TYPE_LEVEL_HIGH 0>;
-		interrupt-names = "sys", "pmc", "msg", "legacy", "err";
-		#interrupt-cells = <1>;
-		interrupt-map-mask = <0 0 0 7>;
-		interrupt-map = <0 0 0 1 &pcie3x2_intc 0>,
-				<0 0 0 2 &pcie3x2_intc 1>,
-				<0 0 0 3 &pcie3x2_intc 2>,
-				<0 0 0 4 &pcie3x2_intc 3>;
-		linux,pci-domain = <1>;
-		max-link-speed = <3>;
-		msi-map = <0x1000 &its1 0x1000 0x1000>;
-		num-lanes = <2>;
-		phys = <&pcie30phy>;
-		phy-names = "pcie-phy";
-		power-domains = <&power RK3588_PD_PCIE>;
-		ranges = <0x01000000 0x0 0xf1100000 0x0 0xf1100000 0x0 0x00100000>,
-			 <0x02000000 0x0 0xf1200000 0x0 0xf1200000 0x0 0x00e00000>,
-			 <0x03000000 0x0 0x40000000 0x9 0x40000000 0x0 0x40000000>;
-		reg = <0xa 0x40400000 0x0 0x00400000>,
-		      <0x0 0xfe160000 0x0 0x00010000>,
-		      <0x0 0xf1000000 0x0 0x00100000>;
-		reg-names = "dbi", "apb", "config";
-		resets = <&cru SRST_PCIE1_POWER_UP>, <&cru SRST_P_PCIE1>;
-		reset-names = "pwr", "pipe";
-		status = "disabled";
-
-		pcie3x2_intc: legacy-interrupt-controller {
-			interrupt-controller;
-			#address-cells = <0>;
-			#interrupt-cells = <1>;
-			interrupt-parent = <&gic>;
-			interrupts = <GIC_SPI 255 IRQ_TYPE_EDGE_RISING 0>;
-		};
-	};
-
-	pcie2x1l0: pcie@fe170000 {
-		compatible = "rockchip,rk3588-pcie", "rockchip,rk3568-pcie";
-		bus-range = <0x20 0x2f>;
-		clocks = <&cru ACLK_PCIE_1L0_MSTR>, <&cru ACLK_PCIE_1L0_SLV>,
-			 <&cru ACLK_PCIE_1L0_DBI>, <&cru PCLK_PCIE_1L0>,
-			 <&cru CLK_PCIE_AUX2>, <&cru CLK_PCIE1L0_PIPE>;
-		clock-names = "aclk_mst", "aclk_slv",
-			      "aclk_dbi", "pclk",
-			      "aux", "pipe";
-		device_type = "pci";
-		interrupts = <GIC_SPI 243 IRQ_TYPE_LEVEL_HIGH 0>,
-			     <GIC_SPI 242 IRQ_TYPE_LEVEL_HIGH 0>,
-			     <GIC_SPI 241 IRQ_TYPE_LEVEL_HIGH 0>,
-			     <GIC_SPI 240 IRQ_TYPE_LEVEL_HIGH 0>,
-			     <GIC_SPI 239 IRQ_TYPE_LEVEL_HIGH 0>;
-		interrupt-names = "sys", "pmc", "msg", "legacy", "err";
-		#interrupt-cells = <1>;
-		interrupt-map-mask = <0 0 0 7>;
-		interrupt-map = <0 0 0 1 &pcie2x1l0_intc 0>,
-				<0 0 0 2 &pcie2x1l0_intc 1>,
-				<0 0 0 3 &pcie2x1l0_intc 2>,
-				<0 0 0 4 &pcie2x1l0_intc 3>;
-		linux,pci-domain = <2>;
-		max-link-speed = <2>;
-		msi-map = <0x2000 &its0 0x2000 0x1000>;
-		num-lanes = <1>;
-		phys = <&combphy1_ps PHY_TYPE_PCIE>;
-		phy-names = "pcie-phy";
-		power-domains = <&power RK3588_PD_PCIE>;
-		ranges = <0x01000000 0x0 0xf2100000 0x0 0xf2100000 0x0 0x00100000>,
-			 <0x02000000 0x0 0xf2200000 0x0 0xf2200000 0x0 0x00e00000>,
-			 <0x03000000 0x0 0x40000000 0x9 0x80000000 0x0 0x40000000>;
-		reg = <0xa 0x40800000 0x0 0x00400000>,
-		      <0x0 0xfe170000 0x0 0x00010000>,
-		      <0x0 0xf2000000 0x0 0x00100000>;
-		reg-names = "dbi", "apb", "config";
-		resets = <&cru SRST_PCIE2_POWER_UP>, <&cru SRST_P_PCIE2>;
-		reset-names = "pwr", "pipe";
-		#address-cells = <3>;
-		#size-cells = <2>;
-		status = "disabled";
-
-		pcie2x1l0_intc: legacy-interrupt-controller {
-			interrupt-controller;
-			#address-cells = <0>;
-			#interrupt-cells = <1>;
-			interrupt-parent = <&gic>;
-			interrupts = <GIC_SPI 240 IRQ_TYPE_EDGE_RISING 0>;
-		};
-	};
-
-	gmac0: ethernet@fe1b0000 {
-		compatible = "rockchip,rk3588-gmac", "snps,dwmac-4.20a";
-		reg = <0x0 0xfe1b0000 0x0 0x10000>;
-		interrupts = <GIC_SPI 227 IRQ_TYPE_LEVEL_HIGH 0>,
-			     <GIC_SPI 226 IRQ_TYPE_LEVEL_HIGH 0>;
-		interrupt-names = "macirq", "eth_wake_irq";
-		clocks = <&cru CLK_GMAC_125M>, <&cru CLK_GMAC_50M>,
-			 <&cru PCLK_GMAC0>, <&cru ACLK_GMAC0>,
-			 <&cru CLK_GMAC0_PTP_REF>;
-		clock-names = "stmmaceth", "clk_mac_ref",
-			      "pclk_mac", "aclk_mac",
-			      "ptp_ref";
-		power-domains = <&power RK3588_PD_GMAC>;
-		resets = <&cru SRST_A_GMAC0>;
-		reset-names = "stmmaceth";
-		rockchip,grf = <&sys_grf>;
-		rockchip,php-grf = <&php_grf>;
-		snps,axi-config = <&gmac0_stmmac_axi_setup>;
-		snps,mixed-burst;
-		snps,mtl-rx-config = <&gmac0_mtl_rx_setup>;
-		snps,mtl-tx-config = <&gmac0_mtl_tx_setup>;
-		snps,tso;
-		status = "disabled";
-
-		mdio0: mdio {
-			compatible = "snps,dwmac-mdio";
-			#address-cells = <0x1>;
-			#size-cells = <0x0>;
-		};
-
-		gmac0_stmmac_axi_setup: stmmac-axi-config {
-			snps,blen = <0 0 0 0 16 8 4>;
-			snps,wr_osr_lmt = <4>;
-			snps,rd_osr_lmt = <8>;
-		};
-
-		gmac0_mtl_rx_setup: rx-queues-config {
-			snps,rx-queues-to-use = <2>;
-			queue0 {};
-			queue1 {};
-		};
-
-		gmac0_mtl_tx_setup: tx-queues-config {
-			snps,tx-queues-to-use = <2>;
-			queue0 {};
-			queue1 {};
-		};
-	};
-
-	sata1: sata@fe220000 {
-		compatible = "rockchip,rk3588-dwc-ahci", "snps,dwc-ahci";
-		reg = <0 0xfe220000 0 0x1000>;
-		interrupts = <GIC_SPI 274 IRQ_TYPE_LEVEL_HIGH 0>;
-		clocks = <&cru ACLK_SATA1>, <&cru CLK_PMALIVE1>,
-			 <&cru CLK_RXOOB1>, <&cru CLK_PIPEPHY1_REF>,
-			 <&cru CLK_PIPEPHY1_PIPE_ASIC_G>;
-		clock-names = "sata", "pmalive", "rxoob", "ref", "asic";
-		ports-implemented = <0x1>;
-		#address-cells = <1>;
-		#size-cells = <0>;
-		status = "disabled";
-
-		sata-port@0 {
-			reg = <0>;
-			hba-port-cap = <HBA_PORT_FBSCP>;
-			phys = <&combphy1_ps PHY_TYPE_SATA>;
-			phy-names = "sata-phy";
-			snps,rx-ts-max = <32>;
-			snps,tx-ts-max = <32>;
-		};
-	};
-
-	combphy1_ps: phy@fee10000 {
-		compatible = "rockchip,rk3588-naneng-combphy";
-		reg = <0x0 0xfee10000 0x0 0x100>;
-		clocks = <&cru CLK_REF_PIPE_PHY1>, <&cru PCLK_PCIE_COMBO_PIPE_PHY1>,
-			 <&cru PCLK_PHP_ROOT>;
-		clock-names = "ref", "apb", "pipe";
-		assigned-clocks = <&cru CLK_REF_PIPE_PHY1>;
-		assigned-clock-rates = <100000000>;
-		#phy-cells = <1>;
-		resets = <&cru SRST_REF_PIPE_PHY1>, <&cru SRST_P_PCIE2_PHY1>;
-		reset-names = "phy", "apb";
-		rockchip,pipe-grf = <&php_grf>;
-		rockchip,pipe-phy-grf = <&pipe_phy1_grf>;
-		status = "disabled";
-	};
-
-	pcie30phy: phy@fee80000 {
-		compatible = "rockchip,rk3588-pcie3-phy";
-		reg = <0x0 0xfee80000 0x0 0x20000>;
-		#phy-cells = <0>;
-		clocks = <&cru PCLK_PCIE_COMBO_PIPE_PHY>;
-		clock-names = "pclk";
-		resets = <&cru SRST_PCIE30_PHY>;
-		reset-names = "phy";
-		rockchip,pipe-grf = <&php_grf>;
-		rockchip,phy-grf = <&pcie30_phy_grf>;
-		status = "disabled";
-	};
-};
+ #include "rk3588s.dtsi"
+ #include "rk3588-pinctrl.dtsi"
+ 
+ / {
+	 usb_host1_xhci: usb@fc400000 {
+		 compatible = "rockchip,rk3588-dwc3", "snps,dwc3";
+		 reg = <0x0 0xfc400000 0x0 0x400000>;
+		 interrupts = <GIC_SPI 221 IRQ_TYPE_LEVEL_HIGH 0>;
+		 clocks = <&cru REF_CLK_USB3OTG1>, <&cru SUSPEND_CLK_USB3OTG1>,
+			  <&cru ACLK_USB3OTG1>;
+		 clock-names = "ref_clk", "suspend_clk", "bus_clk";
+		 dr_mode = "otg";
+		 phys = <&usbdp_phy1 PHY_TYPE_USB3>;
+		 phy-names = "usb3-phy";
+		//  phys = <&u2phy1_otg>, <&usbdp_phy1 PHY_TYPE_USB3>;
+		//  phy-names = "usb2-phy", "usb3-phy";
+		 phy_type = "utmi_wide";
+		 power-domains = <&power RK3588_PD_USB>;
+		 resets = <&cru SRST_A_USB3OTG1>;
+		 snps,dis_enblslpm_quirk;
+		 snps,dis-u2-freeclk-exists-quirk;
+		 snps,dis-del-phy-power-chg-quirk;
+		 snps,dis-tx-ipgap-linecheck-quirk;
+		 status = "disabled";
+	 };
+ 
+	 pcie30_phy_grf: syscon@fd5b8000 {
+		 compatible = "rockchip,rk3588-pcie3-phy-grf", "syscon";
+		 reg = <0x0 0xfd5b8000 0x0 0x10000>;
+	 };
+ 
+	 pipe_phy1_grf: syscon@fd5c0000 {
+		 compatible = "rockchip,rk3588-pipe-phy-grf", "syscon";
+		 reg = <0x0 0xfd5c0000 0x0 0x100>;
+	 };
+ 
+	 usbdpphy1_grf: syscon@fd5cc000 {
+		 compatible = "rockchip,rk3588-usbdpphy-grf", "syscon";
+		 reg = <0x0 0xfd5cc000 0x0 0x4000>;
+	 };
+ 
+	 usb2phy1_grf: syscon@fd5d4000 {
+		 compatible = "rockchip,rk3588-usb2phy-grf", "syscon", "simple-mfd";
+		 reg = <0x0 0xfd5d4000 0x0 0x4000>;
+		 #address-cells = <1>;
+		 #size-cells = <1>;
+ 
+		 u2phy1: usb2phy@4000 {
+			 compatible = "rockchip,rk3588-usb2phy";
+			 reg = <0x4000 0x10>;
+			 #clock-cells = <0>;
+			 clocks = <&cru CLK_USB2PHY_HDPTXRXPHY_REF>;
+			 clock-names = "phyclk";
+			 clock-output-names = "usb480m_phy1";
+			 interrupts = <GIC_SPI 394 IRQ_TYPE_LEVEL_HIGH 0>;
+			 resets = <&cru SRST_OTGPHY_U3_1>, <&cru SRST_P_USB2PHY_U3_1_GRF0>;
+			 reset-names = "phy", "apb";
+			 status = "disabled";
+ 
+			 u2phy1_otg: otg-port {
+				 #phy-cells = <0>;
+				 status = "disabled";
+			 };
+		 };
+	 };
+ 
+	 hdptxphy1_grf: syscon@fd5e4000 {
+		 compatible = "rockchip,rk3588-hdptxphy-grf", "syscon";
+		 reg = <0x0 0xfd5e4000 0x0 0x100>;
+	 };
+ 
+	 i2s8_8ch: i2s@fddc8000 {
+		 compatible = "rockchip,rk3588-i2s-tdm";
+		 reg = <0x0 0xfddc8000 0x0 0x1000>;
+		 interrupts = <GIC_SPI 188 IRQ_TYPE_LEVEL_HIGH 0>;
+		 clocks = <&cru MCLK_I2S8_8CH_TX>, <&cru MCLK_I2S8_8CH_TX>, <&cru HCLK_I2S8_8CH>;
+		 clock-names = "mclk_tx", "mclk_rx", "hclk";
+		 assigned-clocks = <&cru CLK_I2S8_8CH_TX_SRC>;
+		 assigned-clock-parents = <&cru PLL_AUPLL>;
+		 dmas = <&dmac2 22>;
+		 dma-names = "tx";
+		 power-domains = <&power RK3588_PD_VO0>;
+		 resets = <&cru SRST_M_I2S8_8CH_TX>;
+		 reset-names = "tx-m";
+		 #sound-dai-cells = <0>;
+		 status = "disabled";
+	 };
+ 
+	 i2s6_8ch: i2s@fddf4000 {
+		 compatible = "rockchip,rk3588-i2s-tdm";
+		 reg = <0x0 0xfddf4000 0x0 0x1000>;
+		 interrupts = <GIC_SPI 186 IRQ_TYPE_LEVEL_HIGH 0>;
+		 clocks = <&cru MCLK_I2S6_8CH_TX>, <&cru MCLK_I2S6_8CH_TX>, <&cru HCLK_I2S6_8CH>;
+		 clock-names = "mclk_tx", "mclk_rx", "hclk";
+		 assigned-clocks = <&cru CLK_I2S6_8CH_TX_SRC>;
+		 assigned-clock-parents = <&cru PLL_AUPLL>;
+		 dmas = <&dmac2 4>;
+		 dma-names = "tx";
+		 power-domains = <&power RK3588_PD_VO1>;
+		 resets = <&cru SRST_M_I2S6_8CH_TX>;
+		 reset-names = "tx-m";
+		 #sound-dai-cells = <0>;
+		 status = "disabled";
+	 };
+ 
+	 i2s7_8ch: i2s@fddf8000 {
+		 compatible = "rockchip,rk3588-i2s-tdm";
+		 reg = <0x0 0xfddf8000 0x0 0x1000>;
+		 interrupts = <GIC_SPI 187 IRQ_TYPE_LEVEL_HIGH 0>;
+		 clocks = <&cru MCLK_I2S7_8CH_RX>, <&cru MCLK_I2S7_8CH_RX>, <&cru HCLK_I2S7_8CH>;
+		 clock-names = "mclk_tx", "mclk_rx", "hclk";
+		 assigned-clocks = <&cru CLK_I2S7_8CH_RX_SRC>;
+		 assigned-clock-parents = <&cru PLL_AUPLL>;
+		 dmas = <&dmac2 21>;
+		 dma-names = "rx";
+		 power-domains = <&power RK3588_PD_VO1>;
+		 resets = <&cru SRST_M_I2S7_8CH_RX>;
+		 reset-names = "rx-m";
+		 #sound-dai-cells = <0>;
+		 status = "disabled";
+	 };
+ 
+	 i2s10_8ch: i2s@fde00000 {
+		 compatible = "rockchip,rk3588-i2s-tdm";
+		 reg = <0x0 0xfde00000 0x0 0x1000>;
+		 interrupts = <GIC_SPI 190 IRQ_TYPE_LEVEL_HIGH 0>;
+		 clocks = <&cru MCLK_I2S10_8CH_RX>, <&cru MCLK_I2S10_8CH_RX>, <&cru HCLK_I2S10_8CH>;
+		 clock-names = "mclk_tx", "mclk_rx", "hclk";
+		 assigned-clocks = <&cru CLK_I2S10_8CH_RX_SRC>;
+		 assigned-clock-parents = <&cru PLL_AUPLL>;
+		 dmas = <&dmac2 24>;
+		 dma-names = "rx";
+		 power-domains = <&power RK3588_PD_VO1>;
+		 resets = <&cru SRST_M_I2S10_8CH_RX>;
+		 reset-names = "rx-m";
+		 #sound-dai-cells = <0>;
+		 status = "disabled";
+	 };
+ 
+	 dp1: dp@fde60000 {
+		 compatible = "rockchip,rk3588-dp";
+		 reg = <0x0 0xfde60000 0x0 0x4000>;
+		 interrupts = <GIC_SPI 162 IRQ_TYPE_LEVEL_HIGH 0>;
+		 clocks = <&cru PCLK_DP1>, <&cru CLK_AUX16M_1>,
+			  <&cru MCLK_I2S8_8CH_TX>, <&cru MCLK_SPDIF5_DP1>,
+			  <&hclk_vo0>, <&cru CLK_DP1>;
+		 clock-names = "apb", "aux", "i2s", "spdif", "hclk", "hdcp";
+		 assigned-clocks = <&cru CLK_AUX16M_1>;
+		 assigned-clock-rates = <16000000>;
+		 resets = <&cru SRST_DP1>;
+		 phys = <&usbdp_phy1_dp>;
+		 power-domains = <&power RK3588_PD_VO0>;
+		 #sound-dai-cells = <1>;
+		 status = "disabled";
+ 
+		 ports {
+			 #address-cells = <1>;
+			 #size-cells = <0>;
+ 
+			 port@0 {
+				 reg = <0>;
+				 #address-cells = <1>;
+				 #size-cells = <0>;
+ 
+				 dp1_in_vp0: endpoint@0 {
+					 reg = <0>;
+					 remote-endpoint = <&vp0_out_dp1>;
+					 status = "disabled";
+				 };
+ 
+				 dp1_in_vp1: endpoint@1 {
+					 reg = <1>;
+					 remote-endpoint = <&vp1_out_dp1>;
+					 status = "disabled";
+				 };
+ 
+				 dp1_in_vp2: endpoint@2 {
+					 reg = <2>;
+					 remote-endpoint = <&vp2_out_dp1>;
+					 status = "disabled";
+				 };
+			 };
+ 
+			 port@1 {
+				 reg = <1>;
+ 
+				 dp1_out: endpoint { };
+			 };
+		 };
+	 };
+ 
+	 hdptxphy_hdmi1: hdmiphy@fed70000 {
+		 compatible = "rockchip,rk3588-hdptx-phy";
+		 reg = <0x0 0xfed70000 0x0 0x2000>;
+		 clocks = <&cru CLK_USB2PHY_HDPTXRXPHY_REF>, <&cru PCLK_HDPTX1>;
+		 clock-names = "ref", "apb";
+		 clock-output-names = "clk_hdmiphy_pixel1";
+		 #clock-cells = <0>;
+		 resets = <&cru SRST_HDPTX1>, <&cru SRST_P_HDPTX1>,
+			  <&cru SRST_HDPTX1_INIT>, <&cru SRST_HDPTX1_CMN>,
+			  <&cru SRST_HDPTX1_LANE>, <&cru SRST_HDPTX1_ROPLL>,
+			  <&cru SRST_HDPTX1_LCPLL>;
+		 reset-names = "phy", "apb", "init", "cmn", "lane", "ropll",
+				   "lcpll";
+		 rockchip,grf = <&hdptxphy1_grf>;
+		 #phy-cells = <0>;
+		 status = "disabled";
+ 
+		 hdptxphy_hdmi_clk1: clk-port {
+			 #clock-cells = <0>;
+			 status = "okay";
+		 };
+	 };
+ 
+	 hdmi1: hdmi@fdea0000 {
+		 compatible = "rockchip,rk3588-dw-hdmi";
+		 reg = <0x0 0xfdea0000 0x0 0x10000>, <0x0 0xfdeb0000 0x0 0x10000>;
+		 interrupts = <GIC_SPI 173 IRQ_TYPE_LEVEL_HIGH 0>,
+				  <GIC_SPI 174 IRQ_TYPE_LEVEL_HIGH 0>,
+				  <GIC_SPI 175 IRQ_TYPE_LEVEL_HIGH 0>,
+				  <GIC_SPI 176 IRQ_TYPE_LEVEL_HIGH 0>,
+				  <GIC_SPI 361 IRQ_TYPE_LEVEL_HIGH 0>;
+		 clocks = <&cru PCLK_HDMITX1>,
+			  <&cru CLK_HDMIHDP1>,
+			  <&cru CLK_HDMITX1_EARC>,
+			  <&cru CLK_HDMITX1_REF>,
+			  <&cru MCLK_I2S6_8CH_TX>,
+			  <&cru DCLK_VOP0>,
+			  <&cru DCLK_VOP1>,
+			  <&cru DCLK_VOP2>,
+			  <&cru DCLK_VOP3>,
+			  <&hclk_vo1>,
+			  <&hdptxphy_hdmi_clk1>;
+		 clock-names = "pclk",
+				   "hpd",
+				   "earc",
+				   "hdmitx_ref",
+				   "aud",
+				   "dclk_vp0",
+				   "dclk_vp1",
+				   "dclk_vp2",
+				   "dclk_vp3",
+				   "hclk_vo1",
+				   "link_clk";
+		 resets = <&cru SRST_HDMITX1_REF>, <&cru SRST_HDMIHDP1>;
+		 reset-names = "ref", "hdp";
+		 power-domains = <&power RK3588_PD_VO1>;
+		 pinctrl-names = "default";
+		 pinctrl-0 = <&hdmim2_tx1_cec &hdmim0_tx1_hpd &hdmim1_tx1_scl &hdmim1_tx1_sda>;
+		 reg-io-width = <4>;
+		 rockchip,grf = <&sys_grf>;
+		 rockchip,vo1_grf = <&vo1_grf>;
+		 phys = <&hdptxphy_hdmi1>;
+		 phy-names = "hdmi";
+		 #sound-dai-cells = <0>;
+		 status = "disabled";
+ 
+		 ports {
+			 #address-cells = <1>;
+			 #size-cells = <0>;
+ 
+			 hdmi1_in: port@0 {
+				 reg = <0>;
+				 #address-cells = <1>;
+				 #size-cells = <0>;
+ 
+				 hdmi1_in_vp0: endpoint@0 {
+					 reg = <0>;
+					 remote-endpoint = <&vp0_out_hdmi1>;
+					 status = "disabled";
+				 };
+ 
+				 hdmi1_in_vp1: endpoint@1 {
+					 reg = <1>;
+					 remote-endpoint = <&vp1_out_hdmi1>;
+					 status = "disabled";
+				 };
+ 
+				 hdmi1_in_vp2: endpoint@2 {
+					 reg = <2>;
+					 remote-endpoint = <&vp2_out_hdmi1>;
+					 status = "disabled";
+				 };
+			 };
+		 };
+	 };
+ 
+	 pcie3x4: pcie@fe150000 {
+		 compatible = "rockchip,rk3588-pcie", "rockchip,rk3568-pcie";
+		 #address-cells = <3>;
+		 #size-cells = <2>;
+		 bus-range = <0x00 0x0f>;
+		 clocks = <&cru ACLK_PCIE_4L_MSTR>, <&cru ACLK_PCIE_4L_SLV>,
+			  <&cru ACLK_PCIE_4L_DBI>, <&cru PCLK_PCIE_4L>,
+			  <&cru CLK_PCIE_AUX0>, <&cru CLK_PCIE4L_PIPE>;
+		 clock-names = "aclk_mst", "aclk_slv",
+				   "aclk_dbi", "pclk",
+				   "aux", "pipe";
+		 device_type = "pci";
+		 interrupts = <GIC_SPI 263 IRQ_TYPE_LEVEL_HIGH 0>,
+				  <GIC_SPI 262 IRQ_TYPE_LEVEL_HIGH 0>,
+				  <GIC_SPI 261 IRQ_TYPE_LEVEL_HIGH 0>,
+				  <GIC_SPI 260 IRQ_TYPE_LEVEL_HIGH 0>,
+				  <GIC_SPI 259 IRQ_TYPE_LEVEL_HIGH 0>;
+		 interrupt-names = "sys", "pmc", "msg", "legacy", "err";
+		 #interrupt-cells = <1>;
+		 interrupt-map-mask = <0 0 0 7>;
+		 interrupt-map = <0 0 0 1 &pcie3x4_intc 0>,
+				 <0 0 0 2 &pcie3x4_intc 1>,
+				 <0 0 0 3 &pcie3x4_intc 2>,
+				 <0 0 0 4 &pcie3x4_intc 3>;
+		 linux,pci-domain = <0>;
+		 max-link-speed = <3>;
+		 msi-map = <0x0000 &its1 0x0000 0x1000>;
+		 num-lanes = <4>;
+		 phys = <&pcie30phy>;
+		 phy-names = "pcie-phy";
+		 power-domains = <&power RK3588_PD_PCIE>;
+		 ranges = <0x01000000 0x0 0xf0100000 0x0 0xf0100000 0x0 0x00100000>,
+			  <0x02000000 0x0 0xf0200000 0x0 0xf0200000 0x0 0x00e00000>,
+			  <0x03000000 0x0 0x40000000 0x9 0x00000000 0x0 0x40000000>;
+		 reg = <0xa 0x40000000 0x0 0x00400000>,
+			   <0x0 0xfe150000 0x0 0x00010000>,
+			   <0x0 0xf0000000 0x0 0x00100000>;
+		 reg-names = "dbi", "apb", "config";
+		 resets = <&cru SRST_PCIE0_POWER_UP>, <&cru SRST_P_PCIE0>;
+		 reset-names = "pwr", "pipe";
+		 status = "disabled";
+ 
+		 pcie3x4_intc: legacy-interrupt-controller {
+			 interrupt-controller;
+			 #address-cells = <0>;
+			 #interrupt-cells = <1>;
+			 interrupt-parent = <&gic>;
+			 interrupts = <GIC_SPI 260 IRQ_TYPE_EDGE_RISING 0>;
+		 };
+	 };
+ 
+	 pcie3x2: pcie@fe160000 {
+		 compatible = "rockchip,rk3588-pcie", "rockchip,rk3568-pcie";
+		 #address-cells = <3>;
+		 #size-cells = <2>;
+		 bus-range = <0x10 0x1f>;
+		 clocks = <&cru ACLK_PCIE_2L_MSTR>, <&cru ACLK_PCIE_2L_SLV>,
+			  <&cru ACLK_PCIE_2L_DBI>, <&cru PCLK_PCIE_2L>,
+			  <&cru CLK_PCIE_AUX1>, <&cru CLK_PCIE2L_PIPE>;
+		 clock-names = "aclk_mst", "aclk_slv",
+				   "aclk_dbi", "pclk",
+				   "aux", "pipe";
+		 device_type = "pci";
+		 interrupts = <GIC_SPI 258 IRQ_TYPE_LEVEL_HIGH 0>,
+				  <GIC_SPI 257 IRQ_TYPE_LEVEL_HIGH 0>,
+				  <GIC_SPI 256 IRQ_TYPE_LEVEL_HIGH 0>,
+				  <GIC_SPI 255 IRQ_TYPE_LEVEL_HIGH 0>,
+				  <GIC_SPI 254 IRQ_TYPE_LEVEL_HIGH 0>;
+		 interrupt-names = "sys", "pmc", "msg", "legacy", "err";
+		 #interrupt-cells = <1>;
+		 interrupt-map-mask = <0 0 0 7>;
+		 interrupt-map = <0 0 0 1 &pcie3x2_intc 0>,
+				 <0 0 0 2 &pcie3x2_intc 1>,
+				 <0 0 0 3 &pcie3x2_intc 2>,
+				 <0 0 0 4 &pcie3x2_intc 3>;
+		 linux,pci-domain = <1>;
+		 max-link-speed = <3>;
+		 msi-map = <0x1000 &its1 0x1000 0x1000>;
+		 num-lanes = <2>;
+		 phys = <&pcie30phy>;
+		 phy-names = "pcie-phy";
+		 power-domains = <&power RK3588_PD_PCIE>;
+		 ranges = <0x01000000 0x0 0xf1100000 0x0 0xf1100000 0x0 0x00100000>,
+			  <0x02000000 0x0 0xf1200000 0x0 0xf1200000 0x0 0x00e00000>,
+			  <0x03000000 0x0 0x40000000 0x9 0x40000000 0x0 0x40000000>;
+		 reg = <0xa 0x40400000 0x0 0x00400000>,
+			   <0x0 0xfe160000 0x0 0x00010000>,
+			   <0x0 0xf1000000 0x0 0x00100000>;
+		 reg-names = "dbi", "apb", "config";
+		 resets = <&cru SRST_PCIE1_POWER_UP>, <&cru SRST_P_PCIE1>;
+		 reset-names = "pwr", "pipe";
+		 status = "disabled";
+ 
+		 pcie3x2_intc: legacy-interrupt-controller {
+			 interrupt-controller;
+			 #address-cells = <0>;
+			 #interrupt-cells = <1>;
+			 interrupt-parent = <&gic>;
+			 interrupts = <GIC_SPI 255 IRQ_TYPE_EDGE_RISING 0>;
+		 };
+	 };
+ 
+	 pcie2x1l0: pcie@fe170000 {
+		 compatible = "rockchip,rk3588-pcie", "rockchip,rk3568-pcie";
+		 bus-range = <0x20 0x2f>;
+		 clocks = <&cru ACLK_PCIE_1L0_MSTR>, <&cru ACLK_PCIE_1L0_SLV>,
+			  <&cru ACLK_PCIE_1L0_DBI>, <&cru PCLK_PCIE_1L0>,
+			  <&cru CLK_PCIE_AUX2>, <&cru CLK_PCIE1L0_PIPE>;
+		 clock-names = "aclk_mst", "aclk_slv",
+				   "aclk_dbi", "pclk",
+				   "aux", "pipe";
+		 device_type = "pci";
+		 interrupts = <GIC_SPI 243 IRQ_TYPE_LEVEL_HIGH 0>,
+				  <GIC_SPI 242 IRQ_TYPE_LEVEL_HIGH 0>,
+				  <GIC_SPI 241 IRQ_TYPE_LEVEL_HIGH 0>,
+				  <GIC_SPI 240 IRQ_TYPE_LEVEL_HIGH 0>,
+				  <GIC_SPI 239 IRQ_TYPE_LEVEL_HIGH 0>;
+		 interrupt-names = "sys", "pmc", "msg", "legacy", "err";
+		 #interrupt-cells = <1>;
+		 interrupt-map-mask = <0 0 0 7>;
+		 interrupt-map = <0 0 0 1 &pcie2x1l0_intc 0>,
+				 <0 0 0 2 &pcie2x1l0_intc 1>,
+				 <0 0 0 3 &pcie2x1l0_intc 2>,
+				 <0 0 0 4 &pcie2x1l0_intc 3>;
+		 linux,pci-domain = <2>;
+		 max-link-speed = <2>;
+		 msi-map = <0x2000 &its0 0x2000 0x1000>;
+		 num-lanes = <1>;
+		 phys = <&combphy1_ps PHY_TYPE_PCIE>;
+		 phy-names = "pcie-phy";
+		 power-domains = <&power RK3588_PD_PCIE>;
+		 ranges = <0x01000000 0x0 0xf2100000 0x0 0xf2100000 0x0 0x00100000>,
+			  <0x02000000 0x0 0xf2200000 0x0 0xf2200000 0x0 0x00e00000>,
+			  <0x03000000 0x0 0x40000000 0x9 0x80000000 0x0 0x40000000>;
+		 reg = <0xa 0x40800000 0x0 0x00400000>,
+			   <0x0 0xfe170000 0x0 0x00010000>,
+			   <0x0 0xf2000000 0x0 0x00100000>;
+		 reg-names = "dbi", "apb", "config";
+		 resets = <&cru SRST_PCIE2_POWER_UP>, <&cru SRST_P_PCIE2>;
+		 reset-names = "pwr", "pipe";
+		 #address-cells = <3>;
+		 #size-cells = <2>;
+		 status = "disabled";
+ 
+		 pcie2x1l0_intc: legacy-interrupt-controller {
+			 interrupt-controller;
+			 #address-cells = <0>;
+			 #interrupt-cells = <1>;
+			 interrupt-parent = <&gic>;
+			 interrupts = <GIC_SPI 240 IRQ_TYPE_EDGE_RISING 0>;
+		 };
+	 };
+ 
+	 gmac0: ethernet@fe1b0000 {
+		 compatible = "rockchip,rk3588-gmac", "snps,dwmac-4.20a";
+		 reg = <0x0 0xfe1b0000 0x0 0x10000>;
+		 interrupts = <GIC_SPI 227 IRQ_TYPE_LEVEL_HIGH 0>,
+				  <GIC_SPI 226 IRQ_TYPE_LEVEL_HIGH 0>;
+		 interrupt-names = "macirq", "eth_wake_irq";
+		 clocks = <&cru CLK_GMAC_125M>, <&cru CLK_GMAC_50M>,
+			  <&cru PCLK_GMAC0>, <&cru ACLK_GMAC0>,
+			  <&cru CLK_GMAC0_PTP_REF>;
+		 clock-names = "stmmaceth", "clk_mac_ref",
+				   "pclk_mac", "aclk_mac",
+				   "ptp_ref";
+		 power-domains = <&power RK3588_PD_GMAC>;
+		 resets = <&cru SRST_A_GMAC0>;
+		 reset-names = "stmmaceth";
+		 rockchip,grf = <&sys_grf>;
+		 rockchip,php-grf = <&php_grf>;
+		 snps,axi-config = <&gmac0_stmmac_axi_setup>;
+		 snps,mixed-burst;
+		 snps,mtl-rx-config = <&gmac0_mtl_rx_setup>;
+		 snps,mtl-tx-config = <&gmac0_mtl_tx_setup>;
+		 snps,tso;
+		 status = "disabled";
+ 
+		 mdio0: mdio {
+			 compatible = "snps,dwmac-mdio";
+			 #address-cells = <0x1>;
+			 #size-cells = <0x0>;
+		 };
+ 
+		 gmac0_stmmac_axi_setup: stmmac-axi-config {
+			 snps,blen = <0 0 0 0 16 8 4>;
+			 snps,wr_osr_lmt = <4>;
+			 snps,rd_osr_lmt = <8>;
+		 };
+ 
+		 gmac0_mtl_rx_setup: rx-queues-config {
+			 snps,rx-queues-to-use = <2>;
+			 queue0 {};
+			 queue1 {};
+		 };
+ 
+		 gmac0_mtl_tx_setup: tx-queues-config {
+			 snps,tx-queues-to-use = <2>;
+			 queue0 {};
+			 queue1 {};
+		 };
+	 };
+ 
+	 sata1: sata@fe220000 {
+		 compatible = "rockchip,rk3588-dwc-ahci", "snps,dwc-ahci";
+		 reg = <0 0xfe220000 0 0x1000>;
+		 interrupts = <GIC_SPI 274 IRQ_TYPE_LEVEL_HIGH 0>;
+		 clocks = <&cru ACLK_SATA1>, <&cru CLK_PMALIVE1>,
+			  <&cru CLK_RXOOB1>, <&cru CLK_PIPEPHY1_REF>,
+			  <&cru CLK_PIPEPHY1_PIPE_ASIC_G>;
+		 clock-names = "sata", "pmalive", "rxoob", "ref", "asic";
+		 ports-implemented = <0x1>;
+		 #address-cells = <1>;
+		 #size-cells = <0>;
+		 status = "disabled";
+ 
+		 sata-port@0 {
+			 reg = <0>;
+			 hba-port-cap = <HBA_PORT_FBSCP>;
+			 phys = <&combphy1_ps PHY_TYPE_SATA>;
+			 phy-names = "sata-phy";
+			 snps,rx-ts-max = <32>;
+			 snps,tx-ts-max = <32>;
+		 };
+	 };
+ 
+	 usbdp_phy1: phy@fed90000 {
+		 compatible = "rockchip,rk3588-usbdp-phy";
+		 reg = <0x0 0xfed90000 0x0 0x10000>;
+		 #phy-cells = <1>;
+		 clocks = <&cru CLK_USBDPPHY_MIPIDCPPHY_REF>,
+			  <&cru CLK_USBDP_PHY1_IMMORTAL>,
+			  <&cru PCLK_USBDPPHY1>,
+			  <&u2phy1>;
+		 clock-names = "refclk", "immortal", "pclk", "utmi";
+		 resets = <&cru SRST_USBDP_COMBO_PHY1_INIT>,
+			  <&cru SRST_USBDP_COMBO_PHY1_CMN>,
+			  <&cru SRST_USBDP_COMBO_PHY1_LANE>,
+			  <&cru SRST_USBDP_COMBO_PHY1_PCS>,
+			  <&cru SRST_P_USBDPPHY1>;
+		 reset-names = "init", "cmn", "lane", "pcs_apb", "pma_apb";
+		 rockchip,u2phy-grf = <&usb2phy1_grf>;
+		 rockchip,usb-grf = <&usb_grf>;
+		 rockchip,usbdpphy-grf = <&usbdpphy1_grf>;
+		 rockchip,vo-grf = <&vo0_grf>;
+		 status = "disabled";
+ 
+		 usbdp_phy1_dp: dp-port {
+			 #phy-cells = <0>;
+			 status = "disabled";
+		 };
+	 };
+ 
+	 combphy1_ps: phy@fee10000 {
+		 compatible = "rockchip,rk3588-naneng-combphy";
+		 reg = <0x0 0xfee10000 0x0 0x100>;
+		 clocks = <&cru CLK_REF_PIPE_PHY1>, <&cru PCLK_PCIE_COMBO_PIPE_PHY1>,
+			  <&cru PCLK_PHP_ROOT>;
+		 clock-names = "ref", "apb", "pipe";
+		 assigned-clocks = <&cru CLK_REF_PIPE_PHY1>;
+		 assigned-clock-rates = <100000000>;
+		 #phy-cells = <1>;
+		 resets = <&cru SRST_REF_PIPE_PHY1>, <&cru SRST_P_PCIE2_PHY1>;
+		 reset-names = "phy", "apb";
+		 rockchip,pipe-grf = <&php_grf>;
+		 rockchip,pipe-phy-grf = <&pipe_phy1_grf>;
+		 status = "disabled";
+	 };
+ 
+	 pcie30phy: phy@fee80000 {
+		 compatible = "rockchip,rk3588-pcie3-phy";
+		 reg = <0x0 0xfee80000 0x0 0x20000>;
+		 #phy-cells = <0>;
+		 clocks = <&cru PCLK_PCIE_COMBO_PIPE_PHY>;
+		 clock-names = "pclk";
+		 resets = <&cru SRST_PCIE30_PHY>;
+		 reset-names = "phy";
+		 rockchip,pipe-grf = <&php_grf>;
+		 rockchip,phy-grf = <&pcie30_phy_grf>;
+		 status = "disabled";
+	 };
+ };
+ 
+ &display_subsystem {
+	 clocks = <&hdptxphy_hdmi_clk0>, <&hdptxphy_hdmi_clk1>;
+	 clock-names = "hdmi0_phy_pll", "hdmi1_phy_pll";
+ 
+	 route {
+		 route_dp1: route-dp1 {
+			 status = "disabled";
+			 logo,uboot = "logo.bmp";
+			 logo,kernel = "logo_kernel.bmp";
+			 logo,mode = "center";
+			 charge_logo,mode = "center";
+			 connect = <&vp1_out_dp1>;
+		 };
+ 
+		 route_hdmi1: route-hdmi1 {
+			 status = "disabled";
+			 logo,uboot = "logo.bmp";
+			 logo,kernel = "logo_kernel.bmp";
+			 logo,mode = "center";
+			 charge_logo,mode = "center";
+			 connect = <&vp1_out_hdmi1>;
+		 };
+	 };
+ };
+ 
+ &vp0 {
+	 vp0_out_dp1: endpoint@3 {
+		 reg = <3>;
+		 remote-endpoint = <&dp1_in_vp0>;
+	 };
+ 
+	 vp0_out_hdmi1: endpoint@5 {
+		 reg = <5>;
+		 remote-endpoint = <&hdmi1_in_vp0>;
+	 };
+ };
+ 
+ &vp1 {
+	 vp1_out_dp1: endpoint@3 {
+		 reg = <3>;
+		 remote-endpoint = <&dp1_in_vp1>;
+	 };
+ 
+	 vp1_out_hdmi1: endpoint@5 {
+		 reg = <5>;
+		 remote-endpoint = <&hdmi1_in_vp1>;
+	 };
+ };
+ 
+ &vp2 {
+	 vp2_out_dp1: endpoint@5 {
+		 reg = <5>;
+		 remote-endpoint = <&dp1_in_vp2>;
+	 };
+ 
+	 vp2_out_hdmi1: endpoint@7 {
+		 reg = <7>;
+		 remote-endpoint = <&hdmi1_in_vp2>;
+	 };
+ };
+ 
\ No newline at end of file
diff --git a/dts/upstream/src/arm64/rockchip/rk3588s.dtsi b/dts/upstream/src/arm64/rockchip/rk3588s.dtsi
index 36b1b7acfe..6f3a3c158d 100644
--- a/dts/upstream/src/arm64/rockchip/rk3588s.dtsi
+++ b/dts/upstream/src/arm64/rockchip/rk3588s.dtsi
@@ -347,6 +347,31 @@
 		};
 	};
 
+	display_subsystem: display-subsystem {
+		compatible = "rockchip,display-subsystem";
+		ports = <&vop_out>;
+
+		route {
+			route_dp0: route-dp0 {
+				status = "disabled";
+				logo,uboot = "logo.bmp";
+				logo,kernel = "logo_kernel.bmp";
+				logo,mode = "center";
+				charge_logo,mode = "center";
+				connect = <&vp1_out_dp0>;
+			};
+
+			route_hdmi0: route-hdmi0 {
+				status = "disabled";
+				logo,uboot = "logo.bmp";
+				logo,kernel = "logo_kernel.bmp";
+				logo,mode = "center";
+				charge_logo,mode = "center";
+				connect = <&vp0_out_hdmi0>;
+			};
+		};
+	};
+
 	firmware {
 		optee: optee {
 			compatible = "linaro,optee-tz";
@@ -394,9 +419,190 @@
 		#clock-cells = <0>;
 	};
 
-	display_subsystem: display-subsystem {
-		compatible = "rockchip,display-subsystem";
-		ports = <&vop_out>;
+	clocks {
+		compatible = "simple-bus";
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+		hclk_vo1: hclk_vo1@fd7c08ec {
+			compatible = "rockchip,rk3588-clock-gate-link";
+			reg = <0 0xfd7c08ec 0 0x10>;
+			clock-names = "link";
+			clocks = <&cru HCLK_VO1USB_TOP_ROOT>;
+			#power-domain-cells = <1>;
+			#clock-cells = <0>;
+		};
+		hclk_vo0: hclk_vo0@fd7c08dc {
+			compatible = "rockchip,rk3588-clock-gate-link";
+			reg = <0 0xfd7c08dc 0 0x10>;
+			clock-names = "link";
+			clocks = <&cru HCLK_VOP_ROOT>;
+			#power-domain-cells = <1>;
+			#clock-cells = <0>;
+		};
+	};
+
+	vop_opp_table: vop-opp-table {
+		compatible = "operating-points-v2";
+
+		nvmem-cells = <&log_leakage>;
+		nvmem-cell-names = "leakage";
+
+		rockchip,init-freq = <750000>; /* KHz */
+
+		rockchip,leakage-voltage-sel = <
+			1	31	0
+			32	44	1
+			45	57	2
+			58	254	3
+		>;
+
+		opp-5000000000 {
+			opp-hz = /bits/ 64 <500000000>;
+			opp-microvolt = <725000 725000 800000>;
+			opp-microvolt-L1 = <700000 700000 800000>;
+			opp-microvolt-L2 = <687500 687500 800000>;
+			opp-microvolt-L3 = <675000 675000 800000>;
+		};
+		opp-7500000000 {
+			opp-hz = /bits/ 64 <750000000>;
+			opp-microvolt = <725000 725000 800000>;
+			opp-microvolt-L1 = <700000 700000 800000>;
+			opp-microvolt-L2 = <687500 687500 800000>;
+			opp-microvolt-L3 = <675000 675000 800000>;
+		};
+		opp-8500000000 {
+			opp-hz = /bits/ 64 <850000000>;
+			opp-microvolt = <800000 800000 800000>;
+			opp-microvolt-L1 = <775000 775000 800000>;
+			opp-microvolt-L2 = <750000 750000 800000>;
+			opp-microvolt-L3 = <750000 750000 800000>;
+		};
+	};
+
+	dp0: dp@fde50000 {
+		compatible = "rockchip,rk3588-dp";
+		reg = <0x0 0xfde50000 0x0 0x4000>;
+		interrupts = <GIC_SPI 161 IRQ_TYPE_LEVEL_HIGH 0>;
+		clocks = <&cru PCLK_DP0>, <&cru CLK_AUX16M_0>,
+			 <&cru MCLK_I2S4_8CH_TX>, <&cru MCLK_SPDIF2_DP0>,
+			 <&hclk_vo0>, <&cru CLK_DP0>;
+		clock-names = "apb", "aux", "i2s", "spdif", "hclk", "hdcp";
+		assigned-clocks = <&cru CLK_AUX16M_0>;
+		assigned-clock-rates = <16000000>;
+		resets = <&cru SRST_DP0>;
+		phys = <&usbdp_phy0_dp>;
+		power-domains = <&power RK3588_PD_VO0>;
+		#sound-dai-cells = <1>;
+		status = "disabled";
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				dp0_in_vp0: endpoint@0 {
+					reg = <0>;
+					remote-endpoint = <&vp0_out_dp0>;
+					status = "disabled";
+				};
+
+				dp0_in_vp1: endpoint@1 {
+					reg = <1>;
+					remote-endpoint = <&vp1_out_dp0>;
+					status = "disabled";
+				};
+
+				dp0_in_vp2: endpoint@2 {
+					reg = <2>;
+					remote-endpoint = <&vp2_out_dp0>;
+					status = "disabled";
+				};
+			};
+
+			port@1 {
+				reg = <1>;
+
+				dp0_out: endpoint { };
+			};
+		};
+	};
+
+	hdmi0: hdmi@fde80000 {
+		compatible = "rockchip,rk3588-dw-hdmi";
+		reg = <0x0 0xfde80000 0x0 0x10000>, <0x0 0xfde90000 0x0 0x10000>;
+		interrupts = <GIC_SPI 169 IRQ_TYPE_LEVEL_HIGH 0>,
+			     <GIC_SPI 170 IRQ_TYPE_LEVEL_HIGH 0>,
+			     <GIC_SPI 171 IRQ_TYPE_LEVEL_HIGH 0>,
+			     <GIC_SPI 172 IRQ_TYPE_LEVEL_HIGH 0>,
+			     <GIC_SPI 360 IRQ_TYPE_LEVEL_HIGH 0>;
+		clocks = <&cru PCLK_HDMITX0>,
+			 <&cru CLK_HDMIHDP0>,
+			 <&cru CLK_HDMITX0_EARC>,
+			 <&cru CLK_HDMITX0_REF>,
+			 <&cru MCLK_I2S5_8CH_TX>,
+			 <&cru DCLK_VOP0>,
+			 <&cru DCLK_VOP1>,
+			 <&cru DCLK_VOP2>,
+			 <&cru DCLK_VOP3>,
+			 <&hclk_vo1>,
+			 <&hdptxphy_hdmi_clk0>;
+		clock-names = "pclk",
+			      "hpd",
+			      "earc",
+			      "hdmitx_ref",
+			      "aud",
+			      "dclk_vp0",
+			      "dclk_vp1",
+			      "dclk_vp2",
+			      "dclk_vp3",
+			      "hclk_vo1",
+			      "link_clk";
+		resets = <&cru SRST_HDMITX0_REF>, <&cru SRST_HDMIHDP0>;
+		reset-names = "ref", "hdp";
+		power-domains = <&power RK3588_PD_VO1>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&hdmim0_tx0_cec &hdmim0_tx0_hpd &hdmim0_tx0_scl &hdmim0_tx0_sda>;
+		reg-io-width = <4>;
+		rockchip,grf = <&sys_grf>;
+		rockchip,vo1_grf = <&vo1_grf>;
+		phys = <&hdptxphy_hdmi0>;
+		phy-names = "hdmi";
+		#sound-dai-cells = <0>;
+		status = "disabled";
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			hdmi0_in: port@0 {
+				reg = <0>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				hdmi0_in_vp0: endpoint@0 {
+					reg = <0>;
+					remote-endpoint = <&vp0_out_hdmi0>;
+					status = "disabled";
+				};
+
+				hdmi0_in_vp1: endpoint@1 {
+					reg = <1>;
+					remote-endpoint = <&vp1_out_hdmi0>;
+					status = "disabled";
+				};
+
+				hdmi0_in_vp2: endpoint@2 {
+					reg = <2>;
+					remote-endpoint = <&vp2_out_hdmi0>;
+					status = "disabled";
+				};
+			};
+		};
 	};
 
 	timer {
@@ -436,6 +642,84 @@
 		};
 	};
 
+	gpu: gpu@fb000000 {
+		compatible = "rockchip,rk3588-mali", "arm,mali-valhall-csf";
+		reg = <0x0 0xfb000000 0x0 0x200000>;
+		#cooling-cells = <2>;
+		assigned-clocks = <&scmi_clk SCMI_CLK_GPU>;
+		assigned-clock-rates = <200000000>;
+		clocks = <&cru CLK_GPU>, <&cru CLK_GPU_COREGROUP>,
+			 <&cru CLK_GPU_STACKS>;
+		clock-names = "core", "coregroup", "stacks";
+		dynamic-power-coefficient = <2982>;
+		interrupts = <GIC_SPI 92 IRQ_TYPE_LEVEL_HIGH 0>,
+			     <GIC_SPI 93 IRQ_TYPE_LEVEL_HIGH 0>,
+			     <GIC_SPI 94 IRQ_TYPE_LEVEL_HIGH 0>;
+		interrupt-names = "job", "mmu", "gpu";
+		operating-points-v2 = <&gpu_opp_table>;
+		power-domains = <&power RK3588_PD_GPU>;
+		status = "disabled";
+
+		gpu_opp_table: opp-table {
+			compatible = "operating-points-v2";
+
+			opp-300000000 {
+				opp-hz = /bits/ 64 <300000000>;
+				opp-microvolt = <675000 675000 850000>;
+			};
+			opp-400000000 {
+				opp-hz = /bits/ 64 <400000000>;
+				opp-microvolt = <675000 675000 850000>;
+			};
+			opp-500000000 {
+				opp-hz = /bits/ 64 <500000000>;
+				opp-microvolt = <675000 675000 850000>;
+			};
+			opp-600000000 {
+				opp-hz = /bits/ 64 <600000000>;
+				opp-microvolt = <675000 675000 850000>;
+			};
+			opp-700000000 {
+				opp-hz = /bits/ 64 <700000000>;
+				opp-microvolt = <700000 700000 850000>;
+			};
+			opp-800000000 {
+				opp-hz = /bits/ 64 <800000000>;
+				opp-microvolt = <750000 750000 850000>;
+			};
+			opp-900000000 {
+				opp-hz = /bits/ 64 <900000000>;
+				opp-microvolt = <800000 800000 850000>;
+			};
+			opp-1000000000 {
+				opp-hz = /bits/ 64 <1000000000>;
+				opp-microvolt = <850000 850000 850000>;
+			};
+		};
+	};
+
+	usb_host0_xhci: usb@fc000000 {
+		compatible = "rockchip,rk3588-dwc3", "snps,dwc3";
+		reg = <0x0 0xfc000000 0x0 0x400000>;
+		interrupts = <GIC_SPI 220 IRQ_TYPE_LEVEL_HIGH 0>;
+		clocks = <&cru REF_CLK_USB3OTG0>, <&cru SUSPEND_CLK_USB3OTG0>,
+			 <&cru ACLK_USB3OTG0>;
+		clock-names = "ref_clk", "suspend_clk", "bus_clk";
+		dr_mode = "otg";
+		phys = <&u2phy0_otg>, <&usbdp_phy0 PHY_TYPE_USB3>;
+		phy-names = "usb2-phy", "usb3-phy";
+		phy_type = "utmi_wide";
+		power-domains = <&power RK3588_PD_USB>;
+		resets = <&cru SRST_A_USB3OTG0>;
+		snps,dis_enblslpm_quirk;
+		snps,dis-u1-entry-quirk;
+		snps,dis-u2-entry-quirk;
+		snps,dis-u2-freeclk-exists-quirk;
+		snps,dis-del-phy-power-chg-quirk;
+		snps,dis-tx-ipgap-linecheck-quirk;
+		status = "disabled";
+	};
+
 	usb_host0_ehci: usb@fc800000 {
 		compatible = "rockchip,rk3588-ehci", "generic-ehci";
 		reg = <0x0 0xfc800000 0x0 0x40000>;
@@ -501,6 +785,30 @@
 		status = "disabled";
 	};
 
+	mmu600_pcie: iommu@fc900000 {
+		compatible = "arm,smmu-v3";
+		reg = <0x0 0xfc900000 0x0 0x200000>;
+		interrupts = <GIC_SPI 369 IRQ_TYPE_LEVEL_HIGH 0>,
+			     <GIC_SPI 371 IRQ_TYPE_LEVEL_HIGH 0>,
+			     <GIC_SPI 374 IRQ_TYPE_LEVEL_HIGH 0>,
+			     <GIC_SPI 367 IRQ_TYPE_LEVEL_HIGH 0>;
+		interrupt-names = "eventq", "gerror", "priq", "cmdq-sync";
+		#iommu-cells = <1>;
+		status = "disabled";
+	};
+
+	mmu600_php: iommu@fcb00000 {
+		compatible = "arm,smmu-v3";
+		reg = <0x0 0xfcb00000 0x0 0x200000>;
+		interrupts = <GIC_SPI 381 IRQ_TYPE_LEVEL_HIGH 0>,
+			     <GIC_SPI 383 IRQ_TYPE_LEVEL_HIGH 0>,
+			     <GIC_SPI 386 IRQ_TYPE_LEVEL_HIGH 0>,
+			     <GIC_SPI 379 IRQ_TYPE_LEVEL_HIGH 0>;
+		interrupt-names = "eventq", "gerror", "priq", "cmdq-sync";
+		#iommu-cells = <1>;
+		status = "disabled";
+	};
+
 	pmu1grf: syscon@fd58a000 {
 		compatible = "rockchip,rk3588-pmugrf", "syscon", "simple-mfd";
 		reg = <0x0 0xfd58a000 0x0 0x10000>;
@@ -516,9 +824,21 @@
 		reg = <0x0 0xfd5a4000 0x0 0x2000>;
 	};
 
+	vo0_grf: syscon@fd5a6000 {
+		compatible = "rockchip,rk3588-vo-grf", "syscon";
+		reg = <0x0 0xfd5a6000 0x0 0x2000>;
+		clocks = <&cru PCLK_VO0GRF>;
+	};
+
 	vo1_grf: syscon@fd5a8000 {
 		compatible = "rockchip,rk3588-vo-grf", "syscon";
 		reg = <0x0 0xfd5a8000 0x0 0x100>;
+		clocks = <&cru PCLK_VO1GRF>;
+	};
+
+	usb_grf: syscon@fd5ac000 {
+		compatible = "rockchip,rk3588-usb-grf", "syscon";
+		reg = <0x0 0xfd5ac000 0x0 0x4000>;
 	};
 
 	php_grf: syscon@fd5b0000 {
@@ -536,22 +856,52 @@
 		reg = <0x0 0xfd5c4000 0x0 0x100>;
 	};
 
+	usbdpphy0_grf: syscon@fd5c8000 {
+		compatible = "rockchip,rk3588-usbdpphy-grf", "syscon";
+		reg = <0x0 0xfd5c8000 0x0 0x4000>;
+	};
+
+	usb2phy0_grf: syscon@fd5d0000 {
+		compatible = "rockchip,rk3588-usb2phy-grf", "syscon", "simple-mfd";
+		reg = <0x0 0xfd5d0000 0x0 0x4000>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+
+		u2phy0: usb2phy@0 {
+			compatible = "rockchip,rk3588-usb2phy";
+			reg = <0x0 0x10>;
+			#clock-cells = <0>;
+			clocks = <&cru CLK_USB2PHY_HDPTXRXPHY_REF>;
+			clock-names = "phyclk";
+			clock-output-names = "usb480m_phy0";
+			interrupts = <GIC_SPI 393 IRQ_TYPE_LEVEL_HIGH 0>;
+			resets = <&cru SRST_OTGPHY_U3_0>, <&cru SRST_P_USB2PHY_U3_0_GRF0>;
+			reset-names = "phy", "apb";
+			status = "disabled";
+
+			u2phy0_otg: otg-port {
+				#phy-cells = <0>;
+				status = "disabled";
+			};
+		};
+	};
+
 	usb2phy2_grf: syscon@fd5d8000 {
 		compatible = "rockchip,rk3588-usb2phy-grf", "syscon", "simple-mfd";
 		reg = <0x0 0xfd5d8000 0x0 0x4000>;
 		#address-cells = <1>;
 		#size-cells = <1>;
 
-		u2phy2: usb2-phy@8000 {
+		u2phy2: usb2phy@8000 {
 			compatible = "rockchip,rk3588-usb2phy";
 			reg = <0x8000 0x10>;
-			interrupts = <GIC_SPI 391 IRQ_TYPE_LEVEL_HIGH 0>;
-			resets = <&cru SRST_OTGPHY_U2_0>, <&cru SRST_P_USB2PHY_U2_0_GRF0>;
-			reset-names = "phy", "apb";
+			#clock-cells = <0>;
 			clocks = <&cru CLK_USB2PHY_HDPTXRXPHY_REF>;
 			clock-names = "phyclk";
 			clock-output-names = "usb480m_phy2";
-			#clock-cells = <0>;
+			interrupts = <GIC_SPI 391 IRQ_TYPE_LEVEL_HIGH 0>;
+			resets = <&cru SRST_OTGPHY_U2_0>, <&cru SRST_P_USB2PHY_U2_0_GRF0>;
+			reset-names = "phy", "apb";
 			status = "disabled";
 
 			u2phy2_host: host-port {
@@ -567,16 +917,16 @@
 		#address-cells = <1>;
 		#size-cells = <1>;
 
-		u2phy3: usb2-phy@c000 {
+		u2phy3: usb2phy@c000 {
 			compatible = "rockchip,rk3588-usb2phy";
 			reg = <0xc000 0x10>;
-			interrupts = <GIC_SPI 392 IRQ_TYPE_LEVEL_HIGH 0>;
-			resets = <&cru SRST_OTGPHY_U2_1>, <&cru SRST_P_USB2PHY_U2_1_GRF0>;
-			reset-names = "phy", "apb";
+			#clock-cells = <0>;
 			clocks = <&cru CLK_USB2PHY_HDPTXRXPHY_REF>;
 			clock-names = "phyclk";
 			clock-output-names = "usb480m_phy3";
-			#clock-cells = <0>;
+			interrupts = <GIC_SPI 392 IRQ_TYPE_LEVEL_HIGH 0>;
+			resets = <&cru SRST_OTGPHY_U2_1>, <&cru SRST_P_USB2PHY_U2_1_GRF0>;
+			reset-names = "phy", "apb";
 			status = "disabled";
 
 			u2phy3_host: host-port {
@@ -586,6 +936,11 @@
 		};
 	};
 
+	hdptxphy0_grf: syscon@fd5e0000 {
+		compatible = "rockchip,rk3588-hdptxphy-grf", "syscon";
+		reg = <0x0 0xfd5e0000 0x0 0x100>;
+	};
+
 	ioc: syscon@fd5f0000 {
 		compatible = "rockchip,rk3588-ioc", "syscon";
 		reg = <0x0 0xfd5f0000 0x0 0x10000>;
@@ -640,74 +995,6 @@
 		status = "disabled";
 	};
 
-	vop: vop@fdd90000 {
-		compatible = "rockchip,rk3588-vop";
-		reg = <0x0 0xfdd90000 0x0 0x4200>, <0x0 0xfdd95000 0x0 0x1000>;
-		reg-names = "vop", "gamma-lut";
-		interrupts = <GIC_SPI 156 IRQ_TYPE_LEVEL_HIGH 0>;
-		clocks = <&cru ACLK_VOP>,
-			 <&cru HCLK_VOP>,
-			 <&cru DCLK_VOP0>,
-			 <&cru DCLK_VOP1>,
-			 <&cru DCLK_VOP2>,
-			 <&cru DCLK_VOP3>,
-			 <&cru PCLK_VOP_ROOT>;
-		clock-names = "aclk",
-			      "hclk",
-			      "dclk_vp0",
-			      "dclk_vp1",
-			      "dclk_vp2",
-			      "dclk_vp3",
-			      "pclk_vop";
-		iommus = <&vop_mmu>;
-		power-domains = <&power RK3588_PD_VOP>;
-		rockchip,grf = <&sys_grf>;
-		rockchip,vop-grf = <&vop_grf>;
-		rockchip,vo1-grf = <&vo1_grf>;
-		rockchip,pmu = <&pmu>;
-		status = "disabled";
-
-		vop_out: ports {
-			#address-cells = <1>;
-			#size-cells = <0>;
-
-			vp0: port@0 {
-				#address-cells = <1>;
-				#size-cells = <0>;
-				reg = <0>;
-			};
-
-			vp1: port@1 {
-				#address-cells = <1>;
-				#size-cells = <0>;
-				reg = <1>;
-			};
-
-			vp2: port@2 {
-				#address-cells = <1>;
-				#size-cells = <0>;
-				reg = <2>;
-			};
-
-			vp3: port@3 {
-				#address-cells = <1>;
-				#size-cells = <0>;
-				reg = <3>;
-			};
-		};
-	};
-
-	vop_mmu: iommu@fdd97e00 {
-		compatible = "rockchip,rk3588-iommu", "rockchip,rk3568-iommu";
-		reg = <0x0 0xfdd97e00 0x0 0x100>, <0x0 0xfdd97f00 0x0 0x100>;
-		interrupts = <GIC_SPI 156 IRQ_TYPE_LEVEL_HIGH 0>;
-		clocks = <&cru ACLK_VOP>, <&cru HCLK_VOP>;
-		clock-names = "aclk", "iface";
-		#iommu-cells = <0>;
-		power-domains = <&power RK3588_PD_VOP>;
-		status = "disabled";
-	};
-
 	uart0: serial@fd890000 {
 		compatible = "rockchip,rk3588-uart", "snps,dw-apb-uart";
 		reg = <0x0 0xfd890000 0x0 0x100>;
@@ -1078,6 +1365,143 @@
 		};
 	};
 
+	av1d: video-codec@fdc70000 {
+		compatible = "rockchip,rk3588-av1-vpu";
+		reg = <0x0 0xfdc70000 0x0 0x800>;
+		interrupts = <GIC_SPI 108 IRQ_TYPE_LEVEL_HIGH 0>;
+		interrupt-names = "vdpu";
+		assigned-clocks = <&cru ACLK_AV1>, <&cru PCLK_AV1>;
+		assigned-clock-rates = <400000000>, <400000000>;
+		clocks = <&cru ACLK_AV1>, <&cru PCLK_AV1>;
+		clock-names = "aclk", "hclk";
+		power-domains = <&power RK3588_PD_AV1>;
+		resets = <&cru SRST_A_AV1>, <&cru SRST_P_AV1>, <&cru SRST_A_AV1_BIU>, <&cru SRST_P_AV1_BIU>;
+	};
+
+	vop: vop@fdd90000 {
+		compatible = "rockchip,rk3588-vop";
+		reg = <0x0 0xfdd90000 0x0 0x4200>, <0x0 0xfdd95000 0x0 0x1000>;
+		reg-names = "regs", "gamma_lut";
+		interrupts = <GIC_SPI 156 IRQ_TYPE_LEVEL_HIGH 0>;
+		clocks = <&cru ACLK_VOP>,
+			 <&cru HCLK_VOP>,
+			 <&cru DCLK_VOP0>,
+			 <&cru DCLK_VOP1>,
+			 <&cru DCLK_VOP2>,
+			 <&cru DCLK_VOP3>,
+			 <&cru PCLK_VOP_ROOT>,
+			 <&cru DCLK_VOP0_SRC>,
+			 <&cru DCLK_VOP1_SRC>,
+			 <&cru DCLK_VOP2_SRC>;
+		clock-names = "aclk_vop",
+			      "hclk_vop",
+			      "dclk_vp0",
+			      "dclk_vp1",
+			      "dclk_vp2",
+			      "dclk_vp3",
+			      "pclk_vop",
+			      "dclk_src_vp0",
+			      "dclk_src_vp1",
+			      "dclk_src_vp2";
+		assigned-clocks = <&cru ACLK_VOP>;
+		assigned-clock-rates = <750000000>;
+		resets = <&cru SRST_A_VOP>,
+			 <&cru SRST_H_VOP>,
+			 <&cru SRST_D_VOP0>,
+			 <&cru SRST_D_VOP1>,
+			 <&cru SRST_D_VOP2>,
+			 <&cru SRST_D_VOP3>;
+		reset-names = "axi",
+			      "ahb",
+			      "dclk_vp0",
+			      "dclk_vp1",
+			      "dclk_vp2",
+			      "dclk_vp3";
+		rockchip,aclk-normal-mode-rates = <500000000>;
+		rockchip,aclk-advanced-mode-rates = <750000000>;
+		operating-points-v2 = <&vop_opp_table>;
+		iommus = <&vop_mmu>;
+		power-domains = <&power RK3588_PD_VOP>;
+		rockchip,grf = <&sys_grf>;
+		rockchip,vop-grf = <&vop_grf>;
+		rockchip,vo1-grf = <&vo1_grf>;
+		rockchip,pmu = <&pmu>;
+		status = "disabled";
+
+		vop_out: ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			vp0: port@0 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				reg = <0>;
+
+				vp0_out_dp0: endpoint@0 {
+					reg = <0>;
+					remote-endpoint = <&dp0_in_vp0>;
+				};
+
+				vp0_out_hdmi0: endpoint@2 {
+					reg = <2>;
+					remote-endpoint = <&hdmi0_in_vp0>;
+				};
+			};
+
+			vp1: port@1 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				reg = <1>;
+
+				vp1_out_dp0: endpoint@0 {
+					reg = <0>;
+					remote-endpoint = <&dp0_in_vp1>;
+				};
+
+				vp1_out_hdmi0: endpoint@2 {
+					reg = <2>;
+					remote-endpoint = <&hdmi0_in_vp1>;
+				};
+			};
+
+			vp2: port@2 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				reg = <2>;
+
+				assigned-clocks = <&cru DCLK_VOP2_SRC>;
+				assigned-clock-parents = <&cru PLL_V0PLL>;
+
+				vp2_out_dp0: endpoint@0 {
+					reg = <0>;
+					remote-endpoint = <&dp0_in_vp2>;
+				};
+
+				vp2_out_hdmi0: endpoint@2 {
+					reg = <2>;
+					remote-endpoint = <&hdmi0_in_vp2>;
+				};
+			};
+
+			vp3: port@3 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				reg = <3>;
+			};
+		};
+	};
+
+	vop_mmu: iommu@fdd97e00 {
+		compatible = "rockchip,rk3588-iommu", "rockchip,rk3568-iommu";
+		reg = <0x0 0xfdd97e00 0x0 0x100>, <0x0 0xfdd97f00 0x0 0x100>;
+		interrupts = <GIC_SPI 156 IRQ_TYPE_LEVEL_HIGH 0>;
+		clocks = <&cru ACLK_VOP>, <&cru HCLK_VOP>;
+		clock-names = "aclk", "iface";
+		#iommu-cells = <0>;
+		power-domains = <&power RK3588_PD_VOP>;
+		status = "disabled";
+	};
+
 	i2s4_8ch: i2s@fddc0000 {
 		compatible = "rockchip,rk3588-i2s-tdm";
 		reg = <0x0 0xfddc0000 0x0 0x1000>;
@@ -1369,6 +1793,16 @@
 		reg = <0x0 0xfdf82200 0x0 0x20>;
 	};
 
+	dfi: dfi@fe060000 {
+		reg = <0x00 0xfe060000 0x00 0x10000>;
+		compatible = "rockchip,rk3588-dfi";
+		interrupts = <GIC_SPI 28 IRQ_TYPE_LEVEL_HIGH 0>,
+			     <GIC_SPI 38 IRQ_TYPE_LEVEL_HIGH 0>,
+			     <GIC_SPI 48 IRQ_TYPE_LEVEL_HIGH 0>,
+			     <GIC_SPI 58 IRQ_TYPE_LEVEL_HIGH 0>;
+		rockchip,pmu = <&pmu1grf>;
+	};
+
 	pcie2x1l1: pcie@fe180000 {
 		compatible = "rockchip,rk3588-pcie", "rockchip,rk3568-pcie";
 		bus-range = <0x30 0x3f>;
@@ -1471,16 +1905,6 @@
 		};
 	};
 
-	dfi: dfi@fe060000 {
-		reg = <0x00 0xfe060000 0x00 0x10000>;
-		compatible = "rockchip,rk3588-dfi";
-		interrupts = <GIC_SPI 28 IRQ_TYPE_LEVEL_HIGH 0>,
-			     <GIC_SPI 38 IRQ_TYPE_LEVEL_HIGH 0>,
-			     <GIC_SPI 48 IRQ_TYPE_LEVEL_HIGH 0>,
-			     <GIC_SPI 58 IRQ_TYPE_LEVEL_HIGH 0>;
-		rockchip,pmu = <&pmu1grf>;
-	};
-
 	gmac1: ethernet@fe1c0000 {
 		compatible = "rockchip,rk3588-gmac", "snps,dwmac-4.20a";
 		reg = <0x0 0xfe1c0000 0x0 0x10000>;
@@ -1704,7 +2128,6 @@
 		dmas = <&dmac1 0>, <&dmac1 1>;
 		dma-names = "tx", "rx";
 		power-domains = <&power RK3588_PD_AUDIO>;
-		rockchip,trcm-sync-tx-only;
 		pinctrl-names = "default";
 		pinctrl-0 = <&i2s2m1_lrck
 			     &i2s2m1_sclk
@@ -1725,7 +2148,6 @@
 		dmas = <&dmac1 2>, <&dmac1 3>;
 		dma-names = "tx", "rx";
 		power-domains = <&power RK3588_PD_AUDIO>;
-		rockchip,trcm-sync-tx-only;
 		pinctrl-names = "default";
 		pinctrl-0 = <&i2s3_lrck
 			     &i2s3_sclk
@@ -2360,6 +2782,56 @@
 		#dma-cells = <1>;
 	};
 
+	hdptxphy_hdmi0: hdmiphy@fed60000 {
+		compatible = "rockchip,rk3588-hdptx-phy";
+		reg = <0x0 0xfed60000 0x0 0x2000>;
+		clocks = <&cru CLK_USB2PHY_HDPTXRXPHY_REF>, <&cru PCLK_HDPTX0>;
+		clock-names = "ref", "apb";
+		clock-output-names = "clk_hdmiphy_pixel0";
+		#clock-cells = <0>;
+		#phy-cells = <0>;
+		resets = <&cru SRST_HDPTX0>, <&cru SRST_P_HDPTX0>,
+			 <&cru SRST_HDPTX0_INIT>, <&cru SRST_HDPTX0_CMN>,
+			 <&cru SRST_HDPTX0_LANE>, <&cru SRST_HDPTX0_ROPLL>,
+			 <&cru SRST_HDPTX0_LCPLL>;
+		reset-names = "phy", "apb", "init", "cmn", "lane", "ropll",
+			      "lcpll";
+		rockchip,grf = <&hdptxphy0_grf>;
+		status = "disabled";
+
+		hdptxphy_hdmi_clk0: clk-port {
+			#clock-cells = <0>;
+			status = "okay";
+		};
+	};
+
+	usbdp_phy0: phy@fed80000 {
+		compatible = "rockchip,rk3588-usbdp-phy";
+		reg = <0x0 0xfed80000 0x0 0x10000>;
+		#phy-cells = <1>;
+		clocks = <&cru CLK_USBDPPHY_MIPIDCPPHY_REF>,
+			 <&cru CLK_USBDP_PHY0_IMMORTAL>,
+			 <&cru PCLK_USBDPPHY0>,
+			 <&u2phy0>;
+		clock-names = "refclk", "immortal", "pclk", "utmi";
+		resets = <&cru SRST_USBDP_COMBO_PHY0_INIT>,
+			 <&cru SRST_USBDP_COMBO_PHY0_CMN>,
+			 <&cru SRST_USBDP_COMBO_PHY0_LANE>,
+			 <&cru SRST_USBDP_COMBO_PHY0_PCS>,
+			 <&cru SRST_P_USBDPPHY0>;
+		reset-names = "init", "cmn", "lane", "pcs_apb", "pma_apb";
+		rockchip,u2phy-grf = <&usb2phy0_grf>;
+		rockchip,usb-grf = <&usb_grf>;
+		rockchip,usbdpphy-grf = <&usbdpphy0_grf>;
+		rockchip,vo-grf = <&vo0_grf>;
+		status = "disabled";
+
+		usbdp_phy0_dp: dp-port {
+			#phy-cells = <0>;
+			status = "disabled";
+		};
+	};
+
 	combphy0_ps: phy@fee00000 {
 		compatible = "rockchip,rk3588-naneng-combphy";
 		reg = <0x0 0xfee00000 0x0 0x100>;
@@ -2467,19 +2939,6 @@
 			#interrupt-cells = <2>;
 		};
 	};
-
-	av1d: video-codec@fdc70000 {
-		compatible = "rockchip,rk3588-av1-vpu";
-		reg = <0x0 0xfdc70000 0x0 0x800>;
-		interrupts = <GIC_SPI 108 IRQ_TYPE_LEVEL_HIGH 0>;
-		interrupt-names = "vdpu";
-		assigned-clocks = <&cru ACLK_AV1>, <&cru PCLK_AV1>;
-		assigned-clock-rates = <400000000>, <400000000>;
-		clocks = <&cru ACLK_AV1>, <&cru PCLK_AV1>;
-		clock-names = "aclk", "hclk";
-		power-domains = <&power RK3588_PD_AV1>;
-		resets = <&cru SRST_A_AV1>, <&cru SRST_P_AV1>, <&cru SRST_A_AV1_BIU>, <&cru SRST_P_AV1_BIU>;
-	};
 };
 
 #include "rk3588s-pinctrl.dtsi"
diff --git a/include/boot_rkimg.h b/include/boot_rkimg.h
new file mode 100644
index 0000000000..eb8b1ef086
--- /dev/null
+++ b/include/boot_rkimg.h
@@ -0,0 +1,84 @@
+/*
+ * (C) Copyright 2017 Rockchip Electronics Co., Ltd
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#ifndef __BOOT_ROCKCHIP_H_
+#define __BOOT_ROCKCHIP_H_
+
+/* This is a copy from Android boot loader */
+enum _boot_mode {
+	BOOT_MODE_NORMAL = 0,
+	BOOT_MODE_RECOVERY,
+	BOOT_MODE_BOOTLOADER,	/* Android: Fastboot mode */
+	BOOT_MODE_LOADER,	/* Rockchip: Rockusb download mode */
+	BOOT_MODE_CHARGING,
+	BOOT_MODE_UMS,
+	BOOT_MODE_BROM_DOWNLOAD,
+	BOOT_MODE_PANIC,
+	BOOT_MODE_WATCHDOG,
+	BOOT_MODE_DFU,
+	BOOT_MODE_QUIESCENT,
+	BOOT_MODE_UNDEFINE,
+};
+
+struct bootloader_message {
+	char command[32];
+	char status[32];
+	char recovery[768];
+	/*
+	 * The 'recovery' field used to be 1024 bytes.  It has only ever
+	 * been used to store the recovery command line, so 768 bytes
+	 * should be plenty.  We carve off the last 256 bytes to store the
+	 * stage string (for multistage packages) and possible future
+	 * expansion.
+	 */
+	char stage[32];
+	char slot_suffix[32];
+	char reserved[192];
+};
+
+struct rockchip_image {
+	uint32_t tag;
+	uint32_t size;
+	int8_t image[1];
+	uint32_t crc;
+};
+
+#define RK_BLK_SIZE			512
+#define TAG_KERNEL			0x4C4E524B
+#define BCB_MESSAGE_BLK_OFFSET		(16 * 1024 >> 9)
+
+#define PART_UBOOT			"uboot"
+#define PART_TRUST			"trust"
+#define PART_MISC			"misc"
+#define PART_RESOURCE			"resource"
+#define PART_KERNEL			"kernel"
+#define PART_BOOT			"boot"
+#define PART_VENDOR_BOOT		"vendor_boot"
+#define PART_RECOVERY			"recovery"
+#define PART_DTBO			"dtbo"
+#define PART_LOGO			"logo"
+#define PART_SYSTEM			"system"
+#define PART_METADATA			"metadata"
+#define PART_USERDATA			"userdata"
+#define PART_META			"meta"
+
+struct blk_desc *rockchip_get_bootdev(void);
+void rockchip_set_bootdev(struct blk_desc *desc);
+void board_run_recovery_wipe_data(void);
+void setup_download_mode(void);
+int get_bcb_recovery_msg(void);
+int rockchip_read_dtb_file(void *fdt_addr);
+int rockchip_ram_read_dtb_file(void *img, void *fdt_addr);
+int init_kernel_dtb(void);
+int fit_write_trusty_rollback_index(u32 trusty_index);
+int arch_fpga_init(void);
+
+#ifndef CONFIG_SPL_BUILD
+int rockchip_get_boot_mode(void);
+#else
+int rockchip_get_boot_mode(struct blk_desc *dev_desc, u32 bcb_sector_offset);
+#endif
+#endif
diff --git a/include/common.h b/include/common.h
index a79c2bb499..127728e794 100644
--- a/include/common.h
+++ b/include/common.h
@@ -18,6 +18,8 @@
 #include <time.h>
 #include <linux/types.h>
 #include <linux/string.h>
+#include <linux/delay.h>
+#include <image.h>
 #include <stdarg.h>
 #include <stdio.h>
 #include <linux/kernel.h>
diff --git a/include/configs/evb_rk3588.h b/include/configs/evb_rk3588.h
index 4568e2cace..504693c63e 100644
--- a/include/configs/evb_rk3588.h
+++ b/include/configs/evb_rk3588.h
@@ -9,6 +9,7 @@
 #include <configs/rk3588_common.h>
 
 #define ROCKCHIP_DEVICE_SETTINGS \
+		"stdin=serial,usbkbd\0" \
 		"stdout=serial,vidconsole\0" \
 		"stderr=serial,vidconsole\0"
 
diff --git a/include/configs/rk3588_common.h b/include/configs/rk3588_common.h
index 70430612ef..1202c57770 100644
--- a/include/configs/rk3588_common.h
+++ b/include/configs/rk3588_common.h
@@ -31,6 +31,8 @@
 	"partitions=" PARTS_DEFAULT		\
 	ENV_MEM_LAYOUT_SETTINGS			\
 	ROCKCHIP_DEVICE_SETTINGS \
-	"boot_targets=" BOOT_TARGETS "\0"
+	"boot_targets=" BOOT_TARGETS "\0" \
+	"bootmenu_0=" "UEFI Boot Manager=bootefi bootmgr" "\0"\
+	"bootmenu_1=" "UEFI Maintenance Menu=eficonfig" "\0"
 
 #endif /* __CONFIG_RK3588_COMMON_H */
diff --git a/include/configs/rock5b-rk3588.h b/include/configs/rock5b-rk3588.h
index 4f75c80006..1f4d61597b 100644
--- a/include/configs/rock5b-rk3588.h
+++ b/include/configs/rock5b-rk3588.h
@@ -7,6 +7,7 @@
 #define __ROCK5B_RK3588_H
 
 #define ROCKCHIP_DEVICE_SETTINGS \
+		"stdin=serial,usbkbd\0" \
 		"stdout=serial,vidconsole\0" \
 		"stderr=serial,vidconsole\0"
 
diff --git a/include/dm/of_access.h b/include/dm/of_access.h
index de740d4467..1cd2636f74 100644
--- a/include/dm/of_access.h
+++ b/include/dm/of_access.h
@@ -385,6 +385,22 @@ int of_read_u64(const struct device_node *np, const char *propname, u64 *outp);
 int of_read_u32_array(const struct device_node *np, const char *propname,
 		      u32 *out_values, size_t sz);
 
+/**
+ * of_write_u32_array() - Find and write an array of 32 bit integers
+ *
+ * Search for a property in a device node and write 32-bit value(s) to
+ * it.
+ *
+ * @np:		device node from which the property value is to be read.
+ * @propname:	name of the property to be searched.
+ * @values:	pointer to update value, modified only if return value is 0.
+ * @sz:		number of array elements to read
+ * @return 0 on success, -EINVAL if the property does not exist, -ENODATA
+ * if property does not have a value, and -EOVERFLOW is longer than sz.
+ */
+int of_write_u32_array(const struct device_node *np, const char *propname,
+		       u32 *values, size_t sz);
+
 /**
  * of_property_match_string() - Find string in a list and return index
  *
@@ -563,6 +579,17 @@ int of_alias_get_id(const struct device_node *np, const char *stem);
  */
 int of_alias_get_highest_id(const char *stem);
 
+/**
+ * of_alias_get_dev - Get device_node by given stem and alias id
+ *
+ * Travels the lookup table to get the device_node by given stem and alias id.
+ *
+ * @stem:	Alias stem of the given device_node
+ * @id:         Alias id of the given device_node
+ * @return device_node, if found, else NULL
+ */
+struct device_node *of_alias_get_dev(const char *stem, int id);
+
 /**
  * of_get_stdout() - Get node to use for stdout
  *
diff --git a/include/dm/ofnode.h b/include/dm/ofnode.h
index 5795115c49..247e03bda1 100644
--- a/include/dm/ofnode.h
+++ b/include/dm/ofnode.h
@@ -575,6 +575,19 @@ const char *ofnode_read_string(ofnode node, const char *propname);
 int ofnode_read_u32_array(ofnode node, const char *propname,
 			  u32 *out_values, size_t sz);
 
+/**
+ * ofnode_write_u32_array() - Find and write an array of 32 bit integers
+ *
+ * @node:	valid node reference to read property from
+ * @propname:	name of the property to read
+ * @values:	pointer to update value, modified only if return value is 0
+ * @sz:		number of array elements to read
+ * @return 0 on success, -EINVAL if the property does not exist, -ENODATA
+ * if property does not have a value, and -EOVERFLOW is longer than sz.
+ */
+int ofnode_write_u32_array(ofnode node, const char *propname,
+			   u32 *values, size_t sz);
+
 /**
  * ofnode_read_bool() - read a boolean value from a property
  *
diff --git a/include/dm/uclass-id.h b/include/dm/uclass-id.h
index 5271e646bb..52186aec08 100644
--- a/include/dm/uclass-id.h
+++ b/include/dm/uclass-id.h
@@ -156,6 +156,7 @@ enum uclass_id {
 	UCLASS_W1,		/* Dallas 1-Wire bus */
 	UCLASS_W1_EEPROM,	/* one-wire EEPROMs */
 	UCLASS_WDT,		/* Watchdog Timer driver */
+	UCLASS_VIDEO_CRTC,	/* Display Controller */
 
 	UCLASS_COUNT,
 	UCLASS_INVALID = -1,
diff --git a/include/drm/drm_dp_helper.h b/include/drm/drm_dp_helper.h
new file mode 100644
index 0000000000..3711c875db
--- /dev/null
+++ b/include/drm/drm_dp_helper.h
@@ -0,0 +1,1229 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright © 2008 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided "as
+ * is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+#ifndef _DRM_DP_HELPER_H_
+#define _DRM_DP_HELPER_H_
+
+#include <edid.h>
+
+/*
+ * Unless otherwise noted, all values are from the DP 1.1a spec.  Note that
+ * DP and DPCD versions are independent.  Differences from 1.0 are not noted,
+ * 1.0 devices basically don't exist in the wild.
+ *
+ * Abbreviations, in chronological order:
+ *
+ * eDP: Embedded DisplayPort version 1
+ * DPI: DisplayPort Interoperability Guideline v1.1a
+ * 1.2: DisplayPort 1.2
+ * MST: Multistream Transport - part of DP 1.2a
+ *
+ * 1.2 formally includes both eDP and DPI definitions.
+ */
+
+/* MSA (Main Stream Attribute) MISC bits (as MISC1<<8|MISC0) */
+#define DP_MSA_MISC_SYNC_CLOCK			(1 << 0)
+#define DP_MSA_MISC_INTERLACE_VTOTAL_EVEN	(1 << 8)
+#define DP_MSA_MISC_STEREO_NO_3D		(0 << 9)
+#define DP_MSA_MISC_STEREO_PROG_RIGHT_EYE	(1 << 9)
+#define DP_MSA_MISC_STEREO_PROG_LEFT_EYE	(3 << 9)
+/* bits per component for non-RAW */
+#define DP_MSA_MISC_6_BPC			(0 << 5)
+#define DP_MSA_MISC_8_BPC			(1 << 5)
+#define DP_MSA_MISC_10_BPC			(2 << 5)
+#define DP_MSA_MISC_12_BPC			(3 << 5)
+#define DP_MSA_MISC_16_BPC			(4 << 5)
+/* bits per component for RAW */
+#define DP_MSA_MISC_RAW_6_BPC			(1 << 5)
+#define DP_MSA_MISC_RAW_7_BPC			(2 << 5)
+#define DP_MSA_MISC_RAW_8_BPC			(3 << 5)
+#define DP_MSA_MISC_RAW_10_BPC			(4 << 5)
+#define DP_MSA_MISC_RAW_12_BPC			(5 << 5)
+#define DP_MSA_MISC_RAW_14_BPC			(6 << 5)
+#define DP_MSA_MISC_RAW_16_BPC			(7 << 5)
+/* pixel encoding/colorimetry format */
+#define _DP_MSA_MISC_COLOR(misc1_7, misc0_21, misc0_3, misc0_4) \
+	((misc1_7) << 15 | (misc0_4) << 4 | (misc0_3) << 3 | ((misc0_21) << 1))
+#define DP_MSA_MISC_COLOR_RGB			_DP_MSA_MISC_COLOR(0, 0, 0, 0)
+#define DP_MSA_MISC_COLOR_CEA_RGB		_DP_MSA_MISC_COLOR(0, 0, 1, 0)
+#define DP_MSA_MISC_COLOR_RGB_WIDE_FIXED	_DP_MSA_MISC_COLOR(0, 3, 0, 0)
+#define DP_MSA_MISC_COLOR_RGB_WIDE_FLOAT	_DP_MSA_MISC_COLOR(0, 3, 0, 1)
+#define DP_MSA_MISC_COLOR_Y_ONLY		_DP_MSA_MISC_COLOR(1, 0, 0, 0)
+#define DP_MSA_MISC_COLOR_RAW			_DP_MSA_MISC_COLOR(1, 1, 0, 0)
+#define DP_MSA_MISC_COLOR_YCBCR_422_BT601	_DP_MSA_MISC_COLOR(0, 1, 1, 0)
+#define DP_MSA_MISC_COLOR_YCBCR_422_BT709	_DP_MSA_MISC_COLOR(0, 1, 1, 1)
+#define DP_MSA_MISC_COLOR_YCBCR_444_BT601	_DP_MSA_MISC_COLOR(0, 2, 1, 0)
+#define DP_MSA_MISC_COLOR_YCBCR_444_BT709	_DP_MSA_MISC_COLOR(0, 2, 1, 1)
+#define DP_MSA_MISC_COLOR_XVYCC_422_BT601	_DP_MSA_MISC_COLOR(0, 1, 0, 0)
+#define DP_MSA_MISC_COLOR_XVYCC_422_BT709	_DP_MSA_MISC_COLOR(0, 1, 0, 1)
+#define DP_MSA_MISC_COLOR_XVYCC_444_BT601	_DP_MSA_MISC_COLOR(0, 2, 0, 0)
+#define DP_MSA_MISC_COLOR_XVYCC_444_BT709	_DP_MSA_MISC_COLOR(0, 2, 0, 1)
+#define DP_MSA_MISC_COLOR_OPRGB			_DP_MSA_MISC_COLOR(0, 0, 1, 1)
+#define DP_MSA_MISC_COLOR_DCI_P3		_DP_MSA_MISC_COLOR(0, 3, 1, 0)
+#define DP_MSA_MISC_COLOR_COLOR_PROFILE		_DP_MSA_MISC_COLOR(0, 3, 1, 1)
+#define DP_MSA_MISC_COLOR_VSC_SDP		(1 << 14)
+
+#define DP_AUX_MAX_PAYLOAD_BYTES	16
+
+#define DP_AUX_I2C_WRITE		0x0
+#define DP_AUX_I2C_READ			0x1
+#define DP_AUX_I2C_WRITE_STATUS_UPDATE	0x2
+#define DP_AUX_I2C_MOT			0x4
+#define DP_AUX_NATIVE_WRITE		0x8
+#define DP_AUX_NATIVE_READ		0x9
+
+#define DP_AUX_NATIVE_REPLY_ACK		(0x0 << 0)
+#define DP_AUX_NATIVE_REPLY_NACK	(0x1 << 0)
+#define DP_AUX_NATIVE_REPLY_DEFER	(0x2 << 0)
+#define DP_AUX_NATIVE_REPLY_MASK	(0x3 << 0)
+
+#define DP_AUX_I2C_REPLY_ACK		(0x0 << 2)
+#define DP_AUX_I2C_REPLY_NACK		(0x1 << 2)
+#define DP_AUX_I2C_REPLY_DEFER		(0x2 << 2)
+#define DP_AUX_I2C_REPLY_MASK		(0x3 << 2)
+
+/* AUX CH addresses */
+/* DPCD */
+#define DP_DPCD_REV                         0x000
+# define DP_DPCD_REV_10                     0x10
+# define DP_DPCD_REV_11                     0x11
+# define DP_DPCD_REV_12                     0x12
+# define DP_DPCD_REV_13                     0x13
+# define DP_DPCD_REV_14                     0x14
+
+#define DP_MAX_LINK_RATE                    0x001
+
+#define DP_MAX_LANE_COUNT                   0x002
+# define DP_MAX_LANE_COUNT_MASK		    0x1f
+# define DP_TPS3_SUPPORTED		    (1 << 6) /* 1.2 */
+# define DP_ENHANCED_FRAME_CAP		    (1 << 7)
+
+#define DP_MAX_DOWNSPREAD                   0x003
+# define DP_MAX_DOWNSPREAD_0_5		    (1 << 0)
+# define DP_NO_AUX_HANDSHAKE_LINK_TRAINING  (1 << 6)
+# define DP_TPS4_SUPPORTED                  (1 << 7)
+
+#define DP_NORP                             0x004
+
+#define DP_DOWNSTREAMPORT_PRESENT           0x005
+# define DP_DWN_STRM_PORT_PRESENT           (1 << 0)
+# define DP_DWN_STRM_PORT_TYPE_MASK         0x06
+# define DP_DWN_STRM_PORT_TYPE_DP           (0 << 1)
+# define DP_DWN_STRM_PORT_TYPE_ANALOG       (1 << 1)
+# define DP_DWN_STRM_PORT_TYPE_TMDS         (2 << 1)
+# define DP_DWN_STRM_PORT_TYPE_OTHER        (3 << 1)
+# define DP_FORMAT_CONVERSION               (1 << 3)
+# define DP_DETAILED_CAP_INFO_AVAILABLE	    (1 << 4) /* DPI */
+
+#define DP_MAIN_LINK_CHANNEL_CODING         0x006
+# define DP_CAP_ANSI_8B10B		    (1 << 0)
+
+#define DP_DOWN_STREAM_PORT_COUNT	    0x007
+# define DP_PORT_COUNT_MASK		    0x0f
+# define DP_MSA_TIMING_PAR_IGNORED	    (1 << 6) /* eDP */
+# define DP_OUI_SUPPORT			    (1 << 7)
+
+#define DP_RECEIVE_PORT_0_CAP_0		    0x008
+# define DP_LOCAL_EDID_PRESENT		    (1 << 1)
+# define DP_ASSOCIATED_TO_PRECEDING_PORT    (1 << 2)
+
+#define DP_RECEIVE_PORT_0_BUFFER_SIZE	    0x009
+
+#define DP_RECEIVE_PORT_1_CAP_0		    0x00a
+#define DP_RECEIVE_PORT_1_BUFFER_SIZE       0x00b
+
+#define DP_I2C_SPEED_CAP		    0x00c    /* DPI */
+# define DP_I2C_SPEED_1K		    0x01
+# define DP_I2C_SPEED_5K		    0x02
+# define DP_I2C_SPEED_10K		    0x04
+# define DP_I2C_SPEED_100K		    0x08
+# define DP_I2C_SPEED_400K		    0x10
+# define DP_I2C_SPEED_1M		    0x20
+
+#define DP_EDP_CONFIGURATION_CAP            0x00d   /* XXX 1.2? */
+# define DP_ALTERNATE_SCRAMBLER_RESET_CAP   (1 << 0)
+# define DP_FRAMING_CHANGE_CAP		    (1 << 1)
+# define DP_DPCD_DISPLAY_CONTROL_CAPABLE     (1 << 3) /* edp v1.2 or higher */
+
+#define DP_TRAINING_AUX_RD_INTERVAL         0x00e   /* XXX 1.2? */
+# define DP_TRAINING_AUX_RD_MASK            0x7F    /* XXX 1.2? */
+# define DP_EXTENDED_RECEIVER_CAP_FIELD_PRESENT	(1 << 7) /* DP 1.3 */
+
+#define DP_ADAPTER_CAP			    0x00f   /* 1.2 */
+# define DP_FORCE_LOAD_SENSE_CAP	    (1 << 0)
+# define DP_ALTERNATE_I2C_PATTERN_CAP	    (1 << 1)
+
+#define DP_SUPPORTED_LINK_RATES		    0x010 /* eDP 1.4 */
+# define DP_MAX_SUPPORTED_RATES		     8	    /* 16-bit little-endian */
+
+/* Multiple stream transport */
+#define DP_FAUX_CAP			    0x020   /* 1.2 */
+# define DP_FAUX_CAP_1			    (1 << 0)
+
+#define DP_MSTM_CAP			    0x021   /* 1.2 */
+# define DP_MST_CAP			    (1 << 0)
+
+#define DP_NUMBER_OF_AUDIO_ENDPOINTS	    0x022   /* 1.2 */
+
+/* AV_SYNC_DATA_BLOCK                                  1.2 */
+#define DP_AV_GRANULARITY		    0x023
+# define DP_AG_FACTOR_MASK		    (0xf << 0)
+# define DP_AG_FACTOR_3MS		    (0 << 0)
+# define DP_AG_FACTOR_2MS		    (1 << 0)
+# define DP_AG_FACTOR_1MS		    (2 << 0)
+# define DP_AG_FACTOR_500US		    (3 << 0)
+# define DP_AG_FACTOR_200US		    (4 << 0)
+# define DP_AG_FACTOR_100US		    (5 << 0)
+# define DP_AG_FACTOR_10US		    (6 << 0)
+# define DP_AG_FACTOR_1US		    (7 << 0)
+# define DP_VG_FACTOR_MASK		    (0xf << 4)
+# define DP_VG_FACTOR_3MS		    (0 << 4)
+# define DP_VG_FACTOR_2MS		    (1 << 4)
+# define DP_VG_FACTOR_1MS		    (2 << 4)
+# define DP_VG_FACTOR_500US		    (3 << 4)
+# define DP_VG_FACTOR_200US		    (4 << 4)
+# define DP_VG_FACTOR_100US		    (5 << 4)
+
+#define DP_AUD_DEC_LAT0			    0x024
+#define DP_AUD_DEC_LAT1			    0x025
+
+#define DP_AUD_PP_LAT0			    0x026
+#define DP_AUD_PP_LAT1			    0x027
+
+#define DP_VID_INTER_LAT		    0x028
+
+#define DP_VID_PROG_LAT			    0x029
+
+#define DP_REP_LAT			    0x02a
+
+#define DP_AUD_DEL_INS0			    0x02b
+#define DP_AUD_DEL_INS1			    0x02c
+#define DP_AUD_DEL_INS2			    0x02d
+/* End of AV_SYNC_DATA_BLOCK */
+
+#define DP_RECEIVER_ALPM_CAP		    0x02e   /* eDP 1.4 */
+# define DP_ALPM_CAP			    (1 << 0)
+
+#define DP_SINK_DEVICE_AUX_FRAME_SYNC_CAP   0x02f   /* eDP 1.4 */
+# define DP_AUX_FRAME_SYNC_CAP		    (1 << 0)
+
+#define DP_GUID				    0x030   /* 1.2 */
+
+#define DP_DSC_SUPPORT                      0x060   /* DP 1.4 */
+# define DP_DSC_DECOMPRESSION_IS_SUPPORTED  (1 << 0)
+
+#define DP_DSC_REV                          0x061
+# define DP_DSC_MAJOR_MASK                  (0xf << 0)
+# define DP_DSC_MINOR_MASK                  (0xf << 4)
+# define DP_DSC_MAJOR_SHIFT                 0
+# define DP_DSC_MINOR_SHIFT                 4
+
+#define DP_DSC_RC_BUF_BLK_SIZE              0x062
+# define DP_DSC_RC_BUF_BLK_SIZE_1           0x0
+# define DP_DSC_RC_BUF_BLK_SIZE_4           0x1
+# define DP_DSC_RC_BUF_BLK_SIZE_16          0x2
+# define DP_DSC_RC_BUF_BLK_SIZE_64          0x3
+
+#define DP_DSC_RC_BUF_SIZE                  0x063
+
+#define DP_DSC_SLICE_CAP_1                  0x064
+# define DP_DSC_1_PER_DP_DSC_SINK           (1 << 0)
+# define DP_DSC_2_PER_DP_DSC_SINK           (1 << 1)
+# define DP_DSC_4_PER_DP_DSC_SINK           (1 << 3)
+# define DP_DSC_6_PER_DP_DSC_SINK           (1 << 4)
+# define DP_DSC_8_PER_DP_DSC_SINK           (1 << 5)
+# define DP_DSC_10_PER_DP_DSC_SINK          (1 << 6)
+# define DP_DSC_12_PER_DP_DSC_SINK          (1 << 7)
+
+#define DP_DSC_LINE_BUF_BIT_DEPTH           0x065
+# define DP_DSC_LINE_BUF_BIT_DEPTH_MASK     (0xf << 0)
+# define DP_DSC_LINE_BUF_BIT_DEPTH_9        0x0
+# define DP_DSC_LINE_BUF_BIT_DEPTH_10       0x1
+# define DP_DSC_LINE_BUF_BIT_DEPTH_11       0x2
+# define DP_DSC_LINE_BUF_BIT_DEPTH_12       0x3
+# define DP_DSC_LINE_BUF_BIT_DEPTH_13       0x4
+# define DP_DSC_LINE_BUF_BIT_DEPTH_14       0x5
+# define DP_DSC_LINE_BUF_BIT_DEPTH_15       0x6
+# define DP_DSC_LINE_BUF_BIT_DEPTH_16       0x7
+# define DP_DSC_LINE_BUF_BIT_DEPTH_8        0x8
+
+#define DP_DSC_BLK_PREDICTION_SUPPORT       0x066
+# define DP_DSC_BLK_PREDICTION_IS_SUPPORTED (1 << 0)
+
+#define DP_DSC_MAX_BITS_PER_PIXEL_LOW       0x067   /* eDP 1.4 */
+
+#define DP_DSC_MAX_BITS_PER_PIXEL_HI        0x068   /* eDP 1.4 */
+
+#define DP_DSC_DEC_COLOR_FORMAT_CAP         0x069
+# define DP_DSC_RGB                         (1 << 0)
+# define DP_DSC_YCbCr444                    (1 << 1)
+# define DP_DSC_YCbCr422_Simple             (1 << 2)
+# define DP_DSC_YCbCr422_Native             (1 << 3)
+# define DP_DSC_YCbCr420_Native             (1 << 4)
+
+#define DP_DSC_DEC_COLOR_DEPTH_CAP          0x06A
+# define DP_DSC_8_BPC                       (1 << 1)
+# define DP_DSC_10_BPC                      (1 << 2)
+# define DP_DSC_12_BPC                      (1 << 3)
+
+#define DP_DSC_PEAK_THROUGHPUT              0x06B
+# define DP_DSC_THROUGHPUT_MODE_0_MASK      (0xf << 0)
+# define DP_DSC_THROUGHPUT_MODE_0_SHIFT     0
+# define DP_DSC_THROUGHPUT_MODE_0_340       (1 << 0)
+# define DP_DSC_THROUGHPUT_MODE_0_400       (2 << 0)
+# define DP_DSC_THROUGHPUT_MODE_0_450       (3 << 0)
+# define DP_DSC_THROUGHPUT_MODE_0_500       (4 << 0)
+# define DP_DSC_THROUGHPUT_MODE_0_550       (5 << 0)
+# define DP_DSC_THROUGHPUT_MODE_0_600       (6 << 0)
+# define DP_DSC_THROUGHPUT_MODE_0_650       (7 << 0)
+# define DP_DSC_THROUGHPUT_MODE_0_700       (8 << 0)
+# define DP_DSC_THROUGHPUT_MODE_0_750       (9 << 0)
+# define DP_DSC_THROUGHPUT_MODE_0_800       (10 << 0)
+# define DP_DSC_THROUGHPUT_MODE_0_850       (11 << 0)
+# define DP_DSC_THROUGHPUT_MODE_0_900       (12 << 0)
+# define DP_DSC_THROUGHPUT_MODE_0_950       (13 << 0)
+# define DP_DSC_THROUGHPUT_MODE_0_1000      (14 << 0)
+# define DP_DSC_THROUGHPUT_MODE_1_MASK      (0xf << 4)
+# define DP_DSC_THROUGHPUT_MODE_1_SHIFT     4
+# define DP_DSC_THROUGHPUT_MODE_1_340       (1 << 4)
+# define DP_DSC_THROUGHPUT_MODE_1_400       (2 << 4)
+# define DP_DSC_THROUGHPUT_MODE_1_450       (3 << 4)
+# define DP_DSC_THROUGHPUT_MODE_1_500       (4 << 4)
+# define DP_DSC_THROUGHPUT_MODE_1_550       (5 << 4)
+# define DP_DSC_THROUGHPUT_MODE_1_600       (6 << 4)
+# define DP_DSC_THROUGHPUT_MODE_1_650       (7 << 4)
+# define DP_DSC_THROUGHPUT_MODE_1_700       (8 << 4)
+# define DP_DSC_THROUGHPUT_MODE_1_750       (9 << 4)
+# define DP_DSC_THROUGHPUT_MODE_1_800       (10 << 4)
+# define DP_DSC_THROUGHPUT_MODE_1_850       (11 << 4)
+# define DP_DSC_THROUGHPUT_MODE_1_900       (12 << 4)
+# define DP_DSC_THROUGHPUT_MODE_1_950       (13 << 4)
+# define DP_DSC_THROUGHPUT_MODE_1_1000      (14 << 4)
+
+#define DP_DSC_MAX_SLICE_WIDTH              0x06C
+
+#define DP_DSC_SLICE_CAP_2                  0x06D
+# define DP_DSC_16_PER_DP_DSC_SINK          (1 << 0)
+# define DP_DSC_20_PER_DP_DSC_SINK          (1 << 1)
+# define DP_DSC_24_PER_DP_DSC_SINK          (1 << 2)
+
+#define DP_DSC_BITS_PER_PIXEL_INC           0x06F
+# define DP_DSC_BITS_PER_PIXEL_1_16         0x0
+# define DP_DSC_BITS_PER_PIXEL_1_8          0x1
+# define DP_DSC_BITS_PER_PIXEL_1_4          0x2
+# define DP_DSC_BITS_PER_PIXEL_1_2          0x3
+# define DP_DSC_BITS_PER_PIXEL_1            0x4
+
+#define DP_PSR_SUPPORT                      0x070   /* XXX 1.2? */
+# define DP_PSR_IS_SUPPORTED                1
+# define DP_PSR2_IS_SUPPORTED		    2	    /* eDP 1.4 */
+# define DP_PSR2_WITH_Y_COORD_IS_SUPPORTED  3	    /* eDP 1.4a */
+
+#define DP_PSR_CAPS                         0x071   /* XXX 1.2? */
+# define DP_PSR_NO_TRAIN_ON_EXIT            1
+# define DP_PSR_SETUP_TIME_330              (0 << 1)
+# define DP_PSR_SETUP_TIME_275              (1 << 1)
+# define DP_PSR_SETUP_TIME_220              (2 << 1)
+# define DP_PSR_SETUP_TIME_165              (3 << 1)
+# define DP_PSR_SETUP_TIME_110              (4 << 1)
+# define DP_PSR_SETUP_TIME_55               (5 << 1)
+# define DP_PSR_SETUP_TIME_0                (6 << 1)
+# define DP_PSR_SETUP_TIME_MASK             (7 << 1)
+# define DP_PSR_SETUP_TIME_SHIFT            1
+# define DP_PSR2_SU_Y_COORDINATE_REQUIRED   (1 << 4)  /* eDP 1.4a */
+# define DP_PSR2_SU_GRANULARITY_REQUIRED    (1 << 5)  /* eDP 1.4b */
+/*
+ * 0x80-0x8f describe downstream port capabilities, but there are two layouts
+ * based on whether DP_DETAILED_CAP_INFO_AVAILABLE was set.  If it was not,
+ * each port's descriptor is one byte wide.  If it was set, each port's is
+ * four bytes wide, starting with the one byte from the base info.  As of
+ * DP interop v1.1a only VGA defines additional detail.
+ */
+
+/* offset 0 */
+#define DP_DOWNSTREAM_PORT_0		    0x80
+# define DP_DS_PORT_TYPE_MASK		    (7 << 0)
+# define DP_DS_PORT_TYPE_DP		    0
+# define DP_DS_PORT_TYPE_VGA		    1
+# define DP_DS_PORT_TYPE_DVI		    2
+# define DP_DS_PORT_TYPE_HDMI		    3
+# define DP_DS_PORT_TYPE_NON_EDID	    4
+# define DP_DS_PORT_TYPE_DP_DUALMODE        5
+# define DP_DS_PORT_TYPE_WIRELESS           6
+# define DP_DS_PORT_HPD			    (1 << 3)
+/* offset 1 for VGA is maximum megapixels per second / 8 */
+/* offset 2 */
+# define DP_DS_MAX_BPC_MASK	            (3 << 0)
+# define DP_DS_8BPC		            0
+# define DP_DS_10BPC		            1
+# define DP_DS_12BPC		            2
+# define DP_DS_16BPC		            3
+
+/* DP Forward error Correction Registers */
+#define DP_FEC_CAPABILITY		    0x090    /* 1.4 */
+# define DP_FEC_CAPABLE			    (1 << 0)
+# define DP_FEC_UNCORR_BLK_ERROR_COUNT_CAP  (1 << 1)
+# define DP_FEC_CORR_BLK_ERROR_COUNT_CAP    (1 << 2)
+# define DP_FEC_BIT_ERROR_COUNT_CAP	    (1 << 3)
+
+/* link configuration */
+#define	DP_LINK_BW_SET		            0x100
+# define DP_LINK_RATE_TABLE		    0x00    /* eDP 1.4 */
+# define DP_LINK_BW_1_62		    0x06
+# define DP_LINK_BW_2_7			    0x0a
+# define DP_LINK_BW_5_4			    0x14    /* 1.2 */
+# define DP_LINK_BW_8_1			    0x1e    /* 1.4 */
+
+#define DP_LANE_COUNT_SET	            0x101
+# define DP_LANE_COUNT_MASK		    0x0f
+# define DP_LANE_COUNT_ENHANCED_FRAME_EN    (1 << 7)
+
+#define DP_TRAINING_PATTERN_SET	            0x102
+# define DP_TRAINING_PATTERN_DISABLE	    0
+# define DP_TRAINING_PATTERN_1		    1
+# define DP_TRAINING_PATTERN_2		    2
+# define DP_TRAINING_PATTERN_3		    3	    /* 1.2 */
+# define DP_TRAINING_PATTERN_4              7       /* 1.4 */
+# define DP_TRAINING_PATTERN_MASK	    0x3
+# define DP_TRAINING_PATTERN_MASK_1_4	    0xf
+
+/* DPCD 1.1 only. For DPCD >= 1.2 see per-lane DP_LINK_QUAL_LANEn_SET */
+# define DP_LINK_QUAL_PATTERN_11_DISABLE    (0 << 2)
+# define DP_LINK_QUAL_PATTERN_11_D10_2	    (1 << 2)
+# define DP_LINK_QUAL_PATTERN_11_ERROR_RATE (2 << 2)
+# define DP_LINK_QUAL_PATTERN_11_PRBS7	    (3 << 2)
+# define DP_LINK_QUAL_PATTERN_11_MASK	    (3 << 2)
+
+# define DP_RECOVERED_CLOCK_OUT_EN	    (1 << 4)
+# define DP_LINK_SCRAMBLING_DISABLE	    (1 << 5)
+
+# define DP_SYMBOL_ERROR_COUNT_BOTH	    (0 << 6)
+# define DP_SYMBOL_ERROR_COUNT_DISPARITY    (1 << 6)
+# define DP_SYMBOL_ERROR_COUNT_SYMBOL	    (2 << 6)
+# define DP_SYMBOL_ERROR_COUNT_MASK	    (3 << 6)
+
+#define DP_TRAINING_LANE0_SET		    0x103
+#define DP_TRAINING_LANE1_SET		    0x104
+#define DP_TRAINING_LANE2_SET		    0x105
+#define DP_TRAINING_LANE3_SET		    0x106
+
+# define DP_TRAIN_VOLTAGE_SWING_MASK	    0x3
+# define DP_TRAIN_VOLTAGE_SWING_SHIFT	    0
+# define DP_TRAIN_MAX_SWING_REACHED	    (1 << 2)
+# define DP_TRAIN_VOLTAGE_SWING_LEVEL_0 (0 << 0)
+# define DP_TRAIN_VOLTAGE_SWING_LEVEL_1 (1 << 0)
+# define DP_TRAIN_VOLTAGE_SWING_LEVEL_2 (2 << 0)
+# define DP_TRAIN_VOLTAGE_SWING_LEVEL_3 (3 << 0)
+
+# define DP_TRAIN_PRE_EMPHASIS_MASK	    (3 << 3)
+# define DP_TRAIN_PRE_EMPH_LEVEL_0		(0 << 3)
+# define DP_TRAIN_PRE_EMPH_LEVEL_1		(1 << 3)
+# define DP_TRAIN_PRE_EMPH_LEVEL_2		(2 << 3)
+# define DP_TRAIN_PRE_EMPH_LEVEL_3		(3 << 3)
+
+# define DP_TRAIN_PRE_EMPHASIS_SHIFT	    3
+# define DP_TRAIN_MAX_PRE_EMPHASIS_REACHED  (1 << 5)
+
+#define DP_DOWNSPREAD_CTRL		    0x107
+# define DP_SPREAD_AMP_0_5		    (1 << 4)
+# define DP_MSA_TIMING_PAR_IGNORE_EN	    (1 << 7) /* eDP */
+
+#define DP_MAIN_LINK_CHANNEL_CODING_SET	    0x108
+# define DP_SET_ANSI_8B10B		    (1 << 0)
+
+#define DP_I2C_SPEED_CONTROL_STATUS	    0x109   /* DPI */
+/* bitmask as for DP_I2C_SPEED_CAP */
+
+#define DP_EDP_CONFIGURATION_SET            0x10a   /* XXX 1.2? */
+# define DP_ALTERNATE_SCRAMBLER_RESET_ENABLE (1 << 0)
+# define DP_FRAMING_CHANGE_ENABLE	    (1 << 1)
+# define DP_PANEL_SELF_TEST_ENABLE	    (1 << 7)
+
+#define DP_LINK_QUAL_LANE0_SET		    0x10b   /* DPCD >= 1.2 */
+#define DP_LINK_QUAL_LANE1_SET		    0x10c
+#define DP_LINK_QUAL_LANE2_SET		    0x10d
+#define DP_LINK_QUAL_LANE3_SET		    0x10e
+# define DP_LINK_QUAL_PATTERN_DISABLE	    0
+# define DP_LINK_QUAL_PATTERN_D10_2	    1
+# define DP_LINK_QUAL_PATTERN_ERROR_RATE    2
+# define DP_LINK_QUAL_PATTERN_PRBS7	    3
+# define DP_LINK_QUAL_PATTERN_80BIT_CUSTOM  4
+# define DP_LINK_QUAL_PATTERN_HBR2_EYE      5
+# define DP_LINK_QUAL_PATTERN_MASK	    7
+
+#define DP_TRAINING_LANE0_1_SET2	    0x10f
+#define DP_TRAINING_LANE2_3_SET2	    0x110
+# define DP_LANE02_POST_CURSOR2_SET_MASK    (3 << 0)
+# define DP_LANE02_MAX_POST_CURSOR2_REACHED (1 << 2)
+# define DP_LANE13_POST_CURSOR2_SET_MASK    (3 << 4)
+# define DP_LANE13_MAX_POST_CURSOR2_REACHED (1 << 6)
+
+#define DP_MSTM_CTRL			    0x111   /* 1.2 */
+# define DP_MST_EN			    (1 << 0)
+# define DP_UP_REQ_EN			    (1 << 1)
+# define DP_UPSTREAM_IS_SRC		    (1 << 2)
+
+#define DP_AUDIO_DELAY0			    0x112   /* 1.2 */
+#define DP_AUDIO_DELAY1			    0x113
+#define DP_AUDIO_DELAY2			    0x114
+
+#define DP_LINK_RATE_SET		    0x115   /* eDP 1.4 */
+# define DP_LINK_RATE_SET_SHIFT		    0
+# define DP_LINK_RATE_SET_MASK		    (7 << 0)
+
+#define DP_RECEIVER_ALPM_CONFIG		    0x116   /* eDP 1.4 */
+# define DP_ALPM_ENABLE			    (1 << 0)
+# define DP_ALPM_LOCK_ERROR_IRQ_HPD_ENABLE  (1 << 1)
+
+#define DP_SINK_DEVICE_AUX_FRAME_SYNC_CONF  0x117   /* eDP 1.4 */
+# define DP_AUX_FRAME_SYNC_ENABLE	    (1 << 0)
+# define DP_IRQ_HPD_ENABLE		    (1 << 1)
+
+#define DP_UPSTREAM_DEVICE_DP_PWR_NEED	    0x118   /* 1.2 */
+# define DP_PWR_NOT_NEEDED		    (1 << 0)
+
+#define DP_FEC_CONFIGURATION		    0x120    /* 1.4 */
+# define DP_FEC_READY			    (1 << 0)
+# define DP_FEC_ERR_COUNT_SEL_MASK	    (7 << 1)
+# define DP_FEC_ERR_COUNT_DIS		    (0 << 1)
+# define DP_FEC_UNCORR_BLK_ERROR_COUNT	    (1 << 1)
+# define DP_FEC_CORR_BLK_ERROR_COUNT	    (2 << 1)
+# define DP_FEC_BIT_ERROR_COUNT		    (3 << 1)
+# define DP_FEC_LANE_SELECT_MASK	    (3 << 4)
+# define DP_FEC_LANE_0_SELECT		    (0 << 4)
+# define DP_FEC_LANE_1_SELECT		    (1 << 4)
+# define DP_FEC_LANE_2_SELECT		    (2 << 4)
+# define DP_FEC_LANE_3_SELECT		    (3 << 4)
+
+#define DP_AUX_FRAME_SYNC_VALUE		    0x15c   /* eDP 1.4 */
+# define DP_AUX_FRAME_SYNC_VALID	    (1 << 0)
+
+#define DP_DSC_ENABLE                       0x160   /* DP 1.4 */
+
+#define DP_PSR_EN_CFG			    0x170   /* XXX 1.2? */
+# define DP_PSR_ENABLE			    (1 << 0)
+# define DP_PSR_MAIN_LINK_ACTIVE	    (1 << 1)
+# define DP_PSR_CRC_VERIFICATION	    (1 << 2)
+# define DP_PSR_FRAME_CAPTURE		    (1 << 3)
+# define DP_PSR_SELECTIVE_UPDATE	    (1 << 4)
+# define DP_PSR_IRQ_HPD_WITH_CRC_ERRORS     (1 << 5)
+# define DP_PSR_ENABLE_PSR2		    (1 << 6) /* eDP 1.4a */
+
+#define DP_ADAPTER_CTRL			    0x1a0
+# define DP_ADAPTER_CTRL_FORCE_LOAD_SENSE   (1 << 0)
+
+#define DP_BRANCH_DEVICE_CTRL		    0x1a1
+# define DP_BRANCH_DEVICE_IRQ_HPD	    (1 << 0)
+
+#define DP_PAYLOAD_ALLOCATE_SET		    0x1c0
+#define DP_PAYLOAD_ALLOCATE_START_TIME_SLOT 0x1c1
+#define DP_PAYLOAD_ALLOCATE_TIME_SLOT_COUNT 0x1c2
+
+#define DP_SINK_COUNT			    0x200
+/* prior to 1.2 bit 7 was reserved mbz */
+# define DP_GET_SINK_COUNT(x)		    ((((x) & 0x80) >> 1) | ((x) & 0x3f))
+# define DP_SINK_CP_READY		    (1 << 6)
+
+#define DP_DEVICE_SERVICE_IRQ_VECTOR	    0x201
+# define DP_REMOTE_CONTROL_COMMAND_PENDING  (1 << 0)
+# define DP_AUTOMATED_TEST_REQUEST	    (1 << 1)
+# define DP_CP_IRQ			    (1 << 2)
+# define DP_MCCS_IRQ			    (1 << 3)
+# define DP_DOWN_REP_MSG_RDY		    (1 << 4) /* 1.2 MST */
+# define DP_UP_REQ_MSG_RDY		    (1 << 5) /* 1.2 MST */
+# define DP_SINK_SPECIFIC_IRQ		    (1 << 6)
+
+#define DP_LANE0_1_STATUS		    0x202
+#define DP_LANE2_3_STATUS		    0x203
+# define DP_LANE_CR_DONE		    (1 << 0)
+# define DP_LANE_CHANNEL_EQ_DONE	    (1 << 1)
+# define DP_LANE_SYMBOL_LOCKED		    (1 << 2)
+
+#define DP_CHANNEL_EQ_BITS (DP_LANE_CR_DONE |		\
+			    DP_LANE_CHANNEL_EQ_DONE |	\
+			    DP_LANE_SYMBOL_LOCKED)
+
+#define DP_LANE_ALIGN_STATUS_UPDATED	    0x204
+
+#define DP_INTERLANE_ALIGN_DONE		    (1 << 0)
+#define DP_DOWNSTREAM_PORT_STATUS_CHANGED   (1 << 6)
+#define DP_LINK_STATUS_UPDATED		    (1 << 7)
+
+#define DP_SINK_STATUS			    0x205
+
+#define DP_RECEIVE_PORT_0_STATUS	    (1 << 0)
+#define DP_RECEIVE_PORT_1_STATUS	    (1 << 1)
+
+#define DP_ADJUST_REQUEST_LANE0_1	    0x206
+#define DP_ADJUST_REQUEST_LANE2_3	    0x207
+# define DP_ADJUST_VOLTAGE_SWING_LANE0_MASK  0x03
+# define DP_ADJUST_VOLTAGE_SWING_LANE0_SHIFT 0
+# define DP_ADJUST_PRE_EMPHASIS_LANE0_MASK   0x0c
+# define DP_ADJUST_PRE_EMPHASIS_LANE0_SHIFT  2
+# define DP_ADJUST_VOLTAGE_SWING_LANE1_MASK  0x30
+# define DP_ADJUST_VOLTAGE_SWING_LANE1_SHIFT 4
+# define DP_ADJUST_PRE_EMPHASIS_LANE1_MASK   0xc0
+# define DP_ADJUST_PRE_EMPHASIS_LANE1_SHIFT  6
+
+#define DP_ADJUST_REQUEST_POST_CURSOR2      0x20c
+
+#define DP_TEST_REQUEST			    0x218
+# define DP_TEST_LINK_TRAINING		    (1 << 0)
+# define DP_TEST_LINK_VIDEO_PATTERN	    (1 << 1)
+# define DP_TEST_LINK_EDID_READ		    (1 << 2)
+# define DP_TEST_LINK_PHY_TEST_PATTERN	    (1 << 3) /* DPCD >= 1.1 */
+# define DP_TEST_LINK_FAUX_PATTERN	    (1 << 4) /* DPCD >= 1.2 */
+
+#define DP_TEST_LINK_RATE		    0x219
+# define DP_LINK_RATE_162		    (0x6)
+# define DP_LINK_RATE_27		    (0xa)
+
+#define DP_TEST_LANE_COUNT		    0x220
+
+#define DP_TEST_PATTERN			    0x221
+# define DP_NO_TEST_PATTERN                 0x0
+# define DP_COLOR_RAMP                      0x1
+# define DP_BLACK_AND_WHITE_VERTICAL_LINES  0x2
+# define DP_COLOR_SQUARE                    0x3
+
+#define DP_TEST_H_TOTAL_HI                  0x222
+#define DP_TEST_H_TOTAL_LO                  0x223
+
+#define DP_TEST_V_TOTAL_HI                  0x224
+#define DP_TEST_V_TOTAL_LO                  0x225
+
+#define DP_TEST_H_START_HI                  0x226
+#define DP_TEST_H_START_LO                  0x227
+
+#define DP_TEST_V_START_HI                  0x228
+#define DP_TEST_V_START_LO                  0x229
+
+#define DP_TEST_HSYNC_HI                    0x22A
+# define DP_TEST_HSYNC_POLARITY             (1 << 7)
+# define DP_TEST_HSYNC_WIDTH_HI_MASK        (127 << 0)
+#define DP_TEST_HSYNC_WIDTH_LO              0x22B
+
+#define DP_TEST_VSYNC_HI                    0x22C
+# define DP_TEST_VSYNC_POLARITY             (1 << 7)
+# define DP_TEST_VSYNC_WIDTH_HI_MASK        (127 << 0)
+#define DP_TEST_VSYNC_WIDTH_LO              0x22D
+
+#define DP_TEST_H_WIDTH_HI                  0x22E
+#define DP_TEST_H_WIDTH_LO                  0x22F
+
+#define DP_TEST_V_HEIGHT_HI                 0x230
+#define DP_TEST_V_HEIGHT_LO                 0x231
+
+#define DP_TEST_MISC0                       0x232
+# define DP_TEST_SYNC_CLOCK                 (1 << 0)
+# define DP_TEST_COLOR_FORMAT_MASK          (3 << 1)
+# define DP_TEST_COLOR_FORMAT_SHIFT         1
+# define DP_COLOR_FORMAT_RGB                (0 << 1)
+# define DP_COLOR_FORMAT_YCbCr422           (1 << 1)
+# define DP_COLOR_FORMAT_YCbCr444           (2 << 1)
+# define DP_TEST_DYNAMIC_RANGE_CEA          (1 << 3)
+# define DP_TEST_YCBCR_COEFFICIENTS         (1 << 4)
+# define DP_YCBCR_COEFFICIENTS_ITU601       (0 << 4)
+# define DP_YCBCR_COEFFICIENTS_ITU709       (1 << 4)
+# define DP_TEST_BIT_DEPTH_MASK             (7 << 5)
+# define DP_TEST_BIT_DEPTH_SHIFT            5
+# define DP_TEST_BIT_DEPTH_6                (0 << 5)
+# define DP_TEST_BIT_DEPTH_8                (1 << 5)
+# define DP_TEST_BIT_DEPTH_10               (2 << 5)
+# define DP_TEST_BIT_DEPTH_12               (3 << 5)
+# define DP_TEST_BIT_DEPTH_16               (4 << 5)
+
+#define DP_TEST_MISC1                       0x233
+# define DP_TEST_REFRESH_DENOMINATOR        (1 << 0)
+# define DP_TEST_INTERLACED                 (1 << 1)
+
+#define DP_TEST_REFRESH_RATE_NUMERATOR      0x234
+
+#define DP_TEST_MISC0                       0x232
+
+#define DP_TEST_CRC_R_CR		    0x240
+#define DP_TEST_CRC_G_Y			    0x242
+#define DP_TEST_CRC_B_CB		    0x244
+
+#define DP_TEST_SINK_MISC		    0x246
+# define DP_TEST_CRC_SUPPORTED		    (1 << 5)
+# define DP_TEST_COUNT_MASK		    0xf
+
+#define DP_TEST_PHY_PATTERN                 0x248
+# define DP_TEST_PHY_PATTERN_NONE			0x0
+# define DP_TEST_PHY_PATTERN_D10_2_NO_SCRAMBLING	0x1
+# define DP_TEST_PHY_PATTERN_SYMBOL_ERR_MEASUREMENT_CNT 0x2
+# define DP_TEST_PHY_PATTERN_PRBS7			0x3
+# define DP_TEST_PHY_PATTERN_80_BIT_CUSTOM_PATTERN	0x4
+# define DP_TEST_PHY_PATTERN_CP2520_PATTERN_1		0x5
+# define DP_TEST_PHY_PATTERN_CP2520_PATTERN_2		0x6
+# define DP_TEST_PHY_PATTERN_CP2520_PATTERN_3		0x7
+#define DP_TEST_80BIT_CUSTOM_PATTERN_7_0    0x250
+#define	DP_TEST_80BIT_CUSTOM_PATTERN_15_8   0x251
+#define	DP_TEST_80BIT_CUSTOM_PATTERN_23_16  0x252
+#define	DP_TEST_80BIT_CUSTOM_PATTERN_31_24  0x253
+#define	DP_TEST_80BIT_CUSTOM_PATTERN_39_32  0x254
+#define	DP_TEST_80BIT_CUSTOM_PATTERN_47_40  0x255
+#define	DP_TEST_80BIT_CUSTOM_PATTERN_55_48  0x256
+#define	DP_TEST_80BIT_CUSTOM_PATTERN_63_56  0x257
+#define	DP_TEST_80BIT_CUSTOM_PATTERN_71_64  0x258
+#define	DP_TEST_80BIT_CUSTOM_PATTERN_79_72  0x259
+
+#define DP_TEST_RESPONSE		    0x260
+# define DP_TEST_ACK			    (1 << 0)
+# define DP_TEST_NAK			    (1 << 1)
+# define DP_TEST_EDID_CHECKSUM_WRITE	    (1 << 2)
+
+#define DP_TEST_EDID_CHECKSUM		    0x261
+
+#define DP_TEST_SINK			    0x270
+# define DP_TEST_SINK_START		    (1 << 0)
+
+#define DP_FEC_STATUS			    0x280    /* 1.4 */
+# define DP_FEC_DECODE_EN_DETECTED	    (1 << 0)
+# define DP_FEC_DECODE_DIS_DETECTED	    (1 << 1)
+
+#define DP_FEC_ERROR_COUNT_LSB		    0x0281    /* 1.4 */
+
+#define DP_FEC_ERROR_COUNT_MSB		    0x0282    /* 1.4 */
+# define DP_FEC_ERROR_COUNT_MASK	    0x7F
+# define DP_FEC_ERR_COUNT_VALID		    (1 << 7)
+
+#define DP_PAYLOAD_TABLE_UPDATE_STATUS      0x2c0   /* 1.2 MST */
+# define DP_PAYLOAD_TABLE_UPDATED           (1 << 0)
+# define DP_PAYLOAD_ACT_HANDLED             (1 << 1)
+
+#define DP_VC_PAYLOAD_ID_SLOT_1             0x2c1   /* 1.2 MST */
+/* up to ID_SLOT_63 at 0x2ff */
+
+#define DP_SOURCE_OUI			    0x300
+#define DP_SINK_OUI			    0x400
+#define DP_BRANCH_OUI			    0x500
+#define DP_BRANCH_ID                        0x503
+#define DP_BRANCH_REVISION_START            0x509
+#define DP_BRANCH_HW_REV                    0x509
+#define DP_BRANCH_SW_REV                    0x50A
+
+#define DP_SET_POWER                        0x600
+# define DP_SET_POWER_D0                    0x1
+# define DP_SET_POWER_D3                    0x2
+# define DP_SET_POWER_MASK                  0x3
+# define DP_SET_POWER_D3_AUX_ON             0x5
+
+#define DP_EDP_DPCD_REV			    0x700    /* eDP 1.2 */
+# define DP_EDP_11			    0x00
+# define DP_EDP_12			    0x01
+# define DP_EDP_13			    0x02
+# define DP_EDP_14			    0x03
+
+#define DP_EDP_GENERAL_CAP_1		    0x701
+# define DP_EDP_TCON_BACKLIGHT_ADJUSTMENT_CAP		(1 << 0)
+# define DP_EDP_BACKLIGHT_PIN_ENABLE_CAP		(1 << 1)
+# define DP_EDP_BACKLIGHT_AUX_ENABLE_CAP		(1 << 2)
+# define DP_EDP_PANEL_SELF_TEST_PIN_ENABLE_CAP		(1 << 3)
+# define DP_EDP_PANEL_SELF_TEST_AUX_ENABLE_CAP		(1 << 4)
+# define DP_EDP_FRC_ENABLE_CAP				(1 << 5)
+# define DP_EDP_COLOR_ENGINE_CAP			(1 << 6)
+# define DP_EDP_SET_POWER_CAP				(1 << 7)
+
+#define DP_EDP_BACKLIGHT_ADJUSTMENT_CAP     0x702
+# define DP_EDP_BACKLIGHT_BRIGHTNESS_PWM_PIN_CAP	(1 << 0)
+# define DP_EDP_BACKLIGHT_BRIGHTNESS_AUX_SET_CAP	(1 << 1)
+# define DP_EDP_BACKLIGHT_BRIGHTNESS_BYTE_COUNT		(1 << 2)
+# define DP_EDP_BACKLIGHT_AUX_PWM_PRODUCT_CAP		(1 << 3)
+# define DP_EDP_BACKLIGHT_FREQ_PWM_PIN_PASSTHRU_CAP	(1 << 4)
+# define DP_EDP_BACKLIGHT_FREQ_AUX_SET_CAP		(1 << 5)
+# define DP_EDP_DYNAMIC_BACKLIGHT_CAP			(1 << 6)
+# define DP_EDP_VBLANK_BACKLIGHT_UPDATE_CAP		(1 << 7)
+
+#define DP_EDP_GENERAL_CAP_2		    0x703
+# define DP_EDP_OVERDRIVE_ENGINE_ENABLED		(1 << 0)
+
+#define DP_EDP_GENERAL_CAP_3		    0x704    /* eDP 1.4 */
+# define DP_EDP_X_REGION_CAP_MASK			(0xf << 0)
+# define DP_EDP_X_REGION_CAP_SHIFT			0
+# define DP_EDP_Y_REGION_CAP_MASK			(0xf << 4)
+# define DP_EDP_Y_REGION_CAP_SHIFT			4
+
+#define DP_EDP_DISPLAY_CONTROL_REGISTER     0x720
+# define DP_EDP_BACKLIGHT_ENABLE			(1 << 0)
+# define DP_EDP_BLACK_VIDEO_ENABLE			(1 << 1)
+# define DP_EDP_FRC_ENABLE				(1 << 2)
+# define DP_EDP_COLOR_ENGINE_ENABLE			(1 << 3)
+# define DP_EDP_VBLANK_BACKLIGHT_UPDATE_ENABLE		(1 << 7)
+
+#define DP_EDP_BACKLIGHT_MODE_SET_REGISTER  0x721
+# define DP_EDP_BACKLIGHT_CONTROL_MODE_MASK		(3 << 0)
+# define DP_EDP_BACKLIGHT_CONTROL_MODE_PWM		(0 << 0)
+# define DP_EDP_BACKLIGHT_CONTROL_MODE_PRESET		(1 << 0)
+# define DP_EDP_BACKLIGHT_CONTROL_MODE_DPCD		(2 << 0)
+# define DP_EDP_BACKLIGHT_CONTROL_MODE_PRODUCT		(3 << 0)
+# define DP_EDP_BACKLIGHT_FREQ_PWM_PIN_PASSTHRU_ENABLE	(1 << 2)
+# define DP_EDP_BACKLIGHT_FREQ_AUX_SET_ENABLE		(1 << 3)
+# define DP_EDP_DYNAMIC_BACKLIGHT_ENABLE		(1 << 4)
+# define DP_EDP_REGIONAL_BACKLIGHT_ENABLE		(1 << 5)
+# define DP_EDP_UPDATE_REGION_BRIGHTNESS		(1 << 6) /* eDP 1.4 */
+
+#define DP_EDP_BACKLIGHT_BRIGHTNESS_MSB     0x722
+#define DP_EDP_BACKLIGHT_BRIGHTNESS_LSB     0x723
+
+#define DP_EDP_PWMGEN_BIT_COUNT             0x724
+#define DP_EDP_PWMGEN_BIT_COUNT_CAP_MIN     0x725
+#define DP_EDP_PWMGEN_BIT_COUNT_CAP_MAX     0x726
+# define DP_EDP_PWMGEN_BIT_COUNT_MASK       (0x1f << 0)
+
+#define DP_EDP_BACKLIGHT_CONTROL_STATUS     0x727
+
+#define DP_EDP_BACKLIGHT_FREQ_SET           0x728
+# define DP_EDP_BACKLIGHT_FREQ_BASE_KHZ     27000
+
+#define DP_EDP_BACKLIGHT_FREQ_CAP_MIN_MSB   0x72a
+#define DP_EDP_BACKLIGHT_FREQ_CAP_MIN_MID   0x72b
+#define DP_EDP_BACKLIGHT_FREQ_CAP_MIN_LSB   0x72c
+
+#define DP_EDP_BACKLIGHT_FREQ_CAP_MAX_MSB   0x72d
+#define DP_EDP_BACKLIGHT_FREQ_CAP_MAX_MID   0x72e
+#define DP_EDP_BACKLIGHT_FREQ_CAP_MAX_LSB   0x72f
+
+#define DP_EDP_DBC_MINIMUM_BRIGHTNESS_SET   0x732
+#define DP_EDP_DBC_MAXIMUM_BRIGHTNESS_SET   0x733
+
+#define DP_EDP_REGIONAL_BACKLIGHT_BASE      0x740    /* eDP 1.4 */
+#define DP_EDP_REGIONAL_BACKLIGHT_0	    0x741    /* eDP 1.4 */
+
+#define DP_SIDEBAND_MSG_DOWN_REQ_BASE	    0x1000   /* 1.2 MST */
+#define DP_SIDEBAND_MSG_UP_REP_BASE	    0x1200   /* 1.2 MST */
+#define DP_SIDEBAND_MSG_DOWN_REP_BASE	    0x1400   /* 1.2 MST */
+#define DP_SIDEBAND_MSG_UP_REQ_BASE	    0x1600   /* 1.2 MST */
+
+#define DP_SINK_COUNT_ESI		    0x2002   /* 1.2 */
+/* 0-5 sink count */
+# define DP_SINK_COUNT_CP_READY             (1 << 6)
+
+#define DP_DEVICE_SERVICE_IRQ_VECTOR_ESI0   0x2003   /* 1.2 */
+
+#define DP_DEVICE_SERVICE_IRQ_VECTOR_ESI1   0x2004   /* 1.2 */
+# define DP_RX_GTC_MSTR_REQ_STATUS_CHANGE    (1 << 0)
+# define DP_LOCK_ACQUISITION_REQUEST         (1 << 1)
+# define DP_CEC_IRQ                          (1 << 2)
+
+#define DP_LINK_SERVICE_IRQ_VECTOR_ESI0     0x2005   /* 1.2 */
+
+#define DP_PSR_ERROR_STATUS                 0x2006  /* XXX 1.2? */
+# define DP_PSR_LINK_CRC_ERROR              (1 << 0)
+# define DP_PSR_RFB_STORAGE_ERROR           (1 << 1)
+# define DP_PSR_VSC_SDP_UNCORRECTABLE_ERROR (1 << 2) /* eDP 1.4 */
+
+#define DP_PSR_ESI                          0x2007  /* XXX 1.2? */
+# define DP_PSR_CAPS_CHANGE                 (1 << 0)
+
+#define DP_PSR_STATUS                       0x2008  /* XXX 1.2? */
+# define DP_PSR_SINK_INACTIVE               0
+# define DP_PSR_SINK_ACTIVE_SRC_SYNCED      1
+# define DP_PSR_SINK_ACTIVE_RFB             2
+# define DP_PSR_SINK_ACTIVE_SINK_SYNCED     3
+# define DP_PSR_SINK_ACTIVE_RESYNC          4
+# define DP_PSR_SINK_INTERNAL_ERROR         7
+# define DP_PSR_SINK_STATE_MASK             0x07
+
+#define DP_SYNCHRONIZATION_LATENCY_IN_SINK		0x2009 /* edp 1.4 */
+# define DP_MAX_RESYNC_FRAME_COUNT_MASK			(0xf << 0)
+# define DP_MAX_RESYNC_FRAME_COUNT_SHIFT		0
+# define DP_LAST_ACTUAL_SYNCHRONIZATION_LATENCY_MASK	(0xf << 4)
+# define DP_LAST_ACTUAL_SYNCHRONIZATION_LATENCY_SHIFT	4
+
+#define DP_LAST_RECEIVED_PSR_SDP	    0x200a /* eDP 1.2 */
+# define DP_PSR_STATE_BIT		    (1 << 0) /* eDP 1.2 */
+# define DP_UPDATE_RFB_BIT		    (1 << 1) /* eDP 1.2 */
+# define DP_CRC_VALID_BIT		    (1 << 2) /* eDP 1.2 */
+# define DP_SU_VALID			    (1 << 3) /* eDP 1.4 */
+# define DP_FIRST_SCAN_LINE_SU_REGION	    (1 << 4) /* eDP 1.4 */
+# define DP_LAST_SCAN_LINE_SU_REGION	    (1 << 5) /* eDP 1.4 */
+# define DP_Y_COORDINATE_VALID		    (1 << 6) /* eDP 1.4a */
+
+#define DP_RECEIVER_ALPM_STATUS		    0x200b  /* eDP 1.4 */
+# define DP_ALPM_LOCK_TIMEOUT_ERROR	    (1 << 0)
+
+#define DP_LANE0_1_STATUS_ESI                  0x200c /* status same as 0x202 */
+#define DP_LANE2_3_STATUS_ESI                  0x200d /* status same as 0x203 */
+#define DP_LANE_ALIGN_STATUS_UPDATED_ESI       0x200e /* status same as 0x204 */
+#define DP_SINK_STATUS_ESI                     0x200f /* status same as 0x205 */
+
+#define DP_DP13_DPCD_REV                    0x2200
+#define DP_DP13_MAX_LINK_RATE               0x2201
+
+#define DP_DPRX_FEATURE_ENUMERATION_LIST    0x2210  /* DP 1.3 */
+# define DP_GTC_CAP					(1 << 0)  /* DP 1.3 */
+# define DP_SST_SPLIT_SDP_CAP				(1 << 1)  /* DP 1.4 */
+# define DP_AV_SYNC_CAP					(1 << 2)  /* DP 1.3 */
+# define DP_VSC_SDP_EXT_FOR_COLORIMETRY_SUPPORTED	(1 << 3)  /* DP 1.3 */
+# define DP_VSC_EXT_VESA_SDP_SUPPORTED			(1 << 4)  /* DP 1.4 */
+# define DP_VSC_EXT_VESA_SDP_CHAINING_SUPPORTED		(1 << 5)  /* DP 1.4 */
+# define DP_VSC_EXT_CEA_SDP_SUPPORTED			(1 << 6)  /* DP 1.4 */
+# define DP_VSC_EXT_CEA_SDP_CHAINING_SUPPORTED		(1 << 7)  /* DP 1.4 */
+
+/* HDMI CEC tunneling over AUX DP 1.3 section 5.3.3.3.1 DPCD 1.4+ */
+#define DP_CEC_TUNNELING_CAPABILITY            0x3000
+# define DP_CEC_TUNNELING_CAPABLE               (1 << 0)
+# define DP_CEC_SNOOPING_CAPABLE                (1 << 1)
+# define DP_CEC_MULTIPLE_LA_CAPABLE             (1 << 2)
+
+#define DP_CEC_TUNNELING_CONTROL               0x3001
+# define DP_CEC_TUNNELING_ENABLE                (1 << 0)
+# define DP_CEC_SNOOPING_ENABLE                 (1 << 1)
+
+#define DP_CEC_RX_MESSAGE_INFO                 0x3002
+# define DP_CEC_RX_MESSAGE_LEN_MASK             (0xf << 0)
+# define DP_CEC_RX_MESSAGE_LEN_SHIFT            0
+# define DP_CEC_RX_MESSAGE_HPD_STATE            (1 << 4)
+# define DP_CEC_RX_MESSAGE_HPD_LOST             (1 << 5)
+# define DP_CEC_RX_MESSAGE_ACKED                (1 << 6)
+# define DP_CEC_RX_MESSAGE_ENDED                (1 << 7)
+
+#define DP_CEC_TX_MESSAGE_INFO                 0x3003
+# define DP_CEC_TX_MESSAGE_LEN_MASK             (0xf << 0)
+# define DP_CEC_TX_MESSAGE_LEN_SHIFT            0
+# define DP_CEC_TX_RETRY_COUNT_MASK             (0x7 << 4)
+# define DP_CEC_TX_RETRY_COUNT_SHIFT            4
+# define DP_CEC_TX_MESSAGE_SEND                 (1 << 7)
+
+#define DP_CEC_TUNNELING_IRQ_FLAGS             0x3004
+# define DP_CEC_RX_MESSAGE_INFO_VALID           (1 << 0)
+# define DP_CEC_RX_MESSAGE_OVERFLOW             (1 << 1)
+# define DP_CEC_TX_MESSAGE_SENT                 (1 << 4)
+# define DP_CEC_TX_LINE_ERROR                   (1 << 5)
+# define DP_CEC_TX_ADDRESS_NACK_ERROR           (1 << 6)
+# define DP_CEC_TX_DATA_NACK_ERROR              (1 << 7)
+
+#define DP_CEC_LOGICAL_ADDRESS_MASK            0x300E /* 0x300F word */
+# define DP_CEC_LOGICAL_ADDRESS_0               (1 << 0)
+# define DP_CEC_LOGICAL_ADDRESS_1               (1 << 1)
+# define DP_CEC_LOGICAL_ADDRESS_2               (1 << 2)
+# define DP_CEC_LOGICAL_ADDRESS_3               (1 << 3)
+# define DP_CEC_LOGICAL_ADDRESS_4               (1 << 4)
+# define DP_CEC_LOGICAL_ADDRESS_5               (1 << 5)
+# define DP_CEC_LOGICAL_ADDRESS_6               (1 << 6)
+# define DP_CEC_LOGICAL_ADDRESS_7               (1 << 7)
+#define DP_CEC_LOGICAL_ADDRESS_MASK_2          0x300F /* 0x300E word */
+# define DP_CEC_LOGICAL_ADDRESS_8               (1 << 0)
+# define DP_CEC_LOGICAL_ADDRESS_9               (1 << 1)
+# define DP_CEC_LOGICAL_ADDRESS_10              (1 << 2)
+# define DP_CEC_LOGICAL_ADDRESS_11              (1 << 3)
+# define DP_CEC_LOGICAL_ADDRESS_12              (1 << 4)
+# define DP_CEC_LOGICAL_ADDRESS_13              (1 << 5)
+# define DP_CEC_LOGICAL_ADDRESS_14              (1 << 6)
+# define DP_CEC_LOGICAL_ADDRESS_15              (1 << 7)
+
+#define DP_CEC_RX_MESSAGE_BUFFER               0x3010
+#define DP_CEC_TX_MESSAGE_BUFFER               0x3020
+#define DP_CEC_MESSAGE_BUFFER_LENGTH             0x10
+
+#define DP_AUX_HDCP_BKSV		0x68000
+#define DP_AUX_HDCP_RI_PRIME		0x68005
+#define DP_AUX_HDCP_AKSV		0x68007
+#define DP_AUX_HDCP_AN			0x6800C
+#define DP_AUX_HDCP_V_PRIME(h)		(0x68014 + (h) * 4)
+#define DP_AUX_HDCP_BCAPS		0x68028
+# define DP_BCAPS_REPEATER_PRESENT	BIT(1)
+# define DP_BCAPS_HDCP_CAPABLE		BIT(0)
+#define DP_AUX_HDCP_BSTATUS		0x68029
+# define DP_BSTATUS_REAUTH_REQ		BIT(3)
+# define DP_BSTATUS_LINK_FAILURE	BIT(2)
+# define DP_BSTATUS_R0_PRIME_READY	BIT(1)
+# define DP_BSTATUS_READY		BIT(0)
+#define DP_AUX_HDCP_BINFO		0x6802A
+#define DP_AUX_HDCP_KSV_FIFO		0x6802C
+#define DP_AUX_HDCP_AINFO		0x6803B
+
+/* DP 1.2 Sideband message defines */
+/* peer device type - DP 1.2a Table 2-92 */
+#define DP_PEER_DEVICE_NONE		0x0
+#define DP_PEER_DEVICE_SOURCE_OR_SST	0x1
+#define DP_PEER_DEVICE_MST_BRANCHING	0x2
+#define DP_PEER_DEVICE_SST_SINK		0x3
+#define DP_PEER_DEVICE_DP_LEGACY_CONV	0x4
+
+/* DP 1.2 MST sideband request names DP 1.2a Table 2-80 */
+#define DP_LINK_ADDRESS			0x01
+#define DP_CONNECTION_STATUS_NOTIFY	0x02
+#define DP_ENUM_PATH_RESOURCES		0x10
+#define DP_ALLOCATE_PAYLOAD		0x11
+#define DP_QUERY_PAYLOAD		0x12
+#define DP_RESOURCE_STATUS_NOTIFY	0x13
+#define DP_CLEAR_PAYLOAD_ID_TABLE	0x14
+#define DP_REMOTE_DPCD_READ		0x20
+#define DP_REMOTE_DPCD_WRITE		0x21
+#define DP_REMOTE_I2C_READ		0x22
+#define DP_REMOTE_I2C_WRITE		0x23
+#define DP_POWER_UP_PHY			0x24
+#define DP_POWER_DOWN_PHY		0x25
+#define DP_SINK_EVENT_NOTIFY		0x30
+#define DP_QUERY_STREAM_ENC_STATUS	0x38
+
+/* DP 1.2 MST sideband nak reasons - table 2.84 */
+#define DP_NAK_WRITE_FAILURE		0x01
+#define DP_NAK_INVALID_READ		0x02
+#define DP_NAK_CRC_FAILURE		0x03
+#define DP_NAK_BAD_PARAM		0x04
+#define DP_NAK_DEFER			0x05
+#define DP_NAK_LINK_FAILURE		0x06
+#define DP_NAK_NO_RESOURCES		0x07
+#define DP_NAK_DPCD_FAIL		0x08
+#define DP_NAK_I2C_NAK			0x09
+#define DP_NAK_ALLOCATE_FAIL		0x0a
+
+#define MODE_I2C_START	1
+#define MODE_I2C_WRITE	2
+#define MODE_I2C_READ	4
+#define MODE_I2C_STOP	8
+
+/* DP 1.2 MST PORTs - Section 2.5.1 v1.2a spec */
+#define DP_MST_PHYSICAL_PORT_0 0
+#define DP_MST_LOGICAL_PORT_0 8
+
+#define DP_LINK_STATUS_SIZE	   6
+bool drm_dp_channel_eq_ok(const u8 link_status[DP_LINK_STATUS_SIZE],
+			  int lane_count);
+bool drm_dp_clock_recovery_ok(const u8 link_status[DP_LINK_STATUS_SIZE],
+			      int lane_count);
+u8 drm_dp_get_adjust_request_voltage(const u8 link_status[DP_LINK_STATUS_SIZE],
+				     int lane);
+u8 drm_dp_get_adjust_request_pre_emphasis(const u8 link_status[DP_LINK_STATUS_SIZE],
+					  int lane);
+
+#define DP_BRANCH_OUI_HEADER_SIZE	0xc
+#define DP_RECEIVER_CAP_SIZE		0xf
+#define EDP_PSR_RECEIVER_CAP_SIZE	2
+#define EDP_DISPLAY_CTL_CAP_SIZE	3
+
+void drm_dp_link_train_clock_recovery_delay(const u8 dpcd[DP_RECEIVER_CAP_SIZE]);
+void drm_dp_link_train_channel_eq_delay(const u8 dpcd[DP_RECEIVER_CAP_SIZE]);
+
+u8 drm_dp_link_rate_to_bw_code(int link_rate);
+int drm_dp_bw_code_to_link_rate(u8 link_bw);
+
+#define DP_SDP_AUDIO_TIMESTAMP		0x01
+#define DP_SDP_AUDIO_STREAM		0x02
+#define DP_SDP_EXTENSION		0x04 /* DP 1.1 */
+#define DP_SDP_AUDIO_COPYMANAGEMENT	0x05 /* DP 1.2 */
+#define DP_SDP_ISRC			0x06 /* DP 1.2 */
+#define DP_SDP_VSC			0x07 /* DP 1.2 */
+#define DP_SDP_CAMERA_GENERIC(i)	(0x08 + (i)) /* 0-7, DP 1.3 */
+#define DP_SDP_PPS			0x10 /* DP 1.4 */
+#define DP_SDP_VSC_EXT_VESA		0x20 /* DP 1.4 */
+#define DP_SDP_VSC_EXT_CEA		0x21 /* DP 1.4 */
+/* 0x80+ CEA-861 infoframe types */
+
+struct dp_sdp_header {
+	u8 HB0; /* Secondary Data Packet ID */
+	u8 HB1; /* Secondary Data Packet Type */
+	u8 HB2; /* Secondary Data Packet Specific header, Byte 0 */
+	u8 HB3; /* Secondary Data packet Specific header, Byte 1 */
+} __packed;
+
+#define EDP_SDP_HEADER_REVISION_MASK		0x1F
+#define EDP_SDP_HEADER_VALID_PAYLOAD_BYTES	0x1F
+#define DP_SDP_PPS_HEADER_PAYLOAD_BYTES_MINUS_1 0x7F
+
+struct edp_vsc_psr {
+	struct dp_sdp_header sdp_header;
+	u8 DB0; /* Stereo Interface */
+	u8 DB1; /* 0 - PSR State; 1 - Update RFB; 2 - CRC Valid */
+	u8 DB2; /* CRC value bits 7:0 of the R or Cr component */
+	u8 DB3; /* CRC value bits 15:8 of the R or Cr component */
+	u8 DB4; /* CRC value bits 7:0 of the G or Y component */
+	u8 DB5; /* CRC value bits 15:8 of the G or Y component */
+	u8 DB6; /* CRC value bits 7:0 of the B or Cb component */
+	u8 DB7; /* CRC value bits 15:8 of the B or Cb component */
+	u8 DB8_31[24]; /* Reserved */
+} __packed;
+
+#define EDP_VSC_PSR_STATE_ACTIVE	(1 << 0)
+#define EDP_VSC_PSR_UPDATE_RFB		(1 << 1)
+#define EDP_VSC_PSR_CRC_VALUES_VALID	(1 << 2)
+
+enum dp_pixelformat {
+	DP_PIXELFORMAT_RGB = 0,
+	DP_PIXELFORMAT_YUV444 = 0x1,
+	DP_PIXELFORMAT_YUV422 = 0x2,
+	DP_PIXELFORMAT_YUV420 = 0x3,
+	DP_PIXELFORMAT_Y_ONLY = 0x4,
+	DP_PIXELFORMAT_RAW = 0x5,
+	DP_PIXELFORMAT_RESERVED = 0x6,
+};
+
+enum dp_colorimetry {
+	DP_COLORIMETRY_DEFAULT = 0,
+	DP_COLORIMETRY_RGB_WIDE_FIXED = 0x1,
+	DP_COLORIMETRY_BT709_YCC = 0x1,
+	DP_COLORIMETRY_RGB_WIDE_FLOAT = 0x2,
+	DP_COLORIMETRY_XVYCC_601 = 0x2,
+	DP_COLORIMETRY_OPRGB = 0x3,
+	DP_COLORIMETRY_XVYCC_709 = 0x3,
+	DP_COLORIMETRY_DCI_P3_RGB = 0x4,
+	DP_COLORIMETRY_SYCC_601 = 0x4,
+	DP_COLORIMETRY_RGB_CUSTOM = 0x5,
+	DP_COLORIMETRY_OPYCC_601 = 0x5,
+	DP_COLORIMETRY_BT2020_RGB = 0x6,
+	DP_COLORIMETRY_BT2020_CYCC = 0x6,
+	DP_COLORIMETRY_BT2020_YCC = 0x7,
+};
+
+enum dp_dynamic_range {
+	DP_DYNAMIC_RANGE_VESA = 0,
+	DP_DYNAMIC_RANGE_CTA = 1,
+};
+
+enum dp_content_type {
+	DP_CONTENT_TYPE_NOT_DEFINED = 0x00,
+	DP_CONTENT_TYPE_GRAPHICS = 0x01,
+	DP_CONTENT_TYPE_PHOTO = 0x02,
+	DP_CONTENT_TYPE_VIDEO = 0x03,
+	DP_CONTENT_TYPE_GAME = 0x04,
+};
+
+struct drm_dp_vsc_sdp {
+	unsigned char sdp_type;
+	unsigned char revision;
+	unsigned char length;
+	enum dp_pixelformat pixelformat;
+	enum dp_colorimetry colorimetry;
+	int bpc;
+	enum dp_dynamic_range dynamic_range;
+	enum dp_content_type content_type;
+};
+
+static inline int
+drm_dp_max_link_rate(const u8 dpcd[DP_RECEIVER_CAP_SIZE])
+{
+	return drm_dp_bw_code_to_link_rate(dpcd[DP_MAX_LINK_RATE]);
+}
+
+static inline u8
+drm_dp_max_lane_count(const u8 dpcd[DP_RECEIVER_CAP_SIZE])
+{
+	return dpcd[DP_MAX_LANE_COUNT] & DP_MAX_LANE_COUNT_MASK;
+}
+
+static inline bool
+drm_dp_enhanced_frame_cap(const u8 dpcd[DP_RECEIVER_CAP_SIZE])
+{
+	return dpcd[DP_DPCD_REV] >= 0x11 &&
+		(dpcd[DP_MAX_LANE_COUNT] & DP_ENHANCED_FRAME_CAP);
+}
+
+static inline bool
+drm_dp_tps3_supported(const u8 dpcd[DP_RECEIVER_CAP_SIZE])
+{
+	return dpcd[DP_DPCD_REV] >= 0x12 &&
+		dpcd[DP_MAX_LANE_COUNT] & DP_TPS3_SUPPORTED;
+}
+
+static inline bool
+drm_dp_tps4_supported(const u8 dpcd[DP_RECEIVER_CAP_SIZE])
+{
+	return dpcd[DP_DPCD_REV] >= 0x14 &&
+		dpcd[DP_MAX_DOWNSPREAD] & DP_TPS4_SUPPORTED;
+}
+
+static inline u8
+drm_dp_training_pattern_mask(const u8 dpcd[DP_RECEIVER_CAP_SIZE])
+{
+	return (dpcd[DP_DPCD_REV] >= 0x14) ? DP_TRAINING_PATTERN_MASK_1_4 :
+		DP_TRAINING_PATTERN_MASK;
+}
+
+static inline bool
+drm_dp_is_branch(const u8 dpcd[DP_RECEIVER_CAP_SIZE])
+{
+	return dpcd[DP_DOWNSTREAMPORT_PRESENT] & DP_DWN_STRM_PORT_PRESENT;
+}
+
+static inline bool
+drm_dp_channel_coding_supported(const u8 dpcd[DP_RECEIVER_CAP_SIZE])
+{
+	return dpcd[DP_MAIN_LINK_CHANNEL_CODING] & DP_CAP_ANSI_8B10B;
+}
+
+struct drm_dp_aux_msg {
+	unsigned int address;
+	u8 request;
+	u8 reply;
+	void *buffer;
+	size_t size;
+};
+
+struct drm_dp_aux {
+	const char *name;
+	struct ddc_adapter ddc;
+	struct udevice *dev;
+	ssize_t (*transfer)(struct drm_dp_aux *aux,
+			    struct drm_dp_aux_msg *msg);
+	unsigned int i2c_nack_count;
+	unsigned int i2c_defer_count;
+};
+
+ssize_t drm_dp_dpcd_read(struct drm_dp_aux *aux, unsigned int offset,
+			 void *buffer, size_t size);
+ssize_t drm_dp_dpcd_write(struct drm_dp_aux *aux, unsigned int offset,
+			  void *buffer, size_t size);
+
+/**
+ * drm_dp_dpcd_readb() - read a single byte from the DPCD
+ * @aux: DisplayPort AUX channel
+ * @offset: address of the register to read
+ * @valuep: location where the value of the register will be stored
+ *
+ * Returns the number of bytes transferred (1) on success, or a negative
+ * error code on failure.
+ */
+static inline ssize_t drm_dp_dpcd_readb(struct drm_dp_aux *aux,
+					unsigned int offset, u8 *valuep)
+{
+	return drm_dp_dpcd_read(aux, offset, valuep, 1);
+}
+
+/**
+ * drm_dp_dpcd_writeb() - write a single byte to the DPCD
+ * @aux: DisplayPort AUX channel
+ * @offset: address of the register to write
+ * @value: value to write to the register
+ *
+ * Returns the number of bytes transferred (1) on success, or a negative
+ * error code on failure.
+ */
+static inline ssize_t drm_dp_dpcd_writeb(struct drm_dp_aux *aux,
+					 unsigned int offset, u8 value)
+{
+	return drm_dp_dpcd_write(aux, offset, &value, 1);
+}
+
+int drm_dp_read_dpcd_caps(struct drm_dp_aux *aux,
+			  u8 dpcd[DP_RECEIVER_CAP_SIZE]);
+
+int drm_dp_dpcd_read_link_status(struct drm_dp_aux *aux,
+				 u8 status[DP_LINK_STATUS_SIZE]);
+
+int drm_dp_i2c_xfer(struct ddc_adapter *adapter, struct i2c_msg *msgs,
+		    int num);
+#endif /* _DRM_DP_HELPER_H_ */
diff --git a/include/drm/drm_dsc.h b/include/drm/drm_dsc.h
new file mode 100644
index 0000000000..d6860fc9fc
--- /dev/null
+++ b/include/drm/drm_dsc.h
@@ -0,0 +1,610 @@
+/* SPDX-License-Identifier: MIT
+ * Copyright (C) 2018 Intel Corp.
+ *
+ * Authors:
+ * Manasi Navare <manasi.d.navare@intel.com>
+ */
+
+#ifndef DRM_DSC_H_
+#define DRM_DSC_H_
+
+#include <common.h>
+#include <drm/drm_dp_helper.h>
+
+/* VESA Display Stream Compression DSC 1.2 constants */
+#define DSC_NUM_BUF_RANGES			15
+#define DSC_MUX_WORD_SIZE_8_10_BPC		48
+#define DSC_MUX_WORD_SIZE_12_BPC		64
+#define DSC_RC_PIXELS_PER_GROUP			3
+#define DSC_SCALE_DECREMENT_INTERVAL_MAX	4095
+#define DSC_RANGE_BPG_OFFSET_MASK		0x3f
+
+/* DSC Rate Control Constants */
+#define DSC_RC_MODEL_SIZE_CONST		    8192
+#define DSC_RC_EDGE_FACTOR_CONST	    6
+#define DSC_RC_TGT_OFFSET_HI_CONST	    3
+#define DSC_RC_TGT_OFFSET_LO_CONST	    3
+
+/* DSC PPS constants and macros */
+#define DSC_PPS_VERSION_MAJOR_SHIFT		4
+#define DSC_PPS_BPC_SHIFT			4
+#define DSC_PPS_MSB_SHIFT			8
+#define DSC_PPS_LSB_MASK			(0xFF << 0)
+#define DSC_PPS_BPP_HIGH_MASK			(0x3 << 8)
+#define DSC_PPS_VBR_EN_SHIFT			2
+#define DSC_PPS_SIMPLE422_SHIFT			3
+#define DSC_PPS_CONVERT_RGB_SHIFT		4
+#define DSC_PPS_BLOCK_PRED_EN_SHIFT		5
+#define DSC_PPS_INIT_XMIT_DELAY_HIGH_MASK	(0x3 << 8)
+#define DSC_PPS_SCALE_DEC_INT_HIGH_MASK		(0xF << 8)
+#define DSC_PPS_RC_TGT_OFFSET_HI_SHIFT		4
+#define DSC_PPS_RC_RANGE_MINQP_SHIFT		11
+#define DSC_PPS_RC_RANGE_MAXQP_SHIFT		6
+#define DSC_PPS_NATIVE_420_SHIFT		1
+#define DSC_1_2_MAX_LINEBUF_DEPTH_BITS		16
+#define DSC_1_2_MAX_LINEBUF_DEPTH_VAL		0
+#define DSC_1_1_MAX_LINEBUF_DEPTH_BITS		13
+
+/**
+ * struct drm_dsc_rc_range_parameters - DSC Rate Control range parameters
+ *
+ * This defines different rate control parameters used by the DSC engine
+ * to compress the frame.
+ */
+struct drm_dsc_rc_range_parameters {
+	/**
+	 * @range_min_qp: Min Quantization Parameters allowed for this range
+	 */
+	u8 range_min_qp;
+	/**
+	 * @range_max_qp: Max Quantization Parameters allowed for this range
+	 */
+	u8 range_max_qp;
+	/**
+	 * @range_bpg_offset:
+	 * Bits/group offset to apply to target for this group
+	 */
+	u8 range_bpg_offset;
+};
+
+/**
+ * struct drm_dsc_config - Parameters required to configure DSC
+ *
+ * Driver populates this structure with all the parameters required
+ * to configure the display stream compression on the source.
+ */
+struct drm_dsc_config {
+	/**
+	 * @line_buf_depth:
+	 * Bits per component for previous reconstructed line buffer
+	 */
+	u8 line_buf_depth;
+	/**
+	 * @bits_per_component: Bits per component to code (8/10/12)
+	 */
+	u8 bits_per_component;
+	/**
+	 * @convert_rgb:
+	 * Flag to indicate if RGB - YCoCg conversion is needed
+	 * True if RGB input, False if YCoCg input
+	 */
+	bool convert_rgb;
+	/**
+	 * @slice_count: Number of slices per line used by the DSC encoder
+	 */
+	u8 slice_count;
+	/**
+	 *  @slice_width: Width of each slice in pixels
+	 */
+	u16 slice_width;
+	/**
+	 * @slice_height: Slice height in pixels
+	 */
+	u16 slice_height;
+	/**
+	 * @simple_422: True if simple 4_2_2 mode is enabled else False
+	 */
+	bool simple_422;
+	/**
+	 * @pic_width: Width of the input display frame in pixels
+	 */
+	u16 pic_width;
+	/**
+	 * @pic_height: Vertical height of the input display frame
+	 */
+	u16 pic_height;
+	/**
+	 * @rc_tgt_offset_high:
+	 * Offset to bits/group used by RC to determine QP adjustment
+	 */
+	u8 rc_tgt_offset_high;
+	/**
+	 * @rc_tgt_offset_low:
+	 * Offset to bits/group used by RC to determine QP adjustment
+	 */
+	u8 rc_tgt_offset_low;
+	/**
+	 * @bits_per_pixel:
+	 * Target bits per pixel with 4 fractional bits, bits_per_pixel << 4
+	 */
+	u16 bits_per_pixel;
+	/**
+	 * @rc_edge_factor:
+	 * Factor to determine if an edge is present based on the bits produced
+	 */
+	u8 rc_edge_factor;
+	/**
+	 * @rc_quant_incr_limit1:
+	 * Slow down incrementing once the range reaches this value
+	 */
+	u8 rc_quant_incr_limit1;
+	/**
+	 * @rc_quant_incr_limit0:
+	 * Slow down incrementing once the range reaches this value
+	 */
+	u8 rc_quant_incr_limit0;
+	/**
+	 * @initial_xmit_delay:
+	 * Number of pixels to delay the initial transmission
+	 */
+	u16 initial_xmit_delay;
+	/**
+	 * @initial_dec_delay:
+	 * Initial decoder delay, number of pixel times that the decoder
+	 * accumulates data in its rate buffer before starting to decode
+	 * and output pixels.
+	 */
+	u16  initial_dec_delay;
+	/**
+	 * @block_pred_enable:
+	 * True if block prediction is used to code any groups within the
+	 * picture. False if BP not used
+	 */
+	bool block_pred_enable;
+	/**
+	 * @first_line_bpg_offset:
+	 * Number of additional bits allocated for each group on the first
+	 * line of slice.
+	 */
+	u8 first_line_bpg_offset;
+	/**
+	 * @initial_offset: Value to use for RC model offset at slice start
+	 */
+	u16 initial_offset;
+	/**
+	 * @rc_buf_thresh: Thresholds defining each of the buffer ranges
+	 */
+	u16 rc_buf_thresh[DSC_NUM_BUF_RANGES - 1];
+	/**
+	 * @rc_range_params:
+	 * Parameters for each of the RC ranges defined in
+	 * &struct drm_dsc_rc_range_parameters
+	 */
+	struct drm_dsc_rc_range_parameters rc_range_params[DSC_NUM_BUF_RANGES];
+	/**
+	 * @rc_model_size: Total size of RC model
+	 */
+	u16 rc_model_size;
+	/**
+	 * @flatness_min_qp: Minimum QP where flatness information is sent
+	 */
+	u8 flatness_min_qp;
+	/**
+	 * @flatness_max_qp: Maximum QP where flatness information is sent
+	 */
+	u8 flatness_max_qp;
+	/**
+	 * @initial_scale_value: Initial value for the scale factor
+	 */
+	u8 initial_scale_value;
+	/**
+	 * @scale_decrement_interval:
+	 * Specifies number of group times between decrementing the scale factor
+	 * at beginning of a slice.
+	 */
+	u16 scale_decrement_interval;
+	/**
+	 * @scale_increment_interval:
+	 * Number of group times between incrementing the scale factor value
+	 * used at the beginning of a slice.
+	 */
+	u16 scale_increment_interval;
+	/**
+	 * @nfl_bpg_offset: Non first line BPG offset to be used
+	 */
+	u16 nfl_bpg_offset;
+	/**
+	 * @slice_bpg_offset: BPG offset used to enforce slice bit
+	 */
+	u16 slice_bpg_offset;
+	/**
+	 * @final_offset: Final RC linear transformation offset value
+	 */
+	u16 final_offset;
+	/**
+	 * @vbr_enable: True if VBR mode is enabled, false if disabled
+	 */
+	bool vbr_enable;
+	/**
+	 * @mux_word_size: Mux word size (in bits) for SSM mode
+	 */
+	u8 mux_word_size;
+	/**
+	 * @slice_chunk_size:
+	 * The (max) size in bytes of the "chunks" that are used in slice
+	 * multiplexing.
+	 */
+	u16 slice_chunk_size;
+	/**
+	 * @rc_bits: Rate control buffer size in bits
+	 */
+	u16 rc_bits;
+	/**
+	 * @dsc_version_minor: DSC minor version
+	 */
+	u8 dsc_version_minor;
+	/**
+	 * @dsc_version_major: DSC major version
+	 */
+	u8 dsc_version_major;
+	/**
+	 * @native_422: True if Native 4:2:2 supported, else false
+	 */
+	bool native_422;
+	/**
+	 * @native_420: True if Native 4:2:0 supported else false.
+	 */
+	bool native_420;
+	/**
+	 * @second_line_bpg_offset:
+	 * Additional bits/grp for seconnd line of slice for native 4:2:0
+	 */
+	u8 second_line_bpg_offset;
+	/**
+	 * @nsl_bpg_offset:
+	 * Num of bits deallocated for each grp that is not in second line of
+	 * slice
+	 */
+	u16 nsl_bpg_offset;
+	/**
+	 * @second_line_offset_adj:
+	 * Offset adjustment for second line in Native 4:2:0 mode
+	 */
+	u16 second_line_offset_adj;
+};
+
+/**
+ * struct picture_parameter_set - Represents 128 bytes of Picture Parameter Set
+ *
+ * The VESA DSC standard defines picture parameter set (PPS) which display
+ * stream compression encoders must communicate to decoders.
+ * The PPS is encapsulated in 128 bytes (PPS 0 through PPS 127). The fields in
+ * this structure are as per Table 4.1 in Vesa DSC specification v1.1/v1.2.
+ * The PPS fields that span over more than a byte should be stored in Big Endian
+ * format.
+ */
+struct drm_dsc_picture_parameter_set {
+	/**
+	 * @dsc_version:
+	 * PPS0[3:0] - dsc_version_minor: Contains Minor version of DSC
+	 * PPS0[7:4] - dsc_version_major: Contains major version of DSC
+	 */
+	u8 dsc_version;
+	/**
+	 * @pps_identifier:
+	 * PPS1[7:0] - Application specific identifier that can be
+	 * used to differentiate between different PPS tables.
+	 */
+	u8 pps_identifier;
+	/**
+	 * @pps_reserved:
+	 * PPS2[7:0]- RESERVED Byte
+	 */
+	u8 pps_reserved;
+	/**
+	 * @pps_3:
+	 * PPS3[3:0] - linebuf_depth: Contains linebuffer bit depth used to
+	 * generate the bitstream. (0x0 - 16 bits for DSC 1.2, 0x8 - 8 bits,
+	 * 0xA - 10 bits, 0xB - 11 bits, 0xC - 12 bits, 0xD - 13 bits,
+	 * 0xE - 14 bits for DSC1.2, 0xF - 14 bits for DSC 1.2.
+	 * PPS3[7:4] - bits_per_component: Bits per component for the original
+	 * pixels of the encoded picture.
+	 * 0x0 = 16bpc (allowed only when dsc_version_minor = 0x2)
+	 * 0x8 = 8bpc, 0xA = 10bpc, 0xC = 12bpc, 0xE = 14bpc (also
+	 * allowed only when dsc_minor_version = 0x2)
+	 */
+	u8 pps_3;
+	/**
+	 * @pps_4:
+	 * PPS4[1:0] -These are the most significant 2 bits of
+	 * compressed BPP bits_per_pixel[9:0] syntax element.
+	 * PPS4[2] - vbr_enable: 0 = VBR disabled, 1 = VBR enabled
+	 * PPS4[3] - simple_422: Indicates if decoder drops samples to
+	 * reconstruct the 4:2:2 picture.
+	 * PPS4[4] - Convert_rgb: Indicates if DSC color space conversion is
+	 * active.
+	 * PPS4[5] - blobk_pred_enable: Indicates if BP is used to code any
+	 * groups in picture
+	 * PPS4[7:6] - Reserved bits
+	 */
+	u8 pps_4;
+	/**
+	 * @bits_per_pixel_low:
+	 * PPS5[7:0] - This indicates the lower significant 8 bits of
+	 * the compressed BPP bits_per_pixel[9:0] element.
+	 */
+	u8 bits_per_pixel_low;
+	/**
+	 * @pic_height:
+	 * PPS6[7:0], PPS7[7:0] -pic_height: Specifies the number of pixel rows
+	 * within the raster.
+	 */
+	__be16 pic_height;
+	/**
+	 * @pic_width:
+	 * PPS8[7:0], PPS9[7:0] - pic_width: Number of pixel columns within
+	 * the raster.
+	 */
+	__be16 pic_width;
+	/**
+	 * @slice_height:
+	 * PPS10[7:0], PPS11[7:0] - Slice height in units of pixels.
+	 */
+	__be16 slice_height;
+	/**
+	 * @slice_width:
+	 * PPS12[7:0], PPS13[7:0] - Slice width in terms of pixels.
+	 */
+	__be16 slice_width;
+	/**
+	 * @chunk_size:
+	 * PPS14[7:0], PPS15[7:0] - Size in units of bytes of the chunks
+	 * that are used for slice multiplexing.
+	 */
+	__be16 chunk_size;
+	/**
+	 * @initial_xmit_delay_high:
+	 * PPS16[1:0] - Most Significant two bits of initial transmission delay.
+	 * It specifies the number of pixel times that the encoder waits before
+	 * transmitting data from its rate buffer.
+	 * PPS16[7:2] - Reserved
+	 */
+	u8 initial_xmit_delay_high;
+	/**
+	 * @initial_xmit_delay_low:
+	 * PPS17[7:0] - Least significant 8 bits of initial transmission delay.
+	 */
+	u8 initial_xmit_delay_low;
+	/**
+	 * @initial_dec_delay:
+	 *
+	 * PPS18[7:0], PPS19[7:0] - Initial decoding delay which is the number
+	 * of pixel times that the decoder accumulates data in its rate buffer
+	 * before starting to decode and output pixels.
+	 */
+	__be16 initial_dec_delay;
+	/**
+	 * @pps20_reserved:
+	 *
+	 * PPS20[7:0] - Reserved
+	 */
+	u8 pps20_reserved;
+	/**
+	 * @initial_scale_value:
+	 * PPS21[5:0] - Initial rcXformScale factor used at beginning
+	 * of a slice.
+	 * PPS21[7:6] - Reserved
+	 */
+	u8 initial_scale_value;
+	/**
+	 * @scale_increment_interval:
+	 * PPS22[7:0], PPS23[7:0] - Number of group times between incrementing
+	 * the rcXformScale factor at end of a slice.
+	 */
+	__be16 scale_increment_interval;
+	/**
+	 * @scale_decrement_interval_high:
+	 * PPS24[3:0] - Higher 4 bits indicating number of group times between
+	 * decrementing the rcXformScale factor at beginning of a slice.
+	 * PPS24[7:4] - Reserved
+	 */
+	u8 scale_decrement_interval_high;
+	/**
+	 * @scale_decrement_interval_low:
+	 * PPS25[7:0] - Lower 8 bits of scale decrement interval
+	 */
+	u8 scale_decrement_interval_low;
+	/**
+	 * @pps26_reserved:
+	 * PPS26[7:0]
+	 */
+	u8 pps26_reserved;
+	/**
+	 * @first_line_bpg_offset:
+	 * PPS27[4:0] - Number of additional bits that are allocated
+	 * for each group on first line of a slice.
+	 * PPS27[7:5] - Reserved
+	 */
+	u8 first_line_bpg_offset;
+	/**
+	 * @nfl_bpg_offset:
+	 * PPS28[7:0], PPS29[7:0] - Number of bits including frac bits
+	 * deallocated for each group for groups after the first line of slice.
+	 */
+	__be16 nfl_bpg_offset;
+	/**
+	 * @slice_bpg_offset:
+	 * PPS30, PPS31[7:0] - Number of bits that are deallocated for each
+	 * group to enforce the slice constraint.
+	 */
+	__be16 slice_bpg_offset;
+	/**
+	 * @initial_offset:
+	 * PPS32,33[7:0] - Initial value for rcXformOffset
+	 */
+	__be16 initial_offset;
+	/**
+	 * @final_offset:
+	 * PPS34,35[7:0] - Maximum end-of-slice value for rcXformOffset
+	 */
+	__be16 final_offset;
+	/**
+	 * @flatness_min_qp:
+	 * PPS36[4:0] - Minimum QP at which flatness is signaled and
+	 * flatness QP adjustment is made.
+	 * PPS36[7:5] - Reserved
+	 */
+	u8 flatness_min_qp;
+	/**
+	 * @flatness_max_qp:
+	 * PPS37[4:0] - Max QP at which flatness is signalled and
+	 * the flatness adjustment is made.
+	 * PPS37[7:5] - Reserved
+	 */
+	u8 flatness_max_qp;
+	/**
+	 * @rc_model_size:
+	 * PPS38,39[7:0] - Number of bits within RC Model.
+	 */
+	__be16 rc_model_size;
+	/**
+	 * @rc_edge_factor:
+	 * PPS40[3:0] - Ratio of current activity vs, previous
+	 * activity to determine presence of edge.
+	 * PPS40[7:4] - Reserved
+	 */
+	u8 rc_edge_factor;
+	/**
+	 * @rc_quant_incr_limit0:
+	 * PPS41[4:0] - QP threshold used in short term RC
+	 * PPS41[7:5] - Reserved
+	 */
+	u8 rc_quant_incr_limit0;
+	/**
+	 * @rc_quant_incr_limit1:
+	 * PPS42[4:0] - QP threshold used in short term RC
+	 * PPS42[7:5] - Reserved
+	 */
+	u8 rc_quant_incr_limit1;
+	/**
+	 * @rc_tgt_offset:
+	 * PPS43[3:0] - Lower end of the variability range around the target
+	 * bits per group that is allowed by short term RC.
+	 * PPS43[7:4]- Upper end of the variability range around the target
+	 * bits per group that i allowed by short term rc.
+	 */
+	u8 rc_tgt_offset;
+	/**
+	 * @rc_buf_thresh:
+	 * PPS44[7:0] - PPS57[7:0] - Specifies the thresholds in RC model for
+	 * the 15 ranges defined by 14 thresholds.
+	 */
+	u8 rc_buf_thresh[DSC_NUM_BUF_RANGES - 1];
+	/**
+	 * @rc_range_parameters:
+	 * PPS58[7:0] - PPS87[7:0]
+	 * Parameters that correspond to each of the 15 ranges.
+	 */
+	__be16 rc_range_parameters[DSC_NUM_BUF_RANGES];
+	/**
+	 * @native_422_420:
+	 * PPS88[0] - 0 = Native 4:2:2 not used
+	 * 1 = Native 4:2:2 used
+	 * PPS88[1] - 0 = Native 4:2:0 not use
+	 * 1 = Native 4:2:0 used
+	 * PPS88[7:2] - Reserved 6 bits
+	 */
+	u8 native_422_420;
+	/**
+	 * @second_line_bpg_offset:
+	 * PPS89[4:0] - Additional bits/group budget for the
+	 * second line of a slice in Native 4:2:0 mode.
+	 * Set to 0 if DSC minor version is 1 or native420 is 0.
+	 * PPS89[7:5] - Reserved
+	 */
+	u8 second_line_bpg_offset;
+	/**
+	 * @nsl_bpg_offset:
+	 * PPS90[7:0], PPS91[7:0] - Number of bits that are deallocated
+	 * for each group that is not in the second line of a slice.
+	 */
+	__be16 nsl_bpg_offset;
+	/**
+	 * @second_line_offset_adj:
+	 * PPS92[7:0], PPS93[7:0] - Used as offset adjustment for the second
+	 * line in Native 4:2:0 mode.
+	 */
+	__be16 second_line_offset_adj;
+	/**
+	 * @pps_long_94_reserved:
+	 * PPS 94, 95, 96, 97 - Reserved
+	 */
+	u32 pps_long_94_reserved;
+	/**
+	 * @pps_long_98_reserved:
+	 * PPS 98, 99, 100, 101 - Reserved
+	 */
+	u32 pps_long_98_reserved;
+	/**
+	 * @pps_long_102_reserved:
+	 * PPS 102, 103, 104, 105 - Reserved
+	 */
+	u32 pps_long_102_reserved;
+	/**
+	 * @pps_long_106_reserved:
+	 * PPS 106, 107, 108, 109 - reserved
+	 */
+	u32 pps_long_106_reserved;
+	/**
+	 * @pps_long_110_reserved:
+	 * PPS 110, 111, 112, 113 - reserved
+	 */
+	u32 pps_long_110_reserved;
+	/**
+	 * @pps_long_114_reserved:
+	 * PPS 114 - 117 - reserved
+	 */
+	u32 pps_long_114_reserved;
+	/**
+	 * @pps_long_118_reserved:
+	 * PPS 118 - 121 - reserved
+	 */
+	u32 pps_long_118_reserved;
+	/**
+	 * @pps_long_122_reserved:
+	 * PPS 122- 125 - reserved
+	 */
+	u32 pps_long_122_reserved;
+	/**
+	 * @pps_short_126_reserved:
+	 * PPS 126, 127 - reserved
+	 */
+	__be16 pps_short_126_reserved;
+} __packed;
+
+/**
+ * struct drm_dsc_pps_infoframe - DSC infoframe carrying the Picture Parameter
+ * Set Metadata
+ *
+ * This structure represents the DSC PPS infoframe required to send the Picture
+ * Parameter Set metadata required before enabling VESA Display Stream
+ * Compression. This is based on the DP Secondary Data Packet structure and
+ * comprises of SDP Header as defined &struct dp_sdp_header in drm_dp_helper.h
+ * and PPS payload defined in &struct drm_dsc_picture_parameter_set.
+ *
+ * @pps_header: Header for PPS as per DP SDP header format of type
+ *              &struct dp_sdp_header
+ * @pps_payload: PPS payload fields as per DSC specification Table 4-1
+ *               as represented in &struct drm_dsc_picture_parameter_set
+ */
+struct drm_dsc_pps_infoframe {
+	struct dp_sdp_header pps_header;
+	struct drm_dsc_picture_parameter_set pps_payload;
+} __packed;
+
+void drm_dsc_dp_pps_header_init(struct dp_sdp_header *pps_header);
+void drm_dsc_pps_payload_pack(struct drm_dsc_picture_parameter_set *pps_sdp,
+			      const struct drm_dsc_config *dsc_cfg);
+int drm_dsc_compute_rc_parameters(struct drm_dsc_config *vdsc_cfg);
+
+#endif /* _DRM_DSC_H_ */
diff --git a/include/drm/drm_mipi_dsi.h b/include/drm/drm_mipi_dsi.h
new file mode 100644
index 0000000000..d4ead5aac3
--- /dev/null
+++ b/include/drm/drm_mipi_dsi.h
@@ -0,0 +1,257 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * MIPI DSI Bus
+ *
+ * Copyright (C) 2012-2013, Samsung Electronics, Co., Ltd.
+ * Andrzej Hajda <a.hajda@samsung.com>
+ */
+
+#ifndef __DRM_MIPI_DSI_H__
+#define __DRM_MIPI_DSI_H__
+
+#include <mipi_display.h>
+#include <drm/drm_dsc.h>
+#include <dm/device.h>
+
+struct mipi_dsi_host;
+struct mipi_dsi_device;
+
+/* request ACK from peripheral */
+#define MIPI_DSI_MSG_REQ_ACK	BIT(0)
+/* use Low Power Mode to transmit message */
+#define MIPI_DSI_MSG_USE_LPM	BIT(1)
+
+/**
+ * struct mipi_dsi_msg - read/write DSI buffer
+ * @channel: virtual channel id
+ * @type: payload data type
+ * @flags: flags controlling this message transmission
+ * @tx_len: length of @tx_buf
+ * @tx_buf: data to be written
+ * @rx_len: length of @rx_buf
+ * @rx_buf: data to be read, or NULL
+ */
+struct mipi_dsi_msg {
+	u8 channel;
+	u8 type;
+	u16 flags;
+
+	size_t tx_len;
+	const void *tx_buf;
+
+	size_t rx_len;
+	void *rx_buf;
+};
+
+bool mipi_dsi_packet_format_is_short(u8 type);
+bool mipi_dsi_packet_format_is_long(u8 type);
+
+/**
+ * struct mipi_dsi_packet - represents a MIPI DSI packet in protocol format
+ * @size: size (in bytes) of the packet
+ * @header: the four bytes that make up the header (Data ID, Word Count or
+ *     Packet Data, and ECC)
+ * @payload_length: number of bytes in the payload
+ * @payload: a pointer to a buffer containing the payload, if any
+ */
+struct mipi_dsi_packet {
+	size_t size;
+	u8 header[4];
+	size_t payload_length;
+	const u8 *payload;
+};
+
+int mipi_dsi_create_packet(struct mipi_dsi_packet *packet,
+			   const struct mipi_dsi_msg *msg);
+
+/**
+ * struct mipi_dsi_host_ops - DSI bus operations
+ * @attach: attach DSI device to DSI host
+ * @detach: detach DSI device from DSI host
+ * @transfer: transmit a DSI packet
+ *
+ * DSI packets transmitted by .transfer() are passed in as mipi_dsi_msg
+ * structures. This structure contains information about the type of packet
+ * being transmitted as well as the transmit and receive buffers. When an
+ * error is encountered during transmission, this function will return a
+ * negative error code. On success it shall return the number of bytes
+ * transmitted for write packets or the number of bytes received for read
+ * packets.
+ *
+ * Note that typically DSI packet transmission is atomic, so the .transfer()
+ * function will seldomly return anything other than the number of bytes
+ * contained in the transmit buffer on success.
+ */
+struct mipi_dsi_host_ops {
+	int (*attach)(struct mipi_dsi_host *host,
+		      struct mipi_dsi_device *dsi);
+	int (*detach)(struct mipi_dsi_host *host,
+		      struct mipi_dsi_device *dsi);
+	ssize_t (*transfer)(struct mipi_dsi_host *host,
+			    const struct mipi_dsi_msg *msg);
+};
+
+/**
+ * struct mipi_dsi_host - DSI host device
+ * @dev: driver model device node for this DSI host
+ * @ops: DSI host operations
+ * @list: list management
+ */
+struct mipi_dsi_host {
+	struct udevice *dev;
+	const struct mipi_dsi_host_ops *ops;
+};
+
+/* DSI mode flags */
+
+/* video mode */
+#define MIPI_DSI_MODE_VIDEO		BIT(0)
+/* video burst mode */
+#define MIPI_DSI_MODE_VIDEO_BURST	BIT(1)
+/* video pulse mode */
+#define MIPI_DSI_MODE_VIDEO_SYNC_PULSE	BIT(2)
+/* enable auto vertical count mode */
+#define MIPI_DSI_MODE_VIDEO_AUTO_VERT	BIT(3)
+/* enable hsync-end packets in vsync-pulse and v-porch area */
+#define MIPI_DSI_MODE_VIDEO_HSE		BIT(4)
+/* disable hfront-porch area */
+#define MIPI_DSI_MODE_VIDEO_HFP		BIT(5)
+/* disable hback-porch area */
+#define MIPI_DSI_MODE_VIDEO_HBP		BIT(6)
+/* disable hsync-active area */
+#define MIPI_DSI_MODE_VIDEO_HSA		BIT(7)
+/* flush display FIFO on vsync pulse */
+#define MIPI_DSI_MODE_VSYNC_FLUSH	BIT(8)
+/* disable EoT packets in HS mode */
+#define MIPI_DSI_MODE_EOT_PACKET	BIT(9)
+/* device supports non-continuous clock behavior (DSI spec 5.6.1) */
+#define MIPI_DSI_CLOCK_NON_CONTINUOUS	BIT(10)
+/* transmit data in low power */
+#define MIPI_DSI_MODE_LPM		BIT(11)
+
+enum mipi_dsi_pixel_format {
+	MIPI_DSI_FMT_RGB888,
+	MIPI_DSI_FMT_RGB666,
+	MIPI_DSI_FMT_RGB666_PACKED,
+	MIPI_DSI_FMT_RGB565,
+};
+
+#define DSI_DEV_NAME_SIZE		20
+
+/**
+ * struct mipi_dsi_device - DSI peripheral device
+ * @host: DSI host for this peripheral
+ * @dev: driver model device node for this peripheral
+ * @name: DSI peripheral chip type
+ * @channel: virtual channel assigned to the peripheral
+ * @format: pixel format for video mode
+ * @lanes: number of active data lanes
+ * @mode_flags: DSI operation mode related flags
+ * @hs_rate: maximum lane frequency for high speed mode in hertz, this should
+ * be set to the real limits of the hardware, zero is only accepted for
+ * legacy drivers
+ * @lp_rate: maximum lane frequency for low power mode in hertz, this should
+ * be set to the real limits of the hardware, zero is only accepted for
+ * legacy drivers
+ */
+struct mipi_dsi_device {
+	struct mipi_dsi_host *host;
+	struct udevice *dev;
+
+	char name[DSI_DEV_NAME_SIZE];
+	unsigned int channel;
+	unsigned int lanes;
+	enum mipi_dsi_pixel_format format;
+	unsigned long mode_flags;
+	unsigned long hs_rate;
+	unsigned long lp_rate;
+};
+
+/**
+ * mipi_dsi_pixel_format_to_bpp - obtain the number of bits per pixel for any
+ *                                given pixel format defined by the MIPI DSI
+ *                                specification
+ * @fmt: MIPI DSI pixel format
+ *
+ * Returns: The number of bits per pixel of the given pixel format.
+ */
+static inline int mipi_dsi_pixel_format_to_bpp(enum mipi_dsi_pixel_format fmt)
+{
+	switch (fmt) {
+	case MIPI_DSI_FMT_RGB888:
+	case MIPI_DSI_FMT_RGB666:
+		return 24;
+
+	case MIPI_DSI_FMT_RGB666_PACKED:
+		return 18;
+
+	case MIPI_DSI_FMT_RGB565:
+		return 16;
+	}
+
+	return -EINVAL;
+}
+
+int mipi_dsi_attach(struct mipi_dsi_device *dsi);
+int mipi_dsi_detach(struct mipi_dsi_device *dsi);
+int mipi_dsi_shutdown_peripheral(struct mipi_dsi_device *dsi);
+int mipi_dsi_turn_on_peripheral(struct mipi_dsi_device *dsi);
+int mipi_dsi_set_maximum_return_packet_size(struct mipi_dsi_device *dsi,
+					    u16 value);
+
+ssize_t mipi_dsi_compression_mode(struct mipi_dsi_device *dsi, bool enable);
+ssize_t mipi_dsi_picture_parameter_set(struct mipi_dsi_device *dsi,
+				       const struct drm_dsc_picture_parameter_set *pps);
+
+ssize_t mipi_dsi_generic_write(struct mipi_dsi_device *dsi, const void *payload,
+			       size_t size);
+ssize_t mipi_dsi_generic_read(struct mipi_dsi_device *dsi, const void *params,
+			      size_t num_params, void *data, size_t size);
+
+/**
+ * enum mipi_dsi_dcs_tear_mode - Tearing Effect Output Line mode
+ * @MIPI_DSI_DCS_TEAR_MODE_VBLANK: the TE output line consists of V-Blanking
+ *    information only
+ * @MIPI_DSI_DCS_TEAR_MODE_VHBLANK : the TE output line consists of both
+ *    V-Blanking and H-Blanking information
+ */
+enum mipi_dsi_dcs_tear_mode {
+	MIPI_DSI_DCS_TEAR_MODE_VBLANK,
+	MIPI_DSI_DCS_TEAR_MODE_VHBLANK,
+};
+
+#define MIPI_DSI_DCS_POWER_MODE_DISPLAY BIT(2)
+#define MIPI_DSI_DCS_POWER_MODE_NORMAL  BIT(3)
+#define MIPI_DSI_DCS_POWER_MODE_SLEEP   BIT(4)
+#define MIPI_DSI_DCS_POWER_MODE_PARTIAL BIT(5)
+#define MIPI_DSI_DCS_POWER_MODE_IDLE    BIT(6)
+
+ssize_t mipi_dsi_dcs_write_buffer(struct mipi_dsi_device *dsi,
+				  const void *data, size_t len);
+ssize_t mipi_dsi_dcs_write(struct mipi_dsi_device *dsi, u8 cmd,
+			   const void *data, size_t len);
+ssize_t mipi_dsi_dcs_read(struct mipi_dsi_device *dsi, u8 cmd, void *data,
+			  size_t len);
+int mipi_dsi_dcs_nop(struct mipi_dsi_device *dsi);
+int mipi_dsi_dcs_soft_reset(struct mipi_dsi_device *dsi);
+int mipi_dsi_dcs_get_power_mode(struct mipi_dsi_device *dsi, u8 *mode);
+int mipi_dsi_dcs_get_pixel_format(struct mipi_dsi_device *dsi, u8 *format);
+int mipi_dsi_dcs_enter_sleep_mode(struct mipi_dsi_device *dsi);
+int mipi_dsi_dcs_exit_sleep_mode(struct mipi_dsi_device *dsi);
+int mipi_dsi_dcs_set_display_off(struct mipi_dsi_device *dsi);
+int mipi_dsi_dcs_set_display_on(struct mipi_dsi_device *dsi);
+int mipi_dsi_dcs_set_column_address(struct mipi_dsi_device *dsi, u16 start,
+				    u16 end);
+int mipi_dsi_dcs_set_page_address(struct mipi_dsi_device *dsi, u16 start,
+				  u16 end);
+int mipi_dsi_dcs_set_tear_off(struct mipi_dsi_device *dsi);
+int mipi_dsi_dcs_set_tear_on(struct mipi_dsi_device *dsi,
+			     enum mipi_dsi_dcs_tear_mode mode);
+int mipi_dsi_dcs_set_pixel_format(struct mipi_dsi_device *dsi, u8 format);
+int mipi_dsi_dcs_set_tear_scanline(struct mipi_dsi_device *dsi, u16 scanline);
+int mipi_dsi_dcs_set_display_brightness(struct mipi_dsi_device *dsi,
+					u16 brightness);
+int mipi_dsi_dcs_get_display_brightness(struct mipi_dsi_device *dsi,
+					u16 *brightness);
+
+#endif /* __DRM_MIPI_DSI__ */
diff --git a/include/drm_modes.h b/include/drm_modes.h
new file mode 100644
index 0000000000..00fb3169c2
--- /dev/null
+++ b/include/drm_modes.h
@@ -0,0 +1,384 @@
+/*
+ * (C) Copyright 2008-2016 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _DRM_MODES_H
+#define _DRM_MODES_H
+
+#include "fdtdec.h"
+
+#define DRM_DISPLAY_INFO_LEN	32
+#define DRM_CONNECTOR_NAME_LEN	32
+#define DRM_DISPLAY_MODE_LEN	32
+#define DRM_PROP_NAME_LEN	32
+
+#define DRM_MODE_TYPE_BUILTIN	(1<<0)
+#define DRM_MODE_TYPE_CLOCK_C	((1<<1) | DRM_MODE_TYPE_BUILTIN)
+#define DRM_MODE_TYPE_CRTC_C	((1<<2) | DRM_MODE_TYPE_BUILTIN)
+#define DRM_MODE_TYPE_PREFERRED	(1<<3)
+#define DRM_MODE_TYPE_DEFAULT	(1<<4)
+#define DRM_MODE_TYPE_USERDEF	(1<<5)
+#define DRM_MODE_TYPE_DRIVER	(1<<6)
+
+/* Video mode flags */
+/* bit compatible with the xorg definitions. */
+#define DRM_MODE_FLAG_PHSYNC			(1 << 0)
+#define DRM_MODE_FLAG_NHSYNC			(1 << 1)
+#define DRM_MODE_FLAG_PVSYNC			(1 << 2)
+#define DRM_MODE_FLAG_NVSYNC			(1 << 3)
+#define DRM_MODE_FLAG_INTERLACE			(1 << 4)
+#define DRM_MODE_FLAG_DBLSCAN			(1 << 5)
+#define DRM_MODE_FLAG_CSYNC			(1 << 6)
+#define DRM_MODE_FLAG_PCSYNC			(1 << 7)
+#define DRM_MODE_FLAG_NCSYNC			(1 << 8)
+#define DRM_MODE_FLAG_HSKEW			(1 << 9) /* hskew provided */
+#define DRM_MODE_FLAG_BCAST			(1 << 10)
+#define DRM_MODE_FLAG_PIXMUX			(1 << 11)
+#define DRM_MODE_FLAG_DBLCLK			(1 << 12)
+#define DRM_MODE_FLAG_CLKDIV2			(1 << 13)
+/*
+ * When adding a new stereo mode don't forget to adjust DRM_MODE_FLAGS_3D_MAX
+ * (define not exposed to user space).
+ */
+#define DRM_MODE_FLAG_3D_MASK			(0x1f << 14)
+#define  DRM_MODE_FLAG_3D_NONE			(0 << 14)
+#define  DRM_MODE_FLAG_3D_FRAME_PACKING		(1 << 14)
+#define  DRM_MODE_FLAG_3D_FIELD_ALTERNATIVE	(2 << 14)
+#define  DRM_MODE_FLAG_3D_LINE_ALTERNATIVE	(3 << 14)
+#define  DRM_MODE_FLAG_3D_SIDE_BY_SIDE_FULL	(4 << 14)
+#define  DRM_MODE_FLAG_3D_L_DEPTH		(5 << 14)
+#define  DRM_MODE_FLAG_3D_L_DEPTH_GFX_GFX_DEPTH	(6 << 14)
+#define  DRM_MODE_FLAG_3D_TOP_AND_BOTTOM	(7 << 14)
+#define  DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF	(8 << 14)
+
+/* Panel Mirror control */
+#define DRM_MODE_FLAG_XMIRROR			(1<<28)
+#define DRM_MODE_FLAG_YMIRROR			(1<<29)
+#define DRM_MODE_FLAG_XYMIRROR			(DRM_MODE_FLAG_XMIRROR | DRM_MODE_FLAG_YMIRROR)
+
+/* Picture aspect ratio options */
+#define DRM_MODE_PICTURE_ASPECT_NONE		0
+#define DRM_MODE_PICTURE_ASPECT_4_3		1
+#define DRM_MODE_PICTURE_ASPECT_16_9		2
+#define DRM_MODE_PICTURE_ASPECT_64_27		3
+#define DRM_MODE_PICTURE_ASPECT_256_135		4
+
+/* Aspect ratio flag bitmask (4 bits 22:19) */
+#define DRM_MODE_FLAG_PIC_AR_MASK		(0x0F << 19)
+#define  DRM_MODE_FLAG_PIC_AR_NONE \
+			(DRM_MODE_PICTURE_ASPECT_NONE << 19)
+#define  DRM_MODE_FLAG_PIC_AR_4_3 \
+			(DRM_MODE_PICTURE_ASPECT_4_3 << 19)
+#define  DRM_MODE_FLAG_PIC_AR_16_9 \
+			(DRM_MODE_PICTURE_ASPECT_16_9 << 19)
+#define  DRM_MODE_FLAG_PIC_AR_64_27 \
+			(DRM_MODE_PICTURE_ASPECT_64_27 << 19)
+#define  DRM_MODE_FLAG_PIC_AR_256_135 \
+			(DRM_MODE_PICTURE_ASPECT_256_135 << 19)
+
+/*
+ * DRM_MODE_ROTATE_<degrees>
+ *
+ * Signals that a drm plane is been rotated <degrees> degrees in counter
+ * clockwise direction.
+ *
+ * This define is provided as a convenience, looking up the property id
+ * using the name->prop id lookup is the preferred method.
+ */
+#define DRM_MODE_ROTATE_0       (1<<0)
+#define DRM_MODE_ROTATE_90      (1<<1)
+#define DRM_MODE_ROTATE_180     (1<<2)
+#define DRM_MODE_ROTATE_270     (1<<3)
+
+/*
+ * DRM_MODE_ROTATE_MASK
+ *
+ * Bitmask used to look for drm plane rotations.
+ */
+#define DRM_MODE_ROTATE_MASK (\
+		DRM_MODE_ROTATE_0  | \
+		DRM_MODE_ROTATE_90  | \
+		DRM_MODE_ROTATE_180 | \
+		DRM_MODE_ROTATE_270)
+
+/*
+ * DRM_MODE_REFLECT_<axis>
+ *
+ * Signals that the contents of a drm plane is reflected along the <axis> axis,
+ * in the same way as mirroring.
+ * See kerneldoc chapter "Plane Composition Properties" for more details.
+ *
+ * This define is provided as a convenience, looking up the property id
+ * using the name->prop id lookup is the preferred method.
+ */
+#define DRM_MODE_REFLECT_X      (1<<4)
+#define DRM_MODE_REFLECT_Y      (1<<5)
+
+/*
+ * DRM_MODE_REFLECT_MASK
+ *
+ * Bitmask used to look for drm plane reflections.
+ */
+#define DRM_MODE_REFLECT_MASK (\
+		DRM_MODE_REFLECT_X | \
+		DRM_MODE_REFLECT_Y)
+
+#define DRM_MODE_CONNECTOR_Unknown	0
+#define DRM_MODE_CONNECTOR_VGA		1
+#define DRM_MODE_CONNECTOR_DVII		2
+#define DRM_MODE_CONNECTOR_DVID		3
+#define DRM_MODE_CONNECTOR_DVIA		4
+#define DRM_MODE_CONNECTOR_Composite	5
+#define DRM_MODE_CONNECTOR_SVIDEO	6
+#define DRM_MODE_CONNECTOR_LVDS		7
+#define DRM_MODE_CONNECTOR_Component	8
+#define DRM_MODE_CONNECTOR_9PinDIN	9
+#define DRM_MODE_CONNECTOR_DisplayPort	10
+#define DRM_MODE_CONNECTOR_HDMIA	11
+#define DRM_MODE_CONNECTOR_HDMIB	12
+#define DRM_MODE_CONNECTOR_TV		13
+#define DRM_MODE_CONNECTOR_eDP		14
+#define DRM_MODE_CONNECTOR_VIRTUAL      15
+#define DRM_MODE_CONNECTOR_DSI		16
+#define DRM_MODE_CONNECTOR_DPI		17
+
+#define DRM_EDID_PT_HSYNC_POSITIVE (1 << 1)
+#define DRM_EDID_PT_VSYNC_POSITIVE (1 << 2)
+#define DRM_EDID_PT_SEPARATE_SYNC  (3 << 3)
+#define DRM_EDID_PT_STEREO         (1 << 5)
+#define DRM_EDID_PT_INTERLACED     (1 << 7)
+
+/* see also http://vektor.theorem.ca/graphics/ycbcr/ */
+enum v4l2_colorspace {
+	/*
+	 * Default colorspace, i.e. let the driver figure it out.
+	 * Can only be used with video capture.
+	 */
+	V4L2_COLORSPACE_DEFAULT       = 0,
+
+	/* SMPTE 170M: used for broadcast NTSC/PAL SDTV */
+	V4L2_COLORSPACE_SMPTE170M     = 1,
+
+	/* Obsolete pre-1998 SMPTE 240M HDTV standard, superseded by Rec 709 */
+	V4L2_COLORSPACE_SMPTE240M     = 2,
+
+	/* Rec.709: used for HDTV */
+	V4L2_COLORSPACE_REC709        = 3,
+
+	/*
+	 * Deprecated, do not use. No driver will ever return this. This was
+	 * based on a misunderstanding of the bt878 datasheet.
+	 */
+	V4L2_COLORSPACE_BT878         = 4,
+
+	/*
+	 * NTSC 1953 colorspace. This only makes sense when dealing with
+	 * really, really old NTSC recordings. Superseded by SMPTE 170M.
+	 */
+	V4L2_COLORSPACE_470_SYSTEM_M  = 5,
+
+	/*
+	 * EBU Tech 3213 PAL/SECAM colorspace. This only makes sense when
+	 * dealing with really old PAL/SECAM recordings. Superseded by
+	 * SMPTE 170M.
+	 */
+	V4L2_COLORSPACE_470_SYSTEM_BG = 6,
+
+	/*
+	 * Effectively shorthand for V4L2_COLORSPACE_SRGB, V4L2_YCBCR_ENC_601
+	 * and V4L2_QUANTIZATION_FULL_RANGE. To be used for (Motion-)JPEG.
+	 */
+	V4L2_COLORSPACE_JPEG          = 7,
+
+	/* For RGB colorspaces such as produces by most webcams. */
+	V4L2_COLORSPACE_SRGB          = 8,
+
+	/* AdobeRGB colorspace */
+	V4L2_COLORSPACE_ADOBERGB      = 9,
+
+	/* BT.2020 colorspace, used for UHDTV. */
+	V4L2_COLORSPACE_BT2020        = 10,
+
+	/* Raw colorspace: for RAW unprocessed images */
+	V4L2_COLORSPACE_RAW           = 11,
+
+	/* DCI-P3 colorspace, used by cinema projectors */
+	V4L2_COLORSPACE_DCI_P3        = 12,
+};
+
+#define CRTC_INTERLACE_HALVE_V	(1 << 0) /* halve V values for interlacing */
+#define CRTC_STEREO_DOUBLE	(1 << 1) /* adjust timings for stereo modes */
+#define CRTC_NO_DBLSCAN		(1 << 2) /* don't adjust doublescan */
+#define CRTC_NO_VSCAN		(1 << 3) /* don't adjust doublescan */
+#define CRTC_STEREO_DOUBLE_ONLY	(CRTC_STEREO_DOUBLE | CRTC_NO_DBLSCAN | \
+				 CRTC_NO_VSCAN)
+
+#define DRM_MODE_FLAG_3D_MAX	DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF
+
+#define DRM_MODE_MATCH_TIMINGS		(1 << 0)
+#define DRM_MODE_MATCH_CLOCK		(1 << 1)
+#define DRM_MODE_MATCH_FLAGS		(1 << 2)
+#define DRM_MODE_MATCH_3D_FLAGS		(1 << 3)
+#define DRM_MODE_MATCH_ASPECT_RATIO	(1 << 4)
+
+struct drm_display_mode {
+	/* Proposed mode values */
+	int clock;		/* in kHz */
+	int hdisplay;
+	int hsync_start;
+	int hsync_end;
+	int htotal;
+	int vdisplay;
+	int vsync_start;
+	int vsync_end;
+	int vtotal;
+	int vrefresh;
+	int vscan;
+	unsigned int flags;
+	int picture_aspect_ratio;
+	int hskew;
+	unsigned int type;
+	/* Actual mode we give to hw */
+	int crtc_clock;         /* in KHz */
+	int crtc_hdisplay;
+	int crtc_hblank_start;
+	int crtc_hblank_end;
+	int crtc_hsync_start;
+	int crtc_hsync_end;
+	int crtc_htotal;
+	int crtc_hskew;
+	int crtc_vdisplay;
+	int crtc_vblank_start;
+	int crtc_vblank_end;
+	int crtc_vsync_start;
+	int crtc_vsync_end;
+	int crtc_vtotal;
+	bool invalid;
+};
+
+/**
+ * enum drm_mode_status - hardware support status of a mode
+ * @MODE_OK: Mode OK
+ * @MODE_HSYNC: hsync out of range
+ * @MODE_VSYNC: vsync out of range
+ * @MODE_H_ILLEGAL: mode has illegal horizontal timings
+ * @MODE_V_ILLEGAL: mode has illegal vertical timings
+ * @MODE_BAD_WIDTH: requires an unsupported linepitch
+ * @MODE_NOMODE: no mode with a matching name
+ * @MODE_NO_INTERLACE: interlaced mode not supported
+ * @MODE_NO_DBLESCAN: doublescan mode not supported
+ * @MODE_NO_VSCAN: multiscan mode not supported
+ * @MODE_MEM: insufficient video memory
+ * @MODE_VIRTUAL_X: mode width too large for specified virtual size
+ * @MODE_VIRTUAL_Y: mode height too large for specified virtual size
+ * @MODE_MEM_VIRT: insufficient video memory given virtual size
+ * @MODE_NOCLOCK: no fixed clock available
+ * @MODE_CLOCK_HIGH: clock required is too high
+ * @MODE_CLOCK_LOW: clock required is too low
+ * @MODE_CLOCK_RANGE: clock/mode isn't in a ClockRange
+ * @MODE_BAD_HVALUE: horizontal timing was out of range
+ * @MODE_BAD_VVALUE: vertical timing was out of range
+ * @MODE_BAD_VSCAN: VScan value out of range
+ * @MODE_HSYNC_NARROW: horizontal sync too narrow
+ * @MODE_HSYNC_WIDE: horizontal sync too wide
+ * @MODE_HBLANK_NARROW: horizontal blanking too narrow
+ * @MODE_HBLANK_WIDE: horizontal blanking too wide
+ * @MODE_VSYNC_NARROW: vertical sync too narrow
+ * @MODE_VSYNC_WIDE: vertical sync too wide
+ * @MODE_VBLANK_NARROW: vertical blanking too narrow
+ * @MODE_VBLANK_WIDE: vertical blanking too wide
+ * @MODE_PANEL: exceeds panel dimensions
+ * @MODE_INTERLACE_WIDTH: width too large for interlaced mode
+ * @MODE_ONE_WIDTH: only one width is supported
+ * @MODE_ONE_HEIGHT: only one height is supported
+ * @MODE_ONE_SIZE: only one resolution is supported
+ * @MODE_NO_REDUCED: monitor doesn't accept reduced blanking
+ * @MODE_NO_STEREO: stereo modes not supported
+ * @MODE_NO_420: ycbcr 420 modes not supported
+ * @MODE_STALE: mode has become stale
+ * @MODE_BAD: unspecified reason
+ * @MODE_ERROR: error condition
+ *
+ * This enum is used to filter out modes not supported by the driver/hardware
+ * combination.
+ */
+enum drm_mode_status {
+	MODE_OK = 0,
+	MODE_HSYNC,
+	MODE_VSYNC,
+	MODE_H_ILLEGAL,
+	MODE_V_ILLEGAL,
+	MODE_BAD_WIDTH,
+	MODE_NOMODE,
+	MODE_NO_INTERLACE,
+	MODE_NO_DBLESCAN,
+	MODE_NO_VSCAN,
+	MODE_MEM,
+	MODE_VIRTUAL_X,
+	MODE_VIRTUAL_Y,
+	MODE_MEM_VIRT,
+	MODE_NOCLOCK,
+	MODE_CLOCK_HIGH,
+	MODE_CLOCK_LOW,
+	MODE_CLOCK_RANGE,
+	MODE_BAD_HVALUE,
+	MODE_BAD_VVALUE,
+	MODE_BAD_VSCAN,
+	MODE_HSYNC_NARROW,
+	MODE_HSYNC_WIDE,
+	MODE_HBLANK_NARROW,
+	MODE_HBLANK_WIDE,
+	MODE_VSYNC_NARROW,
+	MODE_VSYNC_WIDE,
+	MODE_VBLANK_NARROW,
+	MODE_VBLANK_WIDE,
+	MODE_PANEL,
+	MODE_INTERLACE_WIDTH,
+	MODE_ONE_WIDTH,
+	MODE_ONE_HEIGHT,
+	MODE_ONE_SIZE,
+	MODE_NO_REDUCED,
+	MODE_NO_STEREO,
+	MODE_NO_420,
+	MODE_STALE = -3,
+	MODE_BAD = -2,
+	MODE_ERROR = -1
+};
+
+/*
+ * Subsystem independent description of a videomode.
+ * Can be generated from struct display_timing.
+ */
+struct videomode {
+	unsigned long pixelclock;	/* pixelclock in Hz */
+
+	u32 hactive;
+	u32 hfront_porch;
+	u32 hback_porch;
+	u32 hsync_len;
+
+	u32 vactive;
+	u32 vfront_porch;
+	u32 vback_porch;
+	u32 vsync_len;
+
+	enum display_flags flags; /* display flags */
+};
+
+struct drm_display_mode *drm_mode_create(void);
+void drm_mode_copy(struct drm_display_mode *dst,
+		   const struct drm_display_mode *src);
+void drm_mode_destroy(struct drm_display_mode *mode);
+bool drm_mode_match(const struct drm_display_mode *mode1,
+		    const struct drm_display_mode *mode2,
+		    unsigned int match_flags);
+bool drm_mode_equal(const struct drm_display_mode *mode1,
+		    const struct drm_display_mode *mode2);
+void drm_display_mode_from_videomode(const struct videomode *vm,
+				     struct drm_display_mode *dmode);
+void drm_display_mode_to_videomode(const struct drm_display_mode *dmode,
+				   struct videomode *vm);
+
+#endif
diff --git a/include/edid.h b/include/edid.h
index cee7c4c763..43c1d40cf0 100644
--- a/include/edid.h
+++ b/include/edid.h
@@ -1,30 +1,68 @@
-/* SPDX-License-Identifier: GPL-2.0+ */
 /*
  * Copyright (c) 2012 The Chromium OS Authors.
  *
  * (C) Copyright 2010
  * Petr Stetiar <ynezz@true.cz>
  *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
  * Contains stolen code from ddcprobe project which is:
  * Copyright (C) Nalin Dahyabhai <bigfun@pobox.com>
+ * (C) Copyright 2008-2017 Fuzhou Rockchip Electronics Co., Ltd
  */
 
 #ifndef __EDID_H_
 #define __EDID_H_
 
+#include <div64.h>
 #include <linux/types.h>
+#include <drm_modes.h>
+#include <i2c.h>
 
 /* Size of the EDID data */
 #define EDID_SIZE	128
 #define EDID_EXT_SIZE	256
+#define MODE_LEN	240
+
+#define CEA_EXT	    0x02
+#define VTB_EXT	    0x10
+#define DI_EXT	    0x40
+#define LS_EXT	    0x50
+#define MI_EXT	    0x60
+#define DISPLAYID_EXT 0x70
+
+#define EDID_TIMING_ASPECT_SHIFT 6
+#define EDID_TIMING_ASPECT_MASK  (0x3 << EDID_TIMING_ASPECT_SHIFT)
+
+/* need to add 60 */
+#define EDID_TIMING_VFREQ_SHIFT  0
+#define EDID_TIMING_VFREQ_MASK   (0x3f << EDID_TIMING_VFREQ_SHIFT)
 
 /* OUI of HDMI vendor specific data block */
 #define HDMI_IEEE_OUI 0x000c03
 
+/* drm mode 4k and 3d */
+#define DRM_MODE_FLAG_420_MASK			(0x03 << 23)
+#define  DRM_MODE_FLAG_420			BIT(23)
+#define  DRM_MODE_FLAG_420_ONLY			BIT(24)
+
+#define BITS_PER_BYTE         8
+#define BITS_TO_LONGS(nr)     DIV_ROUND_UP(nr, BITS_PER_BYTE * sizeof(long))
 #define GET_BIT(_x, _pos) \
 	(((_x) >> (_pos)) & 1)
 #define GET_BITS(_x, _pos_msb, _pos_lsb) \
 	(((_x) >> (_pos_lsb)) & ((1 << ((_pos_msb) - (_pos_lsb) + 1)) - 1))
+#define DRM_MODE(t, c, hd, hss, hse, ht, vd, vss, vse, vt, vs, f) \
+	.clock = (c), .type = (t),\
+	.hdisplay = (hd), .hsync_start = (hss), .hsync_end = (hse), \
+	.htotal = (ht), .vdisplay = (vd), \
+	.vsync_start = (vss), .vsync_end = (vse), .vtotal = (vt), \
+	.vscan = (vs), .flags = (f)
+
+#define DDC_SEGMENT_ADDR 0x30
+#define DDC_ADDR 0x50
+#define HDMI_EDID_BLOCK_SIZE 128
+#define SCDC_I2C_SLAVE_ADDRESS 0x54
 
 /* Aspect ratios used in EDID info. */
 enum edid_aspect {
@@ -34,6 +72,129 @@ enum edid_aspect {
 	ASPECT_5625,
 };
 
+struct est_timings {
+	u8 t1;
+	u8 t2;
+	u8 mfg_rsvd;
+} __packed;
+
+/* 00=16:10, 01=4:3, 10=5:4, 11=16:9 */
+#define EDID_TIMING_ASPECT_SHIFT 6
+#define EDID_TIMING_ASPECT_MASK  (0x3 << EDID_TIMING_ASPECT_SHIFT)
+
+/* need to add 60 */
+#define EDID_TIMING_VFREQ_SHIFT  0
+#define EDID_TIMING_VFREQ_MASK   (0x3f << EDID_TIMING_VFREQ_SHIFT)
+
+struct std_timing {
+	u8 hsize; /* need to multiply by 8 then add 248 */
+	u8 vfreq_aspect;
+} __packed;
+
+struct detailed_pixel_timing {
+	u8 hactive_lo;
+	u8 hblank_lo;
+	u8 hactive_hblank_hi;
+	u8 vactive_lo;
+	u8 vblank_lo;
+	u8 vactive_vblank_hi;
+	u8 hsync_offset_lo;
+	u8 hsync_pulse_width_lo;
+	u8 vsync_offset_pulse_width_lo;
+	u8 hsync_vsync_offset_pulse_width_hi;
+	u8 width_mm_lo;
+	u8 height_mm_lo;
+	u8 width_height_mm_hi;
+	u8 hborder;
+	u8 vborder;
+	u8 misc;
+} __packed;
+
+/* If it's not pixel timing, it'll be one of the below */
+struct detailed_data_string {
+	u8 str[13];
+} __packed;
+
+struct detailed_data_monitor_range {
+	u8 min_vfreq;
+	u8 max_vfreq;
+	u8 min_hfreq_khz;
+	u8 max_hfreq_khz;
+	u8 pixel_clock_mhz; /* need to multiply by 10 */
+	u8 flags;
+	union {
+		struct {
+			u8 reserved;
+			u8 hfreq_start_khz; /* need to multiply by 2 */
+			u8 c; /* need to divide by 2 */
+			__le16 m;
+			u8 k;
+			u8 j; /* need to divide by 2 */
+		} __packed gtf2;
+		struct {
+			u8 version;
+			u8 data1; /* high 6 bits: extra clock resolution */
+			u8 data2; /* plus low 2 of above: max hactive */
+			u8 supported_aspects;
+			u8 flags; /* preferred aspect and blanking support */
+			u8 supported_scalings;
+			u8 preferred_refresh;
+		} __packed cvt;
+	} formula;
+} __packed;
+
+struct detailed_data_wpindex {
+	u8 white_yx_lo; /* Lower 2 bits each */
+	u8 white_x_hi;
+	u8 white_y_hi;
+	u8 gamma; /* need to divide by 100 then add 1 */
+} __packed;
+
+struct detailed_data_color_point {
+	u8 windex1;
+	u8 wpindex1[3];
+	u8 windex2;
+	u8 wpindex2[3];
+} __packed;
+
+struct cvt_timing {
+	u8 code[3];
+} __packed;
+
+struct detailed_non_pixel {
+	u8 pad1;
+	u8 type; /* ff=serial, fe=string, fd=monitor range, fc=monitor name
+		  * fb=color point data, fa=standard timing data,
+		  * f9=undefined, f8=mfg. reserved
+		  */
+	u8 pad2;
+	union {
+		struct detailed_data_string str;
+		struct detailed_data_monitor_range range;
+		struct detailed_data_wpindex color;
+		struct std_timing timings[6];
+		struct cvt_timing cvt[4];
+	} data;
+} __packed;
+
+#define EDID_DETAIL_EST_TIMINGS 0xf7
+#define EDID_DETAIL_CVT_3BYTE 0xf8
+#define EDID_DETAIL_COLOR_MGMT_DATA 0xf9
+#define EDID_DETAIL_STD_MODES 0xfa
+#define EDID_DETAIL_MONITOR_CPDATA 0xfb
+#define EDID_DETAIL_MONITOR_NAME 0xfc
+#define EDID_DETAIL_MONITOR_RANGE 0xfd
+#define EDID_DETAIL_MONITOR_STRING 0xfe
+#define EDID_DETAIL_MONITOR_SERIAL 0xff
+
+struct detailed_timing {
+	__le16 pixel_clock; /* need to multiply by 10 KHz */
+	union {
+		struct detailed_pixel_timing pixel_data;
+		struct detailed_non_pixel other_data;
+	} data;
+} __packed;
+
 /* Detailed timing information used in EDID v1.x */
 struct edid_detailed_timing {
 	unsigned char pixel_clock[2];
@@ -125,6 +286,90 @@ struct edid_monitor_descriptor {
 	} data;
 } __attribute__ ((__packed__));
 
+#define DRM_EDID_INPUT_SERRATION_VSYNC (1 << 0)
+#define DRM_EDID_INPUT_SYNC_ON_GREEN   (1 << 1)
+#define DRM_EDID_INPUT_COMPOSITE_SYNC  (1 << 2)
+#define DRM_EDID_INPUT_SEPARATE_SYNCS  (1 << 3)
+#define DRM_EDID_INPUT_BLANK_TO_BLACK  (1 << 4)
+#define DRM_EDID_INPUT_VIDEO_LEVEL     (3 << 5)
+#define DRM_EDID_INPUT_DIGITAL         (1 << 7)
+#define DRM_EDID_DIGITAL_DEPTH_MASK    (7 << 4)
+#define DRM_EDID_DIGITAL_DEPTH_UNDEF   (0 << 4)
+#define DRM_EDID_DIGITAL_DEPTH_6       (1 << 4)
+#define DRM_EDID_DIGITAL_DEPTH_8       (2 << 4)
+#define DRM_EDID_DIGITAL_DEPTH_10      (3 << 4)
+#define DRM_EDID_DIGITAL_DEPTH_12      (4 << 4)
+#define DRM_EDID_DIGITAL_DEPTH_14      (5 << 4)
+#define DRM_EDID_DIGITAL_DEPTH_16      (6 << 4)
+#define DRM_EDID_DIGITAL_DEPTH_RSVD    (7 << 4)
+#define DRM_EDID_DIGITAL_TYPE_UNDEF    (0)
+#define DRM_EDID_DIGITAL_TYPE_DVI      (1)
+#define DRM_EDID_DIGITAL_TYPE_HDMI_A   (2)
+#define DRM_EDID_DIGITAL_TYPE_HDMI_B   (3)
+#define DRM_EDID_DIGITAL_TYPE_MDDI     (4)
+#define DRM_EDID_DIGITAL_TYPE_DP       (5)
+
+#define DRM_EDID_FEATURE_DEFAULT_GTF      (1 << 0)
+#define DRM_EDID_FEATURE_PREFERRED_TIMING (1 << 1)
+#define DRM_EDID_FEATURE_STANDARD_COLOR   (1 << 2)
+/* If analog */
+/* 00=mono, 01=rgb, 10=non-rgb, 11=unknown */
+#define DRM_EDID_FEATURE_DISPLAY_TYPE     (3 << 3)
+/* If digital */
+#define DRM_EDID_FEATURE_COLOR_MASK	  (3 << 3)
+#define DRM_EDID_FEATURE_RGB		  (0 << 3)
+#define DRM_EDID_FEATURE_RGB_YCRCB444	  (1 << 3)
+#define DRM_EDID_FEATURE_RGB_YCRCB422	  (2 << 3)
+/* both 4:4:4 and 4:2:2 */
+#define DRM_EDID_FEATURE_RGB_YCRCB	  (3 << 3)
+
+#define DRM_EDID_FEATURE_PM_ACTIVE_OFF    (1 << 5)
+#define DRM_EDID_FEATURE_PM_SUSPEND       (1 << 6)
+#define DRM_EDID_FEATURE_PM_STANDBY       (1 << 7)
+
+#define DRM_EDID_HDMI_DC_48               (1 << 6)
+#define DRM_EDID_HDMI_DC_36               (1 << 5)
+#define DRM_EDID_HDMI_DC_30               (1 << 4)
+#define DRM_EDID_HDMI_DC_Y444             (1 << 3)
+
+/* YCBCR 420 deep color modes */
+#define DRM_EDID_YCBCR420_DC_48		  (1 << 2)
+#define DRM_EDID_YCBCR420_DC_36		  (1 << 1)
+#define DRM_EDID_YCBCR420_DC_30		  (1 << 0)
+#define DRM_EDID_YCBCR420_DC_MASK (DRM_EDID_YCBCR420_DC_48 | \
+				    DRM_EDID_YCBCR420_DC_36 | \
+				    DRM_EDID_YCBCR420_DC_30)
+
+/* HDMI 2.1 additional fields */
+#define DRM_EDID_MAX_FRL_RATE_MASK		0xf0
+#define DRM_EDID_FAPA_START_LOCATION		BIT(0)
+#define DRM_EDID_ALLM				BIT(1)
+#define DRM_EDID_FVA				BIT(2)
+
+/* Deep Color specific */
+#define DRM_EDID_DC_30BIT_420			BIT(0)
+#define DRM_EDID_DC_36BIT_420			BIT(1)
+#define DRM_EDID_DC_48BIT_420			BIT(2)
+
+/* VRR specific */
+#define DRM_EDID_CNMVRR				BIT(3)
+#define DRM_EDID_CINEMA_VRR			BIT(4)
+#define DRM_EDID_MDELTA				BIT(5)
+#define DRM_EDID_VRR_MAX_UPPER_MASK		0xc0
+#define DRM_EDID_VRR_MAX_LOWER_MASK		0xff
+#define DRM_EDID_VRR_MIN_MASK			0x3f
+
+/* DSC specific */
+#define DRM_EDID_DSC_10BPC			BIT(0)
+#define DRM_EDID_DSC_12BPC			BIT(1)
+#define DRM_EDID_DSC_16BPC			BIT(2)
+#define DRM_EDID_DSC_ALL_BPP			BIT(3)
+#define DRM_EDID_DSC_NATIVE_420			BIT(6)
+#define DRM_EDID_DSC_1P2			BIT(7)
+#define DRM_EDID_DSC_MAX_FRL_RATE_MASK		0xf0
+#define DRM_EDID_DSC_MAX_SLICES			0xf
+#define DRM_EDID_DSC_TOTAL_CHUNK_KBYTES		0x3f
+
 struct edid1_info {
 	unsigned char header[8];
 	unsigned char manufacturer_name[2];
@@ -241,8 +486,19 @@ enum edid_cea861_db_types {
 	EDID_CEA861_DB_VIDEO = 0x02,
 	EDID_CEA861_DB_VENDOR = 0x03,
 	EDID_CEA861_DB_SPEAKER = 0x04,
+	EDID_CEA861_DB_USE_EXTENDED = 0x07,
 };
 
+#define EXT_VIDEO_CAPABILITY_BLOCK 0x00
+#define EXT_VIDEO_DATA_BLOCK_420        0x0E
+#define EXT_VIDEO_CAP_BLOCK_Y420CMDB 0x0F
+#define EDID_BASIC_AUDIO        BIT(6)
+#define EDID_CEA_YCRCB444       BIT(5)
+#define EDID_CEA_YCRCB422       BIT(4)
+#define EDID_CEA_VCDB_QS        BIT(6)
+
+#define EXT_VIDEO_DATA_BLOCK_420 0x0E
+
 struct edid_cea861_info {
 	unsigned char extension_tag;
 #define EDID_CEA861_EXTENSION_TAG	0x02
@@ -266,6 +522,431 @@ struct edid_cea861_info {
 	GET_BITS((_x).data[offset], 4, 0)
 } __attribute__ ((__packed__));
 
+#define DATA_BLOCK_PRODUCT_ID 0x00
+#define DATA_BLOCK_DISPLAY_PARAMETERS 0x01
+#define DATA_BLOCK_COLOR_CHARACTERISTICS 0x02
+#define DATA_BLOCK_TYPE_1_DETAILED_TIMING 0x03
+#define DATA_BLOCK_TYPE_2_DETAILED_TIMING 0x04
+#define DATA_BLOCK_TYPE_3_SHORT_TIMING 0x05
+#define DATA_BLOCK_TYPE_4_DMT_TIMING 0x06
+#define DATA_BLOCK_VESA_TIMING 0x07
+#define DATA_BLOCK_CEA_TIMING 0x08
+#define DATA_BLOCK_VIDEO_TIMING_RANGE 0x09
+#define DATA_BLOCK_PRODUCT_SERIAL_NUMBER 0x0a
+#define DATA_BLOCK_GP_ASCII_STRING 0x0b
+#define DATA_BLOCK_DISPLAY_DEVICE_DATA 0x0c
+#define DATA_BLOCK_INTERFACE_POWER_SEQUENCING 0x0d
+#define DATA_BLOCK_TRANSFER_CHARACTERISTICS 0x0e
+#define DATA_BLOCK_DISPLAY_INTERFACE 0x0f
+#define DATA_BLOCK_STEREO_DISPLAY_INTERFACE 0x10
+#define DATA_BLOCK_TILED_DISPLAY 0x12
+
+struct displayid_hdr {
+	u8 rev;
+	u8 bytes;
+	u8 prod_id;
+	u8 ext_count;
+} __packed;
+
+struct displayid_block {
+	u8 tag;
+	u8 rev;
+	u8 num_bytes;
+} __packed;
+
+struct displayid_detailed_timings_1 {
+	u8 pixel_clock[3];
+	u8 flags;
+	u8 hactive[2];
+	u8 hblank[2];
+	u8 hsync[2];
+	u8 hsw[2];
+	u8 vactive[2];
+	u8 vblank[2];
+	u8 vsync[2];
+	u8 vsw[2];
+} __packed;
+
+struct displayid_detailed_timing_block {
+	struct displayid_block base;
+	struct displayid_detailed_timings_1 timings[0];
+};
+
+/**
+ * struct drm_scrambling: sink's scrambling support.
+ */
+struct drm_scrambling {
+	/**
+	 * @supported: scrambling supported for rates > 340 Mhz.
+	 */
+	bool supported;
+	/**
+	 * @low_rates: scrambling supported for rates <= 340 Mhz.
+	 */
+	bool low_rates;
+};
+
+/**
+ * struct drm_scdc - Information about scdc capabilities of a HDMI 2.0 sink
+ *
+ * Provides SCDC register support and capabilities related information on a
+ * HDMI 2.0 sink. In case of a HDMI 1.4 sink, all parameter must be 0.
+ */
+
+struct drm_scdc {
+	/**
+	 * @supported: status control & data channel present.
+	 */
+	bool supported;
+	/**
+	 * @read_request: sink is capable of generating scdc read request.
+	 */
+	bool read_request;
+	/**
+	 * @scrambling: sink's scrambling capabilities
+	 */
+	struct drm_scrambling scrambling;
+};
+
+/**
+ * struct drm_hdmi_dsc_cap - DSC capabilities of HDMI sink
+ *
+ * Describes the DSC support provided by HDMI 2.1 sink.
+ * The information is fetched fom additional HFVSDB blocks defined
+ * for HDMI 2.1.
+ */
+struct drm_hdmi_dsc_cap {
+	/** @v_1p2: flag for dsc1.2 version support by sink */
+	bool v_1p2;
+
+	/** @native_420: Does sink support DSC with 4:2:0 compression */
+	bool native_420;
+
+	/**
+	 * @all_bpp: Does sink support all bpp with 4:4:4: or 4:2:2
+	 * compressed formats
+	 */
+	bool all_bpp;
+
+	/**
+	 * @bpc_supported: compressed bpc supported by sink : 10, 12 or 16 bpc
+	 */
+	u8 bpc_supported;
+
+	/** @max_slices: maximum number of Horizontal slices supported by */
+	u8 max_slices;
+
+	/** @clk_per_slice : max pixel clock in MHz supported per slice */
+	int clk_per_slice;
+
+	/** @max_lanes : dsc max lanes supported for Fixed rate Link training */
+	u8 max_lanes;
+
+	/** @max_frl_rate_per_lane : maximum frl rate with DSC per lane */
+	u8 max_frl_rate_per_lane;
+
+	/** @total_chunk_kbytes: max size of chunks in KBs supported per line*/
+	u8 total_chunk_kbytes;
+};
+
+/**
+ * struct drm_hdmi_info - runtime information about the connected HDMI sink
+ *
+ * Describes if a given display supports advanced HDMI 2.0 features.
+ * This information is available in CEA-861-F extension blocks (like HF-VSDB).
+ */
+struct drm_hdmi_info {
+	struct drm_scdc scdc;
+
+	/**
+	 * @y420_vdb_modes: bitmap of modes which can support ycbcr420
+	 * output only (not normal RGB/YCBCR444/422 outputs). There are total
+	 * 107 VICs defined by CEA-861-F spec, so the size is 128 bits to map
+	 * upto 128 VICs;
+	 */
+	unsigned long y420_vdb_modes[BITS_TO_LONGS(128)];
+
+	/**
+	 * @y420_cmdb_modes: bitmap of modes which can support ycbcr420
+	 * output also, along with normal HDMI outputs. There are total 107
+	 * VICs defined by CEA-861-F spec, so the size is 128 bits to map upto
+	 * 128 VICs;
+	 */
+	unsigned long y420_cmdb_modes[BITS_TO_LONGS(128)];
+
+	/** @y420_cmdb_map: bitmap of SVD index, to extraxt vcb modes */
+	u64 y420_cmdb_map;
+
+	/** @y420_dc_modes: bitmap of deep color support index */
+	u8 y420_dc_modes;
+
+	/** @max_frl_rate_per_lane: support fixed rate link */
+	u8 max_frl_rate_per_lane;
+
+	/** @max_lanes: supported by sink */
+	u8 max_lanes;
+
+	/* @add_func: support hdmi2.1 function */
+	u8 add_func;
+
+	/** @dsc_cap: DSC capabilities of the sink */
+	struct drm_hdmi_dsc_cap dsc_cap;
+};
+
+enum subpixel_order {
+	subpixelunknown = 0,
+	subpixelhorizontalrgb,
+	subpixelhorizontalbgr,
+	subpixelverticalrgb,
+	subpixelverticalbgr,
+	subpixelnone,
+};
+
+#define DRM_COLOR_FORMAT_RGB444         BIT(0)
+#define DRM_COLOR_FORMAT_YCRCB444       BIT(1)
+#define DRM_COLOR_FORMAT_YCRCB422       BIT(2)
+#define DRM_COLOR_FORMAT_YCRCB420       BIT(3)
+
+/*
+ * Describes a given display (e.g. CRT or flat panel) and its limitations.
+ */
+struct drm_display_info {
+	char name[32];
+
+	/* Physical size */
+	unsigned int width_mm;
+	unsigned int height_mm;
+
+	/* Clock limits FIXME: storage format */
+	unsigned int min_vfreq, max_vfreq;
+	unsigned int min_hfreq, max_hfreq;
+	unsigned int pixel_clock;
+	unsigned int bpc;
+
+	enum subpixel_order subpixel_order;
+	u32 color_formats;
+
+	const u32 *bus_formats;
+	unsigned int num_bus_formats;
+
+	/**
+	 * @max_tmds_clock: Maximum TMDS clock rate supported by the
+	 * sink in kHz. 0 means undefined.
+	 */
+	int max_tmds_clock;
+
+	/**
+	 * @dvi_dual: Dual-link DVI sink?
+	 */
+	bool dvi_dual;
+
+	/* Mask of supported hdmi deep color modes */
+	u8 edid_hdmi_dc_modes;
+
+	u8 cea_rev;
+
+	/**
+	 * @hdmi: advance features of a HDMI sink.
+	 */
+	struct drm_hdmi_info hdmi;
+};
+
+struct edid {
+	u8 header[8];
+	/* Vendor & product info */
+	u8 mfg_id[2];
+	u8 prod_code[2];
+	u32 serial; /* FIXME: byte order */
+	u8 mfg_week;
+	u8 mfg_year;
+	/* EDID version */
+	u8 version;
+	u8 revision;
+	/* Display info: */
+	u8 input;
+	u8 width_cm;
+	u8 height_cm;
+	u8 gamma;
+	u8 features;
+	/* Color characteristics */
+	u8 red_green_lo;
+	u8 black_white_lo;
+	u8 red_x;
+	u8 red_y;
+	u8 green_x;
+	u8 green_y;
+	u8 blue_x;
+	u8 blue_y;
+	u8 white_x;
+	u8 white_y;
+	/* Est. timings and mfg rsvd timings*/
+	struct est_timings established_timings;
+	/* Standard timings 1-8*/
+	struct std_timing standard_timings[8];
+	/* Detailing timings 1-4 */
+	struct detailed_timing detailed_timings[4];
+	/* Number of 128 byte ext. blocks */
+	u8 extensions;
+	/* Checksum */
+	u8 checksum;
+} __packed;
+
+enum base_output_format {
+	DRM_HDMI_OUTPUT_DEFAULT_RGB, /* default RGB */
+	DRM_HDMI_OUTPUT_YCBCR444, /* YCBCR 444 */
+	DRM_HDMI_OUTPUT_YCBCR422, /* YCBCR 422 */
+	DRM_HDMI_OUTPUT_YCBCR420, /* YCBCR 420 */
+	/* (YCbCr444 > YCbCr422 > YCbCr420 > RGB) */
+	DRM_HDMI_OUTPUT_YCBCR_HQ,
+	/* (YCbCr420 > YCbCr422 > YCbCr444 > RGB) */
+	DRM_HDMI_OUTPUT_YCBCR_LQ,
+	DRM_HDMI_OUTPUT_INVALID, /* Guess what ? */
+};
+
+enum  base_output_depth {
+	AUTOMATIC = 0,
+	DEPTH_24BIT = 8,
+	DEPTH_30BIT = 10,
+};
+
+struct base_bcsh_info {
+	unsigned short brightness;
+	unsigned short contrast;
+	unsigned short saturation;
+	unsigned short hue;
+};
+
+struct base_overscan {
+	unsigned int maxvalue;
+	unsigned short leftscale;
+	unsigned short rightscale;
+	unsigned short topscale;
+	unsigned short bottomscale;
+};
+
+struct base_drm_display_mode {
+	int clock;		/* in kHz */
+	int hdisplay;
+	int hsync_start;
+	int hsync_end;
+	int htotal;
+	int vdisplay;
+	int vsync_start;
+	int vsync_end;
+	int vtotal;
+	int vrefresh;
+	int vscan;
+	unsigned int flags;
+	int picture_aspect_ratio;
+};
+
+struct base_screen_info {
+	int type;
+	struct base_drm_display_mode mode;	/* 52 bytes */
+	enum base_output_format  format;	/* 4 bytes */
+	enum base_output_depth depth;		/* 4 bytes */
+	unsigned int feature;			/* 4 bytes */
+};
+
+struct base_disp_info {
+	struct base_screen_info screen_list[5];
+	struct base_overscan scan;		/* 12 bytes */
+};
+
+struct base2_cubic_lut_data {
+	u16 size;
+	u16 lred[4913];
+	u16 lgreen[4913];
+	u16 lblue[4913];
+};
+
+struct base2_screen_info {
+	u32 type;
+	u32 id;
+	struct base_drm_display_mode resolution;
+	enum base_output_format  format;
+	enum base_output_depth depthc;
+	u32 feature;
+};
+
+struct base2_gamma_lut_data {
+	u16 size;
+	u16 lred[1024];
+	u16 lgreen[1024];
+	u16 lblue[1024];
+};
+
+struct framebuffer_info {
+	u32 framebuffer_width;
+	u32 framebuffer_height;
+	u32 fps;
+};
+
+struct csc_info {
+	u16 hue;
+	u16 saturation;
+	u16 contrast;
+	u16 brightness;
+	u16 r_gain;
+	u16 g_gain;
+	u16 b_gain;
+	u16 r_offset;
+	u16 g_offset;
+	u16 b_offset;
+	u16 csc_enable;
+};
+
+
+#define ACM_GAIN_LUT_HY_LENGTH		(9*17)
+#define ACM_GAIN_LUT_HY_TOTAL_LENGTH	(ACM_GAIN_LUT_HY_LENGTH * 3)
+#define ACM_GAIN_LUT_HS_LENGTH		(13*17)
+#define ACM_GAIN_LUT_HS_TOTAL_LENGTH (ACM_GAIN_LUT_HS_LENGTH * 3)
+#define ACM_DELTA_LUT_H_LENGTH		65
+#define ACM_DELTA_LUT_H_TOTAL_LENGTH	(ACM_DELTA_LUT_H_LENGTH * 3)
+
+struct acm_data {
+	s16 delta_lut_h[ACM_DELTA_LUT_H_TOTAL_LENGTH];
+	s16 gain_lut_hy[ACM_GAIN_LUT_HY_TOTAL_LENGTH];
+	s16 gain_lut_hs[ACM_GAIN_LUT_HS_TOTAL_LENGTH];
+	u16 y_gain;
+	u16 h_gain;
+	u16 s_gain;
+	u16 acm_enable;
+};
+
+struct base2_disp_info {
+	char disp_head_flag[6];
+	struct base2_screen_info screen_info[4];
+	struct base_bcsh_info bcsh_info;
+	struct base_overscan overscan_info;
+	struct base2_gamma_lut_data gamma_lut_data;
+	struct base2_cubic_lut_data cubic_lut_data;
+	struct framebuffer_info framebuffer_info;
+	u32 cacm_header;
+	u32 reserved[243];
+	u32 crc;
+	/* baseparameter version 3.0 add */
+	struct csc_info csc_info;
+	struct acm_data acm_data;
+	u8 resv2[10*1024]; /* */
+	u32 crc2;
+	/* baseparameter version 3.0 add */
+};
+
+struct base2_disp_header {
+	u32 connector_type;
+	u32 connector_id;
+	u32 offset;
+};
+
+struct base2_info {
+	char head_flag[4];
+	u16 major_version;
+	u16 minor_version;
+	struct base2_disp_header disp_header[8];
+	struct base2_disp_info disp_info[8];
+};
+
 /**
  * Print the EDID info.
  *
@@ -277,7 +958,7 @@ void edid_print_info(struct edid1_info *edid_info);
  * Check the EDID info.
  *
  * @param info  The EDID info to be checked
- * Return: 0 on valid, or -1 on invalid
+ * @return 0 on valid, or -1 on invalid
  */
 int edid_check_info(struct edid1_info *info);
 
@@ -286,7 +967,7 @@ int edid_check_info(struct edid1_info *info);
  *
  * @param edid_block	EDID block data
  *
- * Return: 0 on success, or a negative errno on error
+ * @return 0 on success, or a negative errno on error
  */
 int edid_check_checksum(u8 *edid_block);
 
@@ -295,17 +976,32 @@ int edid_check_checksum(u8 *edid_block);
  *
  * @param edid	The EDID info
  * @param hmin	Returns the minimum horizontal rate
- * @param hmax	Returns the maxium horizontal rate
+ * @param hmax	Returns the maximum horizontal rate
  * @param vmin	Returns the minimum vertical rate
- * @param vmax	Returns the maxium vertical rate
- * Return: 0 on success, or -1 on error
+ * @param vmax	Returns the maximum vertical rate
+ * @return 0 on success, or -1 on error
  */
 int edid_get_ranges(struct edid1_info *edid, unsigned int *hmin,
 		    unsigned int *hmax, unsigned int *vmin,
 		    unsigned int *vmax);
 
+struct drm_display_mode;
 struct display_timing;
 
+struct hdmi_edid_data {
+	struct drm_display_mode *preferred_mode;
+	int modes;
+	struct drm_display_mode *mode_buf;
+	struct drm_display_info display_info;
+};
+
+struct ddc_adapter {
+	int (*ddc_xfer)(struct ddc_adapter *adap, struct i2c_msg *msgs,
+			int num);
+	struct udevice *i2c_bus;
+	struct dm_i2c_ops *ops;
+};
+
 /**
  * edid_get_timing_validate() - Get basic digital display parameters with
  * mode selection callback
@@ -337,9 +1033,29 @@ int edid_get_timing_validate(u8 *buf, int buf_size,
  * @param panel_bits_per_colourp	Place to put the number of bits per
  *			colour supported by the panel. This will be set to
  *			-1 if not available
- * Return: 0 if timings are OK, -ve on error
+ * @return 0 if timings are OK, -ve on error
  */
 int edid_get_timing(u8 *buf, int buf_size, struct display_timing *timing,
 		    int *panel_bits_per_colourp);
+int edid_get_drm_mode(u8 *buf, int buf_size, struct drm_display_mode *mode,
+		      int *panel_bits_per_colourp);
+int drm_add_edid_modes(struct hdmi_edid_data *data, u8 *edid);
+void drm_add_hdmi_modes(struct hdmi_edid_data *data,
+			const struct drm_display_mode *mode);
+bool drm_detect_hdmi_monitor(struct edid *edid);
+bool drm_detect_monitor_audio(struct edid *edid);
+int do_cea_modes(struct hdmi_edid_data *data, const u8 *db, u8 len);
+int drm_do_get_edid(struct ddc_adapter *adap, u8 *edid);
+enum hdmi_quantization_range
+drm_default_rgb_quant_range(struct drm_display_mode *mode);
+u8 drm_scdc_readb(struct ddc_adapter *adap, u8 offset,
+		  u8 *value);
+u8 drm_scdc_writeb(struct ddc_adapter *adap, u8 offset,
+		   u8 value);
+void drm_mode_sort(struct hdmi_edid_data *edid_data);
+int drm_mode_prune_invalid(struct hdmi_edid_data *edid_data);
+void drm_rk_filter_whitelist(struct hdmi_edid_data *edid_data);
+void drm_rk_select_mode(struct hdmi_edid_data *edid_data,
+			struct base_screen_info *screen_info);
 
 #endif /* __EDID_H_ */
diff --git a/include/fdt_support.h b/include/fdt_support.h
index 4b71b8948d..2c775941f8 100644
--- a/include/fdt_support.h
+++ b/include/fdt_support.h
@@ -129,6 +129,8 @@ static inline int fdt_fixup_memory_banks(void *blob, u64 start[], u64 size[],
 }
 #endif
 
+int fdt_update_reserved_memory(void *blob, char *name, u64 start, u64 size);
+
 void fdt_fixup_ethernet(void *fdt);
 int fdt_find_and_setprop(void *fdt, const char *node, const char *prop,
 			 const void *val, int len, int create);
diff --git a/include/fixp-arith.h b/include/fixp-arith.h
new file mode 100644
index 0000000000..7d7719a634
--- /dev/null
+++ b/include/fixp-arith.h
@@ -0,0 +1,90 @@
+#ifndef _FIXP_ARITH_H
+#define _FIXP_ARITH_H
+
+/*
+ * Simplistic fixed-point arithmetics.
+ * Hmm, I'm probably duplicating some code :(
+ *
+ * Copyright (c) 2002 Johann Deneux
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#include <linux/types.h>
+
+static const s32 sin_table[] = {
+	0x00000000, 0x023be165, 0x04779632, 0x06b2f1d2, 0x08edc7b6, 0x0b27eb5c,
+	0x0d61304d, 0x0f996a26, 0x11d06c96, 0x14060b67, 0x163a1a7d, 0x186c6ddd,
+	0x1a9cd9ac, 0x1ccb3236, 0x1ef74bf2, 0x2120fb82, 0x234815ba, 0x256c6f9e,
+	0x278dde6e, 0x29ac379f, 0x2bc750e8, 0x2ddf003f, 0x2ff31bdd, 0x32037a44,
+	0x340ff241, 0x36185aee, 0x381c8bb5, 0x3a1c5c56, 0x3c17a4e7, 0x3e0e3ddb,
+	0x3fffffff, 0x41ecc483, 0x43d464fa, 0x45b6bb5d, 0x4793a20f, 0x496af3e1,
+	0x4b3c8c11, 0x4d084650, 0x4ecdfec6, 0x508d9210, 0x5246dd48, 0x53f9be04,
+	0x55a6125a, 0x574bb8e5, 0x58ea90c2, 0x5a827999, 0x5c135399, 0x5d9cff82,
+	0x5f1f5ea0, 0x609a52d1, 0x620dbe8a, 0x637984d3, 0x64dd894f, 0x6639b039,
+	0x678dde6d, 0x68d9f963, 0x6a1de735, 0x6b598ea1, 0x6c8cd70a, 0x6db7a879,
+	0x6ed9eba0, 0x6ff389de, 0x71046d3c, 0x720c8074, 0x730baeec, 0x7401e4bf,
+	0x74ef0ebb, 0x75d31a5f, 0x76adf5e5, 0x777f903b, 0x7847d908, 0x7906c0af,
+	0x79bc384c, 0x7a6831b8, 0x7b0a9f8c, 0x7ba3751c, 0x7c32a67c, 0x7cb82884,
+	0x7d33f0c8, 0x7da5f5a3, 0x7e0e2e31, 0x7e6c924f, 0x7ec11aa3, 0x7f0bc095,
+	0x7f4c7e52, 0x7f834ecf, 0x7fb02dc4, 0x7fd317b3, 0x7fec09e1, 0x7ffb025e,
+	0x7fffffff
+};
+
+/**
+ * __fixp_sin32() returns the sin of an angle in degrees
+ *
+ * @degrees: angle, in degrees, from 0 to 360.
+ *
+ * The returned value ranges from -0x7fffffff to +0x7fffffff.
+ */
+static inline s32 __fixp_sin32(int degrees)
+{
+	s32 ret;
+	bool negative = false;
+
+	if (degrees > 180) {
+		negative = true;
+		degrees -= 180;
+	}
+	if (degrees > 90)
+		degrees = 180 - degrees;
+
+	ret = sin_table[degrees];
+
+	return negative ? -ret : ret;
+}
+
+/**
+ * fixp_sin32() returns the sin of an angle in degrees
+ *
+ * @degrees: angle, in degrees. The angle can be positive or negative
+ *
+ * The returned value ranges from -0x7fffffff to +0x7fffffff.
+ */
+static inline s32 fixp_sin32(int degrees)
+{
+	degrees = (degrees % 360 + 360) % 360;
+
+	return __fixp_sin32(degrees);
+}
+
+/* cos(x) = sin(x + 90 degrees) */
+#define fixp_cos32(v) fixp_sin32((v) + 90)
+
+/*
+ * 16 bits variants
+ *
+ * The returned value ranges from -0x7fff to 0x7fff
+ */
+
+#define fixp_sin16(v) (fixp_sin32(v) >> 16)
+#define fixp_cos16(v) (fixp_cos32(v) >> 16)
+
+#endif
diff --git a/include/linux/dw_hdmi.h b/include/linux/dw_hdmi.h
new file mode 100644
index 0000000000..3d15ead54d
--- /dev/null
+++ b/include/linux/dw_hdmi.h
@@ -0,0 +1,192 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc.
+ * (C) Copyright 2008-2017 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+#ifndef __DW_HDMI__
+#define __DW_HDMI__
+
+struct dw_hdmi;
+struct drm_display_mode;
+struct ddc_adapter;
+struct i2c_msg;
+
+/**
+ * DOC: Supported input formats and encodings
+ *
+ * Depending on the Hardware configuration of the Controller IP, it supports
+ * a subset of the following input formats and encodings on its internal
+ * 48bit bus.
+ *
+ * +----------------------+----------------------------------+------------------------------+
+ * + Format Name          + Format Code                      + Encodings                    +
+ * +----------------------+----------------------------------+------------------------------+
+ * + RGB 4:4:4 8bit       + ``MEDIA_BUS_FMT_RGB888_1X24``    + ``V4L2_YCBCR_ENC_DEFAULT``   +
+ * +----------------------+----------------------------------+------------------------------+
+ * + RGB 4:4:4 10bits     + ``MEDIA_BUS_FMT_RGB101010_1X30`` + ``V4L2_YCBCR_ENC_DEFAULT``   +
+ * +----------------------+----------------------------------+------------------------------+
+ * + RGB 4:4:4 12bits     + ``MEDIA_BUS_FMT_RGB121212_1X36`` + ``V4L2_YCBCR_ENC_DEFAULT``   +
+ * +----------------------+----------------------------------+------------------------------+
+ * + RGB 4:4:4 16bits     + ``MEDIA_BUS_FMT_RGB161616_1X48`` + ``V4L2_YCBCR_ENC_DEFAULT``   +
+ * +----------------------+----------------------------------+------------------------------+
+ * + YCbCr 4:4:4 8bit     + ``MEDIA_BUS_FMT_YUV8_1X24``      + ``V4L2_YCBCR_ENC_601``       +
+ * +                      +                                  + or ``V4L2_YCBCR_ENC_709``    +
+ * +                      +                                  + or ``V4L2_YCBCR_ENC_XV601``  +
+ * +                      +                                  + or ``V4L2_YCBCR_ENC_XV709``  +
+ * +----------------------+----------------------------------+------------------------------+
+ * + YCbCr 4:4:4 10bits   + ``MEDIA_BUS_FMT_YUV10_1X30``     + ``V4L2_YCBCR_ENC_601``       +
+ * +                      +                                  + or ``V4L2_YCBCR_ENC_709``    +
+ * +                      +                                  + or ``V4L2_YCBCR_ENC_XV601``  +
+ * +                      +                                  + or ``V4L2_YCBCR_ENC_XV709``  +
+ * +----------------------+----------------------------------+------------------------------+
+ * + YCbCr 4:4:4 12bits   + ``MEDIA_BUS_FMT_YUV12_1X36``     + ``V4L2_YCBCR_ENC_601``       +
+ * +                      +                                  + or ``V4L2_YCBCR_ENC_709``    +
+ * +                      +                                  + or ``V4L2_YCBCR_ENC_XV601``  +
+ * +                      +                                  + or ``V4L2_YCBCR_ENC_XV709``  +
+ * +----------------------+----------------------------------+------------------------------+
+ * + YCbCr 4:4:4 16bits   + ``MEDIA_BUS_FMT_YUV16_1X48``     + ``V4L2_YCBCR_ENC_601``       +
+ * +                      +                                  + or ``V4L2_YCBCR_ENC_709``    +
+ * +                      +                                  + or ``V4L2_YCBCR_ENC_XV601``  +
+ * +                      +                                  + or ``V4L2_YCBCR_ENC_XV709``  +
+ * +----------------------+----------------------------------+------------------------------+
+ * + YCbCr 4:2:2 8bit     + ``MEDIA_BUS_FMT_UYVY8_1X16``     + ``V4L2_YCBCR_ENC_601``       +
+ * +                      +                                  + or ``V4L2_YCBCR_ENC_709``    +
+ * +----------------------+----------------------------------+------------------------------+
+ * + YCbCr 4:2:2 10bits   + ``MEDIA_BUS_FMT_UYVY10_1X20``    + ``V4L2_YCBCR_ENC_601``       +
+ * +                      +                                  + or ``V4L2_YCBCR_ENC_709``    +
+ * +----------------------+----------------------------------+------------------------------+
+ * + YCbCr 4:2:2 12bits   + ``MEDIA_BUS_FMT_UYVY12_1X24``    + ``V4L2_YCBCR_ENC_601``       +
+ * +                      +                                  + or ``V4L2_YCBCR_ENC_709``    +
+ * +----------------------+----------------------------------+------------------------------+
+ * + YCbCr 4:2:0 8bit     + ``MEDIA_BUS_FMT_UYYVYY8_0_5X24`` + ``V4L2_YCBCR_ENC_601``       +
+ * +                      +                                  + or ``V4L2_YCBCR_ENC_709``    +
+ * +----------------------+----------------------------------+------------------------------+
+ * + YCbCr 4:2:0 10bits   + ``MEDIA_BUS_FMT_UYYVYY10_0_5X30``+ ``V4L2_YCBCR_ENC_601``       +
+ * +                      +                                  + or ``V4L2_YCBCR_ENC_709``    +
+ * +----------------------+----------------------------------+------------------------------+
+ * + YCbCr 4:2:0 12bits   + ``MEDIA_BUS_FMT_UYYVYY12_0_5X36``+ ``V4L2_YCBCR_ENC_601``       +
+ * +                      +                                  + or ``V4L2_YCBCR_ENC_709``    +
+ * +----------------------+----------------------------------+------------------------------+
+ * + YCbCr 4:2:0 16bits   + ``MEDIA_BUS_FMT_UYYVYY16_0_5X48``+ ``V4L2_YCBCR_ENC_601``       +
+ * +                      +                                  + or ``V4L2_YCBCR_ENC_709``    +
+ * +----------------------+----------------------------------+------------------------------+
+ */
+
+enum {
+	DW_HDMI_RES_8,
+	DW_HDMI_RES_10,
+	DW_HDMI_RES_12,
+	DW_HDMI_RES_MAX,
+};
+
+enum dw_hdmi_devtype {
+	IMX6Q_HDMI,
+	IMX6DL_HDMI,
+	RK3228_HDMI,
+	RK3288_HDMI,
+	RK3328_HDMI,
+	RK3366_HDMI,
+	RK3368_HDMI,
+	RK3399_HDMI,
+	RK3528_HDMI,
+	RK3568_HDMI,
+};
+
+struct dw_hdmi_audio_tmds_n {
+	unsigned long tmds;
+	unsigned int n_32k;
+	unsigned int n_44k1;
+	unsigned int n_48k;
+};
+
+enum dw_hdmi_phy_type {
+	DW_HDMI_PHY_DWC_HDMI_TX_PHY = 0x00,
+	DW_HDMI_PHY_DWC_MHL_PHY_HEAC = 0xb2,
+	DW_HDMI_PHY_DWC_MHL_PHY = 0xc2,
+	DW_HDMI_PHY_DWC_HDMI_3D_TX_PHY_HEAC = 0xe2,
+	DW_HDMI_PHY_DWC_HDMI_3D_TX_PHY = 0xf2,
+	DW_HDMI_PHY_DWC_HDMI20_TX_PHY = 0xf3,
+	DW_HDMI_PHY_VENDOR_PHY = 0xfe,
+};
+
+struct dw_hdmi_mpll_config {
+	unsigned long mpixelclock;
+	struct {
+		u16 cpce;
+		u16 gmp;
+	} res[DW_HDMI_RES_MAX];
+};
+
+struct dw_hdmi_curr_ctrl {
+	unsigned long mpixelclock;
+	u16 curr[DW_HDMI_RES_MAX];
+};
+
+struct dw_hdmi_phy_config {
+	unsigned long mpixelclock;
+	u16 sym_ctr;    /*clock symbol and transmitter control*/
+	u16 term;       /*transmission termination value*/
+	u16 vlev_ctr;   /* voltage level control */
+};
+
+struct rockchip_connector;
+struct dw_hdmi_phy_ops {
+	int (*init)(struct rockchip_connector *conn, struct dw_hdmi *hdmi, void *data);
+	void (*disable)(struct rockchip_connector *conn, struct dw_hdmi *hdmi, void *data);
+	enum drm_connector_status (*read_hpd)(struct dw_hdmi *hdmi,
+					      void *data);
+	void (*mode_valid)(struct rockchip_connector *conn, struct dw_hdmi *hdmi, void *data);
+};
+
+struct dw_hdmi_qp_phy_ops {
+	int (*init)(struct rockchip_connector *conn, void *hdmi, void *data);
+	void (*disable)(struct rockchip_connector *conn, void *hdmi, void *data);
+	enum drm_connector_status (*read_hpd)(void *data);
+	void (*mode_valid)(void *hdmi, void *data);
+	void (*set_pll)(struct rockchip_connector *conn, void *hdmi, void *data);
+};
+
+struct dw_hdmi_link_config {
+	bool dsc_mode;
+	bool frl_mode;
+	int frl_lanes;
+	int rate_per_lane;
+	int hcactive;
+	bool allm_en;
+	u8 pps_payload[128];
+};
+
+struct dw_hdmi_plat_data {
+	enum dw_hdmi_devtype dev_type;
+	unsigned long input_bus_format;
+	unsigned long input_bus_encoding;
+	u32 vop_sel_bit;
+	u32 grf_vop_sel_reg;
+	/* Vendor PHY support */
+	const struct dw_hdmi_phy_ops *phy_ops;
+	const struct dw_hdmi_qp_phy_ops *qp_phy_ops;
+	const struct dw_hdmi_audio_tmds_n *tmds_n_table;
+	const char *phy_name;
+	void *phy_data;
+	void *hdmi;
+
+	/* Synopsys PHY support */
+	const struct dw_hdmi_mpll_config *mpll_cfg;
+	const struct dw_hdmi_mpll_config *mpll_cfg_420;
+	const struct dw_hdmi_curr_ctrl *cur_ctr;
+	struct dw_hdmi_phy_config *phy_config;
+	int (*configure_phy)(struct dw_hdmi *hdmi,
+			     const struct dw_hdmi_plat_data *pdata,
+			     unsigned long mpixelclock);
+	unsigned long (*get_input_bus_format)(void *data);
+	unsigned long (*get_output_bus_format)(void *data);
+	unsigned long (*get_enc_in_encoding)(void *data);
+	unsigned long (*get_enc_out_encoding)(void *data);
+	unsigned long (*get_quant_range)(void *data);
+};
+
+#endif /* __IMX_HDMI_H__ */
diff --git a/include/linux/hdmi.h b/include/linux/hdmi.h
new file mode 100644
index 0000000000..d977eabadd
--- /dev/null
+++ b/include/linux/hdmi.h
@@ -0,0 +1,376 @@
+/*
+ * Copyright (C) 2012 Avionic Design GmbH
+ * (C) Copyright 2008-2017 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef __LINUX_HDMI_H_
+#define __LINUX_HDMI_H_
+
+#include <linux/types.h>
+#include <drm_modes.h>
+
+enum hdmi_infoframe_type {
+	HDMI_INFOFRAME_TYPE_VENDOR = 0x81,
+	HDMI_INFOFRAME_TYPE_AVI = 0x82,
+	HDMI_INFOFRAME_TYPE_SPD = 0x83,
+	HDMI_INFOFRAME_TYPE_AUDIO = 0x84,
+	HDMI_INFOFRAME_TYPE_DRM = 0x87,
+};
+
+#define HDMI_IEEE_OUI 0x000c03
+#define HDMI_FORUM_IEEE_OUI 0xc45dd8
+#define HDMI_INFOFRAME_HEADER_SIZE  4
+#define HDMI_AVI_INFOFRAME_SIZE    13
+#define HDMI_SPD_INFOFRAME_SIZE    25
+#define HDMI_AUDIO_INFOFRAME_SIZE  10
+
+#define HDMI_INFOFRAME_SIZE(type)	\
+	(HDMI_INFOFRAME_HEADER_SIZE + HDMI_ ## type ## _INFOFRAME_SIZE)
+
+struct hdmi_any_infoframe {
+	enum hdmi_infoframe_type type;
+	unsigned char version;
+	unsigned char length;
+};
+
+enum hdmi_colorspace {
+	HDMI_COLORSPACE_RGB,
+	HDMI_COLORSPACE_YUV422,
+	HDMI_COLORSPACE_YUV444,
+	HDMI_COLORSPACE_YUV420,
+	HDMI_COLORSPACE_RESERVED4,
+	HDMI_COLORSPACE_RESERVED5,
+	HDMI_COLORSPACE_RESERVED6,
+	HDMI_COLORSPACE_IDO_DEFINED,
+};
+
+enum hdmi_scan_mode {
+	HDMI_SCAN_MODE_NONE,
+	HDMI_SCAN_MODE_OVERSCAN,
+	HDMI_SCAN_MODE_UNDERSCAN,
+	HDMI_SCAN_MODE_RESERVED,
+};
+
+enum hdmi_colorimetry {
+	HDMI_COLORIMETRY_NONE,
+	HDMI_COLORIMETRY_ITU_601,
+	HDMI_COLORIMETRY_ITU_709,
+	HDMI_COLORIMETRY_EXTENDED,
+};
+
+enum hdmi_picture_aspect {
+	HDMI_PICTURE_ASPECT_NONE,
+	HDMI_PICTURE_ASPECT_4_3,
+	HDMI_PICTURE_ASPECT_16_9,
+	HDMI_PICTURE_ASPECT_64_27,
+	HDMI_PICTURE_ASPECT_256_135,
+	HDMI_PICTURE_ASPECT_RESERVED,
+};
+
+enum hdmi_active_aspect {
+	HDMI_ACTIVE_ASPECT_16_9_TOP = 2,
+	HDMI_ACTIVE_ASPECT_14_9_TOP = 3,
+	HDMI_ACTIVE_ASPECT_16_9_CENTER = 4,
+	HDMI_ACTIVE_ASPECT_PICTURE = 8,
+	HDMI_ACTIVE_ASPECT_4_3 = 9,
+	HDMI_ACTIVE_ASPECT_16_9 = 10,
+	HDMI_ACTIVE_ASPECT_14_9 = 11,
+	HDMI_ACTIVE_ASPECT_4_3_SP_14_9 = 13,
+	HDMI_ACTIVE_ASPECT_16_9_SP_14_9 = 14,
+	HDMI_ACTIVE_ASPECT_16_9_SP_4_3 = 15,
+};
+
+enum hdmi_extended_colorimetry {
+	HDMI_EXTENDED_COLORIMETRY_XV_YCC_601,
+	HDMI_EXTENDED_COLORIMETRY_XV_YCC_709,
+	HDMI_EXTENDED_COLORIMETRY_S_YCC_601,
+	HDMI_EXTENDED_COLORIMETRY_ADOBE_YCC_601,
+	HDMI_EXTENDED_COLORIMETRY_ADOBE_RGB,
+
+	/* The following EC values are only defined in CEA-861-F. */
+	HDMI_EXTENDED_COLORIMETRY_BT2020_CONST_LUM,
+	HDMI_EXTENDED_COLORIMETRY_BT2020,
+	HDMI_EXTENDED_COLORIMETRY_RESERVED,
+};
+
+enum hdmi_quantization_range {
+	HDMI_QUANTIZATION_RANGE_DEFAULT,
+	HDMI_QUANTIZATION_RANGE_LIMITED,
+	HDMI_QUANTIZATION_RANGE_FULL,
+	HDMI_QUANTIZATION_RANGE_RESERVED,
+};
+
+/* non-uniform picture scaling */
+enum hdmi_nups {
+	HDMI_NUPS_UNKNOWN,
+	HDMI_NUPS_HORIZONTAL,
+	HDMI_NUPS_VERTICAL,
+	HDMI_NUPS_BOTH,
+};
+
+enum hdmi_ycc_quantization_range {
+	HDMI_YCC_QUANTIZATION_RANGE_LIMITED,
+	HDMI_YCC_QUANTIZATION_RANGE_FULL,
+};
+
+enum hdmi_content_type {
+	HDMI_CONTENT_TYPE_GRAPHICS,
+	HDMI_CONTENT_TYPE_PHOTO,
+	HDMI_CONTENT_TYPE_CINEMA,
+	HDMI_CONTENT_TYPE_GAME,
+};
+
+struct hdmi_avi_infoframe {
+	enum hdmi_infoframe_type type;
+	unsigned char version;
+	unsigned char length;
+	enum hdmi_colorspace colorspace;
+	enum hdmi_scan_mode scan_mode;
+	enum hdmi_colorimetry colorimetry;
+	enum hdmi_picture_aspect picture_aspect;
+	enum hdmi_active_aspect active_aspect;
+	bool itc;
+	enum hdmi_extended_colorimetry extended_colorimetry;
+	enum hdmi_quantization_range quantization_range;
+	enum hdmi_nups nups;
+	unsigned char video_code;
+	enum hdmi_ycc_quantization_range ycc_quantization_range;
+	enum hdmi_content_type content_type;
+	unsigned char pixel_repeat;
+	unsigned short top_bar;
+	unsigned short bottom_bar;
+	unsigned short left_bar;
+	unsigned short right_bar;
+};
+
+struct hdmi_drm_infoframe {
+	enum hdmi_infoframe_type type;
+	unsigned char version;
+	unsigned char length;
+	uint16_t eotf;
+	uint16_t metadata_type;
+	uint16_t display_primaries_x[3];
+	uint16_t display_primaries_y[3];
+	uint16_t white_point_x;
+	uint16_t white_point_y;
+	uint16_t max_mastering_display_luminance;
+	uint16_t min_mastering_display_luminance;
+	uint16_t max_fall;
+	uint16_t max_cll;
+	uint16_t min_cll;
+};
+
+int hdmi_avi_infoframe_init(struct hdmi_avi_infoframe *frame);
+ssize_t hdmi_avi_infoframe_pack(struct hdmi_avi_infoframe *frame, void *buffer,
+				size_t size);
+
+int hdmi_drm_infoframe_init(struct hdmi_drm_infoframe *frame);
+
+enum hdmi_spd_sdi {
+	HDMI_SPD_SDI_UNKNOWN,
+	HDMI_SPD_SDI_DSTB,
+	HDMI_SPD_SDI_DVDP,
+	HDMI_SPD_SDI_DVHS,
+	HDMI_SPD_SDI_HDDVR,
+	HDMI_SPD_SDI_DVC,
+	HDMI_SPD_SDI_DSC,
+	HDMI_SPD_SDI_VCD,
+	HDMI_SPD_SDI_GAME,
+	HDMI_SPD_SDI_PC,
+	HDMI_SPD_SDI_BD,
+	HDMI_SPD_SDI_SACD,
+	HDMI_SPD_SDI_HDDVD,
+	HDMI_SPD_SDI_PMP,
+};
+
+struct hdmi_spd_infoframe {
+	enum hdmi_infoframe_type type;
+	unsigned char version;
+	unsigned char length;
+	char vendor[8];
+	char product[16];
+	enum hdmi_spd_sdi sdi;
+};
+
+int hdmi_spd_infoframe_init(struct hdmi_spd_infoframe *frame,
+			    const char *vendor, const char *product);
+ssize_t hdmi_spd_infoframe_pack(struct hdmi_spd_infoframe *frame, void *buffer,
+				size_t size);
+
+enum hdmi_audio_coding_type {
+	HDMI_AUDIO_CODING_TYPE_STREAM,
+	HDMI_AUDIO_CODING_TYPE_PCM,
+	HDMI_AUDIO_CODING_TYPE_AC3,
+	HDMI_AUDIO_CODING_TYPE_MPEG1,
+	HDMI_AUDIO_CODING_TYPE_MP3,
+	HDMI_AUDIO_CODING_TYPE_MPEG2,
+	HDMI_AUDIO_CODING_TYPE_AAC_LC,
+	HDMI_AUDIO_CODING_TYPE_DTS,
+	HDMI_AUDIO_CODING_TYPE_ATRAC,
+	HDMI_AUDIO_CODING_TYPE_DSD,
+	HDMI_AUDIO_CODING_TYPE_EAC3,
+	HDMI_AUDIO_CODING_TYPE_DTS_HD,
+	HDMI_AUDIO_CODING_TYPE_MLP,
+	HDMI_AUDIO_CODING_TYPE_DST,
+	HDMI_AUDIO_CODING_TYPE_WMA_PRO,
+	HDMI_AUDIO_CODING_TYPE_CXT,
+};
+
+enum hdmi_audio_sample_size {
+	HDMI_AUDIO_SAMPLE_SIZE_STREAM,
+	HDMI_AUDIO_SAMPLE_SIZE_16,
+	HDMI_AUDIO_SAMPLE_SIZE_20,
+	HDMI_AUDIO_SAMPLE_SIZE_24,
+};
+
+enum hdmi_audio_sample_frequency {
+	HDMI_AUDIO_SAMPLE_FREQUENCY_STREAM,
+	HDMI_AUDIO_SAMPLE_FREQUENCY_32000,
+	HDMI_AUDIO_SAMPLE_FREQUENCY_44100,
+	HDMI_AUDIO_SAMPLE_FREQUENCY_48000,
+	HDMI_AUDIO_SAMPLE_FREQUENCY_88200,
+	HDMI_AUDIO_SAMPLE_FREQUENCY_96000,
+	HDMI_AUDIO_SAMPLE_FREQUENCY_176400,
+	HDMI_AUDIO_SAMPLE_FREQUENCY_192000,
+};
+
+enum hdmi_audio_coding_type_ext {
+	/* Refer to Audio Coding Type (CT) field in Data Byte 1 */
+	HDMI_AUDIO_CODING_TYPE_EXT_CT,
+
+	/*
+	 * The next three CXT values are defined in CEA-861-E only.
+	 * They do not exist in older versions, and in CEA-861-F they are
+	 * defined as 'Not in use'.
+	 */
+	HDMI_AUDIO_CODING_TYPE_EXT_HE_AAC,
+	HDMI_AUDIO_CODING_TYPE_EXT_HE_AAC_V2,
+	HDMI_AUDIO_CODING_TYPE_EXT_MPEG_SURROUND,
+
+	/* The following CXT values are only defined in CEA-861-F. */
+	HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_HE_AAC,
+	HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_HE_AAC_V2,
+	HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_AAC_LC,
+	HDMI_AUDIO_CODING_TYPE_EXT_DRA,
+	HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_HE_AAC_SURROUND,
+	HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_AAC_LC_SURROUND = 10,
+};
+
+struct hdmi_audio_infoframe {
+	enum hdmi_infoframe_type type;
+	unsigned char version;
+	unsigned char length;
+	unsigned char channels;
+	enum hdmi_audio_coding_type coding_type;
+	enum hdmi_audio_sample_size sample_size;
+	enum hdmi_audio_sample_frequency sample_frequency;
+	enum hdmi_audio_coding_type_ext coding_type_ext;
+	unsigned char channel_allocation;
+	unsigned char level_shift_value;
+	bool downmix_inhibit;
+
+};
+
+int hdmi_audio_infoframe_init(struct hdmi_audio_infoframe *frame);
+ssize_t hdmi_audio_infoframe_pack(struct hdmi_audio_infoframe *frame,
+				  void *buffer, size_t size);
+
+enum hdmi_3d_structure {
+	HDMI_3D_STRUCTURE_INVALID = -1,
+	HDMI_3D_STRUCTURE_FRAME_PACKING = 0,
+	HDMI_3D_STRUCTURE_FIELD_ALTERNATIVE,
+	HDMI_3D_STRUCTURE_LINE_ALTERNATIVE,
+	HDMI_3D_STRUCTURE_SIDE_BY_SIDE_FULL,
+	HDMI_3D_STRUCTURE_L_DEPTH,
+	HDMI_3D_STRUCTURE_L_DEPTH_GFX_GFX_DEPTH,
+	HDMI_3D_STRUCTURE_TOP_AND_BOTTOM,
+	HDMI_3D_STRUCTURE_SIDE_BY_SIDE_HALF = 8,
+};
+
+struct hdmi_vendor_infoframe {
+	enum hdmi_infoframe_type type;
+	unsigned char version;
+	unsigned char length;
+	unsigned int oui;
+	u8 vic;
+	enum hdmi_3d_structure s3d_struct;
+	unsigned int s3d_ext_data;
+};
+
+int hdmi_vendor_infoframe_init(struct hdmi_vendor_infoframe *frame);
+ssize_t hdmi_vendor_infoframe_pack(struct hdmi_vendor_infoframe *frame,
+				   void *buffer, size_t size);
+
+union hdmi_vendor_any_infoframe {
+	struct {
+		enum hdmi_infoframe_type type;
+		unsigned char version;
+		unsigned char length;
+		unsigned int oui;
+	} any;
+	struct hdmi_vendor_infoframe hdmi;
+};
+
+/**
+ * union hdmi_infoframe: overall union of all abstract infoframe representations
+ * @any: generic infoframe
+ * @avi: avi infoframe
+ * @spd: spd infoframe
+ * @vendor: union of all vendor infoframes
+ * @audio: audio infoframe
+ *
+ * This is used by the generic pack function. This works since all infoframes
+ * have the same header which also indicates which type of infoframe should be
+ * packed.
+ */
+union hdmi_infoframe {
+	struct hdmi_any_infoframe any;
+	struct hdmi_avi_infoframe avi;
+	struct hdmi_spd_infoframe spd;
+	union hdmi_vendor_any_infoframe vendor;
+	struct hdmi_audio_infoframe audio;
+	struct hdmi_drm_infoframe drm;
+};
+
+ssize_t
+hdmi_infoframe_pack(union hdmi_infoframe *frame, void *buffer, size_t size);
+int hdmi_infoframe_unpack(union hdmi_infoframe *frame, void *buffer);
+
+ssize_t hdmi_vendor_infoframe_pack(struct hdmi_vendor_infoframe *frame,
+				   void *buffer, size_t size);
+int
+drm_hdmi_vendor_infoframe_from_display_mode(struct hdmi_vendor_infoframe *frame,
+					    struct drm_display_mode *mode);
+ssize_t hdmi_avi_infoframe_pack_only(const struct hdmi_avi_infoframe *frame,
+				     void *buffer, size_t size);
+int
+drm_hdmi_avi_infoframe_from_display_mode(struct hdmi_avi_infoframe *frame,
+					 struct drm_display_mode *mode,
+					 bool is_hdmi2_sink);
+void
+drm_hdmi_avi_infoframe_quant_range(struct hdmi_avi_infoframe *frame,
+				   struct drm_display_mode *mode,
+				   enum hdmi_quantization_range rgb_quant_range,
+				   bool rgb_quant_range_selectable);
+u8 drm_match_cea_mode(struct drm_display_mode *to_match);
+
+#endif /* _DRM_HDMI_H */
diff --git a/include/linux/media-bus-format.h b/include/linux/media-bus-format.h
new file mode 100644
index 0000000000..940d838b26
--- /dev/null
+++ b/include/linux/media-bus-format.h
@@ -0,0 +1,170 @@
+/*
+ * Media Bus API header
+ *
+ * Copyright (C) 2009, Guennadi Liakhovetski <g.liakhovetski@gmx.de>
+ * (C) Copyright 2008-2017 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __LINUX_MEDIA_BUS_FORMAT_H
+#define __LINUX_MEDIA_BUS_FORMAT_H
+
+/*
+ * These bus formats uniquely identify data formats on the data bus. Format 0
+ * is reserved, MEDIA_BUS_FMT_FIXED shall be used by host-client pairs, where
+ * the data format is fixed. Additionally, "2X8" means that one pixel is
+ * transferred in two 8-bit samples, "BE" or "LE" specify in which order those
+ * samples are transferred over the bus: "LE" means that the least significant
+ * bits are transferred first, "BE" means that the most significant bits are
+ * transferred first, and "PADHI" and "PADLO" define which bits - low or high,
+ * in the incomplete high byte, are filled with padding bits.
+ *
+ * The bus formats are grouped by type, bus_width, bits per component, samples
+ * per pixel and order of subsamples. Numerical values are sorted using generic
+ * numerical sort order (8 thus comes before 10).
+ *
+ * As their value can't change when a new bus format is inserted in the
+ * enumeration, the bus formats are explicitly given a numerical value. The next
+ * free values for each category are listed below, update them when inserting
+ * new pixel codes.
+ */
+
+#define MEDIA_BUS_FMT_FIXED			0x0001
+
+/* RGB - next is	0x1024 */
+#define MEDIA_BUS_FMT_RGB444_1X12		0x1016
+#define MEDIA_BUS_FMT_RGB444_2X8_PADHI_BE	0x1001
+#define MEDIA_BUS_FMT_RGB444_2X8_PADHI_LE	0x1002
+#define MEDIA_BUS_FMT_RGB555_2X8_PADHI_BE	0x1003
+#define MEDIA_BUS_FMT_RGB555_2X8_PADHI_LE	0x1004
+#define MEDIA_BUS_FMT_RGB565_1X16		0x1017
+#define MEDIA_BUS_FMT_BGR565_2X8_BE		0x1005
+#define MEDIA_BUS_FMT_BGR565_2X8_LE		0x1006
+#define MEDIA_BUS_FMT_RGB565_2X8_BE		0x1007
+#define MEDIA_BUS_FMT_RGB565_2X8_LE		0x1008
+#define MEDIA_BUS_FMT_RGB666_1X18		0x1009
+#define MEDIA_BUS_FMT_RBG888_1X24		0x100e
+#define MEDIA_BUS_FMT_RGB666_1X24_CPADHI	0x1015
+#define MEDIA_BUS_FMT_RGB666_1X7X3_SPWG		0x1010
+#define MEDIA_BUS_FMT_RGB666_1X7X3_JEIDA	0x101b
+#define MEDIA_BUS_FMT_BGR888_1X24		0x1013
+#define MEDIA_BUS_FMT_BGR888_3X8		0x101b
+#define MEDIA_BUS_FMT_GBR888_1X24		0x1014
+#define MEDIA_BUS_FMT_RGB888_1X24		0x100a
+#define MEDIA_BUS_FMT_RGB888_2X12_BE		0x100b
+#define MEDIA_BUS_FMT_RGB888_2X12_LE		0x100c
+#define MEDIA_BUS_FMT_RGB888_3X8		0x101c
+#define MEDIA_BUS_FMT_RGB888_1X7X4_SPWG		0x1011
+#define MEDIA_BUS_FMT_RGB888_1X7X4_JEIDA	0x1012
+#define MEDIA_BUS_FMT_ARGB8888_1X32		0x100d
+#define MEDIA_BUS_FMT_RGB888_1X32_PADHI		0x100f
+#define MEDIA_BUS_FMT_RGB101010_1X30		0x1018
+#define MEDIA_BUS_FMT_RGB121212_1X36		0x1019
+#define MEDIA_BUS_FMT_RGB161616_1X48		0x101a
+#define MEDIA_BUS_FMT_RGB888_DUMMY_4X8		0x101f
+#define MEDIA_BUS_FMT_BGR888_DUMMY_4X8		0x1020
+#define MEDIA_BUS_FMT_RGB101010_1X7X5_SPWG	0x1022
+#define MEDIA_BUS_FMT_RGB101010_1X7X5_JEIDA	0x1023
+#define MEDIA_BUS_FMT_RGB666_3X6		0x1100
+
+/* YUV (including grey) - next is	0x202e */
+#define MEDIA_BUS_FMT_Y8_1X8			0x2001
+#define MEDIA_BUS_FMT_UV8_1X8			0x2015
+#define MEDIA_BUS_FMT_UYVY8_1_5X8		0x2002
+#define MEDIA_BUS_FMT_VYUY8_1_5X8		0x2003
+#define MEDIA_BUS_FMT_YUYV8_1_5X8		0x2004
+#define MEDIA_BUS_FMT_YVYU8_1_5X8		0x2005
+#define MEDIA_BUS_FMT_UYVY8_2X8			0x2006
+#define MEDIA_BUS_FMT_VYUY8_2X8			0x2007
+#define MEDIA_BUS_FMT_YUYV8_2X8			0x2008
+#define MEDIA_BUS_FMT_YVYU8_2X8			0x2009
+#define MEDIA_BUS_FMT_Y10_1X10			0x200a
+#define MEDIA_BUS_FMT_Y10_2X8_PADHI_LE		0x202c
+#define MEDIA_BUS_FMT_UYVY10_2X10		0x2018
+#define MEDIA_BUS_FMT_VYUY10_2X10		0x2019
+#define MEDIA_BUS_FMT_YUYV10_2X10		0x200b
+#define MEDIA_BUS_FMT_YVYU10_2X10		0x200c
+#define MEDIA_BUS_FMT_Y12_1X12			0x2013
+#define MEDIA_BUS_FMT_UYVY12_2X12		0x201c
+#define MEDIA_BUS_FMT_VYUY12_2X12		0x201d
+#define MEDIA_BUS_FMT_YUYV12_2X12		0x201e
+#define MEDIA_BUS_FMT_YVYU12_2X12		0x201f
+#define MEDIA_BUS_FMT_Y14_1X14			0x202d
+#define MEDIA_BUS_FMT_UYVY8_1X16		0x200f
+#define MEDIA_BUS_FMT_VYUY8_1X16		0x2010
+#define MEDIA_BUS_FMT_YUYV8_1X16		0x2011
+#define MEDIA_BUS_FMT_YVYU8_1X16		0x2012
+#define MEDIA_BUS_FMT_YDYUYDYV8_1X16		0x2014
+#define MEDIA_BUS_FMT_UYVY10_1X20		0x201a
+#define MEDIA_BUS_FMT_VYUY10_1X20		0x201b
+#define MEDIA_BUS_FMT_YUYV10_1X20		0x200d
+#define MEDIA_BUS_FMT_YVYU10_1X20		0x200e
+#define MEDIA_BUS_FMT_VUY8_1X24			0x2024
+#define MEDIA_BUS_FMT_YUV8_1X24			0x2025
+#define MEDIA_BUS_FMT_UYYVYY8_0_5X24		0x2026
+#define MEDIA_BUS_FMT_UYVY12_1X24		0x2020
+#define MEDIA_BUS_FMT_VYUY12_1X24		0x2021
+#define MEDIA_BUS_FMT_YUYV12_1X24		0x2022
+#define MEDIA_BUS_FMT_YVYU12_1X24		0x2023
+#define MEDIA_BUS_FMT_YUV10_1X30		0x2016
+#define MEDIA_BUS_FMT_UYYVYY10_0_5X30		0x2027
+#define MEDIA_BUS_FMT_AYUV8_1X32		0x2017
+#define MEDIA_BUS_FMT_UYYVYY12_0_5X36		0x2028
+#define MEDIA_BUS_FMT_YUV12_1X36		0x2029
+#define MEDIA_BUS_FMT_YUV16_1X48		0x202a
+#define MEDIA_BUS_FMT_UYYVYY16_0_5X48		0x202b
+
+/* Bayer - next is	0x3021 */
+#define MEDIA_BUS_FMT_SBGGR8_1X8		0x3001
+#define MEDIA_BUS_FMT_SGBRG8_1X8		0x3013
+#define MEDIA_BUS_FMT_SGRBG8_1X8		0x3002
+#define MEDIA_BUS_FMT_SRGGB8_1X8		0x3014
+#define MEDIA_BUS_FMT_SBGGR10_ALAW8_1X8		0x3015
+#define MEDIA_BUS_FMT_SGBRG10_ALAW8_1X8		0x3016
+#define MEDIA_BUS_FMT_SGRBG10_ALAW8_1X8		0x3017
+#define MEDIA_BUS_FMT_SRGGB10_ALAW8_1X8		0x3018
+#define MEDIA_BUS_FMT_SBGGR10_DPCM8_1X8		0x300b
+#define MEDIA_BUS_FMT_SGBRG10_DPCM8_1X8		0x300c
+#define MEDIA_BUS_FMT_SGRBG10_DPCM8_1X8		0x3009
+#define MEDIA_BUS_FMT_SRGGB10_DPCM8_1X8		0x300d
+#define MEDIA_BUS_FMT_SBGGR10_2X8_PADHI_BE	0x3003
+#define MEDIA_BUS_FMT_SBGGR10_2X8_PADHI_LE	0x3004
+#define MEDIA_BUS_FMT_SBGGR10_2X8_PADLO_BE	0x3005
+#define MEDIA_BUS_FMT_SBGGR10_2X8_PADLO_LE	0x3006
+#define MEDIA_BUS_FMT_SBGGR10_1X10		0x3007
+#define MEDIA_BUS_FMT_SGBRG10_1X10		0x300e
+#define MEDIA_BUS_FMT_SGRBG10_1X10		0x300a
+#define MEDIA_BUS_FMT_SRGGB10_1X10		0x300f
+#define MEDIA_BUS_FMT_SBGGR12_1X12		0x3008
+#define MEDIA_BUS_FMT_SGBRG12_1X12		0x3010
+#define MEDIA_BUS_FMT_SGRBG12_1X12		0x3011
+#define MEDIA_BUS_FMT_SRGGB12_1X12		0x3012
+#define MEDIA_BUS_FMT_SBGGR14_1X14		0x3019
+#define MEDIA_BUS_FMT_SGBRG14_1X14		0x301a
+#define MEDIA_BUS_FMT_SGRBG14_1X14		0x301b
+#define MEDIA_BUS_FMT_SRGGB14_1X14		0x301c
+#define MEDIA_BUS_FMT_SBGGR16_1X16		0x301d
+#define MEDIA_BUS_FMT_SGBRG16_1X16		0x301e
+#define MEDIA_BUS_FMT_SGRBG16_1X16		0x301f
+#define MEDIA_BUS_FMT_SRGGB16_1X16		0x3020
+
+/* JPEG compressed formats - next is	0x4002 */
+#define MEDIA_BUS_FMT_JPEG_1X8			0x4001
+
+/* Vendor specific formats - next is	0x5002 */
+
+/* S5C73M3 sensor specific interleaved UYVY and JPEG */
+#define MEDIA_BUS_FMT_S5C_UYVY_JPEG_1X8		0x5001
+
+/* HSV - next is	0x6002 */
+#define MEDIA_BUS_FMT_AHSV8888_1X32		0x6001
+
+/* Panel Mirror control */
+#define DRM_MODE_FLAG_XMIRROR 			(1<<28)
+#define DRM_MODE_FLAG_YMIRROR 			(1<<29)
+#define DRM_MODE_FLAG_XYMIRROR			(DRM_MODE_FLAG_XMIRROR | DRM_MODE_FLAG_YMIRROR)
+
+#endif /* __LINUX_MEDIA_BUS_FORMAT_H */
diff --git a/include/mp_boot.h b/include/mp_boot.h
new file mode 100644
index 0000000000..44a16c6385
--- /dev/null
+++ b/include/mp_boot.h
@@ -0,0 +1,25 @@
+/*
+ * (C) Copyright 2023 Rockchip Electronics Co., Ltd
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#ifndef _MP_BOOT_H_
+#define _MP_BOOT_H_
+
+#include <spl.h>
+
+struct task_data {
+	struct spl_load_info info;
+
+	/* to be filled by smp task */
+	void *boot_addr;
+	ulong boot_size;
+};
+
+void mpb_init_1(struct spl_load_info info);
+void mpb_init_x(int evt);
+ulong mpb_post(int evt);
+
+#endif
+
diff --git a/include/regmap.h b/include/regmap.h
index 22b043408a..909961d0d0 100644
--- a/include/regmap.h
+++ b/include/regmap.h
@@ -8,6 +8,7 @@
 #define __REGMAP_H
 
 #include <linux/delay.h>
+#include <dm/ofnode.h>
 
 /**
  * DOC: Overview
diff --git a/include/spl_display.h b/include/spl_display.h
new file mode 100644
index 0000000000..3cb7fe2f61
--- /dev/null
+++ b/include/spl_display.h
@@ -0,0 +1,28 @@
+/* SPDX-License-Identifier:     GPL-2.0+ */
+/*
+ * (C) Copyright 2023 Rockchip Electronics Co., Ltd
+ *
+ */
+
+#ifndef _SPL_DISPLAY_H_
+#define _SPL_DISPLAY_H_
+
+#include <common.h>
+#include <drm_modes.h>
+#include <mp_boot.h>
+
+/* SPL display */
+#define RK3528_VOP_BASE				0xff840000
+#define RK3528_HDMI_BASE			0xff8d0000
+#define RK3528_HDMIPHY_BASE			0xffe00000
+#define RK3528_CRU_BASE				0xff4a0000
+#define RK3528_GPIO0_IOC_BASE			0xff540000
+#define RK3528_GPIO_BASE			0xff610000
+
+struct spl_display_info {
+	struct drm_display_mode mode;
+	u32 bus_format;
+	u32 enabled;
+};
+#endif
+
diff --git a/include/video_bridge.h b/include/video_bridge.h
index 3b429eac57..2c6b7af95d 100644
--- a/include/video_bridge.h
+++ b/include/video_bridge.h
@@ -62,6 +62,14 @@ struct video_bridge_ops {
 	 * @return number of bytes read, <=0 for error
 	 */
 	int (*read_edid)(struct udevice *dev, u8 *buf, int buf_size);
+
+	/**
+	 * get_timing() - Get timing from bridge
+	 *
+	 * @dev:	Device to get timing
+	 * @return 0 if OK, -ve on error
+	 */
+	int (*get_timing)(struct udevice *dev);
 };
 
 #define video_bridge_get_ops(dev) \
@@ -108,4 +116,11 @@ int video_bridge_check_attached(struct udevice *dev);
  */
 int video_bridge_read_edid(struct udevice *dev, u8 *buf, int buf_size);
 
+/**
+ * video_bridge_get_timing() - Get timing from bridge
+ *
+ * @dev:	Device to get timing
+ * @return 0 if OK, -ve on error
+ */
+int video_bridge_get_timing(struct udevice *dev);
 #endif
diff --git a/include/video_rockchip.h b/include/video_rockchip.h
new file mode 100644
index 0000000000..02a6178ff6
--- /dev/null
+++ b/include/video_rockchip.h
@@ -0,0 +1,28 @@
+/*
+ * (C) Copyright 2017 Rockchip Electronics Co., Ltd
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#ifndef VIDEO_ROCKCHIP_H
+#define VIDEO_ROCKCHIP_H
+
+#ifdef CONFIG_DRM_ROCKCHIP_VIDEO_FRAMEBUFFER
+ #define DRM_ROCKCHIP_FB_WIDTH		1920
+ #define DRM_ROCKCHIP_FB_HEIGHT		1080
+ #define DRM_ROCKCHIP_FB_BPP		VIDEO_BPP32
+#else
+ #define DRM_ROCKCHIP_FB_WIDTH		0
+ #define DRM_ROCKCHIP_FB_HEIGHT		0
+ #define DRM_ROCKCHIP_FB_BPP		VIDEO_BPP32
+#endif
+
+#define MEMORY_POOL_SIZE	CONFIG_DRM_MEM_RESERVED_SIZE_MBYTES * 1024 * 1024
+#define DRM_ROCKCHIP_FB_SIZE \
+	VNBYTES(DRM_ROCKCHIP_FB_BPP) * DRM_ROCKCHIP_FB_WIDTH * DRM_ROCKCHIP_FB_HEIGHT
+
+int rockchip_show_bmp(const char *bmp);
+int rockchip_show_logo(void);
+void rockchip_display_fixup(void *blob);
+
+#endif
